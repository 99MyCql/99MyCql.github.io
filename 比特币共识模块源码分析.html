<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/golang32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/golang16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-RpvRDWfflk">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.dounine.live","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言分析比特币系统的共识模块，包括共识算法、交易的流程等，基于比特币开源客户端Bitcoin Core v22.0 版本的源码。">
<meta property="og:type" content="article">
<meta property="og:title" content="比特币共识模块源码分析">
<meta property="og:url" content="https://blog.dounine.live/%E6%AF%94%E7%89%B9%E5%B8%81%E5%85%B1%E8%AF%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">
<meta property="og:site_name" content="dounine&#39;s blog">
<meta property="og:description" content="前言分析比特币系统的共识模块，包括共识算法、交易的流程等，基于比特币开源客户端Bitcoin Core v22.0 版本的源码。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.dounine.live/%E6%AF%94%E7%89%B9%E5%B8%81%E5%85%B1%E8%AF%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png">
<meta property="article:published_time" content="2021-11-02T10:39:52.000Z">
<meta property="article:modified_time" content="2021-11-02T10:39:52.000Z">
<meta property="article:author" content="dounine">
<meta property="article:tag" content="区块链">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.dounine.live/%E6%AF%94%E7%89%B9%E5%B8%81%E5%85%B1%E8%AF%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png">


<link rel="canonical" href="https://blog.dounine.live/%E6%AF%94%E7%89%B9%E5%B8%81%E5%85%B1%E8%AF%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.dounine.live/%E6%AF%94%E7%89%B9%E5%B8%81%E5%85%B1%E8%AF%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html","path":"比特币共识模块源码分析.html","title":"比特币共识模块源码分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>比特币共识模块源码分析 | dounine's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SZN5WSXHZY"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-SZN5WSXHZY","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?66c7065aa71681df47eb23eff557978b"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SZN5WSXHZY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SZN5WSXHZY');
</script>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">dounine's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">50</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">84</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%A4%E6%98%93"><span class="nav-text">创建交易</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%A4%E6%98%93"><span class="nav-text">验证交易</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8C%BA%E5%9D%97"><span class="nav-text">创建区块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CreateNewBlock"><span class="nav-text">CreateNewBlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GenerateBlock"><span class="nav-text">GenerateBlock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%8C%BA%E5%9D%97"><span class="nav-text">处理区块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CheckBlock"><span class="nav-text">CheckBlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AcceptBlock"><span class="nav-text">AcceptBlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ActivateBestChain"><span class="nav-text">ActivateBestChain</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%9C%80%E9%95%BF%E9%93%BE"><span class="nav-text">选择最长链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dounine"
      src="https://avatars.githubusercontent.com/u/41814469?s=400&u=48bf60a3428a3cb86a84a110c8688930cf6ceb08&v=4">
  <p class="site-author-name" itemprop="name">dounine</p>
  <div class="site-description" itemprop="description">回首向来萧瑟处</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/99MyCql" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;99MyCql" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://bkfish.gitee.io/" title="https:&#x2F;&#x2F;bkfish.gitee.io&#x2F;" rel="noopener" target="_blank">bkfish</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://hitworld.github.io/" title="https:&#x2F;&#x2F;hitworld.github.io&#x2F;" rel="noopener" target="_blank">w4rd3n</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wyjoutstanding.github.io/" title="https:&#x2F;&#x2F;wyjoutstanding.github.io&#x2F;" rel="noopener" target="_blank">wyjoutstanding</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://iwtf.github.io/" title="https:&#x2F;&#x2F;iwtf.github.io&#x2F;" rel="noopener" target="_blank">IWTF</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wood1314.github.io/" title="https:&#x2F;&#x2F;wood1314.github.io&#x2F;" rel="noopener" target="_blank">wood</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://desperadoccy.xyz/" title="https:&#x2F;&#x2F;desperadoccy.xyz&#x2F;" rel="noopener" target="_blank">desperadoccy</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://doudouqaq.github.io/" title="https:&#x2F;&#x2F;doudouqaq.github.io&#x2F;" rel="noopener" target="_blank">doudouqaq</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kylinnnnn.github.io/" title="https:&#x2F;&#x2F;kylinnnnn.github.io&#x2F;" rel="noopener" target="_blank">kylinnnnn</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://miaotony.xyz/" title="https:&#x2F;&#x2F;miaotony.xyz" rel="noopener" target="_blank">miaotony</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://110.40.153.120:3030/" title="http:&#x2F;&#x2F;110.40.153.120:3030&#x2F;" rel="noopener" target="_blank">AZhou</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/weixin_40986490" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40986490" rel="noopener" target="_blank">白速龙王的回眸</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/weixin_43116322" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43116322" rel="noopener" target="_blank">Ethan</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.dounine.live/%E6%AF%94%E7%89%B9%E5%B8%81%E5%85%B1%E8%AF%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/41814469?s=400&u=48bf60a3428a3cb86a84a110c8688930cf6ceb08&v=4">
      <meta itemprop="name" content="dounine">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dounine's blog">
      <meta itemprop="description" content="回首向来萧瑟处">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="比特币共识模块源码分析 | dounine's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          比特币共识模块源码分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-02 18:39:52" itemprop="dateCreated datePublished" datetime="2021-11-02T18:39:52+08:00">2021-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Pro/" itemprop="url" rel="index"><span itemprop="name">欲穷千里目，更上一层楼</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Pro/BlockChain/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>41k</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分析比特币系统的共识模块，包括共识算法、交易的流程等，基于比特币开源客户端<a target="_blank" rel="noopener" href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> <strong>v22.0</strong> 版本的源码。</p>
<span id="more"></span>

<p>比特币中共识算法的大体步骤如下：</p>
<ol>
<li><p>新交易被创建并广播到比特币网络中。</p>
</li>
<li><p>每个节点接收到交易后，独立地对交易进行验证。</p>
</li>
<li><p>矿工节点将新交易收集到一个区块中，并为该区块寻找工作量证明，然后将新区块广播到网络中。</p>
</li>
<li><p>每个节点收到区块后，对区块进行独立的校验，并组装进区块链中。</p>
</li>
<li><p>每个节点对区块链进行独立选择，选择最大工作量证明的链。</p>
</li>
</ol>
<p>接下来，将结合源码讲解分析上述步骤。</p>
<h2 id="创建交易"><a href="#创建交易" class="headerlink" title="创建交易"></a>创建交易</h2><p>在Bitcoin Core客户端中，用户可以通过 <code>$ bitcoin-cli createrawtransaction</code>命令创建一笔交易。这个命令背后对应着一个RPC接口，并映射到一个处理函数。映射关系定义在<code>src\rpc\rawtransaction.cpp</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册交易的RPC接口及其对应的处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RegisterRawTransactionRPCCommands</span><span class="params">(CRPCTable &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// clang-format off</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> CRPCCommand commands[] =</span><br><span class="line">&#123; <span class="comment">//  category               actor (function)</span></span><br><span class="line">  <span class="comment">//  ---------------------  -----------------------</span></span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;getrawtransaction,          &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;createrawtransaction,       &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;decoderawtransaction,       &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;decodescript,               &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;sendrawtransaction,         &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;combinerawtransaction,      &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;signrawtransactionwithkey,  &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;testmempoolaccept,          &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;decodepsbt,                 &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;combinepsbt,                &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;finalizepsbt,               &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;createpsbt,                 &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;converttopsbt,              &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;utxoupdatepsbt,             &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;joinpsbts,                  &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;rawtransactions&quot;</span>,     &amp;analyzepsbt,                &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">&quot;blockchain&quot;</span>,          &amp;gettxoutproof,              &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;blockchain&quot;</span>,          &amp;verifytxoutproof,           &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// clang-format on</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; c : commands) &#123;</span><br><span class="line">        t.<span class="built_in">appendCommand</span>(c.name, &amp;c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注册函数的被调用关系图如下：</p>
<p><img src="/%E6%AF%94%E7%89%B9%E5%B8%81%E5%85%B1%E8%AF%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="1"></p>
<p>创建交易RPC接口对应的处理函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> RPCHelpMan <span class="title">createrawtransaction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RPCHelpMan&#123;<span class="string">&quot;createrawtransaction&quot;</span>,</span><br><span class="line">                <span class="string">&quot;\nCreate a transaction spending the given inputs and creating new outputs.\n&quot;</span></span><br><span class="line">                <span class="string">&quot;Outputs can be addresses or data.\n&quot;</span></span><br><span class="line">                <span class="string">&quot;Returns hex-encoded raw transaction.\n&quot;</span></span><br><span class="line">                <span class="string">&quot;Note that the transaction&#x27;s inputs are not signed, and\n&quot;</span></span><br><span class="line">                <span class="string">&quot;it is not stored in the wallet or transmitted to the network.\n&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;<span class="string">&quot;inputs&quot;</span>, RPCArg::Type::ARR, RPCArg::Optional::NO, <span class="string">&quot;The inputs&quot;</span>,</span><br><span class="line">                        &#123;</span><br><span class="line">                            &#123;<span class="string">&quot;&quot;</span>, RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &#123;<span class="string">&quot;txid&quot;</span>, RPCArg::Type::STR_HEX, RPCArg::Optional::NO, <span class="string">&quot;The transaction id&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;vout&quot;</span>, RPCArg::Type::NUM, RPCArg::Optional::NO, <span class="string">&quot;The output number&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;sequence&quot;</span>, RPCArg::Type::NUM, RPCArg::DefaultHint&#123;<span class="string">&quot;depends on the value of the &#x27;replaceable&#x27; and &#x27;locktime&#x27; arguments&quot;</span>&#125;, <span class="string">&quot;The sequence number&quot;</span>&#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;outputs&quot;</span>, RPCArg::Type::ARR, RPCArg::Optional::NO, <span class="string">&quot;The outputs (key-value pairs), where none of the keys are duplicated.\n&quot;</span></span><br><span class="line">                            <span class="string">&quot;That is, each address can only appear once and there can only be one &#x27;data&#x27; object.\n&quot;</span></span><br><span class="line">                            <span class="string">&quot;For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\n&quot;</span></span><br><span class="line">                            <span class="string">&quot;                             accepted as second parameter.&quot;</span>,</span><br><span class="line">                        &#123;</span><br><span class="line">                            &#123;<span class="string">&quot;&quot;</span>, RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &#123;<span class="string">&quot;address&quot;</span>, RPCArg::Type::AMOUNT, RPCArg::Optional::NO, <span class="string">&quot;A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in &quot;</span> + CURRENCY_UNIT&#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#123;<span class="string">&quot;&quot;</span>, RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &#123;<span class="string">&quot;data&quot;</span>, RPCArg::Type::STR_HEX, RPCArg::Optional::NO, <span class="string">&quot;A key-value pair. The key must be \&quot;data\&quot;, the value is hex-encoded data&quot;</span>&#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;locktime&quot;</span>, RPCArg::Type::NUM, RPCArg::Default&#123;<span class="number">0</span>&#125;, <span class="string">&quot;Raw locktime. Non-0 value also locktime-activates inputs&quot;</span>&#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;replaceable&quot;</span>, RPCArg::Type::BOOL, RPCArg::Default&#123;<span class="literal">false</span>&#125;, <span class="string">&quot;Marks this transaction as BIP125-replaceable.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.&quot;</span>&#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                RPCResult&#123;</span><br><span class="line">                    RPCResult::Type::STR_HEX, <span class="string">&quot;transaction&quot;</span>, <span class="string">&quot;hex string of the transaction&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                RPCExamples&#123;</span><br><span class="line">                    <span class="built_in">HelpExampleCli</span>(<span class="string">&quot;createrawtransaction&quot;</span>, <span class="string">&quot;\&quot;[&#123;\\\&quot;txid\\\&quot;:\\\&quot;myid\\\&quot;,\\\&quot;vout\\\&quot;:0&#125;]\&quot; \&quot;[&#123;\\\&quot;address\\\&quot;:0.01&#125;]\&quot;&quot;</span>)</span><br><span class="line">            + <span class="built_in">HelpExampleCli</span>(<span class="string">&quot;createrawtransaction&quot;</span>, <span class="string">&quot;\&quot;[&#123;\\\&quot;txid\\\&quot;:\\\&quot;myid\\\&quot;,\\\&quot;vout\\\&quot;:0&#125;]\&quot; \&quot;[&#123;\\\&quot;data\\\&quot;:\\\&quot;00010203\\\&quot;&#125;]\&quot;&quot;</span>)</span><br><span class="line">            + <span class="built_in">HelpExampleRpc</span>(<span class="string">&quot;createrawtransaction&quot;</span>, <span class="string">&quot;\&quot;[&#123;\\\&quot;txid\\\&quot;:\\\&quot;myid\\\&quot;,\\\&quot;vout\\\&quot;:0&#125;]\&quot;, \&quot;[&#123;\\\&quot;address\\\&quot;:0.01&#125;]\&quot;&quot;</span>)</span><br><span class="line">            + <span class="built_in">HelpExampleRpc</span>(<span class="string">&quot;createrawtransaction&quot;</span>, <span class="string">&quot;\&quot;[&#123;\\\&quot;txid\\\&quot;:\\\&quot;myid\\\&quot;,\\\&quot;vout\\\&quot;:0&#125;]\&quot;, \&quot;[&#123;\\\&quot;data\\\&quot;:\\\&quot;00010203\\\&quot;&#125;]\&quot;&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">        [&amp;](<span class="type">const</span> RPCHelpMan&amp; self, <span class="type">const</span> JSONRPCRequest&amp; request) -&gt; UniValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查四个参数 inputs outputs locktime replaceable 类型是否正确</span></span><br><span class="line">    <span class="built_in">RPCTypeCheck</span>(request.params, &#123;</span><br><span class="line">        UniValue::VARR,</span><br><span class="line">        <span class="built_in">UniValueType</span>(), <span class="comment">// ARR or OBJ, checked later</span></span><br><span class="line">        UniValue::VNUM,</span><br><span class="line">        UniValue::VBOOL</span><br><span class="line">        &#125;, <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> rbf = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!request.params[<span class="number">3</span>].<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        rbf = request.params[<span class="number">3</span>].<span class="built_in">isTrue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造交易（包括交易的输入vin、输出vout及锁定脚本），返回序列化数据</span></span><br><span class="line">    CMutableTransaction rawTx = <span class="built_in">ConstructTransaction</span>(request.params[<span class="number">0</span>], request.params[<span class="number">1</span>], request.params[<span class="number">2</span>], rbf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">EncodeHexTx</span>(<span class="built_in">CTransaction</span>(rawTx));</span><br><span class="line">&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数定义了命令的说明、请求参数、返回值与内部实现过程，主要是根据请求参数构造一笔交易，然后返回交易的哈希值。构造的过程主要包括构造交易的输入vin、输出vout及<strong>锁定脚本</strong> ，具体内容不在此讲解。</p>
<p>构建交易之后，需要使用<code>$ bitcoin-cli signrawtransactionwithkey</code>对交易进行签名，其处理函数也在<code>src\rpc\rawtransaction.cpp</code>中，主要内容是构建vin中的<strong>解锁脚本</strong> 。</p>
<p>签名后，就可以使用<code>$ bitcoin-cli sendrawtransaction</code>将交易广播至比特币网络中，具体实现代码不在此展示。</p>
<h2 id="验证交易"><a href="#验证交易" class="headerlink" title="验证交易"></a>验证交易</h2><p>Bitcoin Core客户端可通过<code>bitcoind</code>命令启动，启动的入口函数是<code>src\bitcoind.cpp</code>中的<code>main</code>函数。启动之后，Bitcoin Core会启动一个线程用于监听、接收并响应比特币网络中的信息，该线程对应的函数<code>CConnman::ThreadMessageHandler</code>在<code>src\net.cpp</code>中。</p>
<p>该函数会调用<code>src\net_processing.cpp</code>中的<code>PeerManagerImpl::ProcessMessages</code>函数处理接收到的信息，而它会进一步调用同在<code>src\net_processing.cpp</code>中的<code>PeerManagerImpl::ProcessMessage</code>函数。其被调用的关系如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main -&gt; AppInit -&gt; AppInitMain -&gt; CConnman::Start -&gt; CConnman::ThreadMessageHandler</span><br><span class="line">-&gt; PeerManagerImpl::ProcessMessages -&gt; PeerManagerImpl::ProcessMessage</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>PeerManagerImpl::ProcessMessage</code>函数中，会根据信息类型进行不同的处理，如果是交易类型的消息，则会调用<code>src\validation.cpp</code>中的<code>AcceptToMemoryPool</code>函数将交易存放到交易池中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeerManagerImpl::ProcessMessage</span><span class="params">(CNode&amp; pfrom, <span class="type">const</span> std::string&amp; msg_type, CDataStream&amp; vRecv,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> std::chrono::microseconds time_received,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> std::atomic&lt;<span class="type">bool</span>&gt;&amp; interruptMsgProc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果消息是交易类型</span></span><br><span class="line">    <span class="keyword">if</span> (msg_type == NetMsgType::TX) &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收到交易池中</span></span><br><span class="line">        <span class="type">const</span> MempoolAcceptResult result = <span class="built_in">AcceptToMemoryPool</span>(m_chainman.<span class="built_in">ActiveChainstate</span>(), m_mempool, ptx, <span class="literal">false</span> <span class="comment">/* bypass_limits */</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AcceptToMemoryPool</code>函数进而调用<code>AcceptToMemoryPoolWithTime</code>函数，接着调用<code>MemPoolAccept:: AcceptSingleTransaction</code>函数。</p>
<p>而这个<code>MemPoolAccept::AcceptSingleTransaction</code>函数，是接收交易的入口函数。在这个函数中，又会调用<code>MemPoolAccept::PreChecks</code>函数，它是关键中的关键，负责对交易进行全方位的检查。在这个函数中：</p>
<ol>
<li>首先，会调用<code>src\consensus\tx_check.cpp</code>中的<code>CheckTransaction</code>函数，进行基础的检查：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckTransaction</span><span class="params">(<span class="type">const</span> CTransaction&amp; tx, TxValidationState&amp; state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查交易的输入输出是否为空</span></span><br><span class="line">    <span class="comment">// Basic checks that don&#x27;t depend on any context</span></span><br><span class="line">    <span class="keyword">if</span> (tx.vin.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-vin-empty&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (tx.vout.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-vout-empty&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查交易大小不能超过MAX_BLOCK_WEIGHT</span></span><br><span class="line">    <span class="comment">// Size limits (this doesn&#x27;t take the witness into account, as that hasn&#x27;t been checked for malleability)</span></span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">GetSerializeSize</span>(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT)</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-oversize&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 检查输出值不能为负数或者超过范围</span></span><br><span class="line">    <span class="comment">// Check for negative or overflow output values (see CVE-2010-5139)</span></span><br><span class="line">    CAmount nValueOut = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; txout : tx.vout) &#123;</span><br><span class="line">        <span class="keyword">if</span> (txout.nValue &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-vout-negative&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (txout.nValue &gt; MAX_MONEY)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-vout-toolarge&quot;</span>);</span><br><span class="line">        nValueOut += txout.nValue;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MoneyRange</span>(nValueOut))</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-txouttotal-toolarge&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 检查是否有重复的输入</span></span><br><span class="line">    <span class="comment">// Check for duplicate inputs (see CVE-2018-17144)</span></span><br><span class="line">    <span class="comment">// While Consensus::CheckTxInputs does check if all inputs of a tx are available, and UpdateCoins marks all inputs</span></span><br><span class="line">    <span class="comment">// of a tx as spent, it does not check if the tx has duplicate inputs.</span></span><br><span class="line">    <span class="comment">// Failure to run this check will result in either a crash or an inflation bug, depending on the implementation of</span></span><br><span class="line">    <span class="comment">// the underlying coins database.</span></span><br><span class="line">    std::set&lt;COutPoint&gt; vInOutPoints;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; txin : tx.vin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vInOutPoints.<span class="built_in">insert</span>(txin.prevout).second)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-inputs-duplicate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tx.<span class="built_in">IsCoinBase</span>()) &#123;</span><br><span class="line">        <span class="comment">// 5.1. 如果是铸币交易，检查输入中解锁脚本的大小</span></span><br><span class="line">        <span class="keyword">if</span> (tx.vin[<span class="number">0</span>].scriptSig.<span class="built_in">size</span>() &lt; <span class="number">2</span> || tx.vin[<span class="number">0</span>].scriptSig.<span class="built_in">size</span>() &gt; <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-cb-length&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 5.2. 若不是铸币交易，检查输入对应的来源不能为空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; txin : tx.vin)</span><br><span class="line">            <span class="keyword">if</span> (txin.prevout.<span class="built_in">IsNull</span>())</span><br><span class="line">                <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-prevout-null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>这笔被接受的交易不能是铸币交易：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Coinbase is only valid in a block, not as a loose transaction</span></span><br><span class="line"><span class="keyword">if</span> (tx.<span class="built_in">IsCoinBase</span>())</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;coinbase&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>检查是否为标准交易，调用<code>src\policy\policy.cpp</code>中的<code>IsStandardTx</code>函数，检查交易的版本、大小、脚本、输出中UTXO个数等是否符合标准。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string reason;</span><br><span class="line"><span class="keyword">if</span> (fRequireStandard &amp;&amp; !<span class="built_in">IsStandardTx</span>(tx, reason))</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_NOT_STANDARD, reason);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>交易的字节大小不能太小。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (::<span class="built_in">GetSerializeSize</span>(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) &lt; MIN_STANDARD_TX_NONWITNESS_SIZE)</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_NOT_STANDARD, <span class="string">&quot;tx-size-small&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>只接受<code>nLockTime</code>满足要求、能够被打包进下一个被挖区块中的交易，防止交易过多溢出交易池。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Only accept nLockTime-using transactions that can be mined in the next</span></span><br><span class="line"><span class="comment">// block; we don&#x27;t want our mempool filled up with transactions that can&#x27;t</span></span><br><span class="line"><span class="comment">// be mined yet.</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CheckFinalTx</span>(m_active_chainstate.m_chain.<span class="built_in">Tip</span>(), tx, STANDARD_LOCKTIME_VERIFY_FLAGS))</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_PREMATURE_SPEND, <span class="string">&quot;non-final&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>检查这笔交易是否已存在交易池中，或有相同未认证的数据已在交易池中。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_pool.<span class="built_in">exists</span>(<span class="built_in">GenTxid</span>(<span class="literal">true</span>, tx.<span class="built_in">GetWitnessHash</span>()))) &#123;</span><br><span class="line">    <span class="comment">// Exact transaction already exists in the mempool.</span></span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONFLICT, <span class="string">&quot;txn-already-in-mempool&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_pool.<span class="built_in">exists</span>(<span class="built_in">GenTxid</span>(<span class="literal">false</span>, tx.<span class="built_in">GetHash</span>()))) &#123;</span><br><span class="line">    <span class="comment">// Transaction with the same non-witness data but different witness (same txid, different</span></span><br><span class="line">    <span class="comment">// wtxid) already exists in the mempool.</span></span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONFLICT, <span class="string">&quot;txn-same-nonwitness-data-in-mempool&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>检查交易输入所指向的上一笔交易输出<code>prevout</code>是否与交易池中某笔交易的一样，即防止双花。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for conflicts with in-memory transactions</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> CTxIn &amp;txin : tx.vin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> CTransaction* ptxConflicting = m_pool.<span class="built_in">GetConflictTx</span>(txin.prevout);</span><br><span class="line">    <span class="keyword">if</span> (ptxConflicting) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>检查交易所有输入的来源(UTXO)是否已在缓存中，若不在则获取。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> CCoinsViewCache&amp; coins_cache = m_active_chainstate.<span class="built_in">CoinsTip</span>();</span><br><span class="line"><span class="comment">// do all inputs exist?</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> CTxIn&amp; txin : tx.vin) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!coins_cache.<span class="built_in">HaveCoinInCache</span>(txin.prevout)) &#123;</span><br><span class="line">        coins_to_uncache.<span class="built_in">push_back</span>(txin.prevout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: this call may add txin.prevout to the coins cache</span></span><br><span class="line">    <span class="comment">// (coins_cache.cacheCoins) by way of FetchCoin(). It should be removed</span></span><br><span class="line">    <span class="comment">// later (via coins_to_uncache) if this tx turns out to be invalid.</span></span><br><span class="line">    <span class="keyword">if</span> (!m_view.<span class="built_in">HaveCoin</span>(txin.prevout)) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>检查时间锁<code>sequence</code>是否满足要求，即可以被打包进下一个待挖区块中，不然就丢弃。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Only accept BIP68 sequence locked transactions that can be mined in the next</span></span><br><span class="line"><span class="comment">// block; we don&#x27;t want our mempool filled up with transactions that can&#x27;t</span></span><br><span class="line"><span class="comment">// be mined yet.</span></span><br><span class="line"><span class="comment">// Pass in m_view which has all of the relevant inputs cached. Note that, since m_view&#x27;s</span></span><br><span class="line"><span class="comment">// backend was removed, it no longer pulls coins from the mempool.</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CheckSequenceLocks</span>(m_active_chainstate.m_chain.<span class="built_in">Tip</span>(), m_view, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &amp;lp))</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_PREMATURE_SPEND, <span class="string">&quot;non-BIP68-final&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>调用<code>src\consensus\tx_verify.cpp</code>中的<code>Consensus::CheckTxInputs</code>函数检查交易的输入。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Consensus::CheckTxInputs</span><span class="params">(<span class="type">const</span> CTransaction&amp; tx, TxValidationState&amp; state, <span class="type">const</span> CCoinsViewCache&amp; inputs, <span class="type">int</span> nSpendHeight, CAmount&amp; txfee)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查输入的来源(UTXO)是否都在缓存中</span></span><br><span class="line">    <span class="comment">// are the actual inputs available?</span></span><br><span class="line">    <span class="keyword">if</span> (!inputs.<span class="built_in">HaveInputs</span>(tx)) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_MISSING_INPUTS, <span class="string">&quot;bad-txns-inputs-missingorspent&quot;</span>,</span><br><span class="line">                         <span class="built_in">strprintf</span>(<span class="string">&quot;%s: inputs missing/spent&quot;</span>, __func__));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CAmount nValueIn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; tx.vin.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">const</span> COutPoint &amp;prevout = tx.vin[i].prevout;</span><br><span class="line">        <span class="type">const</span> Coin&amp; coin = inputs.<span class="built_in">AccessCoin</span>(prevout);</span><br><span class="line">        <span class="comment">// 2. 输入来源不能被双花</span></span><br><span class="line">        <span class="built_in">assert</span>(!coin.<span class="built_in">IsSpent</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 如果来源是coinbase，检查是否成熟（确认数不小于100）</span></span><br><span class="line">        <span class="comment">// If prev is coinbase, check that it&#x27;s matured</span></span><br><span class="line">        <span class="keyword">if</span> (coin.<span class="built_in">IsCoinBase</span>() &amp;&amp; nSpendHeight - coin.nHeight &lt; COINBASE_MATURITY) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_PREMATURE_SPEND, <span class="string">&quot;bad-txns-premature-spend-of-coinbase&quot;</span>,</span><br><span class="line">                <span class="built_in">strprintf</span>(<span class="string">&quot;tried to spend coinbase at depth %d&quot;</span>, nSpendHeight - coin.nHeight));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 检查每一个输入值和总值是否在限定范围内</span></span><br><span class="line">        <span class="comment">// Check for negative or overflow input values</span></span><br><span class="line">        nValueIn += coin.out.nValue;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MoneyRange</span>(coin.out.nValue) || !<span class="built_in">MoneyRange</span>(nValueIn)) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-inputvalues-outofrange&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 交易输出总值不能大于输入总值</span></span><br><span class="line">    <span class="type">const</span> CAmount value_out = tx.<span class="built_in">GetValueOut</span>();</span><br><span class="line">    <span class="keyword">if</span> (nValueIn &lt; value_out) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-in-belowout&quot;</span>,</span><br><span class="line">            <span class="built_in">strprintf</span>(<span class="string">&quot;value in (%s) &lt; value out (%s)&quot;</span>, <span class="built_in">FormatMoney</span>(nValueIn), <span class="built_in">FormatMoney</span>(value_out)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 交易的矿工费用需在规定范围内</span></span><br><span class="line">    <span class="comment">// Tally transaction fees</span></span><br><span class="line">    <span class="type">const</span> CAmount txfee_aux = nValueIn - value_out;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">MoneyRange</span>(txfee_aux)) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_CONSENSUS, <span class="string">&quot;bad-txns-fee-outofrange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    txfee = txfee_aux;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>检查输入和输入的见证脚本是否符合标准（解锁脚本能否解开prevout的锁定脚本）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for non-standard pay-to-script-hash in inputs</span></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> taproot_active = <span class="built_in">DeploymentActiveAfter</span>(m_active_chainstate.m_chain.<span class="built_in">Tip</span>(), args.m_chainparams.<span class="built_in">GetConsensus</span>(), Consensus::DEPLOYMENT_TAPROOT);</span><br><span class="line"><span class="keyword">if</span> (fRequireStandard &amp;&amp; !<span class="built_in">AreInputsStandard</span>(tx, m_view, taproot_active)) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_INPUTS_NOT_STANDARD, <span class="string">&quot;bad-txns-nonstandard-inputs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for non-standard witnesses.</span></span><br><span class="line"><span class="keyword">if</span> (tx.<span class="built_in">HasWitness</span>() &amp;&amp; fRequireStandard &amp;&amp; !<span class="built_in">IsWitnessStandard</span>(tx, m_view))</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_WITNESS_MUTATED, <span class="string">&quot;bad-witness-nonstandard&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>交易中的签名数量(sigops)应小于签名操作数量上限。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nSigOpsCost &gt; MAX_STANDARD_TX_SIGOPS_COST)</span><br><span class="line">    <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(TxValidationResult::TX_NOT_STANDARD, <span class="string">&quot;bad-txns-too-many-sigops&quot;</span>,</span><br><span class="line">            <span class="built_in">strprintf</span>(<span class="string">&quot;%d&quot;</span>, nSigOpsCost));</span><br></pre></td></tr></table></figure>

<h2 id="创建区块"><a href="#创建区块" class="headerlink" title="创建区块"></a>创建区块</h2><p>在Bitcoin Core中，可通过<code>$ bitcoin-cli generatetoaddress</code>命令进行挖矿，命令内部实现定义在<code>src\rpc\mining.cpp</code>的<code>generatetoaddress</code>函数中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> RPCHelpMan <span class="title">generatetoaddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RPCHelpMan&#123;<span class="string">&quot;generatetoaddress&quot;</span>,</span><br><span class="line">                <span class="string">&quot;\nMine blocks immediately to a specified address (before the RPC call returns)\n&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;<span class="string">&quot;nblocks&quot;</span>, RPCArg::Type::NUM, RPCArg::Optional::NO, <span class="string">&quot;How many blocks are generated immediately.&quot;</span>&#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;address&quot;</span>, RPCArg::Type::STR, RPCArg::Optional::NO, <span class="string">&quot;The address to send the newly generated bitcoin to.&quot;</span>&#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;maxtries&quot;</span>, RPCArg::Type::NUM, RPCArg::Default&#123;DEFAULT_MAX_TRIES&#125;, <span class="string">&quot;How many iterations to try.&quot;</span>&#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                RPCResult&#123;</span><br><span class="line">                    RPCResult::Type::ARR, <span class="string">&quot;&quot;</span>, <span class="string">&quot;hashes of blocks generated&quot;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#123;RPCResult::Type::STR_HEX, <span class="string">&quot;&quot;</span>, <span class="string">&quot;blockhash&quot;</span>&#125;,</span><br><span class="line">                    &#125;&#125;,</span><br><span class="line">                RPCExamples&#123;</span><br><span class="line">            <span class="string">&quot;\nGenerate 11 blocks to myaddress\n&quot;</span></span><br><span class="line">            + <span class="built_in">HelpExampleCli</span>(<span class="string">&quot;generatetoaddress&quot;</span>, <span class="string">&quot;11 \&quot;myaddress\&quot;&quot;</span>)</span><br><span class="line">            + <span class="string">&quot;If you are using the &quot;</span> PACKAGE_NAME <span class="string">&quot; wallet, you can get a new address to send the newly generated bitcoin to with:\n&quot;</span></span><br><span class="line">            + <span class="built_in">HelpExampleCli</span>(<span class="string">&quot;getnewaddress&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">        [&amp;](<span class="type">const</span> RPCHelpMan&amp; self, <span class="type">const</span> JSONRPCRequest&amp; request) -&gt; UniValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要创建区块的个数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_blocks&#123;request.params[<span class="number">0</span>].<span class="built_in">get_int</span>()&#125;;</span><br><span class="line">    <span class="comment">// 尝试次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> max_tries&#123;request.params[<span class="number">2</span>].<span class="built_in">isNull</span>() ? DEFAULT_MAX_TRIES : request.params[<span class="number">2</span>].<span class="built_in">get_int</span>()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建区块所获得的coinbase奖励转入的地址</span></span><br><span class="line">    CTxDestination destination = <span class="built_in">DecodeDestination</span>(request.params[<span class="number">1</span>].<span class="built_in">get_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsValidDestination</span>(destination)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">JSONRPCError</span>(RPC_INVALID_ADDRESS_OR_KEY, <span class="string">&quot;Error: Invalid address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NodeContext&amp; node = <span class="built_in">EnsureAnyNodeContext</span>(request.context);</span><br><span class="line">    <span class="type">const</span> CTxMemPool&amp; mempool = <span class="built_in">EnsureMemPool</span>(node);</span><br><span class="line">    ChainstateManager&amp; chainman = <span class="built_in">EnsureChainman</span>(node);</span><br><span class="line"></span><br><span class="line">    CScript coinbase_script = <span class="built_in">GetScriptForDestination</span>(destination);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始创建区块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">generateBlocks</span>(chainman, mempool, coinbase_script, num_blocks, max_tries);</span><br><span class="line">&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行一系列检查后，它将调用同在<code>src\rpc\mining.cpp</code>中的<code>generateBlocks</code>函数，它是创建区块的入口函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> UniValue <span class="title">generateBlocks</span><span class="params">(ChainstateManager&amp; chainman, <span class="type">const</span> CTxMemPool&amp; mempool, <span class="type">const</span> CScript&amp; coinbase_script, <span class="type">int</span> nGenerate, <span class="type">uint64_t</span> nMaxTries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nHeightEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nHeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#123;   <span class="comment">// Don&#x27;t keep cs_main locked</span></span><br><span class="line">        <span class="built_in">LOCK</span>(cs_main);</span><br><span class="line">        <span class="comment">// 区块链当前高度</span></span><br><span class="line">        nHeight = chainman.<span class="built_in">ActiveChain</span>().<span class="built_in">Height</span>();</span><br><span class="line">        <span class="comment">// 创建nGenerate个区块后的高度</span></span><br><span class="line">        nHeightEnd = nHeight+nGenerate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nExtraNonce = <span class="number">0</span>;</span><br><span class="line">    <span class="function">UniValue <span class="title">blockHashes</span><span class="params">(UniValue::VARR)</span></span>;</span><br><span class="line">    <span class="comment">// 开始构造区块并挖矿</span></span><br><span class="line">    <span class="keyword">while</span> (nHeight &lt; nHeightEnd &amp;&amp; !<span class="built_in">ShutdownRequested</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用 BlockAssembler::CreateNewBlock 构造候选区块</span></span><br><span class="line">        <span class="comment">// chainman.ActiveChainstate()会获取当前最长链，新区块将会基于最长链延续</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;CBlockTemplate&gt; <span class="title">pblocktemplate</span><span class="params">(BlockAssembler(chainman.ActiveChainstate(), mempool, Params()).CreateNewBlock(coinbase_script))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!pblocktemplate.<span class="built_in">get</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">JSONRPCError</span>(RPC_INTERNAL_ERROR, <span class="string">&quot;Couldn&#x27;t create new block&quot;</span>);</span><br><span class="line">        CBlock *pblock = &amp;pblocktemplate-&gt;block;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用GenerateBlock进行挖矿：遍历区块的nonce值，使得区块哈希值满足工作量证明</span></span><br><span class="line">        uint256 block_hash;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">GenerateBlock</span>(chainman, *pblock, nMaxTries, nExtraNonce, block_hash)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!block_hash.<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            ++nHeight;</span><br><span class="line">            blockHashes.<span class="built_in">push_back</span>(block_hash.<span class="built_in">GetHex</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> blockHashes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数调用了两个关键函数：</p>
<h3 id="CreateNewBlock"><a href="#CreateNewBlock" class="headerlink" title="CreateNewBlock"></a>CreateNewBlock</h3><p><code>src\miner.cpp</code>中的<code>BlockAssembler::CreateNewBlock</code>函数，用于构造候选区块：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;CBlockTemplate&gt; <span class="title">BlockAssembler::CreateNewBlock</span><span class="params">(<span class="type">const</span> CScript&amp; scriptPubKeyIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int64_t</span> nTimeStart = <span class="built_in">GetTimeMicros</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">resetBlock</span>();</span><br><span class="line"></span><br><span class="line">    pblocktemplate.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">CBlockTemplate</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!pblocktemplate.<span class="built_in">get</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    CBlock* <span class="type">const</span> pblock = &amp;pblocktemplate-&gt;block; <span class="comment">// pointer for convenience</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add dummy coinbase tx as first transaction</span></span><br><span class="line">    <span class="comment">// 1. 区块中的第一个位置留给coinbase交易</span></span><br><span class="line">    pblock-&gt;vtx.<span class="built_in">emplace_back</span>();</span><br><span class="line">    pblocktemplate-&gt;vTxFees.<span class="built_in">push_back</span>(<span class="number">-1</span>); <span class="comment">// updated at end</span></span><br><span class="line">    pblocktemplate-&gt;vTxSigOpsCost.<span class="built_in">push_back</span>(<span class="number">-1</span>); <span class="comment">// updated at end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOCK2</span>(cs_main, m_mempool.cs);</span><br><span class="line">    <span class="comment">// 2. 取当前区块链的最后一个节点，作为新区块的父区块</span></span><br><span class="line">    CBlockIndex* pindexPrev = m_chainstate.m_chain.<span class="built_in">Tip</span>();</span><br><span class="line">    <span class="built_in">assert</span>(pindexPrev != <span class="literal">nullptr</span>);</span><br><span class="line">    nHeight = pindexPrev-&gt;nHeight + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 计算区块版本</span></span><br><span class="line">    pblock-&gt;nVersion = g_versionbitscache.<span class="built_in">ComputeBlockVersion</span>(pindexPrev, chainparams.<span class="built_in">GetConsensus</span>());</span><br><span class="line">    <span class="comment">// -regtest only: allow overriding block.nVersion with</span></span><br><span class="line">    <span class="comment">// -blockversion=N to test forking scenarios</span></span><br><span class="line">    <span class="keyword">if</span> (chainparams.<span class="built_in">MineBlocksOnDemand</span>())</span><br><span class="line">        pblock-&gt;nVersion = gArgs.<span class="built_in">GetArg</span>(<span class="string">&quot;-blockversion&quot;</span>, pblock-&gt;nVersion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 计算时间戳</span></span><br><span class="line">    pblock-&gt;nTime = <span class="built_in">GetAdjustedTime</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> nMedianTimePast = pindexPrev-&gt;<span class="built_in">GetMedianTimePast</span>();</span><br><span class="line"></span><br><span class="line">    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS &amp; LOCKTIME_MEDIAN_TIME_PAST)</span><br><span class="line">                       ? nMedianTimePast</span><br><span class="line">                       : pblock-&gt;<span class="built_in">GetBlockTime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decide whether to include witness transactions</span></span><br><span class="line">    <span class="comment">// This is only needed in case the witness softfork activation is reverted</span></span><br><span class="line">    <span class="comment">// (which would require a very deep reorganization).</span></span><br><span class="line">    <span class="comment">// Note that the mempool would accept transactions with witness data before</span></span><br><span class="line">    <span class="comment">// the deployment is active, but we would only ever mine blocks after activation</span></span><br><span class="line">    <span class="comment">// unless there is a massive block reorganization with the witness softfork</span></span><br><span class="line">    <span class="comment">// not activated.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> replace this with a call to main to assess validity of a mempool</span></span><br><span class="line">    <span class="comment">// transaction (which in most cases can be a no-op).</span></span><br><span class="line">    fIncludeWitness = <span class="built_in">DeploymentActiveAfter</span>(pindexPrev, chainparams.<span class="built_in">GetConsensus</span>(), Consensus::DEPLOYMENT_SEGWIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 从交易池中选择一批交易打包到区块中（注意：并不会从交易持中将交易删除，删除需要等区块确认以后）</span></span><br><span class="line">    <span class="type">int</span> nPackagesSelected = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nDescendantsUpdated = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">addPackageTxs</span>(nPackagesSelected, nDescendantsUpdated);</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> nTime1 = <span class="built_in">GetTimeMicros</span>();</span><br><span class="line"></span><br><span class="line">    m_last_block_num_txs = nBlockTx;</span><br><span class="line">    m_last_block_weight = nBlockWeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 生成铸币交易</span></span><br><span class="line">    <span class="comment">// Create coinbase transaction.</span></span><br><span class="line">    CMutableTransaction coinbaseTx;</span><br><span class="line">    coinbaseTx.vin.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">    coinbaseTx.vin[<span class="number">0</span>].prevout.<span class="built_in">SetNull</span>();</span><br><span class="line">    coinbaseTx.vout.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">    coinbaseTx.vout[<span class="number">0</span>].scriptPubKey = scriptPubKeyIn;</span><br><span class="line">    <span class="comment">// 矿工奖励=区块中交易费用总和（在addPackageTxs时会进行统计）+系统发放奖励</span></span><br><span class="line">    coinbaseTx.vout[<span class="number">0</span>].nValue = nFees + <span class="built_in">GetBlockSubsidy</span>(nHeight, chainparams.<span class="built_in">GetConsensus</span>());</span><br><span class="line">    coinbaseTx.vin[<span class="number">0</span>].scriptSig = <span class="built_in">CScript</span>() &lt;&lt; nHeight &lt;&lt; OP_0;</span><br><span class="line">    pblock-&gt;vtx[<span class="number">0</span>] = <span class="built_in">MakeTransactionRef</span>(std::<span class="built_in">move</span>(coinbaseTx));</span><br><span class="line">    pblocktemplate-&gt;vchCoinbaseCommitment = <span class="built_in">GenerateCoinbaseCommitment</span>(*pblock, pindexPrev, chainparams.<span class="built_in">GetConsensus</span>());</span><br><span class="line">    pblocktemplate-&gt;vTxFees[<span class="number">0</span>] = -nFees;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogPrintf</span>(<span class="string">&quot;CreateNewBlock(): block weight: %u txs: %u fees: %ld sigops %d\n&quot;</span>, <span class="built_in">GetBlockWeight</span>(*pblock), nBlockTx, nFees, nBlockSigOpsCost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 填充区块头</span></span><br><span class="line">    <span class="comment">// Fill in header</span></span><br><span class="line">    pblock-&gt;hashPrevBlock  = pindexPrev-&gt;<span class="built_in">GetBlockHash</span>();</span><br><span class="line">    <span class="built_in">UpdateTime</span>(pblock, chainparams.<span class="built_in">GetConsensus</span>(), pindexPrev);</span><br><span class="line">    <span class="comment">// 设置新区块的工作量难度目标值</span></span><br><span class="line">    pblock-&gt;nBits          = <span class="built_in">GetNextWorkRequired</span>(pindexPrev, pblock, chainparams.<span class="built_in">GetConsensus</span>());</span><br><span class="line">    pblock-&gt;nNonce         = <span class="number">0</span>;</span><br><span class="line">    pblocktemplate-&gt;vTxSigOpsCost[<span class="number">0</span>] = WITNESS_SCALE_FACTOR * <span class="built_in">GetLegacySigOpCount</span>(*pblock-&gt;vtx[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    BlockValidationState state;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">TestBlockValidity</span>(state, chainparams, m_chainstate, *pblock, pindexPrev, <span class="literal">false</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="built_in">strprintf</span>(<span class="string">&quot;%s: TestBlockValidity failed: %s&quot;</span>, __func__, state.<span class="built_in">ToString</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int64_t</span> nTime2 = <span class="built_in">GetTimeMicros</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogPrint</span>(BCLog::BENCH, <span class="string">&quot;CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\n&quot;</span>, <span class="number">0.001</span> * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, <span class="number">0.001</span> * (nTime2 - nTime1), <span class="number">0.001</span> * (nTime2 - nTimeStart));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(pblocktemplate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GenerateBlock"><a href="#GenerateBlock" class="headerlink" title="GenerateBlock"></a>GenerateBlock</h3><p><code>src\rpc\mining.cpp</code>中的<code>GenerateBlock</code>函数，用于挖矿:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GenerateBlock</span><span class="params">(ChainstateManager&amp; chainman, CBlock&amp; block, <span class="type">uint64_t</span>&amp; max_tries, <span class="type">unsigned</span> <span class="type">int</span>&amp; extra_nonce, uint256&amp; block_hash)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block_hash.<span class="built_in">SetNull</span>();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOCK</span>(cs_main);</span><br><span class="line">        <span class="comment">// 在这个函数中会调用src\consensus\merkle.cpp中的BlockMerkleRoot函数</span></span><br><span class="line">        <span class="comment">// 计算区块MerkleRoot的值</span></span><br><span class="line">        <span class="built_in">IncrementExtraNonce</span>(&amp;block, chainman.<span class="built_in">ActiveChain</span>().<span class="built_in">Tip</span>(), extra_nonce);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CChainParams <span class="title">chainparams</span><span class="params">(Params())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历nonce值寻找工作量证明。</span></span><br><span class="line">    <span class="comment">// 调用src\pow.cpp中的CheckProofOfWork函数检查是否满足工作量证明，即区块哈希小于目标值</span></span><br><span class="line">    <span class="keyword">while</span> (max_tries &gt; <span class="number">0</span> &amp;&amp; block.nNonce &lt; std::numeric_limits&lt;<span class="type">uint32_t</span>&gt;::<span class="built_in">max</span>() &amp;&amp; !<span class="built_in">CheckProofOfWork</span>(block.<span class="built_in">GetHash</span>(), block.nBits, chainparams.<span class="built_in">GetConsensus</span>()) &amp;&amp; !<span class="built_in">ShutdownRequested</span>()) &#123;</span><br><span class="line">        ++block.nNonce;</span><br><span class="line">        --max_tries;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max_tries == <span class="number">0</span> || <span class="built_in">ShutdownRequested</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (block.nNonce == std::numeric_limits&lt;<span class="type">uint32_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用src\validation.cpp中的ChainstateManager::ProcessNewBlock函数</span></span><br><span class="line">    <span class="comment">// 处理新区块：验证区块、接收区块（链接到对应链上、广播到网络中等）、更新最长链</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">const</span> CBlock&gt; shared_pblock = std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> CBlock&gt;(block);</span><br><span class="line">    <span class="keyword">if</span> (!chainman.<span class="built_in">ProcessNewBlock</span>(chainparams, shared_pblock, <span class="literal">true</span>, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">JSONRPCError</span>(RPC_INTERNAL_ERROR, <span class="string">&quot;ProcessNewBlock, block not accepted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    block_hash = block.<span class="built_in">GetHash</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理区块"><a href="#处理区块" class="headerlink" title="处理区块"></a>处理区块</h2><p>书接上文，创建区块之后，会调用<code>src\validation.cpp</code>中的<code>ChainstateManager::ProcessNewBlock</code>函数处理新区块。</p>
<p>同样，在接收到其它节点传播来的区块信息后，也会调用这个函数。“验证交易”一节中提到<code>src\net_processing.cpp</code>中的<code>PeerManagerImpl::ProcessMessage</code>函数用于处理从网络中接收到的信息，如果信息是区块类型，则会调用<code>PeerManagerImpl::ProcessBlock</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeerManagerImpl::ProcessMessage</span><span class="params">(CNode&amp; pfrom, <span class="type">const</span> std::string&amp; msg_type, CDataStream&amp; vRecv,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> std::chrono::microseconds time_received,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> std::atomic&lt;<span class="type">bool</span>&gt;&amp; interruptMsgProc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (msg_type == NetMsgType::BLOCK)</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="built_in">ProcessBlock</span>(pfrom, pblock, forceProcessing);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>PeerManagerImpl::ProcessBlock</code>函数则是直接调用<code>ChainstateManager::ProcessNewBlock</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeerManagerImpl::ProcessBlock</span><span class="params">(CNode&amp; node, <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> CBlock&gt;&amp; block, <span class="type">bool</span> force_processing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> new_block&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    m_chainman.<span class="built_in">ProcessNewBlock</span>(m_chainparams, block, force_processing, &amp;new_block);</span><br><span class="line">    <span class="keyword">if</span> (new_block) &#123;</span><br><span class="line">        node.nLastBlockTime = <span class="built_in">GetTime</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOCK</span>(cs_main);</span><br><span class="line">        mapBlockSource.<span class="built_in">erase</span>(block-&gt;<span class="built_in">GetHash</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>src\validation.cpp</code>中的<code>ChainstateManager::ProcessNewBlock</code>函数是处理新区块的入口函数&#x2F;关键函数，它将主要负责：验证区块、接收区块、更新最长链。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ChainstateManager::ProcessNewBlock</span><span class="params">(<span class="type">const</span> CChainParams&amp; chainparams, <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> CBlock&gt;&amp; block, <span class="type">bool</span> force_processing, <span class="type">bool</span>* new_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">AssertLockNotHeld</span>(cs_main);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        CBlockIndex *pindex = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (new_block) *new_block = <span class="literal">false</span>;</span><br><span class="line">        BlockValidationState state;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CheckBlock() does not support multi-threaded block validation because CBlock::fChecked can cause data race.</span></span><br><span class="line">        <span class="comment">// Therefore, the following critical section must include the CheckBlock() call as well.</span></span><br><span class="line">        <span class="built_in">LOCK</span>(cs_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 验证区块</span></span><br><span class="line">        <span class="comment">// Skipping AcceptBlock() for CheckBlock() failures means that we will never mark a block as invalid if</span></span><br><span class="line">        <span class="comment">// CheckBlock() fails.  This is protective against consensus failure if there are any unknown forms of block</span></span><br><span class="line">        <span class="comment">// malleability that cause CheckBlock() to fail; see e.g. CVE-2012-2459 and</span></span><br><span class="line">        <span class="comment">// https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-February/016697.html.  Because CheckBlock() is</span></span><br><span class="line">        <span class="comment">// not very expensive, the anti-DoS benefits of caching failure (of a definitely-invalid block) are not substantial.</span></span><br><span class="line">        <span class="type">bool</span> ret = <span class="built_in">CheckBlock</span>(*block, state, chainparams.<span class="built_in">GetConsensus</span>());</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="comment">// 2. 接收区块</span></span><br><span class="line">            <span class="comment">// Store to disk</span></span><br><span class="line">            ret = <span class="built_in">ActiveChainstate</span>().<span class="built_in">AcceptBlock</span>(block, state, &amp;pindex, force_processing, <span class="literal">nullptr</span>, new_block);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            <span class="built_in">GetMainSignals</span>().<span class="built_in">BlockChecked</span>(*block, state);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">error</span>(<span class="string">&quot;%s: AcceptBlock FAILED (%s)&quot;</span>, __func__, state.<span class="built_in">ToString</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NotifyHeaderTip</span>(<span class="built_in">ActiveChainstate</span>());</span><br><span class="line"></span><br><span class="line">    BlockValidationState state; <span class="comment">// Only used to report errors, not invalidity - ignore it</span></span><br><span class="line">    <span class="comment">// 3. 更新当前链为最长链</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ActiveChainstate</span>().<span class="built_in">ActivateBestChain</span>(state, block)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">error</span>(<span class="string">&quot;%s: ActivateBestChain failed (%s)&quot;</span>, __func__, state.<span class="built_in">ToString</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它主要调用如下三个函数。</p>
<h3 id="CheckBlock"><a href="#CheckBlock" class="headerlink" title="CheckBlock"></a>CheckBlock</h3><p><code>src\validation.cpp</code>中的<code>CheckBlock</code>函数，负责对区块进行检查：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fCheckPOW和fCheckMerkleRoot两个参数的默认值是true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckBlock</span><span class="params">(<span class="type">const</span> CBlock&amp; block, BlockValidationState&amp; state, <span class="type">const</span> Consensus::Params&amp; consensusParams, <span class="type">bool</span> fCheckPOW, <span class="type">bool</span> fCheckMerkleRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// These are checks that are independent of context.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果区块已验证，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (block.fChecked)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检查区块头，是否满足工作量证明</span></span><br><span class="line">    <span class="comment">// Check that the header is valid (particularly PoW).  This is mostly</span></span><br><span class="line">    <span class="comment">// redundant with the call in AcceptBlockHeader.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CheckBlockHeader</span>(block, state, consensusParams, fCheckPOW))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Signet only: check block solution</span></span><br><span class="line">    <span class="keyword">if</span> (consensusParams.signet_blocks &amp;&amp; fCheckPOW &amp;&amp; !<span class="built_in">CheckSignetBlockSolution</span>(block, consensusParams)) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, <span class="string">&quot;bad-signet-blksig&quot;</span>, <span class="string">&quot;signet block signature validation failure&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查merkle root值是否正确</span></span><br><span class="line">    <span class="comment">// Check the merkle root.</span></span><br><span class="line">    <span class="keyword">if</span> (fCheckMerkleRoot) &#123;</span><br><span class="line">        <span class="type">bool</span> mutated;</span><br><span class="line">        uint256 hashMerkleRoot2 = <span class="built_in">BlockMerkleRoot</span>(block, &amp;mutated);</span><br><span class="line">        <span class="keyword">if</span> (block.hashMerkleRoot != hashMerkleRoot2)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_MUTATED, <span class="string">&quot;bad-txnmrklroot&quot;</span>, <span class="string">&quot;hashMerkleRoot mismatch&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for merkle tree malleability (CVE-2012-2459): repeating sequences</span></span><br><span class="line">        <span class="comment">// of transactions in a block without affecting the merkle root of a block,</span></span><br><span class="line">        <span class="comment">// while still invalidating it.</span></span><br><span class="line">        <span class="keyword">if</span> (mutated)</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_MUTATED, <span class="string">&quot;bad-txns-duplicate&quot;</span>, <span class="string">&quot;duplicate transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All potential-corruption validation must be done before we do any</span></span><br><span class="line">    <span class="comment">// transaction validation, as otherwise we may mark the header as invalid</span></span><br><span class="line">    <span class="comment">// because we receive the wrong transactions for it.</span></span><br><span class="line">    <span class="comment">// Note that witness malleability is checked in ContextualCheckBlock, so no</span></span><br><span class="line">    <span class="comment">// checks that use witness data may be performed here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 检查区块大小是否在规定范围内</span></span><br><span class="line">    <span class="comment">// Size limits</span></span><br><span class="line">    <span class="keyword">if</span> (block.vtx.<span class="built_in">empty</span>() || block.vtx.<span class="built_in">size</span>() * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT || ::<span class="built_in">GetSerializeSize</span>(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_WEIGHT)</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, <span class="string">&quot;bad-blk-length&quot;</span>, <span class="string">&quot;size limits failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 第一笔交易必须是coinbase交易，剩余的都不能是coinbase交易</span></span><br><span class="line">    <span class="comment">// First transaction must be coinbase, the rest must not be</span></span><br><span class="line">    <span class="keyword">if</span> (block.vtx.<span class="built_in">empty</span>() || !block.vtx[<span class="number">0</span>]-&gt;<span class="built_in">IsCoinBase</span>())</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, <span class="string">&quot;bad-cb-missing&quot;</span>, <span class="string">&quot;first tx is not coinbase&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt; block.vtx.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (block.vtx[i]-&gt;<span class="built_in">IsCoinBase</span>())</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, <span class="string">&quot;bad-cb-multiple&quot;</span>, <span class="string">&quot;more than one coinbase&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 调用src\consensus\tx_check.cpp中的CheckTransaction函数（上文已介绍）检查每笔交易是否正确，</span></span><br><span class="line">    <span class="comment">// Check transactions</span></span><br><span class="line">    <span class="comment">// Must check for duplicate inputs (see CVE-2018-17144)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tx : block.vtx) &#123;</span><br><span class="line">        TxValidationState tx_state;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">CheckTransaction</span>(*tx, tx_state)) &#123;</span><br><span class="line">            <span class="comment">// CheckBlock() does context-free validation checks. The only</span></span><br><span class="line">            <span class="comment">// possible failures are consensus failures.</span></span><br><span class="line">            <span class="built_in">assert</span>(tx_state.<span class="built_in">GetResult</span>() == TxValidationResult::TX_CONSENSUS);</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, tx_state.<span class="built_in">GetRejectReason</span>(),</span><br><span class="line">                                 <span class="built_in">strprintf</span>(<span class="string">&quot;Transaction check failed (tx hash %s) %s&quot;</span>, tx-&gt;<span class="built_in">GetHash</span>().<span class="built_in">ToString</span>(), tx_state.<span class="built_in">GetDebugMessage</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. sigops个数不能超过限定值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nSigOps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tx : block.vtx)</span><br><span class="line">    &#123;</span><br><span class="line">        nSigOps += <span class="built_in">GetLegacySigOpCount</span>(*tx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nSigOps * WITNESS_SCALE_FACTOR &gt; MAX_BLOCK_SIGOPS_COST)</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_CONSENSUS, <span class="string">&quot;bad-blk-sigops&quot;</span>, <span class="string">&quot;out-of-bounds SigOpCount&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fCheckPOW &amp;&amp; fCheckMerkleRoot)</span><br><span class="line">        block.fChecked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcceptBlock"><a href="#AcceptBlock" class="headerlink" title="AcceptBlock"></a>AcceptBlock</h3><p><code>src\validation.cpp</code>中的<code>CChainState::AcceptBlock</code>函数，用于接收区块，负责基本的验证、链接到对应链上、广播到网络中、保存到本地磁盘等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CChainState::AcceptBlock</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> CBlock&gt;&amp; pblock, BlockValidationState&amp; state, CBlockIndex** ppindex, <span class="type">bool</span> fRequested, <span class="type">const</span> FlatFilePos* dbp, <span class="type">bool</span>* fNewBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> CBlock&amp; block = *pblock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fNewBlock) *fNewBlock = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">AssertLockHeld</span>(cs_main);</span><br><span class="line"></span><br><span class="line">    CBlockIndex *pindexDummy = <span class="literal">nullptr</span>;</span><br><span class="line">    CBlockIndex *&amp;pindex = ppindex ? *ppindex : pindexDummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 接收区块头：</span></span><br><span class="line">    <span class="comment">//   检查是否有重复区块头、是否存在父区块、是否延续于不合法区块之后（分叉情况）</span></span><br><span class="line">    <span class="comment">//   将区块头链接到对应的链上（可能会出现分叉情况）</span></span><br><span class="line">    <span class="type">bool</span> accepted_header = m_blockman.<span class="built_in">AcceptBlockHeader</span>(block, state, m_params, &amp;pindex);</span><br><span class="line">    <span class="built_in">CheckBlockIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!accepted_header)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to process all requested blocks that we don&#x27;t have, but only</span></span><br><span class="line">    <span class="comment">// process an unrequested block if it&#x27;s new and has enough work to</span></span><br><span class="line">    <span class="comment">// advance our tip, and isn&#x27;t too many blocks ahead.</span></span><br><span class="line">    <span class="type">bool</span> fAlreadyHave = pindex-&gt;nStatus &amp; BLOCK_HAVE_DATA;</span><br><span class="line">    <span class="type">bool</span> fHasMoreOrSameWork = (m_chain.<span class="built_in">Tip</span>() ? pindex-&gt;nChainWork &gt;= m_chain.<span class="built_in">Tip</span>()-&gt;nChainWork : <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// Blocks that are too out-of-order needlessly limit the effectiveness of</span></span><br><span class="line">    <span class="comment">// pruning, because pruning will not delete block files that contain any</span></span><br><span class="line">    <span class="comment">// blocks which are too close in height to the tip.  Apply this test</span></span><br><span class="line">    <span class="comment">// regardless of whether pruning is enabled; it should generally be safe to</span></span><br><span class="line">    <span class="comment">// not process unrequested blocks.</span></span><br><span class="line">    <span class="type">bool</span> fTooFarAhead = (pindex-&gt;nHeight &gt; <span class="built_in">int</span>(m_chain.<span class="built_in">Height</span>() + MIN_BLOCKS_TO_KEEP));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Decouple this function from the block download logic by removing fRequested</span></span><br><span class="line">    <span class="comment">// This requires some new chain data structure to efficiently look up if a</span></span><br><span class="line">    <span class="comment">// block is in a chain leading to a candidate for best tip, despite not</span></span><br><span class="line">    <span class="comment">// being such a candidate itself.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> deal better with return value and error conditions for duplicate</span></span><br><span class="line">    <span class="comment">// and unrequested blocks.</span></span><br><span class="line">    <span class="keyword">if</span> (fAlreadyHave) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fRequested) &#123;  <span class="comment">// If we didn&#x27;t ask for it:</span></span><br><span class="line">        <span class="keyword">if</span> (pindex-&gt;nTx != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// This is a previously-processed block that was pruned</span></span><br><span class="line">        <span class="keyword">if</span> (!fHasMoreOrSameWork) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// Don&#x27;t process less-work chains</span></span><br><span class="line">        <span class="keyword">if</span> (fTooFarAhead) <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">// Block height is too high</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Protect against DoS attacks from low-work chains.</span></span><br><span class="line">        <span class="comment">// If our tip is behind, a peer could try to send us</span></span><br><span class="line">        <span class="comment">// low-work blocks on a fake chain that we would never</span></span><br><span class="line">        <span class="comment">// request; don&#x27;t process these.</span></span><br><span class="line">        <span class="keyword">if</span> (pindex-&gt;nChainWork &lt; nMinimumChainWork) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 再一次检查区块</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CheckBlock</span>(block, state, m_params.<span class="built_in">GetConsensus</span>()) ||</span><br><span class="line">        !<span class="built_in">ContextualCheckBlock</span>(block, state, m_params.<span class="built_in">GetConsensus</span>(), pindex-&gt;pprev)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state.<span class="built_in">IsInvalid</span>() &amp;&amp; state.<span class="built_in">GetResult</span>() != BlockValidationResult::BLOCK_MUTATED) &#123;</span><br><span class="line">            pindex-&gt;nStatus |= BLOCK_FAILED_VALID;</span><br><span class="line">            setDirtyBlockIndex.<span class="built_in">insert</span>(pindex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">error</span>(<span class="string">&quot;%s: %s&quot;</span>, __func__, state.<span class="built_in">ToString</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 如果这个区块延续在当前的最佳链上，则调用src\net_processing.cpp</span></span><br><span class="line">    <span class="comment">// 中的PeerManagerImpl::NewPoWValidBlock函数广播这个区块</span></span><br><span class="line">    <span class="comment">// Header is valid/has work, merkle tree and segwit merkle tree are good...RELAY NOW</span></span><br><span class="line">    <span class="comment">// (but if it does not build on our best tip, let the SendMessages loop relay it)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsInitialBlockDownload</span>() &amp;&amp; m_chain.<span class="built_in">Tip</span>() == pindex-&gt;pprev)</span><br><span class="line">        <span class="built_in">GetMainSignals</span>().<span class="built_in">NewPoWValidBlock</span>(pindex, pblock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 将这个区块写入到磁盘中</span></span><br><span class="line">    <span class="comment">// Write block to history file</span></span><br><span class="line">    <span class="keyword">if</span> (fNewBlock) *fNewBlock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FlatFilePos blockPos = <span class="built_in">SaveBlockToDisk</span>(block, pindex-&gt;nHeight, m_chain, m_params, dbp);</span><br><span class="line">        <span class="keyword">if</span> (blockPos.<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            state.<span class="built_in">Error</span>(<span class="built_in">strprintf</span>(<span class="string">&quot;%s: Failed to find position to write new block to disk&quot;</span>, __func__));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ReceivedBlockTransactions</span>(block, pindex, blockPos);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AbortNode</span>(state, std::<span class="built_in">string</span>(<span class="string">&quot;System error: &quot;</span>) + e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FlushStateToDisk</span>(state, FlushStateMode::NONE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CheckBlockIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActivateBestChain"><a href="#ActivateBestChain" class="headerlink" title="ActivateBestChain"></a>ActivateBestChain</h3><p><code>src\validation.cpp</code>中的<code>CChainState::ActivateBestChain</code>函数，更新当前链为最长链。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CChainState::ActivateBestChain</span><span class="params">(BlockValidationState&amp; state, std::shared_ptr&lt;<span class="type">const</span> CBlock&gt; pblock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Note that while we&#x27;re often called here from ProcessNewBlock, this is</span></span><br><span class="line">    <span class="comment">// far from a guarantee. Things in the P2P/RPC will often end up calling</span></span><br><span class="line">    <span class="comment">// us in the middle of ProcessNewBlock - do not assume pblock is set</span></span><br><span class="line">    <span class="comment">// sanely for performance or correctness!</span></span><br><span class="line">    <span class="built_in">AssertLockNotHeld</span>(cs_main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ABC maintains a fair degree of expensive-to-calculate internal state</span></span><br><span class="line">    <span class="comment">// because this function periodically releases cs_main so that it does not lock up other threads for too long</span></span><br><span class="line">    <span class="comment">// during large connects - and to allow for e.g. the callback queue to drain</span></span><br><span class="line">    <span class="comment">// we use m_cs_chainstate to enforce mutual exclusion so that only one caller may execute this function at a time</span></span><br><span class="line">    <span class="built_in">LOCK</span>(m_cs_chainstate);</span><br><span class="line"></span><br><span class="line">    CBlockIndex *pindexMostWork = <span class="literal">nullptr</span>;</span><br><span class="line">    CBlockIndex *pindexNewTip = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> nStopAtHeight = gArgs.<span class="built_in">GetArg</span>(<span class="string">&quot;-stopatheight&quot;</span>, DEFAULT_STOPATHEIGHT);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Block until the validation queue drains. This should largely</span></span><br><span class="line">        <span class="comment">// never happen in normal operation, however may happen during</span></span><br><span class="line">        <span class="comment">// reindex, causing memory blowup if we run too far ahead.</span></span><br><span class="line">        <span class="comment">// Note that if a validationinterface callback ends up calling</span></span><br><span class="line">        <span class="comment">// ActivateBestChain this may lead to a deadlock! We should</span></span><br><span class="line">        <span class="comment">// probably have a DEBUG_LOCKORDER test for this in the future.</span></span><br><span class="line">        <span class="built_in">LimitValidationInterfaceQueue</span>();</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOCK</span>(cs_main);</span><br><span class="line">            <span class="comment">// Lock transaction pool for at least as long as it takes for connectTrace to be consumed</span></span><br><span class="line">            <span class="built_in">LOCK</span>(<span class="built_in">MempoolMutex</span>());</span><br><span class="line">            CBlockIndex* starting_tip = m_chain.<span class="built_in">Tip</span>();</span><br><span class="line">            <span class="type">bool</span> blocks_connected = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// We absolutely may not unlock cs_main until we&#x27;ve made forward progress</span></span><br><span class="line">                <span class="comment">// (with the exception of shutdown due to hardware issues, low disk space, etc).</span></span><br><span class="line">                ConnectTrace connectTrace; <span class="comment">// Destructed before cs_main is unlocked</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. 获取最长链（最大工作量证明），删除不合法的候选链</span></span><br><span class="line">                <span class="keyword">if</span> (pindexMostWork == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    pindexMostWork = <span class="built_in">FindMostWorkChain</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Whether we have anything to do at all.</span></span><br><span class="line">                <span class="keyword">if</span> (pindexMostWork == <span class="literal">nullptr</span> || pindexMostWork == m_chain.<span class="built_in">Tip</span>()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 更新当前链为最长的链</span></span><br><span class="line">                <span class="type">bool</span> fInvalidFound = <span class="literal">false</span>;</span><br><span class="line">                std::shared_ptr&lt;<span class="type">const</span> CBlock&gt; nullBlockPtr;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">ActivateBestChainStep</span>(state, pindexMostWork, pblock &amp;&amp; pblock-&gt;<span class="built_in">GetHash</span>() == pindexMostWork-&gt;<span class="built_in">GetBlockHash</span>() ? pblock : nullBlockPtr, fInvalidFound, connectTrace)) &#123;</span><br><span class="line">                    <span class="comment">// A system error occurred</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                blocks_connected = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fInvalidFound) &#123;</span><br><span class="line">                    <span class="comment">// Wipe cache, we may need another branch now.</span></span><br><span class="line">                    pindexMostWork = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pindexNewTip = m_chain.<span class="built_in">Tip</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 通知各监听器当前链发生变化</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> PerBlockConnectTrace&amp; trace : connectTrace.<span class="built_in">GetBlocksConnected</span>()) &#123;</span><br><span class="line">                    <span class="built_in">assert</span>(trace.pblock &amp;&amp; trace.pindex);</span><br><span class="line">                    <span class="built_in">GetMainSignals</span>().<span class="built_in">BlockConnected</span>(trace.pblock, trace.pindex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!m_chain.<span class="built_in">Tip</span>() || (starting_tip &amp;&amp; <span class="built_in">CBlockIndexWorkComparator</span>()(m_chain.<span class="built_in">Tip</span>(), starting_tip)));</span><br><span class="line">            <span class="keyword">if</span> (!blocks_connected) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> CBlockIndex* pindexFork = m_chain.<span class="built_in">FindFork</span>(starting_tip);</span><br><span class="line">            <span class="type">bool</span> fInitialDownload = <span class="built_in">IsInitialBlockDownload</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 将最长链的高度和新区块告诉其它节点</span></span><br><span class="line">            <span class="comment">// Notify external listeners about the new tip.</span></span><br><span class="line">            <span class="comment">// Enqueue while holding cs_main to ensure that UpdatedBlockTip is called in the order in which blocks are connected</span></span><br><span class="line">            <span class="keyword">if</span> (pindexFork != pindexNewTip) &#123;</span><br><span class="line">                <span class="comment">// Notify ValidationInterface subscribers</span></span><br><span class="line">                <span class="built_in">GetMainSignals</span>().<span class="built_in">UpdatedBlockTip</span>(pindexNewTip, pindexFork, fInitialDownload);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Always notify the UI if a new block tip was connected</span></span><br><span class="line">                uiInterface.<span class="built_in">NotifyBlockTip</span>(<span class="built_in">GetSynchronizationState</span>(fInitialDownload), pindexNewTip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// When we reach this point, we switched to a new tip (stored in pindexNewTip).</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nStopAtHeight &amp;&amp; pindexNewTip &amp;&amp; pindexNewTip-&gt;nHeight &gt;= nStopAtHeight) <span class="built_in">StartShutdown</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We check shutdown only after giving ActivateBestChainStep a chance to run once so that we</span></span><br><span class="line">        <span class="comment">// never shutdown before connecting the genesis block during LoadChainTip(). Previously this</span></span><br><span class="line">        <span class="comment">// caused an assert() failure during shutdown in such cases as the UTXO DB flushing checks</span></span><br><span class="line">        <span class="comment">// that the best block hash is non-null.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ShutdownRequested</span>()) <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pindexNewTip != pindexMostWork);</span><br><span class="line">    <span class="built_in">CheckBlockIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write changes periodically to disk, after relay.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">FlushStateToDisk</span>(state, FlushStateMode::PERIODIC)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择最长链"><a href="#选择最长链" class="headerlink" title="选择最长链"></a>选择最长链</h2><p>在处理区块中所调用的<code>CChainState::ActivateBestChain</code>函数，负责更新当前链为最长链。在其过程中，会调用<code>src\validation.cpp</code>中的<code>CChainState::FindMostWorkChain</code>函数获取最长链。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the tip of the chain with the most work in it, that isn&#x27;t</span></span><br><span class="line"><span class="comment"> * known to be invalid (it&#x27;s however far from certain to be valid).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">CBlockIndex* <span class="title">CChainState::FindMostWorkChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        CBlockIndex *pindexNew = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后往前遍历候选链</span></span><br><span class="line">        <span class="comment">// setBlockIndexCandidates是候选链的集合，且按照一定的规则排序，越符合要求的链在越后面</span></span><br><span class="line">        <span class="comment">// Find the best candidate header.</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::set&lt;CBlockIndex*, CBlockIndexWorkComparator&gt;::reverse_iterator it = setBlockIndexCandidates.<span class="built_in">rbegin</span>();</span><br><span class="line">            <span class="keyword">if</span> (it == setBlockIndexCandidates.<span class="built_in">rend</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            pindexNew = *it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链上的区块，检查是否存在不合法的区块</span></span><br><span class="line">        <span class="comment">// Check whether all blocks on the path between the currently active chain and the candidate are valid.</span></span><br><span class="line">        <span class="comment">// Just going until the active chain is an optimization, as we know all blocks in it are valid already.</span></span><br><span class="line">        CBlockIndex *pindexTest = pindexNew;</span><br><span class="line">        <span class="type">bool</span> fInvalidAncestor = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (pindexTest &amp;&amp; !m_chain.<span class="built_in">Contains</span>(pindexTest)) &#123;</span><br><span class="line">            <span class="built_in">assert</span>(pindexTest-&gt;<span class="built_in">HaveTxsDownloaded</span>() || pindexTest-&gt;nHeight == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pruned nodes may have entries in setBlockIndexCandidates for</span></span><br><span class="line">            <span class="comment">// which block files have been deleted.  Remove those as candidates</span></span><br><span class="line">            <span class="comment">// for the most work chain if we come across them; we can&#x27;t switch</span></span><br><span class="line">            <span class="comment">// to a chain unless we have all the non-active-chain parent blocks.</span></span><br><span class="line">            <span class="type">bool</span> fFailedChain = pindexTest-&gt;nStatus &amp; BLOCK_FAILED_MASK;</span><br><span class="line">            <span class="type">bool</span> fMissingData = !(pindexTest-&gt;nStatus &amp; BLOCK_HAVE_DATA);</span><br><span class="line">            <span class="comment">// 若存在不合法的区块，则删除该链</span></span><br><span class="line">            <span class="keyword">if</span> (fFailedChain || fMissingData) &#123;</span><br><span class="line">                <span class="comment">// Candidate chain is not usable (either invalid or missing data)</span></span><br><span class="line">                <span class="keyword">if</span> (fFailedChain &amp;&amp; (pindexBestInvalid == <span class="literal">nullptr</span> || pindexNew-&gt;nChainWork &gt; pindexBestInvalid-&gt;nChainWork))</span><br><span class="line">                    pindexBestInvalid = pindexNew;</span><br><span class="line">                CBlockIndex *pindexFailed = pindexNew;</span><br><span class="line">                <span class="comment">// Remove the entire chain from the set.</span></span><br><span class="line">                <span class="keyword">while</span> (pindexTest != pindexFailed) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fFailedChain) &#123;</span><br><span class="line">                        pindexFailed-&gt;nStatus |= BLOCK_FAILED_CHILD;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fMissingData) &#123;</span><br><span class="line">                        <span class="comment">// If we&#x27;re missing data, then add back to m_blocks_unlinked,</span></span><br><span class="line">                        <span class="comment">// so that if the block arrives in the future we can try adding</span></span><br><span class="line">                        <span class="comment">// to setBlockIndexCandidates again.</span></span><br><span class="line">                        m_blockman.m_blocks_unlinked.<span class="built_in">insert</span>(</span><br><span class="line">                            std::<span class="built_in">make_pair</span>(pindexFailed-&gt;pprev, pindexFailed));</span><br><span class="line">                    &#125;</span><br><span class="line">                    setBlockIndexCandidates.<span class="built_in">erase</span>(pindexFailed);</span><br><span class="line">                    pindexFailed = pindexFailed-&gt;pprev;</span><br><span class="line">                &#125;</span><br><span class="line">                setBlockIndexCandidates.<span class="built_in">erase</span>(pindexTest);</span><br><span class="line">                fInvalidAncestor = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pindexTest = pindexTest-&gt;pprev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若不存在违法区块，则返回该链</span></span><br><span class="line">        <span class="keyword">if</span> (!fInvalidAncestor)</span><br><span class="line">            <span class="keyword">return</span> pindexNew;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FindMostWorkChain</code>函数所在的<code>CChainState</code>类中包含一个属性：<code>std::set&lt;CBlockIndex*, CBlockIndexWorkComparator&gt; setBlockIndexCandidates</code>候选链集合，该集合的排序规则定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CBlockIndexWorkComparator::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> CBlockIndex *pa, <span class="type">const</span> CBlockIndex *pb)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First sort by most total work, ...</span></span><br><span class="line">    <span class="keyword">if</span> (pa-&gt;nChainWork &gt; pb-&gt;nChainWork) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pa-&gt;nChainWork &lt; pb-&gt;nChainWork) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... then by earliest time received, ...</span></span><br><span class="line">    <span class="keyword">if</span> (pa-&gt;nSequenceId &lt; pb-&gt;nSequenceId) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pa-&gt;nSequenceId &gt; pb-&gt;nSequenceId) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use pointer address as tie breaker (should only happen with blocks</span></span><br><span class="line">    <span class="comment">// loaded from disk, as those all have id 0).</span></span><br><span class="line">    <span class="keyword">if</span> (pa &lt; pb) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pa &gt; pb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identical blocks.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://doxygen.bitcoincore.org/index.html">Bitcoin Core: Main Page</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/MasterBitcoin2CN/README.md">Introduction - 《《精通比特币》第二版》 - 书栈网 · BookStack</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903598522892302">https://juejin.cn/post/6844903598522892302</a></p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/BlockChain/" rel="tag"><i class="fa fa-tag"></i> 区块链</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html" rel="prev" title="装饰器模式">
                  <i class="fa fa-chevron-left"></i> 装饰器模式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81.html" rel="next" title="区块链入门——比特币">
                  区块链入门——比特币 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dounine</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">537k</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"99MyCql/99MyCql.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
